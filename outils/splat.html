<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Splat! v12</title>
<style>
  :root{
    /* THEME (light default) */
    --bg:#f3f4f6;
    --panel:rgba(255,255,255,.96);
    --card:rgba(255,255,255,.80);
    --ink:#111827;
    --muted:#6b7280;

    --field-bg:#ffffff;
    --field-border:rgba(17,24,39,.15);

    --btn:#ffffff;
    --btn2:#f3f4f6;
    --btn-border:rgba(17,24,39,.15);

    --tray-fill:rgba(0,0,0,0.03);
    --tray-stroke:rgba(0,0,0,0.10);

    /* Retour au gris léger pour l'écran */
    --totalbox-fill:rgba(0,0,0,0.04);
    --totalbox-stroke:rgba(0,0,0,0.16);

    --beadH-fill:rgba(0,0,0,0.05);
    --beadH-stroke:rgba(0,0,0,0.25);

    --total-label: rgba(17,24,39,0.70);

    /* SPLAT COLORS */
    --splat-cover: rgb(0,0,0);              
    --splat-reveal: rgba(210,210,210,0.35); 
    --splat-stroke: rgba(0,0,0,0.18);

    /* MODE C/D COLORS (Opaque) */
    --splat-black: rgb(20,20,20);
    --splat-purple: #9d4edd;
    --splat-orange: #f97316;

    /* MODE C/D COLORS (Reveal - Semi-transparent) */
    --splat-black-rev: rgba(40,40,40, 0.15);
    --splat-purple-rev: rgba(157, 78, 221, 0.20);
    --splat-orange-rev: rgba(249, 115, 22, 0.20);

    /* UNIT BEADS */
    --unit-fill: rgba(106,167,255,0.20);
    --unit-stroke: rgba(106,167,255,0.55);

    --danger:#ff6a6a;
    --accent:#6aa7ff;
  }

  *{box-sizing:border-box;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;}
  body{margin:0;background:var(--bg);color:var(--ink);}

  header{
    padding:14px 16px;
    border-bottom:1px solid rgba(255,255,255,0.08);
    display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap
  }
  header h1{font-size:16px;margin:0;font-weight:900;letter-spacing:.2px}

  .wrap{display:flex;flex-direction:row;flex-wrap:nowrap;gap:14px;padding:14px;align-items:flex-start}
.wrap > .panel{flex:0 0 340px;max-width:340px}
.wrap > .stage{flex:1 1 auto;min-width:0}

  .panel{
    background:var(--panel);
    border:1px solid rgba(255,255,255,0.08);
    border-radius:14px;padding:12px;
    box-shadow:0 10px 30px rgba(0,0,0,0.25)
  }

  label{font-size:12px;color:var(--muted);display:block;margin:8px 0 4px}
  select,input{
    width:100%;padding:10px 10px;border-radius:10px;
    border:1px solid var(--field-border);
    background:var(--field-bg);
    color:var(--ink);
    outline:none
  }
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}

  /* PATCH UI — Menu A (U) : mise en page en lignes cohérentes (sans impact JS) */
  #unitSettings .u-section-title{
    font-size:10px;
    color:var(--muted);
    font-weight:800;
    letter-spacing:.08em;
    text-transform:uppercase;
    margin:8px 0 4px;
  }
  #unitSettings .u-grid{
    display:grid;
    grid-template-columns: 84px 1fr;
    gap:8px 10px;
    align-items: center;
  }
  #unitSettings .u-grid .u-label{
    margin:0;
    font-size:12px;
    color:var(--muted);
    font-weight:700;
    line-height:1.2;
  }
  #unitSettings .u-controls{
    display:flex;
    gap:10px;
    flex-wrap:wrap;
    align-items:flex-end;
    min-width:0;
  }
  #unitSettings .u-mini{display:flex;flex-direction:column;gap:4px;min-width:0}
  #unitSettings .u-mini-label{
    font-size:11px;
    color:var(--muted);
    line-height:1.05;
    margin:0;
    text-align:center;
  }
  #unitSettings input{padding:8px 10px;}
  #unitSettings .u-mini input{ width:78px; }
  #unitSettings .u-seed{min-width:200px;}
  #unitSettings .u-seed input{width:200px; max-width:100%;}
  #unitSettings .u-wide input{ width:100%; }

  /* PATCH UI — Menu C (Enquête) : compaction sans changement fonctionnel */
  #investigateSettings{margin-top:6px}
  #investigateSettings label{margin:6px 0 4px}
  #investigateSettings select,#investigateSettings input{padding:8px 10px}
  #investigateSettings .c-grid{
    display:grid;
    grid-template-columns:1fr 1fr;
    gap:8px 10px;
    align-items:end;
  }
  #investigateSettings .c-field{min-width:0}
  #investigateSettings #invStructureRow{grid-column:1 / 2}
  #investigateSettings .c-ops{
    display:grid;
    grid-template-columns:repeat(4, minmax(0, 1fr));
    gap: 6px;
    margin-top:2px;
  }
  #investigateSettings .c-ops .checkInline{
    justify-content:center;
    padding:6px 6px;
    border-radius:10px;
    gap:6px;
    min-width:0;
    white-space:nowrap;
  }
  #investigateSettings .c-ops .checkInline span{font-size:12px}
  #investigateSettings .c-small input{max-width:160px}
  #investigateSettings .c-pairs{
    display:grid;
    grid-template-columns:1fr 1fr;
    gap:8px 10px;
    margin-top:8px;
  }
  #investigateSettings .c-pair{
    display:flex;
    gap:8px;
    align-items:flex-end;
  }
  #investigateSettings .c-mini{flex:1;min-width:0}
  #investigateSettings .c-mini-label{
    font-size:11px;
    color:var(--muted);
    line-height:1.05;
    margin:0 0 4px;
    text-align:center;
  }
  #investigateSettings .c-mini input{width:100%}
input[type="number"]{appearance:textfield}

  .btn{
    padding:10px 12px;border-radius:10px;
    border:1px solid var(--btn-border);
    background:var(--btn);
    color:var(--ink);cursor:pointer;font-weight:650;
    transition: transform .08s ease, background .12s ease, box-shadow .12s ease;
  }
  .btn:hover{background:var(--btn2)}
  .btn:active{transform:translateY(1px)}
  .btn.primary{background:rgba(106,167,255,0.18);border-color:rgba(106,167,255,0.35)}
  .btn.danger{background:rgba(255,106,106,0.14);border-color:rgba(255,106,106,0.35)}
  .btn:disabled{opacity:.45;cursor:not-allowed}

  .iconbtn{
    display:inline-grid;place-items:center;
    width:42px;height:42px;padding:0;border-radius:12px;
    border:1px solid var(--btn-border);
    background: linear-gradient(180deg, rgba(255,255,255,0.10), rgba(255,255,255,0.04));
    box-shadow: 0 6px 18px rgba(0,0,0,0.18);
  }
  .iconbtn:hover{transform:translateY(-1px); box-shadow: 0 10px 22px rgba(0,0,0,0.22);}
  .iconbtn:active{transform:translateY(0px); box-shadow: 0 6px 18px rgba(0,0,0,0.18);}
  .iconbtn svg{width:20px;height:20px;opacity:.95}

  .hint{
    font-size:12px;color:var(--muted);line-height:1.35;margin-top:10px
  }
  .hr{
    height:1px;background:rgba(255,255,255,0.08);margin:10px 0;
  }
  .smallnote{
    font-size:12px;color:var(--muted);line-height:1.35;
    border:1px solid rgba(255,255,255,0.10);
    background: rgba(255,255,255,0.03);
    border-radius:12px;
    padding:10px;
    margin-top:10px;
  }
  .pill{
    display:inline-block;
    padding:2px 8px;
    border-radius:999px;
    border:1px solid rgba(255,255,255,0.14);
    background: rgba(255,255,255,0.04);
    font-size:12px;
    color: var(--muted);
  }

  .stage{display:flex;flex-direction:column;gap:12px}
  .cardbox{
    background:var(--card);
    border:1px solid rgba(255,255,255,0.08);
    border-radius:14px;padding:10px
  }
  .nav{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between}
  .counter{font-size:12px;color:var(--muted)}

  #svgWrap{width:100%;aspect-ratio: 16/10;display:grid;place-items:center}
  #mainSvg{width:100%;height:100%}
  #mainSvg:focus{outline:none}

  .printArea{display:none}

  .checkInline{
    display:flex;gap:8px;align-items:center;
    padding:8px 10px;border-radius:10px;
    border:1px solid var(--btn-border);
    background: rgba(255,255,255,0.04);
    user-select:none;
    cursor:pointer;
  }
  .checkInline input{width:auto;margin:0}
  .checkInline span{font-size:12px;color:var(--muted);white-space:nowrap}

  /* MODE CLAIR */
  body.light{
    --bg:#f5f7fb;
    --panel:rgba(255,255,255,0.94);
    --card:rgba(255,255,255,0.94);
    --ink:#0b1220;
    --muted:#4b5567;

    --field-bg:#ffffff;
    --field-border:rgba(0,0,0,0.14);

    --btn:#eef2f8;
    --btn2:#e3e9f4;
    --btn-border:rgba(0,0,0,0.14);

    --tray-fill:rgba(0,0,0,0.03);
    --tray-stroke:rgba(0,0,0,0.12);

    --totalbox-fill:rgba(0,0,0,0.04);
    --totalbox-stroke:rgba(0,0,0,0.22);

    --beadH-fill:rgba(0,0,0,0.04);
    --beadH-stroke:rgba(0,0,0,0.22);

    --total-label: rgba(0,0,0,0.92);

    --splat-cover: rgb(0,0,0);
    --splat-reveal: rgba(220,220,220,0.40);
    --splat-stroke: rgba(0,0,0,0.18);

    --unit-fill: rgba(27,102,255,0.14);
    --unit-stroke: rgba(27,102,255,0.50);

    --danger:#e11d48;
    --accent:#1b66ff;
  }

  body.light header{border-bottom:1px solid rgba(0,0,0,0.08)}
  body.light .panel{box-shadow:0 10px 30px rgba(0,0,0,0.06)}
  body.light .cardbox{border-color:rgba(0,0,0,0.10)}
  body.light .iconbtn{
    background: linear-gradient(180deg, rgba(0,0,0,0.05), rgba(0,0,0,0.02));
    box-shadow: 0 6px 18px rgba(0,0,0,0.10);
  }
  body.light .iconbtn:hover{box-shadow: 0 10px 22px rgba(0,0,0,0.14);}
  body.light .checkInline{background: rgba(0,0,0,0.03);}
  body.light .smallnote{border-color:rgba(0,0,0,0.12);background: rgba(0,0,0,0.02);}
  body.light .pill{border-color:rgba(0,0,0,0.14);background: rgba(0,0,0,0.03);}

  /* Impression */
  @media print{
    @page{ size: A4; margin: 8mm; }
    body{background:#fff;color:#000}
    header,.wrap{display:none !important}
    .printArea{display:block}
    .sheet{page-break-after:always;padding:6mm}
    /* 2 colonnes (4 cartes / page : 2 x 2) */
    .grid{display:grid;grid-template-columns:repeat(2, 1fr);gap:5mm}
    .pCard{border:1px solid #ddd;border-radius:6mm;padding:2mm}
    .pCard svg{width:100%;height:auto}
  }

  /* Plein écran */
  .fsHost:fullscreen{background:var(--bg)}
  .fsHost:fullscreen #svgWrap{width:100vw;height:100vh;aspect-ratio:auto;padding:10px}
  .fsHost:fullscreen .cardbox{width:100vw;height:100vh;border-radius:0;padding:10px}
</style>
</head>

<body class="light">
<header>
  <h1>Splat!</h1>
</header>

<div class="wrap">
  <section class="panel">
    <label>Type d’activité</label>
    <select id="activity">
      <option value="U">A — Petites billes (sans numéros)</option>
      <option value="N">B — Billes numérotées (une couleur)</option>
      <option value="NPM">B± — Billes numérotées (entiers relatifs)</option>
      <option value="C">C — Enquête (relations, 3 couleurs)</option>
      <option value="D">D — Système (sommes, 3 couleurs)</option>
      <option value="EQ">E — Équation (2 plateaux)</option>
          <option value="EQPM">E± — Equation (2 plateaux, entiers relatifs)</option>
          <option value="C9">F — Opérations en 9 (9 → 99)</option>
          <option value="C8">G — Opérations en 8 (8 → 98)</option>
    </select>

    <div id="classicSettings">
      <div class="row">
        <div style="flex:1">
          <label>Niveau (pré-réglage 1→3)</label>
          <input id="difficulty" type="number" min="1" max="3" value="2" />
        </div>
        <div style="flex:1">
          <label>Graine (optionnelle)</label>
          <input id="seed" type="number" placeholder="ex: 2026" />
        </div>
      </div>
    </div>

    <div id="unitSettings" style="display:none">
      <div class="u-section-title">Contraintes</div>

      <div class="u-grid">
        <label class="u-label">Taches</label>
        <div class="u-controls">
          <div class="u-mini">
            <div class="u-mini-label">min</div>
            <input id="unitTasksMin" type="number" min="1" max="5" value="1" />
          </div>
          <div class="u-mini">
            <div class="u-mini-label">max</div>
            <input id="unitTasks" type="number" min="1" max="5" value="1" />
          </div>
        </div>

        <label class="u-label">Total</label>
        <div class="u-controls">
          <div class="u-mini">
            <div class="u-mini-label">min</div>
            <input id="unitTotalMin" type="number" min="1" max="50" value="1" />
          </div>
          <div class="u-mini">
            <div class="u-mini-label">max</div>
            <input id="unitTotalMax" type="number" min="1" max="50" value="50" />
          </div>
        </div>

        <label class="u-label">Billes</label>
        <div class="u-controls">
          <div class="u-mini">
            <div class="u-mini-label">visibles ≤</div>
            <input id="unitVisibleMax" type="number" min="1" max="20" value="15" />
          </div>
          <div class="u-mini">
            <div class="u-mini-label">cachees ≤</div>
            <input id="unitHiddenMax" type="number" min="0" max="20" value="10" />
          </div>
        </div>

        <label class="u-label">Graine</label>
        <div class="u-controls">
          <div class="u-mini u-seed">
            <div class="u-mini-label">optionnelle</div>
            <input id="seedU" type="number" placeholder="ex: 2026" />
          </div>
        </div>
      </div>
    </div>


    <div id="numberedSettings" style="display:none">
      <div class="row">
        <div style="flex:1">
          <label><span id="labelNumTasks">Nombre de taches</span></label>
          <div id="numTasksRange" style="display:flex; gap:10px; align-items:flex-end">
            <div id="numTasksMinWrap" style="display:none; flex-direction:column; gap:2px">
              <div id="numTasksMinLabel" style="font-size:12px;color:var(--muted)">Min</div>
              <input id="numTasksMin" type="number" min="1" max="6" value="1" style="width:72px" title="Min" />
            </div>

            <div id="numTasksMaxWrap" style="display:flex; flex-direction:column; gap:2px">
              <div id="numTasksMaxLabel" style="font-size:12px;color:var(--muted); display:none">Max</div>
              <input id="numTasks" type="number" min="1" max="6" value="1" style="width:72px" title="Max" />
            </div>

            <span id="numTasksArrow" style="display:none"></span>
          </div>
        </div>
        <div style="flex:1">
          <label>Billes visibles num (min)</label>
          <input id="numVisibleMin" type="number" min="1" max="5" value="2" />
        </div>
        <div style="flex:1">
          <label>Billes visibles num (max)</label>
          <input id="numVisibleMax" type="number" min="1" max="5" value="3" />
        </div>
      </div>
      <div class="row" style="margin-top:10px; flex-wrap:nowrap">
        <div style="flex:0 0 auto">
          <label>Billes cachées<br>par tache</label>
          <select id="numHiddenCount" style="width:72px">
            <option value="1" selected>1</option>
            <option value="2">2</option>
          </select>
        </div>

        <div id="numBeadAbsMaxWrap" style="flex:0 0 auto; display:none">
          <label>Valeur max<br>des billes (|v|)</label>
          <input id="numBeadAbsMax" type="number" min="1" max="99" value="30" style="width:72px" />
        </div>
        <div id="numOpposeModeWrap" style="flex:0 0 auto; display:none">
          <label>Taches opposees<br>(±X)</label>
          <select id="numOpposeMode" style="width:130px">
          <option value="off" selected>Aucune</option>
          <option value="all">Toutes opposees</option>
          <option value="auto">Parfois</option>
          <option value="mix">Melange</option>
        </select>
        </div>

      </div>
      <div class="row" style="margin-top:10px">
        <div style="flex:1">
          <label>Total (min)</label>
          <input id="numTotalMin" type="number" min="1" max="1000" value="20" />
        </div>
        <div style="flex:1">
          <label>Total (max)</label>
          <input id="numTotalMax" type="number" min="1" max="1000" value="50" />
        </div>
        <div style="flex:1">
          <label>Graine (mode B)</label>
          <input id="seedN" type="number" placeholder="ex: 2026" />
        </div>
      </div>
    </div>

    <div id="nineSettings" style="display:none">
      <div class="row">
        <div style="flex:1">
          <label>Opération (…9)</label>
          <select id="nineOp">
            <option value="SUB" selected>Différence (TOTAL − …)</option>
            <option value="ADD">Somme (…9 visible + autres)</option>
            <option value="MIX">Melange</option>
          </select>
        </div>
        <div style="flex:1">
          <label>Nombre de taches</label>
          <input id="nineTasks" type="number" min="1" max="6" value="1" />
        </div>
        <div style="flex:1">
          <label>Billes visibles max</label>
          <input id="nineVisibleMax" type="number" min="1" max="5" value="3" />
        </div>
      </div>
      <div class="row" style="margin-top:10px">
        <div style="flex:1">
          <label>Total (min)</label>
          <input id="nineTotalMin" type="number" min="1" max="1000" value="30" />
        </div>
        <div style="flex:1">
          <label>Total (max)</label>
          <input id="nineTotalMax" type="number" min="1" max="1000" value="120" />
        </div>
        <div style="flex:1">
          <label>Graine (mode C)</label>
          <input id="seedC" type="number" placeholder="ex: 2026" />
        </div>
      </div>
    </div>

    <div id="eightSettings" style="display:none">
      <div class="row">
        <div style="flex:1">
          <label>Opération (…8)</label>
          <select id="eightOp">
            <option value="SUB" selected>Différence (TOTAL − …)</option>
            <option value="ADD">Somme (…8 visible + autres)</option>
            <option value="MIX">Melange</option>
          </select>
        </div>
        <div style="flex:1">
          <label>Nombre de taches</label>
          <input id="eightTasks" type="number" min="1" max="6" value="1" />
        </div>
        <div style="flex:1">
          <label>Billes visibles max</label>
          <input id="eightVisibleMax" type="number" min="1" max="5" value="3" />
        </div>
      </div>
      <div class="row" style="margin-top:10px">
        <div style="flex:1">
          <label>Total (min)</label>
          <input id="eightTotalMin" type="number" min="1" max="1000" value="30" />
        </div>
        <div style="flex:1">
          <label>Total (max)</label>
          <input id="eightTotalMax" type="number" min="1" max="1000" value="120" />
        </div>
        <div style="flex:1">
          <label>Graine (mode D)</label>
          <input id="seedD" type="number" placeholder="ex: 2026" />
        </div>
      </div>
    </div>

    <div id="investigateSettings" style="display:none">
      <div class="c-grid">
        <div class="c-field">
          <label>Nombre de taches</label>
          <select id="invTaskCount">
            <option value="2" selected>2 Taches</option>
            <option value="3">3 Taches</option>
          </select>
        </div>
        <div class="c-field">
          <label>Format Indices</label>
          <select id="invClueType">
            <option value="SENTENCE" selected>Phrases</option>
            <option value="SYMBOL">Symboles (=)</option>
          </select>
        </div>

        <div class="c-field" id="invStructureRow" style="margin-top:6px;">
          <label>Structure (3 taches)</label>
          <select id="invStructure3">
            <option value="CHAIN">Chaîne (A→B→C)</option>
            <option value="PIVOT">Pivot (B←A→C)</option>
            <option value="MIX" selected>Aléatoire</option>
          </select>
        </div>
      </div>

      <label>Opérations autorisées</label>
      <div class="c-ops">

        <label class="checkInline" title="Multiplication (Ex: 3 fois plus)"><input type="checkbox" id="invOpMul" checked> <span>×k</span></label>

        <label class="checkInline" title="Division (Ex: 3 fois moins)"><input type="checkbox" id="invOpDiv" checked> <span>÷k</span></label>

        <label class="checkInline" title="Addition (Ex: 5 de plus)"><input type="checkbox" id="invOpAdd" checked> <span>+k</span></label>

        <label class="checkInline" title="Soustraction (Ex: 5 de moins)"><input type="checkbox" id="invOpSub" checked> <span>−k</span></label>
      </div>

      <div class="c-grid" style="margin-top:8px">
        <div class="c-field c-small">
          <label>Valeur ajout/retrait max</label>
          <input id="invMaxAdd" type="number" min="1" max="100" value="20" />
        </div>
        <div class="c-field c-small">
          <label>Graine (mode C)</label>
          <input id="seedE" type="number" placeholder="ex: 2026" />
        </div>
      </div>

      <div class="c-pairs">
        <div class="c-pair">
          <div class="c-mini">
            <div class="c-mini-label">Billes visibles (min)</div>
            <input id="invVisibleMin" type="number" min="1" max="10" value="1" />
          </div>
          <div class="c-mini">
            <div class="c-mini-label">Billes visibles (max)</div>
            <input id="invVisibleMax" type="number" min="1" max="10" value="3" />
          </div>
        </div>
        <div class="c-pair">
          <div class="c-mini">
            <div class="c-mini-label">Total (min)</div>
            <input id="invTotalMin" type="number" min="1" max="1000" value="20" />
          </div>
          <div class="c-mini">
            <div class="c-mini-label">Total (max)</div>
            <input id="invTotalMax" type="number" min="1" max="1000" value="100" />
          </div>
        </div>
      </div>
    </div>

    <div id="systemSettings" style="display:none">
      <div class="row">
        <div style="flex:1">
          <label>Format Indices</label>
          <select id="sysClueType">
            <option value="SENTENCE" selected>Phrases</option>
            <option value="SYMBOL">Symboles (+)</option>
          </select>
        </div>
      </div>
      <div class="row" style="margin-top:10px">
        <div style="flex:1">
          <label>Billes visibles (min)</label>
          <input id="sysVisibleMin" type="number" min="1" max="10" value="1" />
        </div>
        <div style="flex:1">
          <label>Billes visibles (max)</label>
          <input id="sysVisibleMax" type="number" min="1" max="10" value="3" />
        </div>
      </div>
      <div class="row" style="margin-top:10px">
        <div style="flex:1">
          <label>Total (min)</label>
          <input id="sysTotalMin" type="number" min="1" max="1000" value="30" />
        </div>
        <div style="flex:1">
          <label>Total (max)</label>
          <input id="sysTotalMax" type="number" min="1" max="1000" value="150" />
        </div>
        <div style="flex:1">
          <label>Graine (mode D)</label>
          <input id="seedSys" type="number" placeholder="ex: 2026" />
        </div>
      </div>
    </div>

    <div class="row" style="margin-top:10px; align-items:flex-end">
      <div style="flex:0 0 auto">
        <label>Nombre de cartes</label>
        <input id="count" type="number" min="1" max="300" value="10" style="width:96px" />
      </div>
      <button class="btn primary" id="btnGen">Générer</button>
<button class="btn danger" id="btnClear">Vider</button>
    </div>

    <div class="row" style="margin-top:10px">
      <button class="btn" id="btnPrev">◀</button>
      <button class="btn" id="btnNext">▶</button>
      <button class="iconbtn" id="btnFullscreen" title="Plein écran">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <path fill="currentColor" d="M8 3H3v5h2V5h3V3zm13 0h-5v2h3v3h2V3zM5 16H3v5h5v-2H5v-3zm16 0h-2v3h-3v2h5v-5z"/>
        </svg>
      </button>
    </div>

    <div class="row" style="margin-top:10px">
      <button class="btn" id="btnPrint">Imprimer planche</button>
      <label class="checkInline" title="Imprime avec la/les taches en mode révélé (réponses visibles)">
        <input id="printAnswers" type="checkbox" />
        <span>Avec réponses</span>
      </label>
    </div>
    <div class="hint">
      Raccourcis :<br>
      • Espace = révéler / cacher<br>
      • ← / → = carte précédente / suivante<br>
      • F = plein écran<br><br>
      Graine : vide = série nouvelle à chaque clic ; remplie = série reproductible.
    </div>
  </section>

  <section class="stage fsHost" id="fsHost">
    <div class="cardbox">
      <div class="nav">
        <div class="counter" id="counter">0 carte</div>
      </div>
      <div id="svgWrap">
        <svg id="mainSvg" tabindex="0" viewBox="0 0 1600 1000" aria-label="Splat card"></svg>
      </div>
    </div>
  </section>
</div>

<div class="printArea" id="printArea"></div>

<script>
/* RNG */
function mulberry32(a){return function(){let t=a+=0x6D2B79F5;t=Math.imul(t^(t>>>15),t|1);t^=t+Math.imul(t^(t>>>7),t|61);return((t^(t>>>14))>>>0)/4294967296;};}
function makeRng(seed){
  if(seed===null||seed===undefined||seed==="") return Math.random;
  const s = Number(seed);
  if(!Number.isFinite(s)) return Math.random;
  return mulberry32(s|0);
}
function rInt(rng,a,b){return a+Math.floor(rng()*(b-a+1));}
function rFloat(rng,a,b){return a + rng()*(b-a);}
function shuffleInPlace(arr,rng){for(let i=arr.length-1;i>0;i--){const j=Math.floor(rng()*(i+1));[arr[i],arr[j]]=[arr[j],arr[i]];}}

function beadColorForValue(v){
  // Couleur = valeur (avec une distinction claire entre + et −, mais sans changer les couleurs des positifs)
  const mag = Math.abs(v);
  let hue = (((mag * 37) % 360) + 360) % 360;
  if(v < 0) hue = (hue + 180) % 360;

  const isLight = document.body.classList.contains("light");
  const fillA = isLight ? 0.18 : 0.24;
  const strokeA = isLight ? 0.55 : 0.65;
  return {
    fill: `hsla(${hue}, 78%, 54%, ${fillA})`,
    stroke: `hsla(${hue}, 78%, 48%, ${strokeA})`
  };
}

/* UI refs */
const activityEl = document.getElementById("activity");
const countEl = document.getElementById("count");
const diffEl = document.getElementById("difficulty");
const seedEl = document.getElementById("seed");
const seedUEl = document.getElementById("seedU");

const classicSettingsEl = document.getElementById("classicSettings");
const unitSettingsEl = document.getElementById("unitSettings");

const numberedSettingsEl = document.getElementById("numberedSettings");
const nineSettingsEl = document.getElementById("nineSettings");
const nineOpEl = document.getElementById("nineOp");
const nineTasksEl = document.getElementById("nineTasks");
const nineTotalMinEl = document.getElementById("nineTotalMin");
const nineTotalMaxEl = document.getElementById("nineTotalMax");
const nineVisibleMaxEl = document.getElementById("nineVisibleMax");
const seedCEl = document.getElementById("seedC");

const eightSettingsEl = document.getElementById("eightSettings");
const eightOpEl = document.getElementById("eightOp");
const eightTasksEl = document.getElementById("eightTasks");
const eightVisibleMaxEl = document.getElementById("eightVisibleMax");
const eightTotalMinEl = document.getElementById("eightTotalMin");
const eightTotalMaxEl = document.getElementById("eightTotalMax");
const seedDEl = document.getElementById("seedD");

/* UI refs - Mode C (Enquête) */
const investigateSettingsEl = document.getElementById("investigateSettings");
const invTaskCountEl = document.getElementById("invTaskCount");
const invClueTypeEl = document.getElementById("invClueType");
const invStructureRow = document.getElementById("invStructureRow");
const invStructure3El = document.getElementById("invStructure3");
const invOpMulEl = document.getElementById("invOpMul");
const invOpDivEl = document.getElementById("invOpDiv");
const invOpAddEl = document.getElementById("invOpAdd");
const invOpSubEl = document.getElementById("invOpSub");
const invMaxAddEl = document.getElementById("invMaxAdd");
const invVisibleMinEl = document.getElementById("invVisibleMin");
const invVisibleMaxEl = document.getElementById("invVisibleMax");
const invTotalMinEl = document.getElementById("invTotalMin");
const invTotalMaxEl = document.getElementById("invTotalMax");
const seedEEl = document.getElementById("seedE");

/* UI refs - Mode D (Système) */
const systemSettingsEl = document.getElementById("systemSettings");
const sysClueTypeEl = document.getElementById("sysClueType");
const sysVisibleMinEl = document.getElementById("sysVisibleMin");
const sysVisibleMaxEl = document.getElementById("sysVisibleMax");
const sysTotalMinEl = document.getElementById("sysTotalMin");
const sysTotalMaxEl = document.getElementById("sysTotalMax");
const seedSysEl = document.getElementById("seedSys");

const unitTasksEl = document.getElementById("unitTasks");
const unitTasksMinEl = document.getElementById("unitTasksMin");
const unitVisibleMaxEl = document.getElementById("unitVisibleMax");
const unitHiddenMaxEl = document.getElementById("unitHiddenMax");
const unitTotalMinEl = document.getElementById("unitTotalMin");
const unitTotalMaxEl = document.getElementById("unitTotalMax");

const numTasksEl = document.getElementById("numTasks");
const labelNumTasksEl = document.getElementById("labelNumTasks");
const numTasksMinEl = document.getElementById("numTasksMin");
const numTasksArrowEl = document.getElementById("numTasksArrow");
const numTasksMinWrapEl = document.getElementById("numTasksMinWrap");
const numTasksMaxWrapEl = document.getElementById("numTasksMaxWrap");
const numTasksMinLabelEl = document.getElementById("numTasksMinLabel");
const numTasksMaxLabelEl = document.getElementById("numTasksMaxLabel");
let _tasksUIKeyPrev = null;
let _numTasksSavedNumberedMax = null;
let _numTasksSavedNumberedMin = null;
let _numTasksSavedEquationMax = "6";

function setNumTasksRangeVisible(show){
  // In mode B ("N"): show 2 inputs (tache min / tache max). Otherwise: only the single input (numTasks).
  if(numTasksMinWrapEl) numTasksMinWrapEl.style.display = show ? "flex" : "none";
  if(numTasksMaxLabelEl) numTasksMaxLabelEl.style.display = show ? "" : "none";
  if(numTasksArrowEl) numTasksArrowEl.style.display = "none";
}
function syncNumTasksUI(act){
  if(!numTasksEl || !labelNumTasksEl) return;
  const key = (act === "EQ" || act === "EQPM") ? "EQ" : ((act === "N" || act === "NPM") ? "N" : "OTHER");
  if(_tasksUIKeyPrev === key) return;

  if(key === "EQ"){
    // Save numbered values (B)
    _numTasksSavedNumberedMax = numTasksEl.value;
    if(numTasksMinEl) _numTasksSavedNumberedMin = numTasksMinEl.value;

    // Restore equation max
    if(_numTasksSavedEquationMax != null) numTasksEl.value = _numTasksSavedEquationMax;

    labelNumTasksEl.textContent = "Max (par plateau)";
    setNumTasksRangeVisible(false);

    numTasksEl.min = "2";
    numTasksEl.max = "6";
    const v = clamp(numberOr(numTasksEl.value, 6), 2, 6);
    numTasksEl.value = String(v);
  } else if(key === "N"){
    // Save equation max (E/EQ)
    if(_tasksUIKeyPrev === "EQ") _numTasksSavedEquationMax = numTasksEl.value;

    // Restore numbered values if available
    if(_numTasksSavedNumberedMax != null) numTasksEl.value = _numTasksSavedNumberedMax;
    if(numTasksMinEl && _numTasksSavedNumberedMin != null) numTasksMinEl.value = _numTasksSavedNumberedMin;

    labelNumTasksEl.textContent = "Nombre de taches";
    setNumTasksRangeVisible(true);

    numTasksEl.min = "1";
    numTasksEl.max = "6";
    if(numTasksMinEl){
      numTasksMinEl.min = "1";
      numTasksMinEl.max = "6";
      let a = clamp(numberOr(numTasksMinEl.value, 1), 1, 6);
      let b = clamp(numberOr(numTasksEl.value, 1), 1, 6);
      if(b < a){ const tmp = a; a = b; b = tmp; }
      numTasksMinEl.value = String(a);
      numTasksEl.value = String(b);
    } else {
      const v = clamp(numberOr(numTasksEl.value, 1), 1, 6);
      numTasksEl.value = String(v);
    }
  } else {
    labelNumTasksEl.textContent = "Nombre de taches";
    setNumTasksRangeVisible(false);
    numTasksEl.min = "1";
    numTasksEl.max = "6";
    const v = clamp(numberOr(numTasksEl.value, 1), 1, 6);
    numTasksEl.value = String(v);
  }

  _tasksUIKeyPrev = key;
}

const numVisibleMinEl = document.getElementById("numVisibleMin");
const numVisibleMaxEl = document.getElementById("numVisibleMax");
const numHiddenCountEl = document.getElementById("numHiddenCount");
const numTotalMinEl = document.getElementById("numTotalMin");
const numTotalMaxEl = document.getElementById("numTotalMax");
const seedNEl = document.getElementById("seedN");
const numBeadAbsMaxWrapEl = document.getElementById("numBeadAbsMaxWrap");
const numBeadAbsMaxEl = document.getElementById("numBeadAbsMax");
const numOpposeModeWrapEl = document.getElementById("numOpposeModeWrap");
const numOpposeModeEl = document.getElementById("numOpposeMode");


/* Helpers */
function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }
function numberOr(x, fallback){ const n = Number(x); return Number.isFinite(n) ? n : fallback; }

function sanitizeIntegerInput(el){
  if(!el) return false;
  const raw = (el.value ?? "").toString().trim();
  if(raw === "") return false;
  let v = Number(raw);
  if(!Number.isFinite(v)) return false;

  // Enforce integer (these UIs are all integer-based)
  v = Math.round(v);
  if(Object.is(v, -0)) v = 0;

  const minAttr = (el.min ?? "").toString().trim();
  const maxAttr = (el.max ?? "").toString().trim();
  const hasMin = minAttr !== "" && Number.isFinite(Number(minAttr));
  const hasMax = maxAttr !== "" && Number.isFinite(Number(maxAttr));
  if(hasMin) v = Math.max(v, Number(minAttr));
  if(hasMax) v = Math.min(v, Number(maxAttr));

  const newVal = String(v);
  if(el.value !== newVal){
    el.value = newVal;
    return true;
  }
  return false;
}

function hookNumberInputClamps(){
  const all = Array.from(document.querySelectorAll('input[type="number"]'));
  all.forEach(el=>{
    // Seeds are intentionally free-form; leave them alone.
    if(el.id === "seed" || (el.id && el.id.startsWith("seed"))) return;

    // Only clamp fields that declare min/max (static or dynamic). Others stay as-is.
    const minAttr = (el.min ?? "").toString().trim();
    const maxAttr = (el.max ?? "").toString().trim();
    if(minAttr === "" && maxAttr === "") return;

    const handler = ()=>{
      const changed = sanitizeIntegerInput(el);
      // If we changed the value (clamped), regenerate to match what the UI now shows.
      if(changed) scheduleAutoGenerate();
    };
    el.addEventListener("blur", handler);
    el.addEventListener("change", handler);
  });
}
function hookMinMaxPairs(){
  // Enforce basic coherence on common (min/max) input pairs:
  // if min > max, we set max = min (keeps the user's min as the "master", per UI expectation).
  const pairs = [
    [unitTotalMinEl, unitTotalMaxEl],
    [unitTasksMinEl, unitTasksEl],
    [numTasksMinEl, numTasksEl], // numbered tasks range (only when range UI is visible)
    [numVisibleMinEl, numVisibleMaxEl],
    [numTotalMinEl, numTotalMaxEl],
    [nineTotalMinEl, nineTotalMaxEl],
    [eightTotalMinEl, eightTotalMaxEl],
    [invVisibleMinEl, invVisibleMaxEl],
    [invTotalMinEl, invTotalMaxEl],
    [sysVisibleMinEl, sysVisibleMaxEl],
    [sysTotalMinEl, sysTotalMaxEl],
  ];

  pairs.forEach(([minEl, maxEl])=>{
    if(!minEl || !maxEl) return;

    const handler = ()=>{
      // Only enforce when both inputs are currently visible (avoid touching "saved" hidden values).
      if(minEl.offsetParent === null || maxEl.offsetParent === null) return;

      let changed = false;
      changed = sanitizeIntegerInput(minEl) || changed;
      changed = sanitizeIntegerInput(maxEl) || changed;

      const minV = Number(minEl.value);
      const maxV = Number(maxEl.value);
      if(Number.isFinite(minV) && Number.isFinite(maxV) && minV > maxV){
        maxEl.value = String(minV);
        sanitizeIntegerInput(maxEl);
        changed = true;
      }
      if(changed) scheduleAutoGenerate();
    };

    minEl.addEventListener("blur", handler);
    minEl.addEventListener("change", handler);
    maxEl.addEventListener("blur", handler);
    maxEl.addEventListener("change", handler);
  });
}



// Remember per-mode Total bounds for numbered modes (B and B±)
let lastActivityForBounds = activityEl.value;
const lastNumberedTotalBounds = { N: null, NPM: null };

function getSeedForCurrentMode(){
  const act = activityEl.value;
  if(act === "U") return (seedUEl.value||"").trim() ? Number(seedUEl.value) : "";
  if(act === "N" || act === "NPM") return (seedNEl.value||"").trim() ? Number(seedNEl.value) : "";
  if(act === "EQ" || act === "EQPM") return (seedNEl.value||"").trim() ? Number(seedNEl.value) : "";
  if(act === "C") return (seedEEl.value||"").trim() ? Number(seedEEl.value) : "";
  if(act === "D") return (seedSysEl.value||"").trim() ? Number(seedSysEl.value) : "";
  if(act === "C9") return (seedCEl.value||"").trim() ? Number(seedCEl.value) : "";
  if(act === "C8") return (seedDEl.value||"").trim() ? Number(seedDEl.value) : "";
  return (seedEl.value||"").trim() ? Number(seedEl.value) : "";
}

function syncSettingsUI(){
  const act = activityEl.value;


  // --- B vs B± : Total bounds and allowed ranges (UI only, generator unchanged for now) ---
  if(lastActivityForBounds && lastActivityForBounds !== act){
    // Save current bounds for the mode we leave (only B / B± share these inputs)
    if(lastActivityForBounds === "N" || lastActivityForBounds === "NPM"){
      lastNumberedTotalBounds[lastActivityForBounds] = {
        min: String(numTotalMinEl.value),
        max: String(numTotalMaxEl.value)
      };
    }
    // Restore bounds for the mode we enter
    if(act === "N" || act === "NPM"){
      const saved = lastNumberedTotalBounds[act];
      if(saved && saved.min != null && saved.max != null){
        numTotalMinEl.value = saved.min;
        numTotalMaxEl.value = saved.max;
      } else if(act === "NPM"){
        // Default for B±
        numTotalMinEl.value = "-30";
        numTotalMaxEl.value = "30";
      }
    }
  }

  if(act === "NPM"){
    // B± accepts negative totals, constrained to [-99, +99]
    numTotalMinEl.min = "-99"; numTotalMinEl.max = "99";
    numTotalMaxEl.min = "-99"; numTotalMaxEl.max = "99";

    // If the page loads directly on B± (no prior switch), enforce the defaults once.
    if(!lastNumberedTotalBounds.NPM){
      const curMin = String(numTotalMinEl.value).trim();
      const curMax = String(numTotalMaxEl.value).trim();
      if(curMin === "20" && curMax === "50"){ // initial B defaults in HTML
        numTotalMinEl.value = "-30";
        numTotalMaxEl.value = "30";
      }
    }
  } else if(act === "N" || act === "EQ" || act === "EQPM"){
    // B and EQ stay on positive totals (historical behavior)
    numTotalMinEl.min = "1"; numTotalMinEl.max = "1000";
    numTotalMaxEl.min = "1"; numTotalMaxEl.max = "1000";

    // If coming back from B± with negatives, bring back to a safe range.
    if(Number(numTotalMinEl.value) < 1) numTotalMinEl.value = "20";
    if(Number(numTotalMaxEl.value) < 1) numTotalMaxEl.value = "50";
  }

  const isUnit = act === "U";
  const isEquation = (act === "EQ" || act === "EQPM");
  syncNumTasksUI(act);
  const isNumbered = (act === "N" || act === "NPM" || isEquation);
  const isNine = act === "C9";
  const isEight = act === "C8";
  const isInvestigate = act === "C";
  const isSystem = act === "D";
  const isClassic = !(isUnit || isNumbered || isNine || isEight || isInvestigate || isSystem);

  // En EQ, on autorise jusqu’à 6 billes visibles (par plateau).
  // Dans les autres modes, on garde le plafond historique à 5 pour ne rien casser.
  if(isEquation){
    numVisibleMinEl.max = "6";
    numVisibleMaxEl.max = "6";
  } else {
    numVisibleMinEl.max = "5";
    numVisibleMaxEl.max = "5";
    if(Number(numVisibleMinEl.value) > 5) numVisibleMinEl.value = "5";
    if(Number(numVisibleMaxEl.value) > 5) numVisibleMaxEl.value = "5";
  }


  classicSettingsEl.style.display = isClassic ? "block" : "none";
  unitSettingsEl.style.display = isUnit ? "block" : "none";
  numberedSettingsEl.style.display = isNumbered ? "block" : "none";
  nineSettingsEl.style.display = isNine ? "block" : "none";
  eightSettingsEl.style.display = isEight ? "block" : "none";
  investigateSettingsEl.style.display = isInvestigate ? "block" : "none";
  systemSettingsEl.style.display = isSystem ? "block" : "none";

  // B± uniquement : borne sur la valeur absolue des billes
  if(numBeadAbsMaxWrapEl) numBeadAbsMaxWrapEl.style.display = (act === "NPM" || act === "EQPM") ? "block" : "none";
  if(numOpposeModeWrapEl) numOpposeModeWrapEl.style.display = (act === "NPM" || act === "EQPM") ? "block" : "none";
  if(act === "NPM" || act === "EQPM") sanitizeBeadAbsMaxForBPM();

  if(isInvestigate){
    if(invTaskCountEl.value === "3"){ invStructureRow.style.display = "flex"; } else { invStructureRow.style.display = "none"; }
  }

  if(isUnit) syncUnitTotalBounds();
  lastActivityForBounds = act;
}

function syncUnitTotalBounds(){
  const tasksMax = clamp(numberOr(unitTasksEl.value, 1), 1, 5);
  const tasksMin = clamp(numberOr(unitTasksMinEl ? unitTasksMinEl.value : tasksMax, 1), 1, 5);
  const tasks = Math.max(tasksMin, tasksMax); // use max tasks for safe bounds
  if(unitTasksMinEl){
    const a = Math.min(tasksMin, tasksMax);
    const b = Math.max(tasksMin, tasksMax);
    unitTasksMinEl.value = String(a);
    unitTasksEl.value = String(b);
  }

  const vMax = clamp(numberOr(unitVisibleMaxEl.value, 15), 1, 20);
  const hMax = clamp(numberOr(unitHiddenMaxEl.value, 10), 0, 20);

  const HARD_CAP = 50; 
  const maxPossible = vMax + tasks * hMax;
  const maxAllowed = clamp(Math.min(maxPossible, HARD_CAP), 1, HARD_CAP);
  const minPossible = 1 + tasks * (hMax > 0 ? 1 : 0);

  unitTotalMinEl.min = 1;
  unitTotalMinEl.max = String(maxAllowed);
  unitTotalMaxEl.min = 1;
  unitTotalMaxEl.max = String(maxAllowed);

  let tMin = clamp(numberOr(unitTotalMinEl.value, minPossible), 1, maxAllowed);
  let tMax = clamp(numberOr(unitTotalMaxEl.value, maxAllowed), 1, maxAllowed);

  if(tMin < minPossible) tMin = minPossible;
  if(tMax < minPossible) tMax = minPossible;
  if(tMax < tMin) tMax = tMin;

  unitTotalMinEl.value = String(tMin);
  unitTotalMaxEl.value = String(tMax);
}

let autoGenTimer = null;
function sanitizeNumberedTotalBoundsForMode(){
  const act = activityEl.value;
  if(act !== "NPM") return;

  // En B±, on force les bornes à rester dans [-99, +99] (et min <= max).
  const mn = clamp(Math.round(numberOr(numTotalMinEl.value, -30)), -99, 99);
  let mx = clamp(Math.round(numberOr(numTotalMaxEl.value, 30)), -99, 99);
  if(mn > mx) mx = mn;

  numTotalMinEl.value = String(mn);
  numTotalMaxEl.value = String(mx);
}

function sanitizeBeadAbsMaxForBPM(){
  if(!numBeadAbsMaxEl) return;
  let v = clamp(Math.round(numberOr(numBeadAbsMaxEl.value, 30)), 1, 99);
  numBeadAbsMaxEl.value = String(v);
}

function scheduleAutoGenerate(){
  if(autoGenTimer) clearTimeout(autoGenTimer);
  autoGenTimer = setTimeout(()=>{
    if(activityEl.value === "U") syncUnitTotalBounds();
    sanitizeNumberedTotalBoundsForMode();
    if(activityEl.value === "NPM" || activityEl.value === "EQPM") sanitizeBeadAbsMaxForBPM();
    generate();
  }, 150);
}

activityEl.addEventListener("change", ()=>{
  syncSettingsUI();
  scheduleAutoGenerate();
  // IMPORTANT: after selecting a mode, remove focus from the <select> so ArrowLeft/ArrowRight
  // always navigate cards (and don't change C→D, etc.).
  try{ activityEl.blur(); }catch(_e){}
  const _ms = document.getElementById("mainSvg");
  if(_ms && typeof _ms.focus==="function"){ _ms.focus(); }
});
invTaskCountEl.addEventListener("change", ()=>{ syncSettingsUI(); scheduleAutoGenerate(); });

[
  countEl, diffEl, seedEl,
  unitTasksMinEl, unitTasksEl, unitVisibleMaxEl, unitHiddenMaxEl, unitTotalMinEl, unitTotalMaxEl, seedUEl,
  numTasksMinEl, numTasksEl, numVisibleMinEl, numVisibleMaxEl, numHiddenCountEl, numTotalMinEl, numTotalMaxEl, numBeadAbsMaxEl, numOpposeModeEl, seedNEl,
  nineOpEl, nineTasksEl, nineVisibleMaxEl, nineTotalMinEl, nineTotalMaxEl, seedCEl,
  eightOpEl, eightTasksEl, eightVisibleMaxEl, eightTotalMinEl, eightTotalMaxEl, seedDEl,
  invTaskCountEl, invClueTypeEl, invStructure3El, invOpMulEl, invOpDivEl, invOpAddEl, invOpSubEl, invMaxAddEl, invVisibleMinEl, invVisibleMaxEl, invTotalMinEl, invTotalMaxEl, seedEEl,
  sysClueTypeEl, sysVisibleMinEl, sysVisibleMaxEl, sysTotalMinEl, sysTotalMaxEl, seedSysEl
].forEach(el=>{
  if(!el) return;
  el.addEventListener("input", scheduleAutoGenerate);
  el.addEventListener("change", scheduleAutoGenerate);
});

// Clamp numeric inputs (min/max) so users cannot leave out-of-range values (e.g., 10000) in the UI.
hookNumberInputClamps();


hookMinMaxPairs();
/* Positions + splat */
function blobPath(cx, cy, r){
  const n = 40;
  const lobes = 5;
  const pts = [];
  for(let i=0;i<n;i++){
    const a = (Math.PI * 2 * i) / n;
    const k = 0.90 + 0.16 * Math.sin(lobes*a) + 0.04 * Math.sin(2*lobes*a);
    const rr = r * k;
    pts.push([cx + Math.cos(a)*rr, cy + Math.sin(a)*rr]);
  }
  function cr2bz(p0,p1,p2,p3){
    const t = 1/6;
    const c1x = p1[0] + (p2[0]-p0[0]) * t;
    const c1y = p1[1] + (p2[1]-p0[1]) * t;
    const c2x = p2[0] - (p3[0]-p1[0]) * t;
    const c2y = p2[1] - (p3[1]-p1[1]) * t;
    return [c1x,c1y,c2x,c2y,p2[0],p2[1]];
  }
  let d = `M ${pts[0][0]} ${pts[0][1]}`;
  for(let i=0;i<n;i++){
    const p0 = pts[(i-1+n)%n];
    const p1 = pts[i];
    const p2 = pts[(i+1)%n];
    const p3 = pts[(i+2)%n];
    const [c1x,c1y,c2x,c2y,x,y] = cr2bz(p0,p1,p2,p3);
    d += ` C ${c1x} ${c1y}, ${c2x} ${c2y}, ${x} ${y}`;
  }
  d += " Z";
  return d;
}

function getUnitSplats(taskCount){
  const tray = { x:120, y:260, w:1360, h:650 };
  const cyMid = tray.y + tray.h/2; 
  const anchors = {
    1:[{cx:820, cy:cyMid+25}],
    2:[{cx:580, cy:cyMid+25},{cx:1060, cy:cyMid+25}],
    3:[{cx:820, cy:470},{cx:610, cy:690},{cx:1030, cy:690}],
    4:[{cx:610, cy:480},{cx:1030, cy:480},{cx:610, cy:740},{cx:1030, cy:740}],
    5:[{cx:820, cy:367},{cx:560, cy:585},{cx:1080, cy:585},{cx:560, cy:803},{cx:1080, cy:803}],
  };
  const base = anchors[taskCount] || anchors[2];
  const r = (taskCount<=1) ? 235 : (taskCount===2 ? 185 : (taskCount===3 ? 155 : (taskCount===4 ? 135 : 102)));
  return base.map(p => ({...p, r}));
}

/* TRAY CONFIGURATION */
function getTrayConfig(mode){
  // Plateau (coordonnées de génération + affichage écran)
  // - Mode C : on réserve une zone d'en-tête (TOTAL au-dessus) et une zone d'indices en bas
  // - Mode D : comme C (TOTAL au-dessus + indices sous le plateau)
  if(mode === "C") return { x:120, y:270, w:1360, h:550, isHigh: false };
  if(mode === "D") return { x:120, y:270, w:1360, h:550, isHigh: false };
  return { x:120, y:260, w:1360, h:650, isHigh: false };
}

function getNumberedSplats(taskCount, mode){
  const tray = getTrayConfig(mode);
  const cyMid = tray.y + tray.h/2; 

  const anchors = {
    1:[{cx:820, cy:cyMid+25}],
    2:[{cx:580, cy:cyMid+25},{cx:1060, cy:cyMid+25}],
    
    3:[{cx:820, cy:cyMid-110},{cx:580, cy:cyMid+130},{cx:1060, cy:cyMid+130}],

    4:[{cx:610, cy:465},{cx:1030, cy:465},{cx:610, cy:745},{cx:1030, cy:745}],
    5:[{cx:540, cy:430},{cx:820, cy:430},{cx:1100, cy:430},{cx:680, cy:750},{cx:960, cy:750}],
    6:[{cx:540, cy:430},{cx:820, cy:430},{cx:1100, cy:430},{cx:540, cy:750},{cx:820, cy:750},{cx:1100, cy:750}],
  };
  let base = anchors[taskCount] || anchors[2];
  let r = (taskCount<=1) ? 260 : (taskCount===2 ? 210 : (taskCount===3 ? 165 : (taskCount===4 ? 150 : (taskCount===5 ? 130 : 118))));
  // Mode C : 3 taches => ancrages un peu plus centraux + rayon reduit, pour que les blobs restent dans le plateau.
  if((mode === "C" || mode === "D") && taskCount === 3){
    base = [{cx:820, cy:cyMid-90},{cx:580, cy:cyMid+110},{cx:1060, cy:cyMid+110}];
    r = 145;
  }
  return base.map(p => ({...p, r}));
}

function randomComposition(rng, sum, parts){
  if(parts <= 1) return [sum];
  const minSum = parts; 
  if(sum < minSum) return Array.from({length:parts}, ()=>1);
  const remain = sum - parts;
  const cuts = [];
  for(let i=0;i<parts-1;i++) cuts.push(rInt(rng, 0, remain));
  cuts.sort((a,b)=>a-b);
  const out = [];
  let prev = 0;
  for(const c of cuts){
    out.push((c - prev) + 1);
    prev = c;
  }
  out.push((remain - prev) + 1);
  shuffleInPlace(out, rng);
  return out;
}

/* Signed (relatifs) helpers — zéro interdit sur les parts */
function randomSignedCompositionNonZero(rng, sum, parts, maxAbs){
  if(parts <= 0) return [];
  if(parts === 1){
    if(sum === 0) return null;
    if(Math.abs(sum) > maxAbs) return null;
    return [sum];
  }
  // On construit progressivement en garantissant la faisabilité du reste.
  for(let tries=0; tries<4000; tries++){
    const out = [];
    let rem = sum;
    let ok = true;
    for(let i=0; i<parts-1; i++){
      const remainParts = parts - i;
      const minRem = -(remainParts-1) * maxAbs;
      const maxRem =  (remainParts-1) * maxAbs;

      // v doit être dans [-maxAbs, maxAbs] et laisser un reste faisable
      let vMin = Math.max(-maxAbs, rem - maxRem);
      let vMax = Math.min( maxAbs, rem - minRem);
      if(vMax < vMin){ ok = false; break; }

      let v = null;
      for(let k=0; k<60; k++){
        const candidate = rInt(rng, vMin, vMax);
        if(candidate === 0) continue;
        // si le dernier terme devra être unique, il ne doit pas devenir 0
        if(remainParts-1 === 1){
          const last = rem - candidate;
          if(last === 0) continue;
          if(Math.abs(last) > maxAbs) continue;
        }
        v = candidate;
        break;
      }
      if(v === null){ ok = false; break; }
      out.push(v);
      rem -= v;
    }
    if(!ok) continue;
    const last = rem;
    if(last === 0) continue;
    if(Math.abs(last) > maxAbs) continue;
    out.push(last);
    // sécurité : aucun 0
    if(out.some(x => x === 0)) continue;
    return out;
  }
  return null;
}

function splitTwoNonZeroSum(rng, sum, maxAbs){
  // Trouve (a,b) non nuls, |a|,|b|<=maxAbs, a+b=sum
  for(let tries=0; tries<2000; tries++){
    const a = rInt(rng, -maxAbs, maxAbs);
    if(a === 0) continue;
    const b = sum - a;
    if(b === 0) continue;
    if(Math.abs(b) > maxAbs) continue;
    return [a, b];
  }
  return null;
}


function assignPositionsNumbered(card, rng){
  const tray = getTrayConfig(card.family);
  const margin = 14;

  const meta = card._num;
  const splats = getNumberedSplats(meta.tasks, card.family);
  card._splats = splats;

  const minSplatR = Math.min(...splats.map(s=>s.r));
  let beadR = Math.floor((minSplatR - 28) / 2); 
  beadR = clamp(beadR, 34, 60);
  card._beadR = beadR;

  const posH = [];
  for(let t=0; t<meta.tasks; t++){
    const s = splats[t];
    const arr = meta.hiddenByTask[t];
    if(arr.length === 1){
      const maxD = Math.max(0, s.r - beadR - 30);
      const a = rFloat(rng, 0, Math.PI*2);
      const d = rFloat(rng, 0, Math.min(10, maxD));
      posH.push({cx: s.cx + Math.cos(a)*d, cy: s.cy + Math.sin(a)*d});
    }else{
      const maxD = Math.max(0, s.r - beadR - 22);
      const d = Math.min(beadR, maxD);
      const a = rFloat(rng, 0, Math.PI*2);
      const vx = Math.cos(a)*d;
      const vy = Math.sin(a)*d;
      posH.push({cx: s.cx + vx, cy: s.cy + vy});
      posH.push({cx: s.cx - vx, cy: s.cy - vy});
    }
  }
  card._posH = posH;

  const placed = [];
  function okSpot(cx, cy){
    if(cx < tray.x + beadR + margin) return false;
    if(cx > tray.x + tray.w - beadR - margin) return false;
    if(cy < tray.y + beadR + margin) return false;
    if(cy > tray.y + tray.h - beadR - margin) return false;
for(const s of splats){
      const d = Math.hypot(cx - s.cx, cy - s.cy);
      if(d < s.r + beadR + 14) return false;
    }
    for(const p of placed){
      if(Math.hypot(cx - p.cx, cy - p.cy) < beadR*2 + 12) return false;
    }
    return true;
  }

  function pickVisible(){
    for(let tries=0; tries<2500; tries++){
      const cx = tray.x + beadR + margin + rng()*(tray.w - (beadR+margin)*2);
      const cy = tray.y + beadR + margin + rng()*(tray.h - (beadR+margin)*2);
      if(okSpot(cx,cy)){
        placed.push({cx,cy});
        return {cx,cy};
      }
    }
    let baseY = tray.y + beadR + 16;
    if(card.family === "C" || card.family === "D"){
      baseY = Math.max(baseY, 260 + beadR + 10);
    }
    const step = Math.min(260, Math.floor(tray.w / Math.max(1, card.visible.length+1)));
    const i = placed.length;
    const cx = tray.x + step*(i+1);
    const cy = baseY;
    placed.push({cx,cy});
    return {cx,cy};
  }

  card._posV = card.visible.map(()=> pickVisible());
}
function assignPositions(card, rng){
  if(card.family === "U"){
    assignPositionsUnits(card, rng);
  }else if(card.family === "EQ" || card.family === "EQPM"){
    assignPositionsEquation(card, rng);
  }else if(card.family === "N" || card.family === "NPM" || card.family === "C9" || card.family === "C8" || card.family === "C" || card.family === "D"){
    assignPositionsNumbered(card, rng);
  }else{
    assignPositionsClassic(card, rng);
  }
}


function assignPositionsEquation(card, rng){
  // Mode EQ : positions propres (2 demi-plateaux) avec des taches TOUJOURS de même taille.
  const eq = card._eq;
  if(!eq) return;

  // On remonte légèrement les plateaux (consigne + proche).
  const leftTray  = { x:120, y:190, w:680, h:650 };
  const rightTray = { x:800, y:190, w:680, h:650 };
  const midX = 800;

  // Tailles fixes (uniquement pour EQ)
  const beadR = 34;         // billes numérotées
  const splatR = 74;        // taches : même taille quelle que soit la quantité

  function layoutSplats(tray, n){
    // Zone haute dédiée aux taches (évite toute ambiguïté visuelle)
    const area = { x: tray.x + 70, y: tray.y + 75, w: tray.w - 140, h: 330 };

    // Définition des rangées (1 à 6)
    // - cas 3 : en TRIANGLE (2 + 1) au lieu d'une ligne de 3
    let rows = [];
    if(n === 1) rows = [1];
    else if(n === 2) rows = [2];
    else if(n === 3) rows = [2,1];
    else if(n === 4) rows = [2,2];
    else rows = [3, n-3]; // 5 -> [3,2], 6 -> [3,3]

    const out = [];
    const rowCount = rows.length;

    for(let r=0; r<rowCount; r++){
      const cols = rows[r];
      const cellW = area.w / cols;
      const cy = area.y + area.h * ((r + 0.5) / rowCount);

      for(let c=0; c<cols; c++){
        const cx = area.x + cellW * (c + 0.5);
        out.push({ cx, cy, r: splatR });
      }
    }

    // Petit shuffle pour varier l'apparence sans casser la lisibilité
    for(let i=out.length-1;i>0;i--){
      const j = rInt(rng, 0, i);
      [out[i], out[j]] = [out[j], out[i]];
    }

    return out;
  }

  function layoutVisible(tray, n){
    // Zone basse dédiée aux billes visibles
    const area = { x: tray.x + 70, y: tray.y + 450, w: tray.w - 140, h: 160 };
    if(n <= 0) return [];

    const cellW = area.w / n;
    const baseY = area.y + area.h / 2;
    const jitterX = Math.max(2, Math.floor(cellW * 0.18));
    const jitterY = Math.max(2, Math.floor(area.h * 0.18));

    const out = [];
    for(let i=0;i<n;i++){
      let cx = area.x + cellW * (i + 0.5) + rInt(rng, -jitterX, jitterX);
      let cy = baseY + rInt(rng, -jitterY, jitterY);
      out.push({ cx, cy });
    }
    return out;
  }

  const splatsL = layoutSplats(leftTray, eq.left.tasks);
  const splatsR = layoutSplats(rightTray, eq.right.tasks);

  card._eqTrays = { left:leftTray, right:rightTray, midX };
  card._eqPos = {
    left: {
      beadR,
      // billes visibles et cachées (1 par tache) : positions explicites
      posV: layoutVisible(leftTray, eq.left.visible.length),
      posH: splatsL.map(s=>({cx:s.cx, cy:s.cy})),
      splats: splatsL
    },
    right: {
      beadR,
      posV: layoutVisible(rightTray, eq.right.visible.length),
      posH: splatsR.map(s=>({cx:s.cx, cy:s.cy})),
      splats: splatsR
    }
  };
}


/* --- GÉNÉRATION ENQUÊTE (Mode C) --- */
function genInvestigate(rng){
  const taskCount = parseInt(invTaskCountEl.value); 
  const clueType = invClueTypeEl.value; 
  const structureMode = invStructure3El.value; 

  const userMin = numberOr(invTotalMinEl.value, 20);
  const userMax = numberOr(invTotalMaxEl.value, 100);
  const maxAddVal = numberOr(invMaxAddEl.value, 20); 

  let visMin = clamp(numberOr(invVisibleMinEl.value, 1), 0, 10);
  let visMax = clamp(numberOr(invVisibleMaxEl.value, 3), 0, 10);
  if(visMax < visMin) [visMin, visMax] = [visMax, visMin];

  const minTotal = Math.max(1, Math.min(userMin, userMax));
  const maxTotal = Math.max(1, Math.max(userMin, userMax));

  const ops = [];
  if(invOpAddEl.checked) ops.push('ADD');
  if(invOpSubEl.checked) ops.push('SUB');
  if(invOpMulEl.checked) ops.push('MUL');
  if(invOpDivEl.checked) ops.push('DIV');
  if(ops.length === 0) ops.push('ADD');

  const icons = ["⚫", "🟣", "🟠"];
  const names = ["la noire", "la violette", "l'orange"];

  function pickRelation(){
    const op = ops[rInt(rng, 0, ops.length-1)];
    if(op === 'MUL'){
      const k = rInt(rng, 2, 4);
      return {
        apply: (x) => x * k,
        check: (x) => true,
        desc: (tIdx, sIdx) => (clueType === "SYMBOL") ? `${icons[tIdx]} = ${k} × ${icons[sIdx]}` : `Sous ${names[tIdx]}, il y a ${k} fois plus de billes que sous ${names[sIdx]}.`
      };
    }
    if(op === 'DIV'){
      const k = rInt(rng, 2, 4);
      return {
        apply: (x) => x / k,
        check: (x) => (x % k === 0),
        desc: (tIdx, sIdx) => (clueType === "SYMBOL") ? `${icons[tIdx]} = ${icons[sIdx]} ÷ ${k}` : `Sous ${names[tIdx]}, il y a ${k} fois moins de billes que sous ${names[sIdx]}.`
      };
    }
    if(op === 'ADD'){
      const k = rInt(rng, 1, maxAddVal);
      return {
        apply: (x) => x + k,
        check: (x) => true,
        desc: (tIdx, sIdx) => (clueType === "SYMBOL") ? `${icons[tIdx]} = ${icons[sIdx]} + ${k}` : `Sous ${names[tIdx]}, il y a ${k} billes de plus que sous ${names[sIdx]}.`
      };
    }
    if(op === 'SUB'){
      const k = rInt(rng, 1, maxAddVal);
      return {
        apply: (x) => x - k,
        check: (x) => (x - k > 0), 
        desc: (tIdx, sIdx) => (clueType === "SYMBOL") ? `${icons[tIdx]} = ${icons[sIdx]} − ${k}` : `Sous ${names[tIdx]}, il y a ${k} billes de moins que sous ${names[sIdx]}.`
      };
    }
    return null;
  }

  for(let tries=0; tries<5000; tries++){
    const hiddenVals = new Array(taskCount).fill(0);
    const indices = [];

    if(taskCount === 2){
      const dir = rInt(rng, 0, 1);
      const source = dir; 
      const target = 1 - dir;
      const rel = pickRelation();
      const maxSource = Math.floor(maxTotal * 0.8); 
      const valSource = rInt(rng, 1, maxSource);
      if(!rel.check(valSource)) continue;
      const valTarget = rel.apply(valSource);
      if(valTarget <= 0) continue;
      hiddenVals[source] = valSource;
      hiddenVals[target] = valTarget;
      indices.push(rel.desc(target, source));
    } else {
      let mode = structureMode;
      if(mode === "MIX") mode = (rng() > 0.5) ? "CHAIN" : "PIVOT";
      const p = [0,1,2];
      shuffleInPlace(p, rng);
      const rel1 = pickRelation();
      const rel2 = pickRelation();
      let source2;
      if(mode === "CHAIN"){ source2 = p[1]; } else { source2 = p[0]; }
      const maxRoot = Math.floor(maxTotal * 0.6);
      const valRoot = rInt(rng, 1, maxRoot);
      if(!rel1.check(valRoot)) continue;
      const val1 = rel1.apply(valRoot);
      if(val1 <= 0) continue;
      const valSource2 = (source2 === p[0]) ? valRoot : val1;
      if(!rel2.check(valSource2)) continue;
      const val2 = rel2.apply(valSource2);
      if(val2 <= 0) continue;
      hiddenVals[p[0]] = valRoot;
      hiddenVals[p[1]] = val1;
      hiddenVals[p[2]] = val2;
      indices.push(rel1.desc(p[1], p[0]));
      indices.push(rel2.desc(p[2], source2));
    }

    const hiddenSum = hiddenVals.reduce((a,b)=>a+b, 0);
    const visCount = rInt(rng, visMin, visMax);
    const visBeads = [];
    let visSum = 0;
    for(let k=0; k<visCount; k++){
        const val = rInt(rng, 1, 9);
        visBeads.push(val);
        visSum += val;
    }
    const total = hiddenSum + visSum;

    if(total >= minTotal && total <= maxTotal){
      return {
        family: "C",
        total,
        visible: visBeads, 
        hidden: hiddenVals, 
        _num: { tasks: taskCount, hiddenByTask: hiddenVals.map(v=>[v]), hiddenBeadsPerTask:1 },
        _inv: { indices } 
      };
    }
  }
  return { family: "C", total: 10, visible: [], hidden: [3,3], _num: { tasks: taskCount, hiddenByTask: [[3],[3]], hiddenBeadsPerTask:1 }, _inv: { indices: ["Erreur"] } };
}

/* --- GÉNÉRATION SYSTÈME (Mode D) --- */
function genSystem(rng){
  const taskCount = 3; 
  const clueType = sysClueTypeEl.value; // SENTENCE ou SYMBOL

  const userMin = numberOr(sysTotalMinEl.value, 30);
  const userMax = numberOr(sysTotalMaxEl.value, 150);

  let visMin = clamp(numberOr(sysVisibleMinEl.value, 1), 0, 10);
  let visMax = clamp(numberOr(sysVisibleMaxEl.value, 3), 0, 10);
  if(visMax < visMin) [visMin, visMax] = [visMax, visMin];

  const minTotal = Math.max(1, Math.min(userMin, userMax));
  const maxTotal = Math.max(1, Math.max(userMin, userMax));

  const icons = ["⚫", "🟣", "🟠"];
  const colorNames = ["Noir", "Violet", "Orange"];

  for(let tries=0; tries<5000; tries++){
    const vals = [
        rInt(rng, 5, Math.floor(maxTotal/3)),
        rInt(rng, 5, Math.floor(maxTotal/3)),
        rInt(rng, 5, Math.floor(maxTotal/3))
    ];
    
    const visCount = rInt(rng, visMin, visMax);
    const visBeads = [];
    let visSum = 0;
    for(let k=0; k<visCount; k++){
        const val = rInt(rng, 1, 9);
        visBeads.push(val);
        visSum += val;
    }

    const total = vals[0] + vals[1] + vals[2] + visSum;

    if(total < minTotal || total > maxTotal) continue;

    // 2 indices (Sommes de paires)
    const pairs = [[0,1], [1,2], [0,2]];
    shuffleInPlace(pairs, rng);
    
    const p1 = pairs[0];
    const p2 = pairs[1];

    const sum1 = vals[p1[0]] + vals[p1[1]];
    const sum2 = vals[p2[0]] + vals[p2[1]];

    const indices = [];

    function formatClue(idxA, idxB, s){
        if(clueType === "SYMBOL"){
            return `${icons[idxA]} + ${icons[idxB]} = ${s}`;
        } else {
            return `${colorNames[idxA]} + ${colorNames[idxB]} = ${s}`;
        }
    }

    indices.push(formatClue(p1[0], p1[1], sum1));
    indices.push(formatClue(p2[0], p2[1], sum2));

    return {
        family: "D",
        total,
        visible: visBeads,
        hidden: vals,
        _num: { tasks: 3, hiddenByTask: vals.map(v=>[v]), hiddenBeadsPerTask:1 },
        _inv: { indices } 
    };
  }

  return { family: "D", total: 20, visible: [], hidden: [5,5,5], _num: { tasks:3, hiddenByTask:[[5],[5],[5]] }, _inv: { indices: ["Erreur"] } };
}


/* Existing Gens */
function genNumbered(rng){
  let tMin = clamp(numberOr(numTasksMinEl ? numTasksMinEl.value : 1, 1), 1, 6);
  let tMax = clamp(numberOr(numTasksEl.value, 1), 1, 6);
  if(tMax < tMin) [tMin, tMax] = [tMax, tMin];
  const tasks = rInt(rng, tMin, tMax);
  let vMin = clamp(numberOr(numVisibleMinEl.value, 2), 1, 5);
  let vMax = clamp(numberOr(numVisibleMaxEl.value, 3), 1, 5);
  if(vMax < vMin) [vMin, vMax] = [vMax, vMin];
  let userMin = numberOr(numTotalMinEl ? numTotalMinEl.value : 10, 10);
  let userMax = numberOr(numTotalMaxEl ? numTotalMaxEl.value : 50, 50);
  if(userMax < userMin) [userMin, userMax] = [userMax, userMin];
  let totalMin = clamp(userMin, 1, 1000);
  let totalMax = clamp(userMax, 1, 1000);
  const hiddenBeadsPerTask = clamp(numberOr(numHiddenCountEl ? numHiddenCountEl.value : 1, 1), 1, 2);
  const minPossible = vMin + tasks*hiddenBeadsPerTask;
  if(totalMax < minPossible) totalMax = minPossible;
  if(totalMin < minPossible) totalMin = minPossible;
  if(totalMax < totalMin) totalMax = totalMin;
  for(let tries=0; tries<2000; tries++){
    const total = rInt(rng, totalMin, totalMax);
    const visibleCount = rInt(rng, vMin, vMax);
    const maxH = Math.floor((total - visibleCount) / tasks);
    if(maxH < hiddenBeadsPerTask) continue;
    const H = rInt(rng, hiddenBeadsPerTask, maxH);
    const visibleSum = total - tasks*H;
    if(visibleSum < visibleCount) continue;
    const visible = randomComposition(rng, visibleSum, visibleCount);
    const hiddenByTask = [];
    for(let t=0; t<tasks; t++){
      if(hiddenBeadsPerTask === 1){
        hiddenByTask.push([H]);
      }else{
        const a = rInt(rng, 1, H-1);
        hiddenByTask.push([a, H-a]);
      }
    }
    const hidden = hiddenByTask.flat();
    return {
      family: "N",
      total,
      visible,
      hidden,
      _num: { tasks, visibleCount, vMin, vMax, totalMin, totalMax, hiddenBeadsPerTask, H, hiddenByTask }
    };
  }
  const total = totalMin;
  const visibleCount = vMin;
  const H = hiddenBeadsPerTask;
  const visible = Array.from({length: visibleCount}, ()=>1);
  const hiddenByTask = Array.from({length: tasks}, ()=> (hiddenBeadsPerTask===1 ? [H] : [1, H-1]) );
  const hidden = hiddenByTask.flat();
  return {
    family:"N",
    total,
    visible,
    hidden,
    _num:{ tasks, visibleCount, vMin, vMax, totalMin, totalMax, hiddenBeadsPerTask, H, hiddenByTask }
  };
}

// Mode B± : billes numérotées en entiers relatifs (zéro interdit sur les billes, total pouvant être 0)
function genNumberedSigned(rng){
  let tMin = clamp(numberOr(numTasksMinEl?.value, 1), 1, 6);
  let tMax = clamp(numberOr(numTasksEl.value, 1), 1, 6);
  if(tMin > tMax) [tMin, tMax] = [tMax, tMin];
  const tasks = rInt(rng, tMin, tMax);

  const vMin = clamp(numberOr(numVisibleMinEl.value, 2), 1, 5);
  const vMax = clamp(numberOr(numVisibleMaxEl.value, 3), vMin, 5);
  const visibleCount = rInt(rng, vMin, vMax);

  const hiddenCount = clamp(numberOr(numHiddenCountEl.value, 1), 1, 2);

  let totalMin = clamp(numberOr(numTotalMinEl.value, -50), -99, 99);
  let totalMax = clamp(numberOr(numTotalMaxEl.value, 50), -99, 99);
  if(totalMin > totalMax) [totalMin, totalMax] = [totalMax, totalMin];

  const maxAbs = clamp(numberOr(numBeadAbsMaxEl?.value, 30), 1, 99);
  const maxTaskAbs = (hiddenCount === 1) ? maxAbs : 2*maxAbs; // somme max par tâche

  // Mode "taches opposées" :
  // - "Aucune" : B± classique (toutes les tâches ont la même somme H, H peut être + ou -)
  // - "Toutes opposees" : toutes les tâches ont la somme -A (A>0)
  // - "Mélange" : certaines tâches ont +A, d'autres -A, sans annulation globale
  // - "Parfois" : une fois sur deux, aucune / toutes opposées
  const opposeSetting = (numOpposeModeEl && numOpposeModeEl.value) ? numOpposeModeEl.value : "off";
  let opposeMode = opposeSetting;
  if(opposeSetting === "auto"){
    opposeMode = (rng() < 0.5) ? "off" : "all";
  }

  function buildHiddenByTask(targetSums){
    const hiddenByTask = [];
    for(let t=0; t<targetSums.length; t++){
      const S = targetSums[t];
      if(hiddenCount === 1){
        if(S === 0 || Math.abs(S) > maxAbs) return null;
        hiddenByTask.push([S]);
      }else{
        const pair = splitTwoNonZeroSum(rng, S, maxAbs);
        if(!pair) return null;
        hiddenByTask.push(pair);
      }
    }
    return hiddenByTask;
  }

  // --- B± classique ---
  function tryClassic(){
    for(let attempt=0; attempt<700; attempt++){
      const total = rInt(rng, totalMin, totalMax);

      let H = rInt(rng, -maxTaskAbs, maxTaskAbs);
      if(H === 0) continue;
      if(hiddenCount === 1 && Math.abs(H) > maxAbs) continue;

      const targetSums = new Array(tasks).fill(H);
      const hiddenByTask = buildHiddenByTask(targetSums);
      if(!hiddenByTask) continue;

      const hidden = hiddenByTask.flat();
      const hiddenSum = targetSums.reduce((a,b)=>a+b,0);
      const visibleSum = total - hiddenSum;

      const visible = randomSignedCompositionNonZero(rng, visibleSum, visibleCount, maxAbs);
      if(!visible) continue;

      return { family:"NPM", total, visible, hidden, _num:{ tasks, hiddenCount, H, hiddenByTask } };
    }
    return null;
  }

  // --- Opposé / Mélange ---
  function tryOppose(mode){
    for(let attempt=0; attempt<900; attempt++){
      const total = rInt(rng, totalMin, totalMax);

      const A = rInt(rng, 1, maxTaskAbs);
      if(hiddenCount === 1 && A > maxAbs) continue;

      let opposedTasks = new Array(tasks).fill(false);

      if(mode === "all"){
        opposedTasks.fill(true);
      }else if(mode === "mix"){
        if(tasks <= 2){
          // mélange impossible (risque annulation) → on bascule en "all"
          opposedTasks.fill(true);
        }else{
          // k tâches opposées, éviter annulation : k != tasks/2 si tasks pair
          let k = 1;
          for(let kTry=0; kTry<50; kTry++){
            k = rInt(rng, 1, tasks-1);
            if(tasks % 2 === 0 && k === tasks/2) continue;
            break;
          }
          const idxs = [...Array(tasks).keys()];
          shuffleInPlace(idxs, rng);
          for(let i=0; i<k; i++) opposedTasks[idxs[i]] = true;
        }
      }else{
        return null;
      }

      const targetSums = new Array(tasks).fill(A); // chaque tache cache une somme +A
      const hiddenSum = opposedTasks.reduce((acc,o)=>acc + (o ? -A : A), 0);
      if(hiddenSum === 0) continue;

      const hiddenByTask = buildHiddenByTask(targetSums);
      if(!hiddenByTask) continue;

      const hidden = hiddenByTask.flat();
      const visibleSum = total - hiddenSum;

      const visible = randomSignedCompositionNonZero(rng, visibleSum, visibleCount, maxAbs);
      if(!visible) continue;

      return {
        family:"NPM", total, visible, hidden,
        _num:{ tasks, hiddenCount, A, opposedTasks, hiddenByTask }
      };
    }
    return null;
  }

  let card = null;
  if(opposeMode === "off") card = tryClassic();
  else if(opposeMode === "all") card = tryOppose("all") || tryClassic();
  else if(opposeMode === "mix") card = tryOppose("mix") || tryClassic();
  else card = tryClassic();

  if(card) return card;

  return { family:"NPM", total:1, visible:[1], hidden:[-1], _num:{ tasks:1, hiddenCount:1, H:-1, hiddenByTask:[[-1]] } };
}




function randomCompositionBounded(rng, sum, parts, maxPart=99){
  if(parts === 0) return (sum === 0) ? [] : null;
  if(parts === 1) return (sum <= maxPart) ? [sum] : null;
  if(sum < parts) return null;
  if(sum > parts*maxPart) return null;

  // On part de 1 partout, puis on distribue le reste en respectant maxPart.
  const arr = new Array(parts).fill(1);
  let rem = sum - parts;

  // Première passe : ajout aléatoire
  for(let i=0;i<parts;i++){
    const cap = Math.min(maxPart - arr[i], rem);
    if(cap <= 0) continue;
    const add = rInt(rng, 0, cap);
    arr[i] += add;
    rem -= add;
  }

  // Deuxième passe : on distribue le reliquat
  let safety = 2000;
  while(rem > 0 && safety-- > 0){
    const i = rInt(rng, 0, parts-1);
    const cap = maxPart - arr[i];
    if(cap <= 0) continue;
    const add = Math.min(rem, rInt(rng, 1, cap));
    arr[i] += add;
    rem -= add;
  }
  if(rem !== 0) return null;

  // Petit shuffle
  for(let i=arr.length-1;i>0;i--){
    const j = rInt(rng, 0, i);
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

function genEquation(rng){
  // Mode EQ : deux plateaux (gauche/droite) avec la même quantité totale.
  // Chaque tache cache le même nombre X (1 bille cachée par tache), identique partout.
  // Pour que l'équation soit résoluble, on impose tasksGauche !== tasksDroite.

  const maxTasksUser = clamp(numberOr(numTasksEl.value, 6), 1, 6);
  const maxTasksEq = Math.max(2, maxTasksUser);

  // IMPORTANT : en EQ, Billes visibles (min/max) s'appliquent PAR PLATEAU (gauche ET droite),
  // et non sur la somme des deux plateaux.
  let vMin = clamp(numberOr(numVisibleMinEl.value, 1), 0, 6);
  let vMax = clamp(numberOr(numVisibleMaxEl.value, 3), 0, 6);
  if(vMax < vMin) [vMin, vMax] = [vMax, vMin];

  // Total min/max = total à gauche (et donc le même à droite), pas la somme des 2 plateaux.
  let userMin = numberOr(numTotalMinEl ? numTotalMinEl.value : 20, 20);
  let userMax = numberOr(numTotalMaxEl ? numTotalMaxEl.value : 50, 50);
  if(userMax < userMin) [userMin, userMax] = [userMax, userMin];
  userMin = clamp(userMin, 1, 999);
  userMax = clamp(userMax, 1, 999);

  // Génération robuste :
  // On choisit (a,b,x, nbVisL, nbVisR) puis on choisit un total T dans l'intersection
  // des contraintes de décomposition sur les billes visibles.
  const MAX_TRIES = 8000;

  for(let tries=0; tries<MAX_TRIES; tries++){
    // 1) Nombre de taches par plateau (1..max), mais DIFFERENTS.
    const a = rInt(rng, 1, maxTasksEq);
    let b = rInt(rng, 1, maxTasksEq);
    if(b === a){
      // petit "shift" pour éviter de retomber tout le temps sur l'égalité
      b = (b % maxTasksEq) + 1;
    }
    if(a === b) continue;

    // 2) Nombre de billes visibles par plateau (dans [vMin..vMax]) : INDEPENDANT gauche/droite.
    const vCountL = rInt(rng, vMin, vMax);
    const vCountR = rInt(rng, vMin, vMax);
    if(vCountL === 0 && vCountR === 0) continue; // exercice vide

    // 3) Choisir X (valeur cachée sous une tache)
    // On borne X pour rester compatible avec userMax (au pire, il reste au moins 1 par bille visible).
    const minVisAny = Math.min(
      vCountL > 0 ? vCountL : 1,
      vCountR > 0 ? vCountR : 1
    );
    const denom = Math.max(1, Math.min(a, b));
    let xMax = Math.floor((userMax - minVisAny) / denom);
    xMax = Math.max(1, Math.min(99, xMax));
    if(xMax < 1) continue;
    const x = rInt(rng, 1, xMax);

    // 4) Trouver un total T dans l'intersection des contraintes :
    //    VL = T - a*x doit être décomposable en vCountL nombres entre 1 et 99
    //    VR = T - b*x doit être décomposable en vCountR nombres entre 1 et 99
    // => T ∈ [a*x + vCountL*1, a*x + vCountL*99] ∩ [b*x + vCountR*1, b*x + vCountR*99] ∩ [userMin,userMax]
    let tLow = userMin;
    let tHigh = userMax;

    const lMinT = a*x + (vCountL * 1);
    const lMaxT = a*x + (vCountL * 99);
    const rMinT = b*x + (vCountR * 1);
    const rMaxT = b*x + (vCountR * 99);

    tLow = Math.max(tLow, lMinT, rMinT);
    tHigh = Math.min(tHigh, lMaxT, rMaxT);

    if(tHigh < tLow) continue;

    const total = (tLow === tHigh) ? tLow : rInt(rng, tLow, tHigh);
    const VL = total - a*x;
    const VR = total - b*x;

    const leftVisible  = (vCountL === 0) ? [] : randomCompositionBounded(rng, VL, vCountL, 99);
    const rightVisible = (vCountR === 0) ? [] : randomCompositionBounded(rng, VR, vCountR, 99);
    if(leftVisible === null || rightVisible === null) continue;

    const leftHiddenByTask  = Array.from({length:a}, ()=>[x]);
    const rightHiddenByTask = Array.from({length:b}, ()=>[x]);

    return {
      family: "EQ",
      total: total, // stocké mais non affiché dans ce mode
      visible: leftVisible.concat(rightVisible),
      hidden: leftHiddenByTask.flat().concat(rightHiddenByTask.flat()),
      _eq: {
        total,
        x,
        left:  { tasks:a, visible:leftVisible,  hiddenByTask:leftHiddenByTask },
        right: { tasks:b, visible:rightVisible, hiddenByTask:rightHiddenByTask }
      }
    };
  }

  // Phase 2 : recherche déterministe si les paramètres sont très contraignants.
  for(let a=1; a<=maxTasksEq; a++){
    for(let b=1; b<=maxTasksEq; b++){
      if(a === b) continue;
      for(let x=1; x<=99; x++){
        for(let vCountL=vMin; vCountL<=vMax; vCountL++){
          for(let vCountR=vMin; vCountR<=vMax; vCountR++){
            if(vCountL === 0 && vCountR === 0) continue;

            let tLow = userMin;
            let tHigh = userMax;

            const lMinT = a*x + (vCountL * 1);
            const lMaxT = a*x + (vCountL * 99);
            const rMinT = b*x + (vCountR * 1);
            const rMaxT = b*x + (vCountR * 99);

            tLow = Math.max(tLow, lMinT, rMinT);
            tHigh = Math.min(tHigh, lMaxT, rMaxT);
            if(tHigh < tLow) continue;

            const total = tLow; // on prend le plus petit faisable
            const VL = total - a*x;
            const VR = total - b*x;

            const leftVisible  = (vCountL === 0) ? [] : randomCompositionBounded(rng, VL, vCountL, 99);
            const rightVisible = (vCountR === 0) ? [] : randomCompositionBounded(rng, VR, vCountR, 99);
            if(leftVisible === null || rightVisible === null) continue;

            const leftHiddenByTask  = Array.from({length:a}, ()=>[x]);
            const rightHiddenByTask = Array.from({length:b}, ()=>[x]);

            return {
              family: "EQ",
              total: total,
              visible: leftVisible.concat(rightVisible),
              hidden: leftHiddenByTask.flat().concat(rightHiddenByTask.flat()),
              _eq: {
                total,
                x,
                left:  { tasks:a, visible:leftVisible,  hiddenByTask:leftHiddenByTask },
                right: { tasks:b, visible:rightVisible, hiddenByTask:rightHiddenByTask }
              }
            };
          }
        }
      }
    }
  }

  // Ultime fallback (ne devrait jamais arriver) : on fabrique quelque chose de cohérent,
  // même si les réglages utilisateur sont impossibles.
  const a = 2, b = 1, x = 2;
  const vCountL = Math.max(1, vMin), vCountR = Math.max(1, vMin);
  const total = Math.max(userMin, a*x + vCountL);
  const VL = total - a*x;
  const VR = total - b*x;
  const leftVisible  = randomCompositionBounded(rng, VL, vCountL, 99) || Array.from({length:vCountL}, ()=>1);
  const rightVisible = randomCompositionBounded(rng, VR, vCountR, 99) || Array.from({length:vCountR}, ()=>1);
  const leftHiddenByTask  = Array.from({length:a}, ()=>[x]);
  const rightHiddenByTask = Array.from({length:b}, ()=>[x]);

  return {
    family: "EQ",
    total: total,
    visible: leftVisible.concat(rightVisible),
    hidden: leftHiddenByTask.flat().concat(rightHiddenByTask.flat()),
    _eq: {
      total,
      x,
      left:  { tasks:a, visible:leftVisible,  hiddenByTask:leftHiddenByTask },
      right: { tasks:b, visible:rightVisible, hiddenByTask:rightHiddenByTask }
    }
  };
}



function genEquationSigned(rng){
  // Mode EQPM : deux plateaux (gauche/droite) avec la même quantité totale,
  // mais avec billes visibles signées et possibilité de taches "opposees" (-x).
  // Chaque tache cache exactement 1 bille (valeur +x ou -x), identique en valeur absolue partout.
  // Pour que l'équation soit résoluble, on impose coefGauche !== coefDroite (et coef != 0).

  const maxTasksUser = clamp(numberOr(numTasksEl.value, 6), 1, 6);
  const maxTasksEq = Math.max(2, maxTasksUser);

  // Billes visibles (min/max) s'appliquent PAR PLATEAU (gauche ET droite)
  let vMin = clamp(numberOr(numVisibleMinEl.value, 1), 0, 6);
  let vMax = clamp(numberOr(numVisibleMaxEl.value, 3), 0, 6);
  if(vMax < vMin) [vMin, vMax] = [vMax, vMin];

  // Total min/max = total à gauche (et donc le même à droite), pas la somme des 2 plateaux.
  let userMin = clamp(numberOr(numTotalMinEl.value, 20), 1, 1000);
  let userMax = clamp(numberOr(numTotalMaxEl.value, 50), 1, 1000);
  if(userMax < userMin) [userMin, userMax] = [userMax, userMin];

  const maxAbs = clamp(numberOr(numBeadAbsMaxEl?.value, 30), 1, 99);

// Mode "taches opposees" (comme B±) :
// - off  : aucune tache opposee (tout +x)
// - all  : pas de melange : chaque cote est soit tout +x, soit tout -x (au hasard)
// - auto : parfois aucun oppose, parfois melange
// - mix  : melange possible dans un cote
const opposeSetting = (numOpposeModeEl && numOpposeModeEl.value) ? String(numOpposeModeEl.value).toLowerCase() : "off";
const autoPick = (opposeSetting === "auto") ? ((rng() < 0.5) ? "off" : "mix") : null;

function sumArr(a){ let s=0; for(const x of a) s+=x; return s; }
function hasBothSigns(arr){
  let pos=false, neg=false;
  for(const s of arr){ if(s>0) pos=true; else if(s<0) neg=true; if(pos && neg) return true; }
  return false;
}

function chooseUniformSigns(n){
  const s = (rng() < 0.5) ? 1 : -1;
  return new Array(n).fill(s);
}
function chooseMixedSignsNonZero(n){
  // n>=3 attendu
  const candidates = [];
  for(let k=1; k<=n-1; k++){
    if(n % 2 === 0 && k === (n/2)) continue; // eviter somme = 0
    candidates.push(k);
  }
  if(candidates.length === 0) return new Array(n).fill(1);
  const k = candidates[rInt(rng, 0, candidates.length-1)];
  const out = new Array(n).fill(1);
  for(let i=0;i<k;i++) out[i] = -1;
  shuffleInPlace(out, rng);
  return out;
}
function chooseSignsPair(nL, nR, mode){
  if(mode === "off"){
    return { L:new Array(nL).fill(1), R:new Array(nR).fill(1) };
  }
  if(mode === "all"){
    return { L:chooseUniformSigns(nL), R:chooseUniformSigns(nR) };
  }
  // mode "mix" : on veut du vrai melange (au moins un cote avec + et -)
  const canMixL = (nL >= 3);
  const canMixR = (nR >= 3);
  if(!canMixL && !canMixR) return null;

  // 1/3 : mix/mix, 1/3 : uniforme/mix, 1/3 : mix/uniforme (quand possible)
  let pattern = 0; // 0=mix/mix, 1=uni/mix, 2=mix/uni
  if(canMixL && canMixR){
    pattern = rInt(rng, 0, 2);
  }else if(canMixR){
    pattern = 1;
  }else{
    pattern = 2;
  }

  let L, R;
  if(pattern === 0){
    L = chooseMixedSignsNonZero(nL);
    R = chooseMixedSignsNonZero(nR);
  }else if(pattern === 1){
    L = chooseUniformSigns(nL);
    R = chooseMixedSignsNonZero(nR);
  }else{
    L = chooseMixedSignsNonZero(nL);
    R = chooseUniformSigns(nR);
  }
  return { L, R };
}

  for(let tries=0; tries<6000; tries++){
    const tasksL = rInt(rng, 1, maxTasksEq);
    const tasksR = rInt(rng, 1, maxTasksEq);

    let mode = opposeSetting;
    if(mode === "auto") mode = autoPick;

    const pair = chooseSignsPair(tasksL, tasksR, mode);
    if(!pair) continue;
    const signsL = pair.L;
    const signsR = pair.R;
if(mode === "mix"){
      // Forcer un vrai "melange" (au moins un cote avec + et -)
      if(!(hasBothSigns(signsL) || hasBothSigns(signsR))) continue;
    }

    const a = sumArr(signsL);
    const b = sumArr(signsR);

    // Eviter les simplifications "0x" (sur un plateau) et l'annulation complète
    if(a === 0 || b === 0) continue;
    if(a === b) continue;

    const vCountL = rInt(rng, vMin, vMax);
    const vCountR = rInt(rng, vMin, vMax);

    const maxCoeff = Math.max(Math.abs(a), Math.abs(b), 1);
    // borne grossière pour x, puis on clamp à maxAbs (logique "valeur absolue")
    let xMax = Math.floor((userMax + Math.max(vCountL, vCountR) * maxAbs) / maxCoeff);
    xMax = clamp(xMax, 1, maxAbs);
    const x = rInt(rng, 1, xMax);

    // Chercher un total T faisable pour les deux plateaux :
    // VL = T - a*x doit être décomposable en vCountL nombres non nuls avec |val|<=maxAbs
    // VR = T - b*x doit être décomposable en vCountR nombres non nuls avec |val|<=maxAbs
    let tLow = userMin;
    let tHigh = userMax;

    function applyRange(coef, vCount){
      if(vCount === 0){
        // somme visible doit être 0 => T = coef*x
        const t = coef * x;
        tLow = Math.max(tLow, t);
        tHigh = Math.min(tHigh, t);
        return;
      }
      const lo = (coef * x) - (vCount * maxAbs);
      const hi = (coef * x) + (vCount * maxAbs);
      tLow = Math.max(tLow, Math.min(lo, hi));
      tHigh = Math.min(tHigh, Math.max(lo, hi));
    }
    applyRange(a, vCountL);
    applyRange(b, vCountR);

    if(tHigh < tLow) continue;

    // Petit biais vers des totaux proches des bornes pour varier (et obtenir plus souvent des négatifs)
    let total;
    if(rng() < 0.25){
      total = tLow;
    }else if(rng() < 0.50){
      total = tHigh;
    }else{
      total = (tLow === tHigh) ? tLow : rInt(rng, tLow, tHigh);
    }

    const VL = total - a*x;
    const VR = total - b*x;

    const leftVisible  = (vCountL === 0) ? [] : randomSignedCompositionNonZero(rng, VL, vCountL, maxAbs);
    const rightVisible = (vCountR === 0) ? [] : randomSignedCompositionNonZero(rng, VR, vCountR, maxAbs);
    if(leftVisible === null || rightVisible === null) continue;

    const leftHiddenByTask  = Array.from({length:tasksL}, (_,i)=>[signsL[i] * x]);
    const rightHiddenByTask = Array.from({length:tasksR}, (_,i)=>[signsR[i] * x]);

    return {
      family: "EQPM",
      total: total,
      visible: leftVisible.concat(rightVisible),
      hidden: leftHiddenByTask.flat().concat(rightHiddenByTask.flat()),
      _eq: {
        total,
        x,
        left:  { tasks:tasksL, visible:leftVisible,  hiddenByTask:leftHiddenByTask,  opposeFlags: signsL.map(s=>s<0) },
        right: { tasks:tasksR, visible:rightVisible, hiddenByTask:rightHiddenByTask, opposeFlags: signsR.map(s=>s<0) }
      }
    };
  }

  // Fallback robuste : EQ classique
  return genEquation(rng);
}



function genOp9(rng){
  const opSetting = (nineOpEl.value || "SUB");
  const tasks = clamp(numberOr(nineTasksEl.value, 1), 1, 6);
  const vMaxUser = clamp(numberOr(nineVisibleMaxEl.value, 3), 1, 5);
  let userMin = numberOr(nineTotalMinEl.value, 30);
  let userMax = numberOr(nineTotalMaxEl.value, 120);
  if(userMax < userMin) [userMin, userMax] = [userMax, userMin];
  const totalMin = clamp(userMin, 1, 1000);
  const totalMax = clamp(userMax, 1, 1000);
  const family = [];
  for(let v=9; v<=99; v+=10) family.push(v);
  function pickOp(){ if(opSetting === "MIX") return (rng() < 0.5) ? "SUB" : "ADD"; return opSetting; }
  const visBudgetMax = totalMax - tasks * 1;
  for(let tries=0; tries<4000; tries++){
    const op = pickOp();
    let k = family[rInt(rng, 0, family.length-1)];
    if(k > visBudgetMax){ k = 9; if(k > visBudgetMax) continue; }
    let visibleCount;
    if(op === "SUB"){ visibleCount = 1; }else{
      const maxVis = Math.max(2, vMaxUser);
      visibleCount = rInt(rng, 2, maxVis);
      while(visibleCount > 2 && (k + (visibleCount-1)*1) > visBudgetMax) visibleCount--;
      if((k + (visibleCount-1)*1) > visBudgetMax) continue;
    }
    const visible = [k];
    if(visibleCount > 1){
      let budget = visBudgetMax - k;
      let remaining = visibleCount - 1;
      for(let i=0; i<remaining; i++){
        const minRest = (remaining - 1 - i) * 1;
        let maxV = Math.min(99, budget - minRest);
        if(maxV < 1){ budget = -1; break; }
        const v = rInt(rng, 1, maxV);
        visible.push(v);
        budget -= v;
      }
      if(budget < 0) continue;
    }
    const visibleSum = visible.reduce((a,b)=>a+b,0);
    const hLow = Math.max(1, Math.ceil((totalMin - visibleSum) / tasks));
    const hHigh = Math.floor((totalMax - visibleSum) / tasks);
    if(hHigh < hLow) continue;
    const H = rInt(rng, hLow, hHigh);
    const total = visibleSum + tasks * H;
    const hiddenByTask = Array.from({length: tasks}, ()=> [H]);
    const hidden = hiddenByTask.flat();
    return {
      family: "C9",
      total, visible, hidden,
      _num: { tasks, visibleCount, vMin:visibleCount, vMax:visibleCount, totalMin, totalMax, hiddenBeadsPerTask:1, H, hiddenByTask },
      _c9: { op, opSetting, k }
    };
  }
  return genNumbered(rng); 
}

function genOp8(rng){
  const opSetting = (eightOpEl.value || "SUB");
  const tasks = clamp(numberOr(eightTasksEl.value, 1), 1, 6);
  const vMaxUser = clamp(numberOr(eightVisibleMaxEl.value, 3), 1, 5);
  let userMin = numberOr(eightTotalMinEl.value, 30);
  let userMax = numberOr(eightTotalMaxEl.value, 120);
  if(userMax < userMin) [userMin, userMax] = [userMax, userMin];
  const totalMin = clamp(userMin, 1, 1000);
  const totalMax = clamp(userMax, 1, 1000);
  const family = [];
  for(let v=8; v<=98; v+=10) family.push(v);
  function pickOp(){ if(opSetting === "MIX") return (rng() < 0.5) ? "SUB" : "ADD"; return opSetting; }
  const visBudgetMax = totalMax - tasks * 1;
  for(let tries=0; tries<4000; tries++){
    const op = pickOp();
    let k = family[rInt(rng, 0, family.length-1)];
    if(k > visBudgetMax){ k = 8; if(k > visBudgetMax) continue; }
    let visibleCount;
    if(op === "SUB"){ visibleCount = 1; }else{
      const maxVis = Math.max(2, vMaxUser);
      visibleCount = rInt(rng, 2, maxVis);
      while(visibleCount > 2 && (k + (visibleCount-1)*1) > visBudgetMax) visibleCount--;
      if((k + (visibleCount-1)*1) > visBudgetMax) continue;
    }
    const visible = [k];
    if(visibleCount > 1){
      let budget = visBudgetMax - k;
      let remaining = visibleCount - 1;
      for(let i=0; i<remaining; i++){
        const minRest = (remaining - 1 - i) * 1;
        let maxV = Math.min(99, budget - minRest);
        if(maxV < 1){ budget = -1; break; }
        const v = rInt(rng, 1, maxV);
        visible.push(v);
        budget -= v;
      }
      if(budget < 0) continue;
    }
    const visibleSum = visible.reduce((a,b)=>a+b,0);
    const hLow = Math.max(1, Math.ceil((totalMin - visibleSum) / tasks));
    const hHigh = Math.floor((totalMax - visibleSum) / tasks);
    if(hHigh < hLow) continue;
    const H = rInt(rng, hLow, hHigh);
    const total = visibleSum + tasks * H;
    const hiddenByTask = Array.from({length: tasks}, ()=> [H]);
    const hidden = hiddenByTask.flat();
    return {
      family: "C8",
      total, visible, hidden,
      _num: { tasks, visibleCount, vMin:visibleCount, vMax:visibleCount, totalMin, totalMax, hiddenBeadsPerTask:1, H, hiddenByTask },
      _c8: { op, opSetting, k }
    };
  }
  return genNumbered(rng);
}

function assignPositionsClassic(card, rng){
  const tray = { x:120, y:260, w:1360, h:650 };
  const beadR = 95;
  const margin = 18;
  const splat = { cx: 820, cy: 610, r: 260 };
  card._splat = splat;
  const placed = [];
  function okSpotVisible(cx, cy){
    if(cx < tray.x + beadR + margin) return false;
    if(cx > tray.x + tray.w - beadR - margin) return false;
    if(cy < tray.y + beadR + margin) return false;
    if(cy > tray.y + tray.h - beadR - margin) return false;
    const d = Math.hypot(cx - splat.cx, cy - splat.cy);
    if(d < splat.r + beadR + 18) return false;
    for(const p of placed){
      const dd = Math.hypot(cx - p.cx, cy - p.cy);
      if(dd < beadR*2 + 18) return false;
    }
    return true;
  }
  function pickVisible(area){
    for(let tries=0; tries<800; tries++){
      const cx = area.x + beadR + margin + rng() * (area.w - 2*(beadR+margin));
      const cy = area.y + beadR + margin + rng() * (area.h - 2*(beadR+margin));
      if(okSpotVisible(cx, cy)){
        placed.push({cx,cy});
        return {cx,cy};
      }
    }
    const cx = area.x + area.w/2, cy = area.y + area.h/2;
    placed.push({cx,cy});
    return {cx,cy};
  }
  function pickHiddenInSplat(){
    const maxR = (splat.r - beadR - 60);
    for(let tries=0; tries<1000; tries++){
      const a = rng() * Math.PI * 2;
      const rr = Math.sqrt(rng()) * Math.max(10, maxR);
      const cx = splat.cx + Math.cos(a) * rr;
      const cy = splat.cy + Math.sin(a) * rr;
      if(cx < tray.x + beadR + margin) continue;
      if(cx > tray.x + tray.w - beadR - margin) continue;
      if(cy < tray.y + beadR + margin) continue;
      if(cy > tray.y + tray.h - beadR - margin) continue;
      let ok = true;
      for(const p of placed){
        const dd = Math.hypot(cx - p.cx, cy - p.cy);
        if(dd < beadR*2 + 18){ ok = false; break; }
      }
      if(ok){
        placed.push({cx,cy});
        return {cx,cy};
      }
    }
    const cx = splat.cx, cy = splat.cy;
    placed.push({cx,cy});
    return {cx,cy};
  }
  const topArea = { x: tray.x, y: tray.y, w: tray.w, h: 300 };
  card._posV = card.visible.map(()=> pickVisible(topArea));
  card._posH = card.hidden.map(()=> pickHiddenInSplat());
}

function assignPositionsUnits(card, rng){
  const tray = { x:120, y:260, w:1360, h:650 };
  const margin = 8;
  const tasks = card._unit?.tasks ?? 1;
  const hiddenByTask = card._unit?.hiddenByTask ?? Array.from({length: tasks}, ()=>0);
  const splats = getUnitSplats(tasks);
  card._splats = splats;
  const ctx = (function(){
    if(assignPositionsUnits._hitCtx) return assignPositionsUnits._hitCtx;
    const c = document.createElement("canvas");
    c.width = 1; c.height = 1;
    const ct = c.getContext("2d");
    assignPositionsUnits._hitCtx = ct;
    return ct;
  })();
  const canPath2D = (typeof Path2D !== "undefined") && ctx && typeof ctx.isPointInPath === "function";
  const splatObjs = splats.map(s=>{
    const d = blobPath(s.cx, s.cy, s.r);
    return { ...s, d, path: (canPath2D ? new Path2D(d) : null) };
  });
  const maxHidden = Math.max(0, ...hiddenByTask);
  const minR = Math.min(...splatObjs.map(o=>o.r));
  const rPad = Math.max(28, minR - 26);
  let beadR = 24;
  if(maxHidden > 0){
    const calc = Math.floor(rPad * Math.sqrt(0.82 / Math.max(1, maxHidden)));
    beadR = clamp(calc, 12, 26);
  } else {
    beadR = 26;
  }
  const totalBeads = (card._unit?.visibleCount ?? card.visible.length) + hiddenByTask.reduce((a,b)=>a+b,0);
  if(totalBeads >= 55) beadR = Math.min(beadR, 15);
  else if(totalBeads >= 45) beadR = Math.min(beadR, 17);
  else if(totalBeads >= 35) beadR = Math.min(beadR, 19);
  else if(totalBeads >= 25) beadR = Math.min(beadR, 21);
  function insideTray(cx, cy){
    if(cx < tray.x + beadR + margin) return false;
    if(cx > tray.x + tray.w - beadR - margin) return false;
    if(cy < tray.y + beadR + margin) return false;
    if(cy > tray.y + tray.h - beadR - margin) return false;
    return true;
  }
  function noOverlap(cx, cy, placed){
    for(const p of placed){
      if(Math.hypot(cx-p.cx, cy-p.cy) < (beadR*2 + 2)) return false; 
    }
    return true;
  }
  function farFromSplats(cx, cy){
    for(const o of splatObjs){
      if(Math.hypot(cx-o.cx, cy-o.cy) < (o.r + beadR + 18)) return false;
    }
    return true;
  }
  function pointInSplat(o, x, y){
    if(canPath2D && o.path){
      return ctx.isPointInPath(o.path, x, y);
    }
    return Math.hypot(x-o.cx, y-o.cy) <= (o.r - 10);
  }
  function beadFullyInSplat(o, x, y){
    if(!pointInSplat(o, x, y)) return false;
    if(canPath2D && o.path){
      return (function(){
        const r = beadR;
        const d = r * 0.7071067811865476; 
        const pts = [
          [ r, 0], [-r, 0], [0,  r], [0, -r],
          [ d, d], [ d,-d], [-d, d], [-d,-d]
        ];
        for(const [dx,dy] of pts){
          if(!ctx.isPointInPath(o.path, x+dx, y+dy)) return false;
        }
        return true;
      })();
    }
    return Math.hypot(x-o.cx, y-o.cy) <= (o.r - beadR - 14);
  }
  function tryPlaceWithRadius(R){
    beadR = R;
    const placed = [];
    function pickVisible(){
      for(let tries=0; tries<12000; tries++){
        const cx = tray.x + beadR + margin + rFloat(rng, 0, tray.w - (beadR*2 + margin*2));
        const cy = tray.y + beadR + margin + rFloat(rng, 0, tray.h - (beadR*2 + margin*2));
        if(!insideTray(cx,cy)) continue;
        if(!farFromSplats(cx,cy)) continue;
        let bad=false;
        for(const o of splatObjs){ if(pointInSplat(o, cx, cy)) { bad=true; break; } }
        if(bad) continue;
        if(!noOverlap(cx,cy, placed)) continue;
        placed.push({cx,cy});
        return {cx,cy};
      }
      return null;
    }
    function pickHiddenInSplat(o){
      for(let tries=0; tries<16000; tries++){
        const a = rFloat(rng, 0, Math.PI*2);
        const rr = Math.sqrt(rFloat(rng, 0, 1)) * Math.max(10, o.r - beadR - 18);
        const cx = o.cx + Math.cos(a)*rr;
        const cy = o.cy + Math.sin(a)*rr;
        if(!insideTray(cx,cy)) continue;
        if(!beadFullyInSplat(o, cx, cy)) continue;
        if(!noOverlap(cx,cy, placed)) continue;
        placed.push({cx,cy});
        return {cx,cy};
      }
      return null;
    }
    const vCount = card._unit?.visibleCount ?? card.visible.length;
    const posV = [];
    for(let i=0;i<vCount;i++){
      const p = pickVisible();
      if(!p) return null;
      posV.push(p);
    }
    const posH = [];
    for(let t=0; t<tasks; t++){
      const o = splatObjs[t];
      const k = hiddenByTask[t] ?? 0;
      for(let j=0; j<k; j++){
        const p = pickHiddenInSplat(o);
        if(!p) return null;
        posH.push(p);
      }
    }
    return { posV, posH };
  }
  let placedRes = null;
  for(let attempt=0; attempt<8 && !placedRes; attempt++){
    const R = Math.max(12, beadR - attempt);
    placedRes = tryPlaceWithRadius(R);
  }
  if(!placedRes){
    placedRes = tryPlaceWithRadius(12) || { posV:[], posH:[] };
  }
  card._beadR = beadR;
  card._posV = placedRes.posV;
  card._posH = placedRes.posH;
}

function genUnits(rng){
  let tasksMin = clamp(numberOr(unitTasksMinEl ? unitTasksMinEl.value : unitTasksEl.value, 1), 1, 5);
  let tasksMax = clamp(numberOr(unitTasksEl.value, 1), 1, 5);
  if(tasksMax < tasksMin){ const tmp = tasksMin; tasksMin = tasksMax; tasksMax = tmp; }
  // PATCH UI-A — tâches en plage (comme mode B)
  const tasks = rInt(rng, tasksMin, tasksMax);
  const visibleMax = clamp(numberOr(unitVisibleMaxEl.value, 15), 1, 20);
  const hiddenMax = clamp(numberOr(unitHiddenMaxEl.value, 10), 0, 20);
  const userMin = numberOr(unitTotalMinEl ? unitTotalMinEl.value : 1, 1);
  const userMax = numberOr(unitTotalMaxEl ? unitTotalMaxEl.value : 50, 50);
  const minHiddenPerTask = (hiddenMax === 0) ? 0 : 1;
  const minPossible = 1 + tasks * minHiddenPerTask;
  const maxPossible = visibleMax + tasks * hiddenMax;
  let totalMin = clamp(userMin, 1, 80);
  let totalMax = clamp(userMax, 1, 80);
  totalMin = Math.min(totalMin, maxPossible);
  totalMax = Math.min(totalMax, maxPossible);
  totalMax = Math.max(totalMax, minPossible);
  if(totalMin < minPossible) totalMin = minPossible;
  if(totalMax < totalMin) totalMax = totalMin;
  let visibleCount = 1;
  let hiddenPerTask = 0;
  let total = 0;
  for(let tries=0; tries<500; tries++){
    visibleCount = rInt(rng, 1, visibleMax);
    hiddenPerTask = (hiddenMax === 0) ? 0 : rInt(rng, 1, hiddenMax);
    total = visibleCount + tasks * hiddenPerTask;
    if(total >= totalMin && total <= totalMax) break;
  }
  if(total > totalMax){
    hiddenPerTask = clamp(Math.floor((totalMax - visibleCount) / tasks), 0, hiddenMax);
    if(hiddenMax > 0 && hiddenPerTask === 0 && totalMax >= (1 + tasks)) hiddenPerTask = 1;
    total = visibleCount + tasks * hiddenPerTask;
    if(total > totalMax){
      visibleCount = clamp(totalMax - tasks * hiddenPerTask, 1, visibleMax);
      total = visibleCount + tasks * hiddenPerTask;
    }
  }
  if(total < totalMin){
    const need = totalMin - total;
    const add = Math.ceil(need / tasks);
    hiddenPerTask = clamp(hiddenPerTask + add, (hiddenMax===0?0:1), hiddenMax);
    total = visibleCount + tasks * hiddenPerTask;
    if(total < totalMin){
      visibleCount = clamp(totalMin - tasks * hiddenPerTask, 1, visibleMax);
      total = visibleCount + tasks * hiddenPerTask;
    }
  }
  const hiddenByTask = Array.from({length: tasks}, ()=> hiddenPerTask);
  const hiddenTotal = tasks * hiddenPerTask;
  const visible = Array.from({length: visibleCount}, ()=> 1);
  const hidden = Array.from({length: hiddenTotal}, ()=> 1);
  return {
    family:"U",
    total,
    visible,
    hidden,
    _unit: { tasks, visibleCount, visibleMax, hiddenMax, hiddenPerTask, hiddenByTask, totalMin, totalMax }
  };
}

function genMinusMix(rng,diff){
  const ks=[19,29,39];
  const k=ks[rInt(rng,0,ks.length-1)];
  let tmin,tmax;
  if(diff===1){tmin=40;tmax=120;}
  else if(diff===2){tmin=60;tmax=180;}
  else {tmin=80;tmax=250;}
  let total=rInt(rng,tmin,tmax);
  total=Math.floor(total/10)*10 + rInt(rng,0,9);
  if(total<=k+5) total=k+25;
  return {family:"C", total, visible:[k], hidden:[total-k], _k:k};
}

/* SVG helpers */
const svg = document.getElementById("mainSvg");
function clearSvg(){ while(svg.firstChild) svg.removeChild(svg.firstChild); }
function el(name, attrs={}){
  const n = document.createElementNS("http://www.w3.org/2000/svg", name);
  for(const k in attrs) n.setAttribute(k, attrs[k]);
  return n;
}
function text(x,y,txt,attrs={}){
  const t = el("text", {x, y, ...attrs});
  t.textContent = txt;
  return t;
}

// Somme sûre (utile pour visible/caché)
function sumArray(arr){
  let s = 0;
  if(!arr) return 0;
  for(const v of arr){
    const n = Number(v);
    if(Number.isFinite(n)) s += n;
  }
  return s;
}

// Approximation de largeur de texte (pour garantir qu'un nombre "rentre" dans une case)
function approxTextWidthForNumber(num, fontSize){
  const s = String(num);
  const n = Math.max(1, s.length);
  // largeur moyenne d'un caractère ~ 0,56em (approx) ; marge de sécurité via padding
  return n * (Number(fontSize) || 0) * 0.56;
}
function minCellWidthForNumber(num, fontSize, pad){
  const p = (pad == null) ? 22 : Number(pad) || 22;
  return approxTextWidthForNumber(num, fontSize) + p;
}


/**
 * Dessine un "schéma en barre" (tableau 2 lignes) :
 *  - ligne 1 : TOTAL
 *  - ligne 2 : visible / caché (largeurs proportionnelles), la partie cachée est grisée.
 *
 * API attendue :
 *  - rect(attrs) -> <rect>
 *  - line(attrs) -> <line>
 *  - text(x,y,txt,attrs) -> <text>
 */
function drawBarModelInGroup(g, cx, topY, total, visibleVal, hiddenVal, api){
  const baseW = (api && api.w) ? api.w : 300;
  const hTop = (api && api.hTop) ? api.hTop : 56;
  const hBottom = (api && api.hBottom) ? api.hBottom : 72;

  const stroke = (api && api.stroke) ? api.stroke : "#000";
  const strokeWidth = (api && api.strokeWidth) ? api.strokeWidth : 3;
  const greyFill = (api && api.greyFill) ? api.greyFill : "rgba(0,0,0,0.10)";
  const ink = (api && api.ink) ? api.ink : "#000";
  const fontTop = (api && api.fontTop) ? api.fontTop : 72;
  const fontBottom = (api && api.fontBottom) ? api.fontBottom : 72;

  const dyVal = (api && api.textDy) ? api.textDy : "0";
  const visibleTextColor = (api && api.visibleTextColor) ? api.visibleTextColor : ink;

  const minPad = (api && api.minCellPad != null) ? api.minCellPad : 22;

  const mkRect = api.rect;
  const mkLine = api.line;
  const mkText = api.text;

  const vis = Math.max(0, Number(visibleVal) || 0);
  const hid = Math.max(0, Number(hiddenVal) || 0);
  const denom = (vis + hid) > 0 ? (vis + hid) : (Number(total) || 1);

  // Largeurs proportionnelles + minimum pour que le texte "rentre"
  const visWProp = (denom > 0) ? (baseW * (vis / denom)) : (baseW * 0.5);
  const hidWProp = baseW - visWProp;

  const minVisW = minCellWidthForNumber(vis, fontBottom, minPad);
  const minHidW = minCellWidthForNumber(hid, fontBottom, minPad);

  const visW = Math.max(visWProp, minVisW);
  const hidW = Math.max(hidWProp, minHidW);

  const w = Math.max(baseW, visW + hidW);

  const x0 = cx - w/2;
  const y0 = topY;
  const ySplit = y0 + hTop;

  const xSplit = x0 + visW;
  const hidWDraw = w - visW;

  // Fills
  g.appendChild(mkRect({x:x0, y:y0, width:w, height:hTop, fill:"rgba(255,255,255,0)"}));
  g.appendChild(mkRect({x:x0, y:ySplit, width:visW, height:hBottom, fill:"rgba(255,255,255,0)"}));
  if(hidWDraw > 0.5){
    g.appendChild(mkRect({x:xSplit, y:ySplit, width:hidWDraw, height:hBottom, fill:greyFill}));
  }

  // Border + grid
  g.appendChild(mkRect({x:x0, y:y0, width:w, height:(hTop+hBottom), rx:0, fill:"none", stroke, "stroke-width":strokeWidth}));
  g.appendChild(mkLine({x1:x0, y1:ySplit, x2:x0+w, y2:ySplit, stroke, "stroke-width":strokeWidth}));
  if(hidWDraw > 0.5 && visW > 0.5){
    g.appendChild(mkLine({x1:xSplit, y1:ySplit, x2:xSplit, y2:ySplit+hBottom, stroke, "stroke-width":strokeWidth}));
  }

  // Texts (juste les nombres)
  g.appendChild(mkText(cx, y0 + hTop/2, String(total), {
    "text-anchor":"middle",
    "dominant-baseline":"middle",
    "alignment-baseline":"middle",
    "dy":dyVal,
    "font-size":String(fontTop),
    "fill":ink,
    "font-weight":"900"
  }));

  // Visible
  g.appendChild(mkText(x0 + visW/2, ySplit + hBottom/2, String(vis), {
    "text-anchor":"middle",
    "dominant-baseline":"middle",
    "alignment-baseline":"middle",
    "dy":dyVal,
    "font-size":String(fontBottom),
    "fill":visibleTextColor,
    "font-weight":"900"
  }));

  // Caché (si largeur nulle, on l'omet)
  if(hidWDraw > 0.5){
    g.appendChild(mkText(xSplit + hidWDraw/2, ySplit + hBottom/2, String(hid), {
      "text-anchor":"middle",
      "dominant-baseline":"middle",
      "alignment-baseline":"middle",
      "dy":dyVal,
      "font-size":String(fontBottom),
      "fill":ink,
      "font-weight":"900"
    }));
  }
}


/**
 * Variante "multi-parties" du schéma en barre :
 *  - ligne 1 : TOTAL (une seule case sur toute la largeur)
 *  - ligne 2 : plusieurs cases (1 visible + n cachées), largeurs proportionnelles
 *    Les cases "cachées" sont grisées.
 *
 * parts = [{value:number, hidden:boolean}, ...]
 */
function drawBarModelPartsInGroup(g, cx, topY, total, parts, api){
  const baseW = (api && api.w) ? api.w : 300;
  const hTop = (api && api.hTop) ? api.hTop : 56;
  const hBottom = (api && api.hBottom) ? api.hBottom : 72;

  const stroke = (api && api.stroke) ? api.stroke : "#000";
  const strokeWidth = (api && api.strokeWidth) ? api.strokeWidth : 3;
  const greyFill = (api && api.greyFill) ? api.greyFill : "rgba(0,0,0,0.10)";
  const ink = (api && api.ink) ? api.ink : "#000";
  const fontTop = (api && api.fontTop) ? api.fontTop : 72;
  const fontBottom = (api && api.fontBottom) ? api.fontBottom : 72;

  const dyVal = (api && api.textDy) ? api.textDy : "0";
  const visibleTextColor = (api && api.visibleTextColor) ? api.visibleTextColor : ink;
  const hiddenTextColor = (api && api.hiddenTextColor) ? api.hiddenTextColor : ink;

  const minPad = (api && api.minCellPad != null) ? api.minCellPad : 22;

  const mkRect = api.rect;
  const mkLine = api.line;
  const mkText = api.text;

  const safeParts = Array.isArray(parts) ? parts : [];
  const values = safeParts.map(p => Math.max(0, Number(p && p.value) || 0));
  const flagsHidden = safeParts.map(p => !!(p && p.hidden));

  let denom = values.reduce((a,b)=>a+b, 0);
  if(!(denom > 0)) denom = (Number(total) || 1);

  // Largeurs proportionnelles + minimum pour que les nombres rentrent
  const widths = values.map(v => {
    const prop = baseW * (v / denom);
    const minW = minCellWidthForNumber(v, fontBottom, minPad);
    return Math.max(prop, minW);
  });

  const w = Math.max(baseW, widths.reduce((a,b)=>a+b, 0));

  const x0 = cx - w/2;
  const y0 = topY;
  const ySplit = y0 + hTop;

  // Contour global + séparation horizontale
  g.appendChild(mkRect({x:x0, y:y0, width:w, height:(hTop+hBottom), rx:0, fill:"none", stroke, "stroke-width":strokeWidth}));
  g.appendChild(mkLine({x1:x0, y1:ySplit, x2:x0+w, y2:ySplit, stroke, "stroke-width":strokeWidth}));

  // Ligne du haut : fond transparent + texte total
  g.appendChild(mkRect({x:x0, y:y0, width:w, height:hTop, fill:"rgba(255,255,255,0)"}));
  g.appendChild(mkText(cx, y0 + hTop/2, String(total), {
    "text-anchor":"middle",
    "dominant-baseline":"middle",
    "alignment-baseline":"middle",
    "dy":dyVal,
    "font-size":String(fontTop),
    "fill":ink,
    "font-weight":"900"
  }));

  // Ligne du bas : cases
  let x = x0;
  for(let i=0;i<values.length;i++){
    const v = values[i];

    // Dernière case : on comble exactement le reste (évite micro-trous)
    let segW = (i === values.length - 1) ? ((x0 + w) - x) : widths[i];
    if(segW < 0) segW = 0;

    // fond
    if(flagsHidden[i] && segW > 0.5){
      g.appendChild(mkRect({x:x, y:ySplit, width:segW, height:hBottom, fill:greyFill}));
    }else{
      g.appendChild(mkRect({x:x, y:ySplit, width:segW, height:hBottom, fill:"rgba(255,255,255,0)"}));
    }

    // texte
    if(segW > 1){
      const fill = (i === 0) ? visibleTextColor : hiddenTextColor;
      g.appendChild(mkText(x + segW/2, ySplit + hBottom/2, String(v), {
        "text-anchor":"middle",
        "dominant-baseline":"middle",
        "alignment-baseline":"middle",
        "dy":dyVal,
        "font-size":String(fontBottom),
        "fill":fill,
        "font-weight":"900"
      }));
    }

    // séparateur vertical (entre cases, uniquement sur la ligne du bas)
    if(i < values.length - 1){
      const xNext = x + segW;
      if(segW > 0.5){
        g.appendChild(mkLine({x1:xNext, y1:ySplit, x2:xNext, y2:ySplit+hBottom, stroke, "stroke-width":strokeWidth}));
      }
      x = xNext;
    }
  }
}


/* Render écran */
function renderCard(card, revealed){
  clearSvg();

  if(card.family === "EQ" || card.family === "EQPM"){
    renderCardEquation(card, revealed);
    return;
  }

  // Config plateau : remonte si mode C ou D
  const trayCfg = getTrayConfig(card.family);
  const isModeC_or_D = (card.family === "C" || card.family === "D");
  const isModeC = (card.family === "C");

  // Plateau : les coordonnées sont entièrement gérées par getTrayConfig (pas de décalage supplémentaire)
  const trayLayer = svg;
  trayLayer.appendChild(el("rect",{
    x:trayCfg.x, y:trayCfg.y, width:trayCfg.w, height:trayCfg.h,
    rx:30, fill:"rgba(0,0,0,0.03)", stroke:"rgba(0,0,0,0.15)", "stroke-width":"6"
  }));

  // TOTAL Position
  let tx = 800, ty = 92; 

  const gTotal = el("g", {id:"totalGroup"});

  const isBarModelTotalU = (card.family === "U" && revealed);
  const isBarModelTotalN = (card.family === "N" && revealed);
  const isBarModelTotal = isBarModelTotalU || isBarModelTotalN;

  // Mode A (U) : à la révélation (bouton Suivant), on affiche un schéma en barre
  // à la place du nombre du total (projection), uniquement à l'écran (pas l'impression).
  // Mode B (N) : idem, mais les "visibles" sont la SOMME des billes visibles (numérotées),
  // et si plusieurs taches : on sépare en plusieurs cases cachées (une par tache).
  if(isBarModelTotal){
    if(isBarModelTotalU){
      const vis = sumArray(card.visible);

      // Mode A (U) : si plusieurs taches, on découpe la partie cachée en plusieurs cases (une par tache),
      // exactement comme en mode B, au lieu d'une seule case "caché total".
      const unit = card._unit || {};
      const tasksFromSplats = (Array.isArray(card._splats) && card._splats.length) ? card._splats.length : 0;
      const tasks = Math.max(1, tasksFromSplats || Number(unit.tasks) || 1);

      const totalHid = sumArray(card.hidden);

      let hiddenSums = [];
      if(totalHid === 0){
        hiddenSums = [0];
      }else if(Array.isArray(unit.hiddenByTask) && unit.hiddenByTask.length === tasks){
        hiddenSums = unit.hiddenByTask.map(v => Array.isArray(v) ? sumArray(v) : Number(v));
      }else{
        const base = Math.floor(totalHid / tasks);
        let rem = totalHid - base * tasks;
        hiddenSums = Array.from({length: tasks}, (_, i)=> base + (i < rem ? 1 : 0));
      }
      hiddenSums = hiddenSums.map(v => (Number.isFinite(v) ? v : 0));
if(hiddenSums.length <= 1){
        const hid = (hiddenSums[0] ?? sumArray(card.hidden));
        drawBarModelInGroup(gTotal, tx, ty-56, card.total, vis, hid, {
          rect:(a)=>el("rect", a),
          line:(a)=>el("line", a),
          text:(x,y,t,a)=>text(x,y,t,a),
          w: 380,
          hTop: 86,
          hBottom: 86,
          stroke:"#000",
          strokeWidth:4,
          greyFill:"rgba(0,0,0,0.10)",
          ink:"var(--ink)",
          visibleTextColor:"var(--accent)",
          textDy:"0.10em",
          fontTop:70,
          fontBottom:70
        });
      }else{
        const parts = [{value: vis, hidden:false}, ...hiddenSums.map(v => ({value:v, hidden:true}))];
        drawBarModelPartsInGroup(gTotal, tx, ty-56, card.total, parts, {
          rect:(a)=>el("rect", a),
          line:(a)=>el("line", a),
          text:(x,y,t,a)=>text(x,y,t,a),
          w: 380,
          hTop: 86,
          hBottom: 86,
          stroke:"#000",
          strokeWidth:4,
          greyFill:"rgba(0,0,0,0.10)",
          ink:"var(--ink)",
          visibleTextColor:"var(--accent)",
          textDy:"0.10em",
          fontTop:70,
          fontBottom:70
        });
      }
    }else{
      const visSum = sumArray(card.visible);

      const num = card._num || {};
      const tasks = Math.max(1, Number(num.tasks) || (Array.isArray(card._splats) ? card._splats.length : 1));

      let hiddenSums = [];
      if(Array.isArray(num.hiddenByTask) && num.hiddenByTask.length){
        hiddenSums = num.hiddenByTask.map(arr => sumArray(arr));
      }else{
        const totalHid = sumArray(card.hidden);
        const each = Math.round(totalHid / tasks);
        hiddenSums = Array.from({length: tasks}, ()=> each);
      }
      hiddenSums = hiddenSums.map(v => (Number.isFinite(v) ? v : 0));

      if(hiddenSums.length <= 1){
        const hidSum = (hiddenSums[0] ?? sumArray(card.hidden));
        drawBarModelInGroup(gTotal, tx, ty-56, card.total, visSum, hidSum, {
          rect:(a)=>el("rect", a),
          line:(a)=>el("line", a),
          text:(x,y,t,a)=>text(x,y,t,a),
          w: 380,
          hTop: 86,
          hBottom: 86,
          stroke:"#000",
          strokeWidth:4,
          greyFill:"rgba(0,0,0,0.10)",
          ink:"var(--ink)",
          visibleTextColor:"var(--ink)",
          textDy:"0.10em",
          fontTop:70,
          fontBottom:70
        });
      }else{
        const parts = [{value: visSum, hidden:false}, ...hiddenSums.map(v => ({value:v, hidden:true}))];
        drawBarModelPartsInGroup(gTotal, tx, ty-56, card.total, parts, {
          rect:(a)=>el("rect", a),
          line:(a)=>el("line", a),
          text:(x,y,t,a)=>text(x,y,t,a),
          w: 380,
          hTop: 86,
          hBottom: 86,
          stroke:"#000",
          strokeWidth:4,
          greyFill:"rgba(0,0,0,0.10)",
          ink:"var(--ink)",
          visibleTextColor:"var(--ink)",
          hiddenTextColor:"var(--ink)",
          textDy:"0.10em",
          fontTop:70,
          fontBottom:70
        });
      }
    }
  }else{
    const tLabel = text(tx, ty, "TOTAL", {
      "text-anchor":"middle","font-size":"42",
      "fill":"var(--total-label)","font-weight":"800","letter-spacing":"2"
    });
    const tNum = text(tx, ty+83, String(card.total), {
      "text-anchor":"middle","font-size":"96",
      "fill":"var(--ink)","font-weight":"900"
    });
    gTotal.appendChild(tLabel);
    gTotal.appendChild(tNum);
  }
  svg.appendChild(gTotal);

  const bbTotal = gTotal.getBBox();
  const padX = 40, padY = 26;
  
  if(!isBarModelTotal){
  // Rect du Total
    let boxX = bbTotal.x - padX;
    svg.insertBefore(el("rect",{
      x: boxX,
      y: bbTotal.y - padY,
      width: bbTotal.width + padX*2,
      height: bbTotal.height + padY*2,
      rx: 22,
      fill:"var(--totalbox-fill)",
      stroke:"#000",
      "stroke-width":"4"
    }), gTotal);
  }

  /* Affichage des indices si Mode C ou D */
  if(isModeC_or_D && card._inv && card._inv.indices){
    const indices = card._inv.indices;
    const gInd = el("g", {id: "clueGroup"});

    if(card.family === "C"){
      // Mode C : indices sous le plateau, sans gros vide en dessous
      const trayBottom = trayCfg.y + trayCfg.h;
      // Mode C : les phrases doivent etre proches du plateau (sans gros vide dessous)
      const yMax = 965; // viewBox H=1000
      let lineH = 65;
      let startY = trayBottom + 70;

      // Si ça ne rentre pas, on compacte l'interligne
      if(indices.length > 1){
        const needed = startY + (indices.length - 1) * lineH;
        if(needed > yMax){
          lineH = Math.max(48, (yMax - startY) / (indices.length - 1));
        }
      }
indices.forEach((txt, i) => {
        gInd.appendChild(text(800, startY + i*lineH, txt, {
          "text-anchor":"middle",
          "font-size":"45",
          "fill":"var(--ink)",
          "font-weight":"700"
        }));
      });
    } else {
      // Mode D : indices sous le plateau (comme C), sans gros vide en dessous
      const trayBottom = trayCfg.y + trayCfg.h;
      const yMax = 965; // viewBox H=1000
      let lineH = 65;
      let startY = trayBottom + 70;

      // Si ça ne rentre pas, on compacte l'interligne
      if(indices.length > 1){
        const needed = startY + (indices.length - 1) * lineH;
        if(needed > yMax){
          lineH = Math.max(48, (yMax - startY) / (indices.length - 1));
        }
      }

      indices.forEach((txt, i) => {
        gInd.appendChild(text(800, startY + i*lineH, txt, {
          "text-anchor":"middle",
          "font-size":"45",
          "fill":"var(--ink)",
          "font-weight":"700"
        }));
      });
    }svg.appendChild(gInd);
  }

  const layer = trayLayer;

  // unit mode (A)
  if(card.family === "U"){
    const beadR = card._beadR ?? 26;
    for(let i=0;i<card.hidden.length;i++){
      const cx = card._posH?.[i]?.cx ?? 820;
      const cy = card._posH?.[i]?.cy ?? 610;
      layer.appendChild(el("circle",{cx, cy, r:beadR, fill:"var(--beadH-fill)", stroke:"var(--beadH-stroke)", "stroke-width":"3"}));
    }
    const splats = card._splats || [{cx:820, cy:610, r:220}];
    for(const s of splats){
      layer.appendChild(el("path",{
        d: blobPath(s.cx, s.cy, s.r),
        fill: revealed ? "var(--splat-reveal)" : "var(--splat-cover)",
        stroke: "var(--splat-stroke)",
        "stroke-width":"5"
      }));
    }
    for(let i=0;i<card.visible.length;i++){
      const cx = card._posV?.[i]?.cx ?? (450 + i*40);
      const cy = card._posV?.[i]?.cy ?? 360;
      layer.appendChild(el("circle",{cx, cy, r:beadR, fill:"var(--unit-fill)", stroke:"var(--unit-stroke)", "stroke-width":"3"}));
    }
    return;
  }

  // numbered multi-splats (B, C, D, E, F)
  if(["N","NPM","C","D","C9","C8"].includes(card.family)){
    const beadR = card._beadR ?? 52;
    const font = Math.round(beadR * 0.9);

    // hidden beads (under splat)
    for(let i=0;i<card.hidden.length;i++){
      const cx = card._posH?.[i]?.cx ?? 820;
      const cy = card._posH?.[i]?.cy ?? 610;
      layer.appendChild(el("circle",{cx, cy, r:beadR, fill:"var(--beadH-fill)", stroke:"var(--beadH-stroke)", "stroke-width":"5"}));
      layer.appendChild(text(cx, cy, String(card.hidden[i]), {
        "text-anchor":"middle","dominant-baseline":"middle","alignment-baseline":"middle","dy":"0.06em","font-size":String(font),"fill":"var(--ink)","font-weight":"900"
      }));
    }

    // splats (multi)
    const splats = card._splats || [{cx:820, cy:610, r:220}];
    
    // Couleurs opaques et transparentes pour le mode C/D
    const opqCols = ["var(--splat-black)", "var(--splat-purple)", "var(--splat-orange)"];
    const revCols = ["var(--splat-black-rev)", "var(--splat-purple-rev)", "var(--splat-orange-rev)"];

    const opp = (card.family === "NPM" && card._num && card._num.oppose && Array.isArray(card._num.oppose.flags)) ? card._num.oppose : null;
    splats.forEach((s, idx) => {
      let fillCol;
      if(card.family === "C" || card.family === "D"){
        fillCol = revealed ? revCols[idx%3] : opqCols[idx%3];
      } else {
        fillCol = revealed ? "var(--splat-reveal)" : "var(--splat-cover)";
      }
      layer.appendChild(el("path",{
        d: blobPath(s.cx, s.cy, s.r),
        fill: fillCol,
        stroke: "var(--splat-stroke)",
        "stroke-width":"5"
      }));
      if(card.family === "NPM" && card._num && Array.isArray(card._num.opposedTasks) && card._num.opposedTasks[idx]){
        const fs = clamp(Math.round(s.r*0.34), 28, 64);
        const y = revealed ? (s.cy - s.r*0.65) : (s.cy);
        layer.appendChild(text(s.cx, y, "opposé", {
          "text-anchor":"middle",
          "dominant-baseline":"middle",
          "font-size": fs,
          "font-weight":"900",
          "fill":(revealed ? "rgba(0,0,0,0.92)" : "rgba(255,255,255,0.95)"),
          "stroke":(revealed ? "rgba(255,255,255,0.78)" : "rgba(0,0,0,0)"),
          "stroke-width":(revealed ? "5" : "0"),
          "paint-order":"stroke fill"
        }));
      }
      // PATCH 6 — libellé "oppose" sur certaines taches (B±)
      if(opp && opp.flags[idx]){
        const fs = clamp(Math.round(s.r*0.34), 28, 64);
        const y = revealed ? (s.cy - s.r*0.65) : (s.cy);
        layer.appendChild(text(s.cx, y, "opposé", {
          "text-anchor":"middle",
          "dominant-baseline":"middle",
          "font-size": fs,
          "font-weight":"900",
          "fill":(revealed ? "rgba(0,0,0,0.92)" : "rgba(255,255,255,0.95)"),
          "stroke":(revealed ? "rgba(255,255,255,0.78)" : "rgba(0,0,0,0)"),
          "stroke-width":(revealed ? "5" : "0"),
          "paint-order":"stroke fill"
        }));
      }

    });

    // visible beads (pour modes N, C, D, E, F)
    for(let i=0;i<card.visible.length;i++){
      const cx = card._posV?.[i]?.cx ?? (450 + i*250);
      const cy = card._posV?.[i]?.cy ?? 380;
      const col = beadColorForValue(card.visible[i]);
      layer.appendChild(el("circle",{cx, cy, r:beadR, fill:col.fill, stroke:col.stroke, "stroke-width":"5"}));
      layer.appendChild(text(cx, cy, String(card.visible[i]), {
        "text-anchor":"middle","dominant-baseline":"middle","alignment-baseline":"middle","dy":"0.06em","font-size":String(font),"fill":"var(--ink)","font-weight":"900"
      }));
    }
    return;
  }

  // classic mode
  const beadR=95;
  for(let i=0;i<card.hidden.length;i++){
    const cx = card._posH?.[i]?.cx ?? 820;
    const cy = card._posH?.[i]?.cy ?? 610;
    layer.appendChild(el("circle",{cx, cy, r:beadR, fill:"var(--beadH-fill)", stroke:"var(--beadH-stroke)", "stroke-width":"5"}));
    layer.appendChild(text(cx, cy, String(card.hidden[i]), {"text-anchor":"middle","dominant-baseline":"middle","alignment-baseline":"middle","dy":"0.06em","font-size":"64","fill":"var(--ink)","font-weight":"900"}));
  }
  const s0 = card._splat || {cx:820, cy:610, r:220};
  layer.appendChild(el("path",{
    d: blobPath(s0.cx, s0.cy, s0.r),
    fill: revealed ? "var(--splat-reveal)" : "var(--splat-cover)",
    stroke: "var(--splat-stroke)",
    "stroke-width":"5"
  }));
  for(let i=0;i<card.visible.length;i++){
    const cx = card._posV?.[i]?.cx ?? (450 + i*250);
    const cy = card._posV?.[i]?.cy ?? 380;
    const col = beadColorForValue(card.visible[i]);
    layer.appendChild(el("circle",{cx, cy, r:beadR, fill:col.fill, stroke:col.stroke, "stroke-width":"5"}));
    layer.appendChild(text(cx, cy, String(card.visible[i]), {"text-anchor":"middle","dominant-baseline":"middle","alignment-baseline":"middle","dy":"0.06em","font-size":"64","fill":"var(--ink)","font-weight":"900"}));
  }
}


function renderCardEquation(card, revealed){
  const eq = card._eq;
  const trays = card._eqTrays;
  const pos = card._eqPos;
  if(!eq || !trays || !pos) return;
  const layer = svg; // FIX: en EQ on dessine directement dans le svg principal

  const cover = "rgba(0,0,0,0.95)";
  const reveal = "rgba(220,220,220,0.35)";

  // Deux plateaux
  layer.appendChild(el("rect",{
    x:trays.left.x, y:trays.left.y, width:trays.left.w, height:trays.left.h,
    rx:30, fill:"rgba(0,0,0,0.03)", stroke:"rgba(0,0,0,0.20)", "stroke-width":"5"
  }));
  layer.appendChild(el("rect",{
    x:trays.right.x, y:trays.right.y, width:trays.right.w, height:trays.right.h,
    rx:30, fill:"rgba(0,0,0,0.03)", stroke:"rgba(0,0,0,0.20)", "stroke-width":"5"
  }));

  // Trait vertical de séparation
  layer.appendChild(el("line",{
    x1:trays.midX, y1:trays.left.y-10,
    x2:trays.midX, y2:trays.left.y+trays.left.h+10,
    stroke:"#000", "stroke-width":"10", "stroke-linecap":"round"
  }));

  // Consigne (uniquement en haut)
  layer.appendChild(text(800, 78, "Même quantité à gauche qu'à droite",{
    "text-anchor":"middle", "font-size":"44", "fill":"rgba(0,0,0,0.92)", "font-weight":"900"
  }));
    function drawSide(side, metaSide){
    const beadR = side.beadR ?? 26;
    const font = Math.max(18, Math.round(beadR * 0.95));

    // billes cachées (sous taches)
    let hIndex = 0;
    for(const taskArr of metaSide.hiddenByTask){
      for(const val of taskArr){
        const p = side.posH?.[hIndex] || {cx:820, cy:610};
        const col = beadColorForValue(val);
        layer.appendChild(el("circle",{cx:p.cx, cy:p.cy, r:beadR, fill:col.fill, stroke:col.stroke, "stroke-width":"5"}));
        layer.appendChild(text(p.cx, p.cy + Math.round(font*0.32), String(val),{
          "text-anchor":"middle", "font-size":String(font), fill:"#000", "font-weight":"900"
        }));
        hIndex++;
      }
    }

    // taches
    const oppFlags = Array.isArray(metaSide.opposeFlags) ? metaSide.opposeFlags : null;
    (side.splats || []).forEach((s, idx)=>{
      layer.appendChild(el("path",{
        d: blobPath(s.cx, s.cy, s.r),
        fill: revealed ? reveal : cover,
        stroke:"rgba(0,0,0,0.18)",
        "stroke-width":"5"
      }));
      if(oppFlags && oppFlags[idx]){
        const fs = clamp(Math.round(s.r*0.28), 16, 44);
        const yy = revealed ? (s.cy - s.r*0.65) : (s.cy);
        layer.appendChild(text(s.cx, yy, "opposé", {
          "text-anchor":"middle",
          "dominant-baseline":"middle",
          "font-size": String(fs),
          "font-weight":"900",
          "fill": (revealed ? "rgba(0,0,0,0.92)" : "rgba(255,255,255,0.95)"),
          "stroke": (revealed ? "rgba(255,255,255,0.78)" : "rgba(0,0,0,0)"),
          "stroke-width": (revealed ? "5" : "0"),
          "paint-order":"stroke fill"
        }));
      }
    });

    // billes visibles
    for(let i=0;i<metaSide.visible.length;i++){
      const p = side.posV?.[i] || {cx:450+i*40, cy:360};
      const val = metaSide.visible[i];
      const col = beadColorForValue(val);
      layer.appendChild(el("circle",{cx:p.cx, cy:p.cy, r:beadR, fill:col.fill, stroke:col.stroke, "stroke-width":"5"}));
      layer.appendChild(text(p.cx, p.cy + Math.round(font*0.32), String(val),{
        "text-anchor":"middle", "font-size":String(font), fill:"#000", "font-weight":"900"
      }));
    }
  }

  drawSide(pos.left, eq.left);
  drawSide(pos.right, eq.right);
}

function renderCardEquationPrint(targetSvg, card, revealAnswers, tEl, tText){
  // Version impression : identique au rendu écran, mais sur targetSvg
  const eq = card._eq;
  const trays = card._eqTrays;
  const pos = card._eqPos;
  if(!eq || !trays || !pos) return;

  const cover = "rgba(0,0,0,0.95)";
  const reveal = "rgba(220,220,220,0.35)";

  // Plateaux
  targetSvg.appendChild(tEl("rect",{x:trays.left.x, y:trays.left.y, width:trays.left.w, height:trays.left.h, rx:30, fill:"rgba(0,0,0,0.02)", stroke:"rgba(0,0,0,0.15)","stroke-width":"6"}));
  targetSvg.appendChild(tEl("rect",{x:trays.right.x, y:trays.right.y, width:trays.right.w, height:trays.right.h, rx:30, fill:"rgba(0,0,0,0.02)", stroke:"rgba(0,0,0,0.15)","stroke-width":"6"}));

  // Séparateur
  targetSvg.appendChild(tEl("line",{x1:trays.midX, y1:trays.left.y-10, x2:trays.midX, y2:trays.left.y+trays.left.h+10, stroke:"#000","stroke-width":"10","stroke-linecap":"round"}));

  // Consigne en haut
  targetSvg.appendChild(tText(800, 78, "Même quantité à gauche qu'à droite", {"text-anchor":"middle","font-size":"44","fill":"rgba(0,0,0,0.92)","font-weight":"900"}));
function drawSide(side, metaSide){
    const beadR = side.beadR ?? 26;
    const font = Math.max(18, Math.round(beadR * 0.95));

    let hIndex = 0;
    for(const taskArr of metaSide.hiddenByTask){
      for(const val of taskArr){
        const p = side.posH?.[hIndex] || {cx:820, cy:610};
        const col = beadColorForValue(val);
        targetSvg.appendChild(tEl("circle",{cx:p.cx, cy:p.cy, r:beadR, fill:col.fill, stroke:col.stroke, "stroke-width":"5"}));
        targetSvg.appendChild(tText(p.cx, p.cy + Math.round(font*0.32), String(val), {"text-anchor":"middle","font-size":String(font),"fill":"#000","font-weight":"900"}));
        hIndex++;
      }
    }

    const oppFlags = Array.isArray(metaSide.opposeFlags) ? metaSide.opposeFlags : null;
    (side.splats || []).forEach((s, idx)=>{
      targetSvg.appendChild(tEl("path",{d: blobPath(s.cx, s.cy, s.r), fill: revealAnswers ? reveal : cover, stroke:"rgba(0,0,0,0.18)","stroke-width":"5"}));
      if(oppFlags && oppFlags[idx]){
        const fs = clamp(Math.round(s.r*0.28), 16, 44);
        const yy = revealAnswers ? (s.cy - s.r*0.65) : (s.cy);
        targetSvg.appendChild(tText(s.cx, yy, "opposé", {
          "text-anchor":"middle",
          "dominant-baseline":"middle",
          "font-size": String(fs),
          "font-weight":"900",
          "fill": (revealAnswers ? "rgba(0,0,0,0.92)" : "rgba(255,255,255,0.95)"),
          "stroke": (revealAnswers ? "rgba(255,255,255,0.78)" : "rgba(0,0,0,0)"),
          "stroke-width": (revealAnswers ? "5" : "0"),
          "paint-order":"stroke fill"
        }));
      }
    });

    for(let i=0;i<metaSide.visible.length;i++){
      const p = side.posV?.[i] || {cx:450+i*40, cy:360};
      const val = metaSide.visible[i];
      const col = beadColorForValue(val);
      targetSvg.appendChild(tEl("circle",{cx:p.cx, cy:p.cy, r:beadR, fill:col.fill, stroke:col.stroke, "stroke-width":"5"}));
      targetSvg.appendChild(tText(p.cx, p.cy + Math.round(font*0.32), String(val), {"text-anchor":"middle","font-size":String(font),"fill":"#000","font-weight":"900"}));
    }
  }

  drawSide(pos.left, eq.left);
  drawSide(pos.right, eq.right);
}


/* Render impression */
function renderCardIntoSvg(targetSvg, card, revealAnswers){
  while(targetSvg.firstChild) targetSvg.removeChild(targetSvg.firstChild);

  const W = 1600;
  const H = 2200;

  function tEl(name, attrs={}){
    const n = document.createElementNS("http://www.w3.org/2000/svg", name);
    for(const k in attrs) n.setAttribute(k, attrs[k]);
    return n;
  }
  function tText(x,y,txt,attrs={}){
    const t = tEl("text",{x,y,...attrs}); t.textContent=txt; return t;
  }

  targetSvg.appendChild(tEl("rect",{x:0,y:0,width:W,height:H,rx:26,fill:"#fff"}));

  if(card.family === "EQ" || card.family === "EQPM"){
    renderCardEquationPrint(targetSvg, card, revealAnswers, tEl, tText);
    return;
  }

  // Modes
  const isModeC_or_D = (card.family === "C" || card.family === "D");
  const isModeC = (card.family === "C");
  const isModeD = (card.family === "D");

  // Plateau (impression) : calé sur le plateau "logique" de génération
  const trayY = (isModeC || isModeD) ? 270 : 260;
  const trayH = (isModeC || isModeD) ? 550 : 650;

  targetSvg.appendChild(tEl("rect",{x:120,y:trayY,width:1360,height:trayH,rx:30,fill:"rgba(0,0,0,0.02)",stroke:"rgba(0,0,0,0.15)","stroke-width":"6"}));

  // Adapt for print: position du total et éventuel décalage des coordonnées générées
  let tx = 800, ty = 92;
  let printOffsetY = 0;
  // Position du TOTAL : au-dessus du plateau (comme A/B), centré
  if(isModeC || isModeD){
    tx = 800;
    ty = 92;
  }

  const g = tEl("g",{id:"totalGroupPrint"});
  const lbl = tText(tx, ty, "TOTAL", {"text-anchor":"middle","font-size":"42","fill":"rgba(0,0,0,0.92)","font-weight":"900","letter-spacing":"2"});
  const num = tText(tx, ty+83, String(card.total), {"text-anchor":"middle","font-size":"96","fill":"#000","font-weight":"900"});
  g.appendChild(lbl); g.appendChild(num);
  targetSvg.appendChild(g);

  // Cadre TOTAL en impression : dimensions fixes
  // (getBBox ne marche pas tant que .printArea est display:none hors impression)
  const boxH = 210;
  const boxY = ty - 70;

  let boxW = 360;
  let boxX = tx - boxW/2;

  // En C/D, on garde la taille du cadre ; pour D on centre sur le texte (TOTAL centré),
  // et on conserve l'alignement historique de C si besoin.
  if(isModeD){
    boxW = 280;
    boxX = tx - boxW/2;
  } else if(isModeC){
    boxW = 280;
    boxX = 120;
  }
targetSvg.insertBefore(tEl("rect",{
    x:Math.round(boxX), y:Math.round(boxY), width:Math.round(boxW), height:Math.round(boxH), rx:22,
    fill:"rgba(0,0,0,0.02)", stroke:"rgba(0,0,0,0.22)", "stroke-width":"4"
  }), g);

    /* Indices impression Mode C/D : SOUS LE PLATEAU */
  if(isModeC_or_D && card._inv && card._inv.indices){
    const indices = card._inv.indices;
    const lineH = 84;
    const startY = trayY + trayH + 220;

    indices.forEach((txt, i) => {
      targetSvg.appendChild(tText(800, startY + i*lineH, txt, {
        "text-anchor":"middle","font-size":"56","fill":"#000","font-weight":"700"
      }));
    });
  }
  // (Impression) Zone de réponse : pas de cadre, on laisse l’espace libre.

  const cover = "rgb(0,0,0)";
  const reveal = "rgba(210,210,210,0.35)";
  const colorsE = ["rgb(0,0,0)", "#9d4edd", "#f97316"];
  const colorsERev = ["rgba(40,40,40,0.2)", "rgba(157,78,221,0.2)", "rgba(249,115,22,0.2)"];

  if(card.family === "U"){
    const beadR = card._beadR ?? 26;
    for(let i=0;i<card.hidden.length;i++){
      const cx = card._posH?.[i]?.cx ?? 820;
      const cy = card._posH?.[i]?.cy ?? 610;
      targetSvg.appendChild(tEl("circle",{cx, cy, r:beadR, fill:"rgba(0,0,0,0.05)", stroke:"rgba(0,0,0,0.18)","stroke-width":"3"}));
    }
    const splats = card._splats || [{cx:820, cy:610, r:220}];
    for(const s of splats){
      targetSvg.appendChild(tEl("path",{d: blobPath(s.cx,s.cy,s.r), fill:(revealAnswers?reveal:cover), stroke:"rgba(0,0,0,0.18)","stroke-width":"5"}));
    }
    for(let i=0;i<card.visible.length;i++){
      const cx = card._posV?.[i]?.cx ?? (450 + i*40);
      const cy = card._posV?.[i]?.cy ?? 360;
      targetSvg.appendChild(tEl("circle",{cx, cy, r:beadR, fill:"rgba(106,167,255,0.20)", stroke:"rgba(106,167,255,0.55)","stroke-width":"3"}));
    }

    // Schéma en barre en correction (impression) : uniquement si on imprime la correction (révélé)
    if(revealAnswers){
      const vis = sumArray(card.visible);

      // Mode A (U) : en correction imprimée aussi, on découpe le caché par tache si plusieurs taches.
      const unit = card._unit || {};
      const tasksFromSplats = (Array.isArray(card._splats) && card._splats.length) ? card._splats.length : 0;
      const tasks = Math.max(1, tasksFromSplats || Number(unit.tasks) || 1);

      const totalHid = sumArray(card.hidden);

      let hiddenSums = [];
      if(totalHid === 0){
        hiddenSums = [0];
      }else if(Array.isArray(unit.hiddenByTask) && unit.hiddenByTask.length === tasks){
        hiddenSums = unit.hiddenByTask.map(v => Array.isArray(v) ? sumArray(v) : Number(v));
      }else{
        const base = Math.floor(totalHid / tasks);
        let rem = totalHid - base * tasks;
        hiddenSums = Array.from({length: tasks}, (_, i)=> base + (i < rem ? 1 : 0));
      }
      hiddenSums = hiddenSums.map(v => (Number.isFinite(v) ? v : 0));
const gBM = tEl("g",{id:"barModelPrint"});
      if(hiddenSums.length <= 1){
        const hid = (hiddenSums[0] ?? sumArray(card.hidden));
        drawBarModelInGroup(gBM, 800, 980, card.total, vis, hid, {
          rect:(a)=>tEl("rect", a),
          line:(a)=>tEl("line", a),
          text:(x,y,t,a)=>tText(x,y,t,a),
          w: 1200,
          hTop: 140,
          hBottom: 140,
          stroke:"#000",
          strokeWidth:5,
          greyFill:"rgba(0,0,0,0.10)",
          ink:"#000",
          visibleTextColor:"rgb(106,167,255)",
          fontTop:118,
          fontBottom:118
        });
      }else{
        const parts = [{value: vis, hidden:false}, ...hiddenSums.map(v => ({value:v, hidden:true}))];
        drawBarModelPartsInGroup(gBM, 800, 980, card.total, parts, {
          rect:(a)=>tEl("rect", a),
          line:(a)=>tEl("line", a),
          text:(x,y,t,a)=>tText(x,y,t,a),
          w: 1200,
          hTop: 140,
          hBottom: 140,
          stroke:"#000",
          strokeWidth:5,
          greyFill:"rgba(0,0,0,0.10)",
          ink:"#000",
          visibleTextColor:"rgb(106,167,255)",
          fontTop:118,
          fontBottom:118
        });
      }
      targetSvg.appendChild(gBM);
    }

  }else if(["N","NPM","C","D","C9","C8"].includes(card.family)){
    const beadR = card._beadR ?? 52;
    const font = Math.round(beadR * 0.9);

    for(let i=0;i<card.hidden.length;i++){
      const cx = card._posH?.[i]?.cx ?? 820;
      // APPLIQUER OFFSET POUR C/D
      const cy = (card._posH?.[i]?.cy ?? 610) + printOffsetY;
      
      // Billes cachées : grisées (comme le mode B) pour les distinguer des billes visibles
      targetSvg.appendChild(tEl("circle",{cx, cy, r:beadR, fill:"rgba(0,0,0,0.06)", stroke:"rgba(0,0,0,0.22)","stroke-width":"5"}));
      targetSvg.appendChild(tText(cx, cy, String(card.hidden[i]), {"text-anchor":"middle","dominant-baseline":"middle","alignment-baseline":"middle","dy":"0.06em","font-size":String(font),"fill":"#000","font-weight":"900"}));
    }

    const splats = card._splats || [{cx:820, cy:610, r:220}];
    const oppP = (card.family === "NPM" && card._num && card._num.oppose && Array.isArray(card._num.oppose.flags)) ? card._num.oppose : null;
    splats.forEach((s,idx)=>{
      let f;
      if(card.family === "C" || card.family === "D"){
        f = revealAnswers ? colorsERev[idx%3] : colorsE[idx%3];
      } else {
        f = revealAnswers ? reveal : cover;
      }
      // APPLIQUER OFFSET POUR C/D
      targetSvg.appendChild(tEl("path",{d: blobPath(s.cx, s.cy + printOffsetY, s.r), fill:f, stroke:"rgba(0,0,0,0.18)","stroke-width":"5"}));
      if(card.family === "NPM" && card._num && Array.isArray(card._num.opposedTasks) && card._num.opposedTasks[idx]){
        const fs = clamp(Math.round(s.r*0.34), 28, 64);
        const y = revealAnswers ? (s.cy + printOffsetY - s.r*0.65) : (s.cy + printOffsetY);
        targetSvg.appendChild(tText(s.cx, y, "opposé", {
          "text-anchor":"middle",
          "dominant-baseline":"middle",
          "font-size": fs,
          "font-weight":"900",
          "fill":(revealAnswers ? "rgba(0,0,0,0.92)" : "rgba(255,255,255,0.95)"),
          "stroke":(revealAnswers ? "rgba(255,255,255,0.78)" : "rgba(0,0,0,0)"),
          "stroke-width":(revealAnswers ? "5" : "0"),
          "paint-order":"stroke fill"
        }));
      }
      // PATCH 6 — libellé "oppose" (impression)
      if(oppP && oppP.flags[idx]){
        const fs = clamp(Math.round(s.r*0.34), 28, 64);
        const y = revealAnswers ? (s.cy + printOffsetY - s.r*0.65) : (s.cy + printOffsetY);
        targetSvg.appendChild(tText(s.cx, y, "opposé", {
          "text-anchor":"middle",
          "dominant-baseline":"middle",
          "font-size": fs,
          "font-weight":"900",
          "fill":(revealAnswers ? "rgba(0,0,0,0.92)" : "rgba(255,255,255,0.95)"),
          "stroke":(revealAnswers ? "rgba(255,255,255,0.78)" : "rgba(0,0,0,0)"),
          "stroke-width":(revealAnswers ? "5" : "0"),
          "paint-order":"stroke fill"
        }));
      }

    });

    for(let i=0;i<card.visible.length;i++){
      const cx = card._posV?.[i]?.cx ?? (450 + i*250);
      // APPLIQUER OFFSET POUR C/D
      const cy = (card._posV?.[i]?.cy ?? 380) + printOffsetY;

      const colV = beadColorForValue(card.visible[i]);
      targetSvg.appendChild(tEl("circle",{cx, cy, r:beadR, fill:colV.fill, stroke:colV.stroke,"stroke-width":"5"}));
      targetSvg.appendChild(tText(cx, cy, String(card.visible[i]), {"text-anchor":"middle","dominant-baseline":"middle","alignment-baseline":"middle","dy":"0.06em","font-size":String(font),"fill":"#000","font-weight":"900"}));
    }
    // Schéma en barre en correction (impression) pour le mode B (N) : uniquement si on imprime la correction (révélé)
    if(card.family === "N" && revealAnswers){
      const visSum = sumArray(card.visible);

      const num = card._num || {};
      const tasks = Math.max(1, Number(num.tasks) || (Array.isArray(card._splats) ? card._splats.length : 1));

      let hiddenSums = [];
      if(Array.isArray(num.hiddenByTask) && num.hiddenByTask.length){
        hiddenSums = num.hiddenByTask.map(arr => sumArray(arr));
      }else{
        const totalHid = sumArray(card.hidden);
        const each = Math.round(totalHid / tasks);
        hiddenSums = Array.from({length: tasks}, ()=> each);
      }
      hiddenSums = hiddenSums.map(v => (Number.isFinite(v) ? v : 0));

      const gBM = tEl("g",{id:"barModelPrint"});
      if(hiddenSums.length <= 1){
        const hidSum = (hiddenSums[0] ?? sumArray(card.hidden));
        drawBarModelInGroup(gBM, 800, 980, card.total, visSum, hidSum, {
          rect:(a)=>tEl("rect", a),
          line:(a)=>tEl("line", a),
          text:(x,y,t,a)=>tText(x,y,t,a),
          w: 1200,
          hTop: 140,
          hBottom: 140,
          stroke:"#000",
          strokeWidth:5,
          greyFill:"rgba(0,0,0,0.10)",
          ink:"#000",
          visibleTextColor:"#000",
          textDy:"0.06em",
          fontTop:118,
          fontBottom:118
        });
      }else{
        const parts = [{value: visSum, hidden:false}, ...hiddenSums.map(v => ({value:v, hidden:true}))];
        drawBarModelPartsInGroup(gBM, 800, 980, card.total, parts, {
          rect:(a)=>tEl("rect", a),
          line:(a)=>tEl("line", a),
          text:(x,y,t,a)=>tText(x,y,t,a),
          w: 1200,
          hTop: 140,
          hBottom: 140,
          stroke:"#000",
          strokeWidth:5,
          greyFill:"rgba(0,0,0,0.10)",
          ink:"#000",
          visibleTextColor:"#000",
          hiddenTextColor:"#000",
          textDy:"0.06em",
          fontTop:118,
          fontBottom:118
        });
      }
      targetSvg.appendChild(gBM);
    }


  }else{
    const beadR=95;
    for(let i=0;i<card.hidden.length;i++){
      const cx = card._posH?.[i]?.cx ?? 820;
      const cy = card._posH?.[i]?.cy ?? 610;
      targetSvg.appendChild(tEl("circle",{cx, cy, r:beadR, fill:"rgba(0,0,0,0.04)", stroke:"rgba(0,0,0,0.25)","stroke-width":"5"}));
      targetSvg.appendChild(tText(cx, cy, String(card.hidden[i]), {"text-anchor":"middle","dominant-baseline":"middle","alignment-baseline":"middle","dy":"0.06em","font-size":"64","fill":"#000","font-weight":"900"}));
    }
    const s0 = card._splat || {cx:820, cy:610, r:220};
    targetSvg.appendChild(tEl("path",{d: blobPath(s0.cx,s0.cy,s0.r), fill:(revealAnswers?reveal:cover), stroke:"rgba(0,0,0,0.18)","stroke-width":"5"}));
    for(let i=0;i<card.visible.length;i++){
      const cx = card._posV?.[i]?.cx ?? (450 + i*250);
      const cy = card._posV?.[i]?.cy ?? 380;
      targetSvg.appendChild(tEl("circle",{cx, cy, r:beadR, fill:"rgba(0,0,0,0.04)", stroke:"rgba(0,0,0,0.25)","stroke-width":"5"}));
      targetSvg.appendChild(tText(cx, cy, String(card.visible[i]), {"text-anchor":"middle","dominant-baseline":"middle","alignment-baseline":"middle","dy":"0.06em","font-size":"64","fill":"#000","font-weight":"900"}));
    }
  }
}

function printSheet(){
  if(cards.length===0) return;
  const showAnswers = !!document.getElementById("printAnswers").checked;
  const printArea = document.getElementById("printArea");
  printArea.innerHTML = "";
  const perSheet = 4; 
  const sheets = Math.ceil(cards.length / perSheet);
  for(let s=0;s<sheets;s++){
    const sheet = document.createElement("div");
    sheet.className = "sheet";
    const grid = document.createElement("div");
    grid.className = "grid";
    for(let i=0;i<perSheet;i++){
      const k = s*perSheet + i;
      if(k >= cards.length) break;
      const holder = document.createElement("div");
      holder.className = "pCard";
      const sv = document.createElementNS("http://www.w3.org/2000/svg","svg");
      sv.setAttribute("viewBox","0 0 1600 2200");
      sv.style.width = "100%";
      renderCardIntoSvg(sv, cards[k], showAnswers);
      holder.appendChild(sv);
      grid.appendChild(holder);
    }
    sheet.appendChild(grid);
    printArea.appendChild(sheet);
  }
  window.print();
}

let cards = [];
let idx = 0;
let revealed = false;
const counterEl = document.getElementById("counter");
const fsHost = document.getElementById("fsHost");

function updateUI(){
  counterEl.textContent = cards.length ? `Carte ${idx+1} / ${cards.length}` : "0 carte";
  document.getElementById("btnPrev").disabled = (cards.length===0 || (idx===0 && !revealed));
  document.getElementById("btnNext").disabled = (cards.length===0 || (idx===cards.length-1 && revealed));
  if(cards.length===0){ renderEmpty(); }
  else { renderCard(cards[idx], revealed); }
}
function renderEmpty(){
  clearSvg();
  svg.appendChild(el("rect",{x:0,y:0,width:1600,height:1000,rx:26,fill:"rgba(255,255,255,0.03)"}));
  svg.appendChild(text(800, 520, "Génère une série pour commencer", {"text-anchor":"middle","font-size":"54","fill":"rgba(0,0,0,0.35)"}));
}

function generate(){
  const act = activityEl.value;
  const n = clamp(numberOr(countEl.value, 30), 1, 300);

  if(act==="U") syncUnitTotalBounds();

  const seedValue = getSeedForCurrentMode();
  const rng = makeRng(seedValue);

  const out = [];
  for(let i=0;i<n;i++){
    let c;
    if(act==="U"){
      c = genUnits(rng);
    }else if(act==="N"){
      c = genNumbered(rng);
    }else if(act==="NPM"){
      c = genNumberedSigned(rng);
    }else if(act==="EQ"){
      c = genEquation(rng);
    }else if(act==="EQPM"){
      c = genEquationSigned(rng);
    }else if(act==="C"){
      c = genInvestigate(rng);
    }else if(act==="D"){
      c = genSystem(rng);
    }else if(act==="C9"){
      c = genOp9(rng);
    }else if(act==="C8"){
      c = genOp8(rng);
    }else{
      const diff = clamp(numberOr(diffEl.value, 2), 1, 3);
      c = genMinusMix(rng, diff);
    }
    assignPositions(c, rng);
    out.push(c);
  }

  cards = out;
  idx = 0;
  revealed = false;
  updateUI();
}

function shuffleCards(){
  if(cards.length<=1) return;
  const seedValue = getSeedForCurrentMode();
  const rng = makeRng(seedValue);
  shuffleInPlace(cards, rng);
  idx = 0;
  revealed = false;
  updateUI();
}

async function toggleFullscreen(){
  try{
    if(!document.fullscreenElement) await fsHost.requestFullscreen();
    else await document.exitFullscreen();
  }catch(e){ console.warn("Fullscreen non dispo:", e); }
}

document.getElementById("btnGen").addEventListener("click", generate);
document.getElementById("btnClear").addEventListener("click", ()=>{ cards=[]; idx=0; revealed=false; updateUI(); });
document.getElementById("btnPrev").addEventListener("click", ()=>{
  if(cards.length===0) return;
  if(revealed){ revealed = false; updateUI(); return; }
  if(idx>0){ idx--; revealed=false; updateUI(); }
});
document.getElementById("btnNext").addEventListener("click", ()=>{
  if(cards.length===0) return;
  if(!revealed){ revealed = true; updateUI(); return; }
  if(idx<cards.length-1){ idx++; revealed=false; updateUI(); }
});
document.getElementById("btnPrint").addEventListener("click", printSheet);
document.getElementById("btnFullscreen").addEventListener("click", toggleFullscreen);
window.addEventListener("keydown",(e)=>{
  // If the activity <select> has focus, ArrowLeft/ArrowRight would normally change the selected mode.
  // We want ArrowLeft/ArrowRight to always navigate cards; so we blur the select and prevent default.
  const _ae = document.activeElement;
  if((_ae && _ae.id==="activity") && (e.key==="ArrowLeft" || e.key==="ArrowRight")){
    e.preventDefault();
    try{ _ae.blur(); }catch(_e){}
    const _ms = document.getElementById("mainSvg");
    if(_ms && typeof _ms.focus==="function"){ _ms.focus(); }
  }
  if(e.key==="ArrowLeft"){
    if(cards.length===0) return;
    if(revealed){ revealed=false; updateUI(); return; }
    if(idx>0){ idx--; revealed=false; updateUI(); }
  }
  if(e.key==="ArrowRight"){
    if(cards.length===0) return;
    if(!revealed){ revealed=true; updateUI(); return; }
    if(idx<cards.length-1){ idx++; revealed=false; updateUI(); }
  }
  if(e.key===" "){
    e.preventDefault();
    if(cards.length){ revealed=!revealed; updateUI(); }
  }
  if(e.key==="f" || e.key==="F"){ toggleFullscreen(); }
});
syncSettingsUI();
generate();
</script>
</body>
</html>
