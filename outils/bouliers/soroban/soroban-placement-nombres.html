<!doctype html>
<html lang="fr">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Soroban interactif â€” EntraÃ®nement (vÃ©rification auto)</title>
<style>
  :root{
    --bg:#ffffff;
    --rod:#111111;           /* barres haut/bas + tiges */
    --midbar:#cfcfcf;        /* barre centrale gris clair */
    --bead-stroke:#111111;   /* contour perles */
    --c0:#ffffff;            /* blanc */
    --c1:#c7c7c7;            /* gris clair un peu plus foncÃ© */
    --c2:#4f4f4f;            /* gris foncÃ© soutenu */
    --ok:#13b113;            /* vert validation */
    --err:#d33;              /* rouge erreur */
  }
  html,body{margin:0;height:100%;background:var(--bg);color:#111;font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
  .wrap{max-width:1100px;margin:24px auto;padding:0 16px}
  h1{font-size:20px;margin:0 0 12px}
  .panel{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin-bottom:12px}
  input[type="number"]{width:84px}
  input,button{font-size:16px;padding:9px 12px;border-radius:10px;border:1px solid #ccc}
  button{background:#111;color:#fff;cursor:pointer}
  button.secondary{background:#444}
  button.ghost{background:#fff;color:#111;border:1px solid #bbb}
  button:hover{filter:brightness(1.08)}
  #holder{user-select:none;touch-action:manipulation;display:inline-block;border-radius:12px;box-shadow:0 8px 24px rgba(0,0,0,.08)}
  .row{display:flex;align-items:center;gap:12px;flex-wrap:wrap}
  .target{font:600 18px ui-monospace,SFMono-Regular,Menlo,monospace}
  .status{font-size:14px;min-height:1.2em}
  .status.ok{color:var(--ok)} .status.err{color:var(--err)}
</style>

<div class="wrap">
  <h1>Soroban interactif â€” entraÃ®nement</h1>

  <div class="panel">
    <label>Chiffres : <input id="digits" type="number" min="1" max="15" value="5"></label>
    <label>Exercices : <input id="count" type="number" min="1" max="200" value="10"></label>
    <label>Zoom : <input id="zoom" type="range" min="100" max="260" value="180" step="1"></label>
    <button id="start">DÃ©marrer</button>
    <button id="reset" class="ghost">ZÃ©ro</button>
    <button id="save"  class="secondary">TÃ©lÃ©charger PNG</button>
    <button id="copy"  class="secondary">Copier lâ€™image</button>
  </div>

  <div class="row" style="margin-bottom:6px">
    <div class="target">Cible : <span id="goal">â€”</span> <span id="progress" style="opacity:.75"></span></div>
    <div id="status" class="status"></div>
  </div>

  <div id="holder" aria-label="Soroban"></div>

  <div style="margin-top:10px;font-size:12px;opacity:.8">
    Gestes : unaires = clic (la 4áµ‰ â‡’ 4 actives ; Ã  3 actives, clic 1Ê³áµ‰ â‡’ 0 ; clic 2áµ‰ â‡’ 2, etc.).  
    Quinaire = clic (active/dÃ©sactive). Couleurs : Shift/Ctrl/Alt + clic (ou appui long) â†’ blanc â†’ gris â†’ gris foncÃ©.  
    Validation : la vÃ©rification est automatique et passe au suivant dÃ¨s que câ€™est correct.
  </div>
</div>

<script>
(function(){
  const NS = "http://www.w3.org/2000/svg";
  const $  = id => document.getElementById(id);
  const holder = $('holder');

  let state = [];           // par colonne { upper:bool, lowerCount:0..4, _cU,_cL0..3 }
  let session = null;       // {digits,count,nums,idx,done}
  const beadColors = [css('--c0'), css('--c1'), css('--c2')];

  function css(v){ return getComputedStyle(document.documentElement).getPropertyValue(v).trim(); }

  /* =========== Perle biconique ============ */
  function beadBiconic(svg, cx, cy, w, h, stroke, fill, dataset){
    const g = document.createElementNS(NS,'g');
    if (dataset) Object.entries(dataset).forEach(([k,v]) => g.dataset[k]=v);
    g.style.cursor = 'pointer';

    const hw=w/2, hh=h/2;
    const poly = document.createElementNS(NS,'polygon');
    poly.setAttribute('points', [[cx,cy-hh],[cx+hw,cy],[cx,cy+hh],[cx-hw,cy]].map(p=>p.join(',')).join(' '));
    poly.setAttribute('fill', fill);
    poly.setAttribute('stroke', stroke);
    poly.setAttribute('stroke-width', Math.max(1, w*0.07));
    poly.setAttribute('stroke-linejoin','round');

    const mid = document.createElementNS(NS,'line');
    mid.setAttribute('x1', cx-hw*0.6); mid.setAttribute('y1', cy);
    mid.setAttribute('x2', cx+hw*0.6); mid.setAttribute('y2', cy);
    mid.setAttribute('stroke', stroke);
    mid.setAttribute('stroke-width', Math.max(1, w*0.05));
    mid.setAttribute('stroke-linecap','round'); mid.setAttribute('opacity','0.6');

    g.appendChild(poly); g.appendChild(mid);
    svg.appendChild(g);

    // Interactions : clic = logique soroban; Shift/Ctrl/Alt ou appui long = cycle couleur
    let lpTimer=null, ignoreNextClick=false;
    g.addEventListener('pointerdown', () => { lpTimer=setTimeout(()=>{ cycleColor(g); ignoreNextClick=true; }, 550); });
    const stopLP=()=>{ if(lpTimer){clearTimeout(lpTimer); lpTimer=null;} };
    g.addEventListener('pointerup', stopLP);
    g.addEventListener('pointerleave', stopLP);
    g.addEventListener('click', (e) => {
      if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey){ cycleColor(g); return; }
      if (ignoreNextClick){ ignoreNextClick=false; return; }
      toggleActive(g);
    });
    return g;
  }

  function cycleColor(g){
    const i = +g.dataset.col;
    const key = (g.dataset.type==='upper') ? '_cU' : `_cL${g.dataset.id}`;
    state[i][key] = ((state[i][key] ?? 0) + 1) % beadColors.length;
    g.querySelector('polygon').setAttribute('fill', beadColors[state[i][key]]);
  }

  /* =========== Logique dâ€™activation (fidÃ¨le Ã  tes consignes) ============ */
  function toggleActive(g){
    const i = +g.dataset.col;
    if (g.dataset.type==='upper'){
      state[i].upper = !state[i].upper;
    } else {
      const id = +g.dataset.id;           // 0 prÃ¨s de la barre centrale â€¦ 3 en bas
      let n  = state[i].lowerCount|0;     // 0..4
      if (id === 0){
        // RÃ¨gle spÃ©ciale souhaitÃ©e : si au moins 1 active et on clique la 1Ê³áµ‰ â‡’ 0 ; sinon â‡’ 1
        state[i].lowerCount = (n > 0) ? 0 : 1;
      } else {
        // Sinon, le nombre dâ€™actives devient id+1 (ex: clic 3áµ‰ â‡’ 3 actives)
        state[i].lowerCount = id + 1;
      }
    }
    redrawBeads();
    autoCheck();
  }

  /* =========== Construction du soroban ============ */
  function buildSoroban(cols, Z){
    cols = Math.max(1, Math.min(25, cols|0));
    state = Array.from({length: cols}, () => ({
      upper:false, lowerCount:0,
      _cU:0, _cL0:0, _cL1:0, _cL2:0, _cL3:0
    }));

    /* --- GÃ©omÃ©trie (celle qui marche chez toi) --- */
    const padX = Z*0.70, padY = Z*0.52;
    const rodGap = Z*0.56;
    const rodW   = Math.max(4, Z*0.05);

    const barH   = Math.max(8, Z*0.08);
    const beadW  = Math.max(22, Z*0.33);
    const beadH  = Math.max(18, Z*0.25);

    const TIP_GAP = Math.max(1.0, beadH*0.02);     // Ã©vite lâ€™effet â€œbouleâ€
    const step    = beadH + TIP_GAP;

    const width  = Math.round(padX*2 + rodGap*(cols-1));
    const height = Math.round(padY*2 + Z*2.10);

    // barres
    const topY = padY;
    const barY = padY + Z*0.82;            // centrale
    const bottomY = height - padY;

    // *** Coefficient validÃ© : rapproche la barre SUP de la centrale ***
    const yTopBar = topY - barH*0.55 + Z*0.308;
    const yMidBar = barY - barH/2;
    const yBotBar = bottomY - barH*0.08;

    // jeux aux barres (collage visuel haut/bas)
    const CLEAR_TOP    = Math.max(0.2, beadH*0.008);
    const CLEAR_BOTTOM = Math.max(0.8, beadH*0.018);

    // distance au repos â†” barre centrale (mouvement perceptible)
    const GAP_TOP    = Math.max(3, beadH*0.22);
    const GAP_BOTTOM = Math.max(3, beadH*0.22);

    const TOUCH = beadH/2;

    const svg = document.createElementNS(NS,'svg');
    svg.setAttribute('xmlns', NS);
    svg.setAttribute('width', width);
    svg.setAttribute('height', height);
    svg.setAttribute('viewBox', `0 0 ${width} ${height}`);

    const bg = document.createElementNS(NS,'rect');
    bg.setAttribute('x',0); bg.setAttribute('y',0);
    bg.setAttribute('width',width); bg.setAttribute('height',height);
    bg.setAttribute('fill','#ffffff'); svg.appendChild(bg);

    const barRect = (y, color) => {
      const r = document.createElementNS(NS,'rect');
      r.setAttribute('x', padX*0.16); r.setAttribute('y', y);
      r.setAttribute('width', width - padX*0.32); r.setAttribute('height', barH);
      r.setAttribute('fill', color); return r;
    };
    svg.appendChild(barRect(yTopBar, css('--rod')));
    svg.appendChild(barRect(yMidBar, css('--midbar')));
    svg.appendChild(barRect(yBotBar, css('--rod')));

    // tiges
    const yRodTop = yTopBar + barH + 2;
    const yRodBot = yBotBar - 2;
    const startX = padX + rodGap*(cols-1);   // unitÃ©s Ã  droite
    const rodsX = [];
    for (let i=0;i<cols;i++){
      const x = startX - i*rodGap; rodsX.push(x);
      const rod = document.createElementNS(NS,'line');
      rod.setAttribute('x1',x); rod.setAttribute('x2',x);
      rod.setAttribute('y1',yRodTop); rod.setAttribute('y2',yRodBot);
      rod.setAttribute('stroke',css('--rod')); rod.setAttribute('stroke-width',rodW);
      rod.setAttribute('stroke-linecap','round');
      svg.appendChild(rod);
    }

    // point noir des unitÃ©s (au milieu de la barre centrale)
    const dot = document.createElementNS(NS,'circle');
    dot.setAttribute('cx', rodsX[0]);
    dot.setAttribute('cy', yMidBar + barH/2);
    dot.setAttribute('r', Math.max(1.6, Z*0.035));
    dot.setAttribute('fill', '#000');
    svg.appendChild(dot);

    // perles
    for (let i=0;i<cols;i++){
      const x = startX - i*rodGap;
      beadBiconic(svg, x, 0, beadW, beadH, css('--bead-stroke'), beadColors[0], {col:i, type:'upper'});
      for (let id=0; id<4; id++){
        beadBiconic(svg, x, 0, beadW, beadH, css('--bead-stroke'), beadColors[0], {col:i, type:'lower', id});
      }
    }

    svg._geom = {beadW,beadH,step,cols,startX,rodGap,barH,
                 yTopBar,yMidBar,yBotBar,CLEAR_TOP,CLEAR_BOTTOM,
                 GAP_TOP,GAP_BOTTOM,TOUCH};
    holder.innerHTML = ""; holder.appendChild(svg);
    redrawBeads();
  }

  /* =========== Placement ============ */
  function redrawBeads(){
    const svg = holder.querySelector('svg'); if(!svg) return;
    const {beadW, beadH, step, cols, startX, rodGap, barH,
           yTopBar, yMidBar, yBotBar, CLEAR_TOP, CLEAR_BOTTOM,
           GAP_TOP, GAP_BOTTOM, TOUCH} = svg._geom;

    const beads = Array.from(svg.querySelectorAll('g'));

    for (let i=0;i<cols;i++){
      const x = startX - i*rodGap;

      // Quinaire (haut)
      const yUpperAct  = (yMidBar) - TOUCH;
      const yUpperRest = (yTopBar + barH) + CLEAR_TOP + beadH/2;
      const gUp = beads.find(g => g.dataset.type==='upper' && +g.dataset.col===i);
      setGeom(gUp, x, state[i].upper ? yUpperAct : yUpperRest, beadW, beadH);
      setColor(gUp, state[i]._cU ?? 0);

      // Unaires (bas)
      const n = state[i].lowerCount|0;
      const yActStart  = (yMidBar + barH) + TOUCH; // actives vers le bas
      const yRestTop   = Math.max(
        (yBotBar - CLEAR_BOTTOM) - beadH/2,        // quasi collÃ© bas
        (yMidBar + barH) + TOUCH + GAP_BOTTOM
      );
      for (let id=0; id<4; id++){
        const g = beads.find(g => g.dataset.type==='lower' && +g.dataset.col===i && +g.dataset.id===id);
        const y = (id < n) ? (yActStart + id*step) : (yRestTop - (3-id)*step);
        setGeom(g, x, y, beadW, beadH);
        setColor(g, state[i][`_cL${id}`] ?? 0);
      }
    }

    function setGeom(g, cx, cy, w, h){
      const poly = g.querySelector('polygon');
      const mid  = g.querySelector('line');
      const hw=w/2, hh=h/2;
      poly.setAttribute('points', [[cx,cy-hh],[cx+hw,cy],[cx,cy+hh],[cx-hw,cy]].map(p=>p.join(',')).join(' '));
      mid.setAttribute('x1', cx-hw*0.6); mid.setAttribute('y1', cy);
      mid.setAttribute('x2', cx+hw*0.6); mid.setAttribute('y2', cy);
    }
    function setColor(g, idx){
      g.querySelector('polygon').setAttribute('fill', beadColors[idx]);
    }
  }

  /* =========== Lecture de la valeur du soroban ============ */
  function readValue(){
    // unitÃ©s Ã  droite (col 0)
    let cols = state.length;
    let digits = [];
    for (let i=cols-1; i>=0; i--){ // colonne la plus Ã  gauche en premier (MSD)
      const d = (state[i].upper ? 5 : 0) + (state[i].lowerCount|0);
      digits.push(d);
    }
    return digits.join('');
  }

  /* =========== EntraÃ®nement ============ */
  function startSession(){
    const digits = clamp(+$('digits').value, 1, 15);
    const count  = clamp(+$('count').value, 1, 200);
    $('digits').value = digits; $('count').value = count;

    // GÃ©nÃ¨re des nombres Ã  EXACTEMENT "digits" chiffres (sans zÃ©ros en tÃªte sauf digits=1 â‡’ 0..9)
    const min = (digits === 1) ? 0 : Math.pow(10, digits-1);
    const max = Math.pow(10, digits) - 1;
    const nums = Array.from({length: count}, () => randInt(min, max));

    session = {digits, count, nums, idx:0, done:0};
    buildSoroban(digits, +$('zoom').value);
    updateTarget();
    setStatus('');
  }

  function updateTarget(){
    if (!session) return;
    const goalStr = String(session.nums[session.idx]).padStart(session.digits, '0');
    $('goal').textContent = goalStr;
    $('progress').textContent = `(${session.idx+1}/${session.count})`;
  }

  function autoCheck(){
    if (!session) return;
    const goalStr = String(session.nums[session.idx]).padStart(session.digits, '0');
    const cur = readValue().padStart(session.digits, '0');
    if (cur === goalStr){
      setStatus('Correct âœ…', 'ok');
      // passe au suivant aprÃ¨s un petit dÃ©lai
      setTimeout(() => {
        session.idx++;
        if (session.idx >= session.count){
          setStatus(`TerminÃ© ! Score ${session.count}/${session.count} ðŸŽ‰`, 'ok');
          session = null; // fin de sÃ©ance
        }else{
          // rÃ©initialise le boulier et nouvelle cible
          zeroSoroban();
          updateTarget();
          setStatus('');
        }
      }, 550);
    } else {
      // Indice non bloquant (affichÃ© seulement si quelque chose est posÃ©)
      if (cur.replace(/^0+/, '').length){
        setStatus('Encoreâ€¦', 'err');
      } else {
        setStatus('');
      }
    }
  }

  function zeroSoroban(){
    if (!state.length) return;
    for (const c of state){ c.upper=false; c.lowerCount=0; }
    redrawBeads();
  }

  /* =========== Divers utils ============ */
  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
  function randInt(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }
  function setStatus(t, cls){
    const s = $('status'); s.textContent = t||'';
    s.className = 'status' + (cls ? (' '+cls) : '');
  }

  /* =========== Export PNG / Copier â€” HD recadrÃ© ============ */
  async function svgToCanvas(svg, scale = 3, tight = true, padding = 16){
    const xml = new XMLSerializer().serializeToString(svg);
    const img = new Image();
    const url = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(xml)));
    await new Promise(res => { img.onload = res; img.src = url; });

    let sx = 0, sy = 0, sw, sh;
    if (svg.viewBox && svg.viewBox.baseVal && svg.viewBox.baseVal.width) {
      const vb = svg.viewBox.baseVal; sw = vb.width; sh = vb.height; sx = vb.x; sy = vb.y;
    } else { sw = svg.width.baseVal.value; sh = svg.height.baseVal.value; }

    if (tight && svg.getBBox) {
      const bb = svg.getBBox();
      sx = bb.x - padding; sy = bb.y - padding;
      sw = bb.width + padding*2; sh = bb.height + padding*2;
    }

    const canvas = document.createElement('canvas');
    canvas.width  = Math.max(1, Math.round(sw * scale));
    canvas.height = Math.max(1, Math.round(sh * scale));
    const cx = canvas.getContext('2d');
    cx.scale(scale, scale);
    cx.fillStyle = '#ffffff'; cx.fillRect(0,0,sw,sh);
    cx.drawImage(img, -sx, -sy);
    return canvas;
  }

  /* =========== Ã‰vÃ©nements UI ============ */
  $('start').addEventListener('click', startSession);
  $('reset').addEventListener('click', () => { zeroSoroban(); setStatus(''); autoCheck(); });
  $('zoom').addEventListener('input', () => {
    const d = session ? session.digits : +$('digits').value || 5;
    buildSoroban(d, +$('zoom').value);
    autoCheck();
  });

  $('save').addEventListener('click', async () => {
    const svg = holder.querySelector('svg'); if(!svg) return;
    const canvas = await svgToCanvas(svg, 3, true, 16);
    const a = document.createElement('a');
    a.href = canvas.toDataURL('image/png');
    a.download = `soroban_${state.length}cols.png`;
    a.click();
  });

  $('copy').addEventListener('click', async () => {
    const svg = holder.querySelector('svg'); if(!svg) return;
    try{
      const canvas = await svgToCanvas(svg, 3, true, 16);
      const blob = await new Promise(r => canvas.toBlob(r, 'image/png'));
      await navigator.clipboard.write([new ClipboardItem({'image/png': blob})]);
      alert('Image HD copiÃ©e dans le presse-papiers âœ…');
    }catch(err){
      alert("Impossible de copier (navigateur/permissions). Utilise Â« TÃ©lÃ©charger PNG Â».");
    }
  });

  // Premier rendu (avant sÃ©ance)
  buildSoroban(+$('digits').value, +$('zoom').value);
})();
</script>
</html>
