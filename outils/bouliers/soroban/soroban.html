<!doctype html>
<html lang="fr">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Soroban interactif — zoom étendu + barre haute 0.30</title>
<style>
  :root{
    --bg:#ffffff;
    --rod:#111111;           /* barres haut/bas + tiges */
    --midbar:#cfcfcf;        /* barre centrale gris clair */
    --bead-stroke:#111111;   /* contour perles */
    --c0:#ffffff;            /* blanc */
    --c1:#c7c7c7;            /* gris clair un peu plus foncé */
    --c2:#4f4f4f;            /* gris foncé soutenu */
  }
  html,body{margin:0;height:100%;background:var(--bg);color:#111;font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
  .wrap{max-width:1100px;margin:24px auto;padding:0 16px}
  h1{font-size:20px;margin:0 0 12px}
  .panel{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin-bottom:14px}
  input[type="number"]{width:90px}
  input,button{font-size:16px;padding:10px 12px;border-radius:10px;border:1px solid #ccc}
  button{background:#111;color:#fff;cursor:pointer}
  button.secondary{background:#444}
  button:hover{filter:brightness(1.08)}
  #holder{user-select:none;touch-action:manipulation;display:inline-block;border-radius:12px;box-shadow:0 8px 24px rgba(0,0,0,.08)}
  .note{font-size:12px;opacity:.8;margin-top:8px}
</style>

<div class="wrap">
  <h1>Soroban interactif (style biconique)</h1>
  <div class="panel">
    <label>Colonnes : <input id="cols" type="number" min="1" max="25" value="6"></label>
    <!-- Nouvelle plage : min=100, max=260 ; 180 (ancien max) = milieu -->
    <label>Zoom : <input id="zoom" type="range" min="100" max="260" value="180" step="1"></label>
    <button id="build">Construire</button>
    <button id="save"  class="secondary">Télécharger PNG (HD)</button>
    <button id="copy"  class="secondary">Copier l’image (HD)</button>
  </div>
  <div id="holder" aria-label="Soroban"></div>
  <div class="note">
    Unaires : clic sur la 4ᵉ ⇒ 4 actives ; à 3 actives, clic 1ʳᵉ ⇒ 0 ; clic 2ᵉ ⇒ 2, etc.  
    Couleurs : Shift/Ctrl/Alt + clic (ou appui long mobile) → blanc → gris → gris foncé.  
    Barre centrale gris clair + petit point noir sur la colonne des unités.
  </div>
</div>

<script>
(function(){
  const NS = "http://www.w3.org/2000/svg";
  const $  = id => document.getElementById(id);
  const holder = $('holder');

  let state = []; // par colonne
  const beadColors = [css('--c0'), css('--c1'), css('--c2')];
  function css(v){ return getComputedStyle(document.documentElement).getPropertyValue(v).trim(); }

  /* ===== Perle biconique ===== */
  function beadBiconic(svg, cx, cy, w, h, stroke, fill, dataset){
    const g = document.createElementNS(NS,'g');
    if (dataset) Object.entries(dataset).forEach(([k,v]) => g.dataset[k]=v);
    g.style.cursor = 'pointer';

    const hw=w/2, hh=h/2;
    const poly = document.createElementNS(NS,'polygon');
    poly.setAttribute('points', [[cx,cy-hh],[cx+hw,cy],[cx,cy+hh],[cx-hw,cy]].map(p=>p.join(',')).join(' '));
    poly.setAttribute('fill', fill);
    poly.setAttribute('stroke', stroke);
    poly.setAttribute('stroke-width', Math.max(1, w*0.07));
    poly.setAttribute('stroke-linejoin','round');

    const mid = document.createElementNS(NS,'line');
    mid.setAttribute('x1', cx-hw*0.6); mid.setAttribute('y1', cy);
    mid.setAttribute('x2', cx+hw*0.6); mid.setAttribute('y2', cy);
    mid.setAttribute('stroke', stroke);
    mid.setAttribute('stroke-width', Math.max(1, w*0.05));
    mid.setAttribute('stroke-linecap','round'); mid.setAttribute('opacity','0.6');

    g.appendChild(poly); g.appendChild(mid);
    svg.appendChild(g);

    // Interactions : click = logique soroban ; Shift/Ctrl/Alt OU appui long = cycle couleur
    let lpTimer=null, ignoreNextClick=false;
    g.addEventListener('pointerdown', () => { lpTimer=setTimeout(()=>{ cycleColor(g); ignoreNextClick=true; }, 550); });
    const stopLP=()=>{ if(lpTimer){clearTimeout(lpTimer); lpTimer=null;} };
    g.addEventListener('pointerup', stopLP);
    g.addEventListener('pointerleave', stopLP);
    g.addEventListener('click', (e) => {
      if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey){ cycleColor(g); return; }
      if (ignoreNextClick){ ignoreNextClick=false; return; }
      toggleActive(g);
    });
    return g;
  }

  function cycleColor(g){
    const i = +g.dataset.col;
    const key = (g.dataset.type==='upper') ? '_cU' : `_cL${g.dataset.id}`;
    state[i][key] = ((state[i][key] ?? 0) + 1) % beadColors.length;
    g.querySelector('polygon').setAttribute('fill', beadColors[state[i][key]]);
  }

  /* ===== Logique d’activation ===== */
  function toggleActive(g){
    const i = +g.dataset.col;
    if (g.dataset.type==='upper'){
      state[i].upper = !state[i].upper;
    } else {
      const id = +g.dataset.id;         // 0 proche de la barre centrale … 3 en bas
      const n  = state[i].lowerCount|0; // 0..4
      state[i].lowerCount = (id < n) ? id : (id + 1);
    }
    redrawBeads();
  }

  /* ===== Construction ===== */
  function buildSoroban(cols, Z){
    cols = Math.max(1, Math.min(25, cols|0));
    state = Array.from({length: cols}, () => ({
      upper:false, lowerCount:0,
      _cU:0, _cL0:0, _cL1:0, _cL2:0, _cL3:0
    }));

    /* --- Géométrie (resserrée) --- */
    const padX = Z*0.70, padY = Z*0.52;
    const rodGap = Z*0.56;
    const rodW   = Math.max(4, Z*0.05);

    const barH   = Math.max(8, Z*0.08);
    const beadW  = Math.max(22, Z*0.33);
    const beadH  = Math.max(18, Z*0.25);

    const TIP_GAP = Math.max(1.0, beadH*0.02);     // filet d’air pour éviter la “boule”
    const step    = beadH + TIP_GAP;

    const width  = Math.round(padX*2 + rodGap*(cols-1));
    const height = Math.round(padY*2 + Z*2.10);

    // barres
    const topY = padY;
    const barY = padY + Z*0.82;      // centrale
    const bottomY = height - padY;

    // *** Coef demandé : rapproche la barre SUP de la centrale ***
    const yTopBar = topY - barH*0.55 + Z*0.308;
    const yMidBar = barY - barH/2;
    const yBotBar = bottomY - barH*0.08;

    // jeux aux barres (inchangés)
    const CLEAR_TOP    = Math.max(0.2, beadH*0.008);  // quinaire quasi-collée en haut
    const CLEAR_BOTTOM = Math.max(0.8, beadH*0.018);  // unaires quasi-collées en bas

    // distance au repos ↔ barre centrale (mouvement perceptible)
    const GAP_TOP    = Math.max(3, beadH*0.22);
    const GAP_BOTTOM = Math.max(3, beadH*0.22);

    const TOUCH = beadH/2;

    const svg = document.createElementNS(NS,'svg');
    svg.setAttribute('xmlns', NS);
    svg.setAttribute('width', width);
    svg.setAttribute('height', height);
    svg.setAttribute('viewBox', `0 0 ${width} ${height}`);

    const bg = document.createElementNS(NS,'rect');
    bg.setAttribute('x',0); bg.setAttribute('y',0);
    bg.setAttribute('width',width); bg.setAttribute('height',height);
    bg.setAttribute('fill','#ffffff'); svg.appendChild(bg);

    const barRect = (y, color) => {
      const r = document.createElementNS(NS,'rect');
      r.setAttribute('x', padX*0.16); r.setAttribute('y', y);
      r.setAttribute('width', width - padX*0.32); r.setAttribute('height', barH);
      r.setAttribute('fill', color); return r;
    };
    svg.appendChild(barRect(yTopBar, css('--rod')));
    svg.appendChild(barRect(yMidBar, css('--midbar')));
    svg.appendChild(barRect(yBotBar, css('--rod')));

    // tiges
    const yRodTop = yTopBar + barH + 2;
    const yRodBot = yBotBar - 2;
    const startX = padX + rodGap*(cols-1);
    const rodsX = [];
    for (let i=0;i<cols;i++){
      const x = startX - i*rodGap; rodsX.push(x);
      const rod = document.createElementNS(NS,'line');
      rod.setAttribute('x1',x); rod.setAttribute('x2',x);
      rod.setAttribute('y1',yRodTop); rod.setAttribute('y2',yRodBot);
      rod.setAttribute('stroke',css('--rod')); rod.setAttribute('stroke-width',rodW);
      rod.setAttribute('stroke-linecap','round');
      svg.appendChild(rod);
    }

    // point noir des unités
    const dot = document.createElementNS(NS,'circle');
    dot.setAttribute('cx', rodsX[0]);
    dot.setAttribute('cy', yMidBar + barH/2);
    dot.setAttribute('r', Math.max(1.6, Z*0.035));
    dot.setAttribute('fill', '#000');
    svg.appendChild(dot);

    // perles
    for (let i=0;i<cols;i++){
      const x = startX - i*rodGap;
      beadBiconic(svg, x, 0, beadW, beadH, css('--bead-stroke'), beadColors[0], {col:i, type:'upper'});
      for (let id=0; id<4; id++){
        beadBiconic(svg, x, 0, beadW, beadH, css('--bead-stroke'), beadColors[0], {col:i, type:'lower', id});
      }
    }

    svg._geom = {beadW,beadH,step,cols,startX,rodGap,barH,
                 yTopBar,yMidBar,yBotBar,CLEAR_TOP,CLEAR_BOTTOM,
                 GAP_TOP,GAP_BOTTOM,TOUCH};
    holder.innerHTML = ""; holder.appendChild(svg);
    redrawBeads();
  }

  /* ===== Placement ===== */
  function redrawBeads(){
    const svg = holder.querySelector('svg'); if(!svg) return;
    const {beadW, beadH, step, cols, startX, rodGap, barH,
           yTopBar, yMidBar, yBotBar, CLEAR_TOP, CLEAR_BOTTOM,
           GAP_TOP, GAP_BOTTOM, TOUCH} = svg._geom;

    const beads = Array.from(svg.querySelectorAll('g'));

    for (let i=0;i<cols;i++){
      const x = startX - i*rodGap;

      // Quinaire : active touche la centrale, repos quasi-collée sous la barre haute
      const yUpperAct  = (yMidBar) - TOUCH;
      const yUpperRest = (yTopBar + barH) + CLEAR_TOP + beadH/2;

      const gUp = beads.find(g => g.dataset.type==='upper' && +g.dataset.col===i);
      setGeom(gUp, x, state[i].upper ? yUpperAct : yUpperRest, beadW, beadH);
      setColor(gUp, state[i]._cU ?? 0);

      // Bas : inchangé
      const n = state[i].lowerCount|0;
      const yActStart  = (yMidBar + barH) + TOUCH; // actives vers le bas
      const yRestTop   = Math.max(
        (yBotBar - CLEAR_BOTTOM) - beadH/2,        // quasi collé bas
        (yMidBar + barH) + TOUCH + GAP_BOTTOM
      );

      for (let id=0; id<4; id++){
        const g = beads.find(g => g.dataset.type==='lower' && +g.dataset.col===i && +g.dataset.id===id);
        const y = (id < n) ? (yActStart + id*step) : (yRestTop - (3-id)*step);
        setGeom(g, x, y, beadW, beadH);
        setColor(g, state[i][`_cL${id}`] ?? 0);
      }
    }

    function setGeom(g, cx, cy, w, h){
      const poly = g.querySelector('polygon');
      const mid  = g.querySelector('line');
      const hw=w/2, hh=h/2;
      poly.setAttribute('points', [[cx,cy-hh],[cx+hw,cy],[cx,cy+hh],[cx-hw,cy]].map(p=>p.join(',')).join(' '));
      mid.setAttribute('x1', cx-hw*0.6); mid.setAttribute('y1', cy);
      mid.setAttribute('x2', cx+hw*0.6); mid.setAttribute('y2', cy);
    }
    function setColor(g, idx){
      g.querySelector('polygon').setAttribute('fill', beadColors[idx]);
    }
  }

  /* ===== Export PNG / Copier — HD recadré ===== */
  async function svgToCanvas(svg, scale = 3, tight = true, padding = 16){
    const xml = new XMLSerializer().serializeToString(svg);
    const img = new Image();
    const url = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(xml)));
    await new Promise(res => { img.onload = res; img.src = url; });

    let sx = 0, sy = 0, sw, sh;
    if (svg.viewBox && svg.viewBox.baseVal && svg.viewBox.baseVal.width) {
      const vb = svg.viewBox.baseVal; sw = vb.width; sh = vb.height; sx = vb.x; sy = vb.y;
    } else { sw = svg.width.baseVal.value; sh = svg.height.baseVal.value; }

    if (tight && svg.getBBox) {
      const bb = svg.getBBox();
      sx = bb.x - padding; sy = bb.y - padding;
      sw = bb.width + padding*2; sh = bb.height + padding*2;
    }

    const canvas = document.createElement('canvas');
    canvas.width  = Math.max(1, Math.round(sw * scale));
    canvas.height = Math.max(1, Math.round(sh * scale));
    const cx = canvas.getContext('2d');
    cx.scale(scale, scale);
    cx.fillStyle = '#ffffff'; cx.fillRect(0,0,sw,sh);
    cx.drawImage(img, -sx, -sy);
    return canvas;
  }

  $('build').addEventListener('click', () => buildSoroban(+$('cols').value, +$('zoom').value));
  $('zoom').addEventListener('input', () => buildSoroban(+$('cols').value, +$('zoom').value));
  $('cols').addEventListener('change', () => buildSoroban(+$('cols').value, +$('zoom').value));

  $('save').addEventListener('click', async () => {
    const svg = holder.querySelector('svg'); if(!svg) return;
    const canvas = await svgToCanvas(svg, 3, true, 16);
    const a = document.createElement('a');
    a.href = canvas.toDataURL('image/png');
    a.download = `soroban_${$('cols').value}cols.png`;
    a.click();
  });

  $('copy').addEventListener('click', async () => {
    const svg = holder.querySelector('svg'); if(!svg) return;
    try{
      const canvas = await svgToCanvas(svg, 3, true, 16);
      const blob = await new Promise(r => canvas.toBlob(r, 'image/png'));
      await navigator.clipboard.write([new ClipboardItem({'image/png': blob})]);
      alert('Image HD copiée dans le presse-papiers ✅');
    }catch(err){
      alert("Impossible de copier (navigateur/permissions). Utilise « Télécharger PNG (HD) ».");
    }
  });

  buildSoroban(+$('cols').value, +$('zoom').value);
})();
</script>
</html>
