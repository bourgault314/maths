<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
  <title>Abaque de Gerbert – Multiplications</title>
  <style>
    :root{
      --paper1:#f7f1e6;
      --paper2:#efe5d4;
      --ink:#1a1a1a;
      --warn:#f39c12;
      --shadow: 0 10px 30px rgba(0,0,0,0.10);
      --shadow2: 0 3px 12px rgba(0,0,0,0.12);
      --token:#ffffff;

      /* ✅ arche plus basse (prend moins de place) */
      --archH: 0px;
    }

    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:var(--ink);
      min-height:100vh;
      display:flex;
      flex-direction:column;
      background:
        radial-gradient(1200px 800px at 50% -220px, rgba(255,255,255,0.85) 0%, rgba(255,255,255,0.0) 70%),
        radial-gradient(900px 700px at 10% 20%, rgba(255,255,255,0.25) 0%, rgba(255,255,255,0.0) 60%),
        radial-gradient(900px 700px at 90% 20%, rgba(255,255,255,0.18) 0%, rgba(255,255,255,0.0) 60%),
        linear-gradient(180deg, var(--paper1) 0%, var(--paper2) 100%);
    }

    header{
      padding:10px 12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      border-bottom:1px solid rgba(0,0,0,0.06);
      background: rgba(255,255,255,0.55);
      backdrop-filter: blur(6px);
      position:sticky;
      top:0;
      z-index:60;
    }

    .title{
      font-weight:850;
      letter-spacing:0.2px;
      font-size: clamp(14px, 2.2vw, 18px);
      display:flex;
      align-items:center;
      gap:10px;
    }
    .titleBadge{
      font-size:12px;
      font-weight:900;
      padding:5px 9px;
      border-radius:999px;
      background: rgba(0,0,0,0.05);
      border:1px solid rgba(0,0,0,0.10);
      color: rgba(0,0,0,0.75);
      user-select:none;
    }

    .tools{
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .btn{
      border:1px solid rgba(0,0,0,0.12);
      background:#fff;
      color:var(--ink);
      border-radius:12px;
      padding:8px 10px;
      font-weight:750;
      font-size:13px;
      cursor:pointer;
      box-shadow:0 1px 0 rgba(0,0,0,0.04);
      user-select:none;
      display:inline-flex;
      align-items:center;
      gap:8px;
    }
    .btn:active{ transform: translateY(1px); }
    .btn.primary{ border-color: rgba(44,123,229,0.35); color:#0d3b82; }
    .btn.danger{ border-color: rgba(214,69,61,0.35); color:#7a1410; }
    .btn.disabled{ opacity:.55; pointer-events:none; }

    .icon{ width:16px;height:16px;display:inline-block; }

    main{
      flex:1;
      display:flex;
      flex-direction:column;
      padding:10px 10px 0;
      gap:10px;
      max-width:1200px;
      width:100%;
      margin:0 auto;
    }

    .bigValueOutside{
      display:none;
      align-items:center;
      justify-content:center;
      padding:10px 12px;
      border-radius:16px;
      background: rgba(255,255,255,0.78);
      border:1px solid rgba(0,0,0,0.10);
      box-shadow:0 8px 24px rgba(0,0,0,0.08);
      font-weight:950;
      letter-spacing:.6px;
      font-size: clamp(18px, 3.8vw, 34px);
      color: rgba(0,0,0,0.82);
      user-select:none;
    }

    .boardWrap{
      position:relative;
      flex:1;
      min-height:56vh;
      border-radius:18px;
      box-shadow:var(--shadow);
      overflow:visible;
      background:
        linear-gradient(180deg, rgba(255,255,255,0.35) 0%, rgba(255,255,255,0.10) 100%),
        repeating-linear-gradient(0deg, rgba(0,0,0,0.015) 0px, rgba(0,0,0,0.015) 1px, rgba(0,0,0,0.0) 7px),
        radial-gradient(900px 700px at 50% 0%, rgba(255,255,255,0.5) 0%, rgba(255,255,255,0.0) 70%);
      border:1px solid rgba(0,0,0,0.10);
    }

    .boardTop{
      display:none;
    }

    

    /* ===== Tableau de multiplication (dans le "grand tableau") ===== */
    .opTable{
      height:100%;
      display:flex;
      flex-direction:column;
      justify-content:flex-start;
      gap:6px;
    }
    .opRow{
      display:flex;
      gap:8px;
      align-items:center;
      padding:0 12px;
      height:26px;
    }
    .opCell{
      flex:1 1 0;
      min-width:56px;
      height:26px;
      border-radius:10px;
      background: rgba(255,255,255,0.60);
      border:1px solid rgba(0,0,0,0.10);
      display:flex;
      align-items:center;
      justify-content:center;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-weight:950;
      font-size: 22px;
      letter-spacing: .4px;
      color: rgba(0,0,0,0.86);
      line-height:1;
      box-sizing:border-box;
    }
    .opSep{
      width:12px;
      flex:0 0 12px;
      height:26px;
      position:relative;
    }
    .opSep:before{
      content:"";
      position:absolute;
      left:50%;
      top:2px;
      bottom:2px;
      transform:translateX(-50%);
      border-left:2px dashed rgba(0,0,0,0.16);
    }
    .opRule{
      height:2px;
      margin:0 12px;
      background: rgba(0,0,0,0.28);
      border-radius:999px;
    }
    .opDigit.current{ text-decoration: underline; text-underline-offset: 3px; }
    .opDigit.processed{ text-decoration: line-through; opacity: .55; }
    .opSign{
      font-weight:950;
      opacity:.85;
    }

    /* Millions OFF : masque la zone "Millions" aussi dans le tableau */
    body.noMillions .opCell[data-group="0"]{ display:none; }
    body.noMillions .opSep[data-boundary="1"]{ display:none; }

    /* En mode direct : on compact un peu */
    body.directMul .opRow{ height:30px; }
    body.directMul .opCell{ height:30px; font-size:30px; }

    /* ✅ Mode direct : tableau abaissé (plus proche du bas, moins d'espace perdu) */
    body.directMul .board{ align-items:flex-end; padding-bottom:12px; }
    body.directMul .groupSep{ align-self:stretch; }

    /* ✅ Mode direct : les colonnes ne s'étirent pas (on libère de la place en bas pour la zone d'échange) */
        body.directMul .colBody{ flex:0 0 auto; }

    /* On n’affiche plus la multiplication posée dans la carte (elle est dans le tableau) */
    .exerciseCard .exProblemWrap{ display:none; }
.bigArches{
      height: 100%;
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 14px;
      padding: 0 4px 0;
      margin: 0;
      align-items:stretch;
    }

    .bigArchBlock{
      position:relative;
      height:100%;
      display:flex;
      align-items:stretch;
      justify-content:center;
    }

    .bigArchSvg{
      position:absolute;
      left:0; right:0;
      bottom:0;
      width:100%;
      height: var(--archH);
      display:block;
      overflow:visible;
      opacity:.98;
    }

    /* ✅ Texte abaissé (plus centré) */
    .groupName{
      position:absolute;
      left:0; right:0;
      top: 48px;
      text-align:center;
      font-weight:950;
      letter-spacing:.6px;
      font-size: 13px;
      color: rgba(0,0,0,0.70);
      text-transform: uppercase;
      user-select:none;
    }

    .retLayer{
      position:absolute;
      left:0; right:0;
      top: calc(var(--archH) + 6px);
      height:28px;
      z-index:22;
      pointer-events:none;
    }
    .retBadge{
      position:absolute;
      transform: translateX(-50%);
      font-size:11px;
      font-weight:950;
      color:#fff;
      padding:4px 8px;
      border-radius:999px;
      background: var(--warn);
      box-shadow:0 6px 18px rgba(0,0,0,0.10);
      white-space:nowrap;
      pointer-events:auto;
      user-select:none;
      cursor:pointer;
      display:none;
    }

    .board{
      position:absolute;
      inset: var(--archH) 0 0;
      display:flex;
      padding:10px;
      gap:8px;
      align-items:stretch;
      z-index:5;
    }

    .groupSep{
      width:12px;
      flex:0 0 12px;
      position:relative;
    }
    .groupSep:before{
      content:"";
      position:absolute;
      inset:8px 5px 10px;
      border-left:2px dashed rgba(0,0,0,0.18);
    }

    .col{
      flex:1 1 0;
      min-width:56px;
      background: rgba(255,255,255,0.55);
      border:1px solid rgba(0,0,0,0.14);
      border-radius:14px;
      display:flex;
      flex-direction:column;
      overflow:visible;
      position:relative;
      touch-action:none;
    }

    .colHeader{
      height:78px;
      position:relative;
      border-bottom:1px solid rgba(0,0,0,0.10);
      background: rgba(255,255,255,0.70);
    }
    .colCalc{
      display:flex;
      flex-direction:column;
      gap:4px;
      padding:10px 0 2px;
      align-items:center;
      justify-content:flex-start;
      border-bottom:none;
      background:rgba(255,255,255,0.55);
    }
    .calcRow{
      height:28px;
      line-height:28px;
      width:100%;
      display:flex;
      align-items:center;
      justify-content:center;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;
      font-size:30px;
      color:#0f172a;
      user-select:none;
    }
    .calcRow.ruleAfter{
      border-bottom:2px solid rgba(15,23,42,0.18);
      
      padding-bottom:0;
      margin-bottom:0;
    }
    .calcDigit{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      min-width:26px;
      height:34px;
      padding:0 8px;
      border-radius:999px;
      text-align:center;
    }
    .calcDigit.zero{ opacity:0.45; }
    .calcDigit.done{
      opacity:0.45;
      text-decoration:line-through;
      text-decoration-thickness:2px;
    }
    .calcDigit.focus{
      outline:2px solid rgba(29,78,216,0.85);
      background: rgba(29,78,216,0.12);
    }
    .calcSign{
      font-weight:900;
      color:#0f172a;
    }


    /* ===== Multiplication : lignes posées + lignes en jetons (dans l’abaque) ===== */
    .calcRow.hdr{
      height:40px;
      line-height:40px;
      font-size:36px;
      font-weight:900;
    }
    .calcRow.line{
      height:32px;
      line-height:32px;
    }

    .miniToken{
      display:inline-flex;
      width:28px;
      height:28px;
      border-radius:999px;
      align-items:center;
      justify-content:center;
      font-weight:950;
      font-size:16px;
      line-height:1;
      background: rgba(255,255,255,0.92);
      border:2px solid rgba(0,0,0,0.22);
      box-shadow: 0 2px 10px rgba(0,0,0,0.10);
      user-select:none;
    }
    .miniToken.zero{ opacity:0.55; }

    .miniPile{
      position:relative;
      display:inline-block;
      width:48px;
      height:30px;
    }
    .miniPile .miniToken{
      position:absolute;
      top:0;
      left:0;
      transform: translateX(calc(var(--i) * 10px));
    }

    .miniCount{
      display:inline-flex;
      padding:2px 8px;
      border-radius:999px;
      font-weight:950;
      font-size:12px;
      background: rgba(0,0,0,0.07);
      border:1px solid rgba(0,0,0,0.14);
      color: rgba(0,0,0,0.70);
      user-select:none;
    }

    .colLabel{
      position:absolute;
      left:0; right:0;
      top:15px;
      text-align:center;
      font-weight:950;
      letter-spacing:.9px;
      font-size:12px;
      color: rgba(0,0,0,0.72);
      pointer-events:none;
    }
    .colValueTop{
      position:absolute;
      left:0; right:0;
      top:30px;
      text-align:center;
      font-weight:900;
      font-size:11px;
      color: rgba(0,0,0,0.55);
      letter-spacing:.2px;
      display:none;
      pointer-events:none;
      user-select:none;
    }
    .colBody{
      flex:1;
      padding:2px 6px 10px;
      display:flex;
      flex-direction:column;
      gap:10px;
      align-items:center;
      justify-content:flex-start;
    }

    /* ===== Multiplication par lignes : garder l'alignement vertical ===== */
    .colBody.lineMode{
      /* même padding, mais on utilise des "cases" de lignes fixes */
      gap:10px;
      align-items:center;
      justify-content:flex-start;
    }
    .lineSlot{
      width:100%;
      height: calc(clamp(54px, 7.4vw, 86px) + 12px);
      position:relative;
      border-radius:10px;
    }
    .lineSlot.lockedRow{
      pointer-events:none; /* même les cases vides sont "verrouillées" */
    }
    .lineSlot.activeRow{
      /* léger repère (très discret) */
      outline:1px dashed rgba(37,99,235,0.25);
      outline-offset: -1px;
    }
    .lineSlot .token{
      position:absolute;
      left:50%;
      top:50%;
    }

    /* ===== Mode direct : pile compacte (empilement) ===== */
    .pileSlot{
      width:100%;
      height: calc(clamp(54px, 7.4vw, 86px) + 12px);
      position:relative;
      border-radius:10px;
    }
    .pileSlot .token{
      position:absolute;
      left:50%;
      top:50%;
    }


    .token{
      width: clamp(54px, 7.4vw, 86px);
      height: clamp(54px, 7.4vw, 86px);
      border-radius:999px;
      background: var(--token);
      border:2px solid rgba(0,0,0,0.24);
      box-shadow: var(--shadow2);
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:950;
      font-size: clamp(20px, 3.6vw, 30px);
      user-select:none;
      touch-action:none;
      cursor:grab;
      position:relative;
    }
    .token:active{ cursor:grabbing; }
    .token.locked{
      opacity:0.35;
      filter: grayscale(0.85);
      pointer-events:none;
    }

    .token.frozen{
      opacity:0.45;
      filter: grayscale(0.75);
      pointer-events:none;
    }
    .token.selected{
      border-color: rgba(243,156,18,0.95);
      box-shadow: 0 0 0 4px rgba(243,156,18,0.25), var(--shadow2);
      background: rgba(243,156,18,0.12);
    }

    .token:before{
      content:"";
      position:absolute;
      inset:8px;
      border-radius:999px;
      border:1px solid rgba(0,0,0,0.08);
      pointer-events:none;
    }

    .palette{
      position:sticky;
      bottom:0;
      z-index:30;
      padding:10px;
      background: rgba(255,255,255,0.78);
      border-top:1px solid rgba(0,0,0,0.08);
      backdrop-filter: blur(8px);
    }
    .paletteInner{
      display:flex;
      align-items:center;
      justify-content:center;
      max-width:1200px;
      margin:0 auto;
    }
    .tray{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:center;
      flex-wrap:wrap;
      padding:2px 0;
    }

    .overlay{
      position:absolute;
      inset:0;
      background: rgba(0,0,0,0.12);
      display:none;
      z-index:18;
      pointer-events:none;
    }
    .resolveBar{
      position:absolute;
      left:10px; right:10px; top:10px;
      z-index:25;
      display:none;
      gap:8px;
      align-items:center;
      justify-content:space-between;
      padding:10px 10px;
      border-radius:14px;
      background: rgba(255,255,255,0.92);
      border:1px solid rgba(0,0,0,0.10);
      box-shadow: var(--shadow);
      backdrop-filter: blur(8px);
      pointer-events:auto;
    }
    .resolveBar .txt{
      font-weight:900;
      font-size:13px;
      color: rgba(0,0,0,0.78);
      line-height:1.15;
    }
    .resolveBar .actions{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .col.focus{
      outline:3px solid rgba(44,123,229,0.55);
      outline-offset:-3px;
      background: rgba(44,123,229,0.06);
    }
    .col.locked{
      filter: grayscale(0.7);
      opacity:0.55;
      pointer-events:none;
    }

    @keyframes shake {
      0% { transform: translateX(0); }
      20% { transform: translateX(-6px); }
      40% { transform: translateX(6px); }
      60% { transform: translateX(-4px); }
      80% { transform: translateX(4px); }
      100% { transform: translateX(0); }
    }
    .shake{ animation: shake 260ms ease-in-out; }

    
    /* ✅ Jetons "à traiter" : pas remplis orange, mais un halo/contour clair + petit X */
    .token.toResolve{
      background: var(--token);
      border-color: rgba(243,156,18,0.85);
      box-shadow: 0 0 0 4px rgba(243,156,18,0.22), var(--shadow2);
    }
    /* ✅ Zone poubelle (repère visuel) */
    .trashZone{
      position:absolute;
      border-radius:18px;
      background: rgba(132, 98, 64, 0.12); /* bande brune discrète */
      border: 1px dashed rgba(132, 98, 64, 0.35);
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.55);
      padding:10px 10px 12px;
      display:flex;
      flex-direction:column;
      gap:10px;
      user-select:none;
      pointer-events:none; /* la détection se fait via la zone, mais on garde la compat */
      opacity:0.95;
      z-index:19;
    }
    .trashZone.active{
      border-style: solid;
      border-color: rgba(214,69,61,0.55);
      background: rgba(214,69,61,0.06);
    }
    .trashZone{ align-items:center; }
    .zoneTitle{ width:100%; text-align:center; }

    .trashTxt{
      font-size:12px;
      font-weight:900;
      letter-spacing:.3px;
      text-align:center;
      opacity:.85;
      pointer-events:none;
    }
    .binTokens{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      justify-content:flex-start;
      align-content:flex-start;
      pointer-events:auto;
      min-height:44px;
    }
    .binTokens .token{
      width:60px;
      height:60px;
      font-size:24px;
      pointer-events:auto;
    }
    /* ✅ Bouton ÉCHANGER par colonne */
    .exBtn{
      position:absolute;
      top:34px;
      left:50%;
      transform:translateX(-50%);
      padding:6px 10px;
      border-radius:999px;
      font-weight:900;
      font-size:11px;
      letter-spacing:.2px;
      background: rgba(255,255,255,0.92);
      border:1px solid rgba(0,0,0,0.18);
      box-shadow: 0 10px 22px rgba(0,0,0,0.10);
      cursor:pointer;
      user-select:none;
      display:none;
      z-index:6;
    }
    .col.has2 .exBtn{ display:inline-flex; gap:6px; align-items:center; }
    .col.has2 .exBtn::before{ content:"↺"; font-weight:900; }
    .col.locked .exBtn{ display:none !important; }

    @media (max-width: 520px){

      .btn{ padding:7px 9px; font-size:12px; }
      :root{ --archH: 0px; }
      .groupName{ top: 44px; }
    }
  /* ✅ Mode échange : on retire le gros texte d'aide (pour ne rien décaler / pas de scroll horizontal) */
    #resolveTxt{ display:none !important; }
    /* Barre compacte au-dessus de la zone d'échange */
    #resolveBar{
      padding:10px 12px;
      gap:10px;
      justify-content:center;
    }
/* ✅ Zone d’échange : jetons centrés + léger chevauchement si beaucoup */
#exchangeBinTokens{
  justify-content:center !important;
  align-content:flex-start;
}
#exchangeBinTokens .token{
  margin: 0; /* reset */
}
#exchangeBinTokens.overlap .token{
  margin-left: -10px; /* chevauchement léger */
}
#exchangeBinTokens.overlap .token:first-child{
  margin-left: 0;
}

/* ✅ Barre d'échange compacte, largeur calée sur la zone d'échange */
#resolveBar{
  position:absolute;
  right:auto !important;
  width:auto;            /* JS fixe la largeur */
  max-width: calc(100vw - 20px);
  padding: 8px 10px !important;
  border-radius: 16px !important;
  gap: 8px !important;
}
#resolveBar button{
  font-size: 13px !important;
  padding: 10px 14px !important;
  border-radius: 999px !important;
}
@media (max-width: 520px){
  #resolveBar button{
    font-size: 12px !important;
    padding: 9px 12px !important;
  }
  #resolveBar{
    padding: 7px 8px !important;
    gap: 6px !important;
  }
}


/* ✅ Mode échange : plus de gros rectangle. On affiche uniquement les 2 boutons. */
#resolveBar{
  background: transparent !important;
  border: none !important;
  box-shadow: none !important;
  padding: 0 !important;
  border-radius: 0 !important;
  width: auto !important; /* JS fixe via left/top mais pas de carte */
  max-width: none !important;
  z-index: 80;
}
#resolveBar button{
  box-shadow: 0 10px 22px rgba(0,0,0,0.12) !important;
}



/* ✅ Barres Valider/Annuler : compactes, au-dessus de la zone d’échange */
#resolveBar{
  display:flex;
  flex-direction: column;
  align-items: center;
  gap: 10px;
}
#resolveBar button{
  min-width: 150px;
  text-align:center;
}
@media (max-width: 520px){
  #resolveBar button{ min-width: 130px; }
}


/* ✅ Fix placement : les boutons sont ancrés au-dessus de la Zone d’échange (position: fixed) */
#resolveBar{ position: fixed !important; }


/* ✅ V39 : pas de “zone floue” derrière les boutons */
#resolveBar{
  background: transparent !important;
  border: none !important;
  box-shadow: none !important;
  backdrop-filter: none !important;
  padding: 0 !important;
  border-radius: 0 !important;
  gap: 10px !important;
}
#resolveBar button{
  width: 100% !important;          /* même largeur que la zone d’échange */
  min-width: 0 !important;
  font-size: 16px !important;      /* plus petit */
  padding: 10px 12px !important;   /* plus compact */
  box-shadow: 0 8px 18px rgba(0,0,0,0.12) !important; /* ombre légère, pas de blur */
}
@media (max-width: 520px){
  #resolveBar button{ font-size: 15px !important; padding: 9px 10px !important; }
}


/* ✅ Option : masquer/afficher le groupe "Millions" (par défaut masqué) */
body.noMillions .bigArchBlock[data-group="0"]{ display:none; }
body.noMillions .bigArches{ grid-template-columns: 1fr 1fr; }
body.noMillions .col[data-group="0"]{ display:none; }
body.noMillions .groupSep[data-boundary="1"]{ display:none; }


body.noMillions .pill[data-adigits="7"],
body.noMillions .pill[data-adigits="8"],
body.noMillions .pill[data-adigits="9"]{ display:none; }


body.withMillions .board{ padding:8px; gap:6px; }
body.withMillions .col{ min-width:50px; }
body.withMillions .groupSep{ width:10px; flex:0 0 10px; }


/* ✅ En mode "sans millions", on évite l’échange entre milliers et millions (col 3 -> col 2) */
body.noMillions .col[data-col-index="3"] .exBtn{ display:none !important; }
    .col.noEx .exBtn{ display:none !important; }

/* ✅ Option : afficher/masquer les arceaux (par défaut affichés) */
body.noArches{ }
body.noArches .bigArchSvg{ display:none; }
body.noArches .bigArchBlock{
  background: rgba(255,255,255,0.62);
  border:1px solid rgba(0,0,0,0.14);
  border-radius:14px;
}
body.noArches .groupName{
  top: 50%;
  transform: translateY(-50%);
  font-size: 12px;
  letter-spacing: .8px;
  color: rgba(0,0,0,0.78);
}
body.noArches .boardTop{ padding-top: 6px; }


/* ✅ Mode Exercices (Multiplications) : carte au-dessus de la zone d’échange, adaptée tablette */
.exerciseCard{
  position: fixed;
  z-index: 75;
  display:flex;
  flex-direction:column;
  gap:10px;
  padding:12px 12px 10px;
  border-radius:18px;
  background: rgba(255,255,255,0.94);
  border:1px solid rgba(0,0,0,0.10);
  box-shadow: 0 10px 28px rgba(0,0,0,0.12);
  backdrop-filter: blur(8px);
  user-select:none;
  max-width: calc(100vw - 16px);
}
.exHead{
  display:flex;
  align-items:flex-start;
  justify-content:space-between;
  gap:10px;
}
.exTitle{
  font-weight:950;
  letter-spacing:.3px;
  font-size: 15px;
}
.exSub{
  font-size: 12px;
  font-weight:800;
  opacity:.68;
  margin-top:2px;
}
.exHeadRight{ display:flex; align-items:center; gap:8px; }
.exProblem{
  margin:0;
  padding:12px 12px;
  border-radius:14px;
  background: rgba(0,0,0,0.035);
  border:1px solid rgba(0,0,0,0.08);
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-weight:900;
  font-size: 22px;
  line-height: 1.25;
  letter-spacing: .5px;
  white-space: pre;
  overflow:hidden;
}


.mulDigit.current{ text-decoration: underline; text-underline-offset: 3px; }
.mulDigit.processed{ text-decoration: line-through; opacity: .55; }

.exCarryWrap{ text-align:center; margin-top: -4px; }
.exCarry{
  margin:0;
  padding: 0 12px 6px;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-weight:900;
  font-size: 16px;
  line-height: 1.05;
  letter-spacing: .5px;
  white-space: pre;
  opacity: .70;
}
.exCarry:empty{ display:none; }

.exResultWrap{ text-align:center; margin-top: -6px; }
.exResult{
  margin:0;
  padding: 0 12px 2px;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-weight:950;
  font-size: 22px;
  line-height: 1.15;
  letter-spacing: .5px;
  white-space: pre;
  display:inline-block;
}
.exResult:empty{ display:none; }

.exResult.ok{ color: #1a7f37; }
.exResult.no{ color: #b42318; }


.exInlineResult{ display:inline-block; }
.exInlineResult.ok{ color: #1a7f37; }
.exInlineResult.no{ color: #b42318; }
.exProblemWrap{ text-align:center; }
.exProblem{ display:inline-block; max-width:100%; }

.exActions{
  display:flex;
  gap:10px;
  justify-content:space-between;
  align-items:center;
}
.exActions .btn{
  flex:1;
  justify-content:center;
  padding: 12px 12px;
  font-size: 15px;
  border-radius: 14px;
}
.exFeedback{
  min-height: 20px;
  text-align:center;
  font-weight:950;
  letter-spacing:.2px;
  font-size: 15px;
}
.exFeedback.ok{ color: #1a7f37; }
.exFeedback.no{ color: #b42318; }

.exSettings{
  margin-top:2px;
  padding-top:10px;
  border-top:1px dashed rgba(0,0,0,0.14);
  display:flex;
  flex-direction:column;
  gap:10px;  max-height: min(360px, calc(100vh - 190px));
  overflow:auto;
}

.exRowSet{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
}
.exLbl{
  font-size: 12px;
  font-weight:950;
  opacity:.75;
  width:64px;
}
.exPills{ display:flex; gap:8px; flex-wrap:wrap; justify-content:center; }
.pill{
  border:1px solid rgba(0,0,0,0.14);
  background:#fff;
  border-radius:999px;
  padding:8px 12px;
  font-weight:950;
  font-size: 13px;
  cursor:pointer;
}
.pill.active{
  border-color: rgba(44,123,229,0.45);
  box-shadow: 0 0 0 4px rgba(44,123,229,0.16);
  color:#0d3b82;
}

/* Chiffres : plus compact, comme "Termes" (et wrap sur 2 lignes) */
.exDigitsPills{ gap:6px; justify-content:flex-start; }
.exDigitsPills .pill{
  min-width:32px;
  width:32px;
  padding:7px 0;
  text-align:center;
}

@media (max-width: 520px){
  .exerciseCard{ padding: 10px 10px 10px; border-radius:16px; }
  .exProblem{ font-size: 20px; padding:10px 10px; }
  .exActions .btn{ font-size: 14px; padding: 11px 10px; }
  .pill{ padding: 8px 10px; font-size: 13px; }
}

</style>
</head>

<body class="directMul">
<header>
  <div class="title">
    Abaque de Gerbert – Multiplications</div>
  <div class="tools">
    <button class="btn" id="btnUndo">Retour</button>
    <button class="btn primary" id="btnClear">Réinitialiser</button>
        <button class="btn" id="btnColValues">Valeurs : OFF</button>

    <button class="btn" id="btnMillions">Millions : OFF</button>

<button class="btn" id="btnFullscreen" title="Plein écran">
      <svg class="icon" viewBox="0 0 24 24" aria-hidden="true">
        <path fill="currentColor" d="M9 3H5c-1.1 0-2 .9-2 2v4h2V5h4V3zm10 0h-4v2h4v4h2V5c0-1.1-.9-2-2-2zm-4 18h4c1.1 0 2-.9 2-2v-4h-2v4h-4v2zM3 15v4c0 1.1.9 2 2 2h4v-2H5v-4H3z"/>
      </svg>
      Plein écran
    </button>

    <button class="btn danger" id="btnExitResolve" style="display:none;">Quitter échange</button>
  </div>
</header>

<main>
  <div class="bigValueOutside" id="bigValueOutside">0</div>

  <div class="boardWrap" id="boardWrap">
    <div class="trashZone" id="trashZone" aria-hidden="true" title="Dépose ici les jetons à échanger">
      <div class="trashTxt zoneTitle">Zone d’échange</div>
      
    <div class="binTokens" id="exchangeBinTokens"></div>
    </div>

    <div class="exerciseCard" id="exerciseCard" aria-live="polite">
          <div class="exHead">
            <div class="exHeadLeft">
              <div class="exTitle">Multiplication</div>
              <div class="exSub" id="exSub">Exercice</div>
            </div>
            <div class="exHeadRight">
              <button class="btn" id="btnExNew">Nouveau</button>
              <button class="btn" id="btnExSettings" title="Réglages">⚙️</button>
            </div>
          </div>

          <div class="exCarryWrap"><pre class="exCarry" id="exCarry"></pre></div>

          <div class="exProblemWrap"><pre class="exProblem" id="exProblem"></pre></div>

          <div class="exResultWrap"><pre class="exResult" id="exResult"></pre></div>

          <div class="exActions">
            <button class="btn primary" id="btnExCheck">Valider</button>
            <button class="btn" id="btnExReset">Recommencer</button>
          </div>

          <div class="exFeedback" id="exFeedback"></div>

          <div class="exSettings" id="exSettings" style="display:none;">
<div class="exRowSet">
              <span class="exLbl">A</span>
              <div class="exPills exDigitsPills" role="group" aria-label="Chiffres du multiplicande">
                <button class="pill" data-adigits="1">1</button>
                <button class="pill" data-adigits="2">2</button>
                <button class="pill" data-adigits="3">3</button>
                <button class="pill" data-adigits="4">4</button>
                <button class="pill" data-adigits="5">5</button>
                <button class="pill" data-adigits="6">6</button>
                <button class="pill" data-adigits="7">7</button>
                <button class="pill" data-adigits="8">8</button>
                <button class="pill" data-adigits="9">9</button>
              </div>
            </div>

            <div class="exRowSet">
              <span class="exLbl">B</span>
              <div class="exPills" role="group" aria-label="Chiffres du multiplicateur">
                <button class="pill" data-bdigits="1">1</button>
                <button class="pill" data-bdigits="2">2</button>
                <button class="pill" data-bdigits="3">3</button>
              </div>
            </div>

            <div class="exRowSet">
              <span class="exLbl">Retenues</span>
              <div class="exPills" role="group" aria-label="Retenues">
                <button class="pill" data-carry="allow">Autoriser</button>
                <button class="pill" data-carry="none">Sans retenue</button>
              </div>
            </div>

            <div class="exRowSet">
              <span class="exLbl">Zéros</span>
              <div class="exPills" role="group" aria-label="Zéros dans les nombres">
                <button class="pill" data-zeros="off">Éviter</button>
                <button class="pill" data-zeros="on">Autoriser</button>
              </div>
            </div>
          </div>
        </div>

    <div class="boardTop">
      <div class="opTable" id="opTable"></div>
    </div>

    <div class="retLayer" id="retLayer"></div>

    <div class="overlay" id="overlay"></div>

    <div class="resolveBar" id="resolveBar">
      <div class="txt" id="resolveTxt">Mode échange</div>
      <div class="actions">
        <button class="btn" id="btnValidate">Valider l’échange</button>
        <button class="btn danger" id="btnCancel">↩ Annuler</button>
      </div>
    </div>

    <div class="board" id="board"></div>
  </div>
</main>

<div class="palette">
  <div class="paletteInner">
    <div class="tray" id="tray"></div>
  </div>
</div>

<script>
(() => {
  const COL_COUNT = 9;
  const LABELS = ["C","D","U"];

  function placeValue(colIndex){
    const pow = (COL_COUNT - 1) - colIndex;
    return Math.pow(10, pow);
  }
  function placeValueShort(colIndex){
    return placeValue(colIndex).toLocaleString("fr-FR");
  }

  const state = {
    cols: Array.from({length: COL_COUNT}, () => []),
    bin: [],
    dragging: null,
    exchange: null, // {focusCol,leftCol,snapshotCols,snapshotBin,nextIdSnapshot}
    nextId: 1,
    undoStack: [],
    showBigValue: false,
    showColValues: false,
    showMillions: false,
// ✅ Exercices (Multiplications)
    exCfg: {
      mode: "direct",      // "steps" | "direct"
      aDigits: 3,         // 1..6 (ou 9 si Millions ON)
      bDigits: 2,         // 1..3 (recommandé)
      carry: "allow",     // "allow" | "none"
      zeros: true         // autoriser des zéros dans les facteurs
    },
    ex: null
  };

  const board = document.getElementById("board");
  const tray = document.getElementById("tray");
  const bigValueOutside = document.getElementById("bigValueOutside");

  const boardWrap = document.getElementById("boardWrap");
  const boardTopEl = document.querySelector(".boardTop");
  const opTableEl = document.getElementById("opTable");
  const retLayerEl = document.getElementById("retLayer");
  const trashZone = document.getElementById("trashZone");
  const binTokens = document.getElementById("exchangeBinTokens");

  const btnUndo = document.getElementById("btnUndo");
  const btnClear = document.getElementById("btnClear");
  const btnBigValue = document.getElementById("btnBigValue");
  const btnColValues = document.getElementById("btnColValues");
  const btnMillions = document.getElementById("btnMillions");
const btnExitResolve = document.getElementById("btnExitResolve");
  const btnFullscreen = document.getElementById("btnFullscreen");

  const overlay = document.getElementById("overlay");
  const resolveBar = document.getElementById("resolveBar");
  const resolveTxt = document.getElementById("resolveTxt");
  const btnValidate = document.getElementById("btnValidate");
  const btnCancel = document.getElementById("btnCancel");


  // ✅ Exercices (Multiplications)
  const exerciseCard = document.getElementById("exerciseCard");
  const exProblem = document.getElementById("exProblem");
  const exCarry = document.getElementById("exCarry");
  const exResult = document.getElementById("exResult");
  const exSub = document.getElementById("exSub");
  const exFeedback = document.getElementById("exFeedback");
  const exSettings = document.getElementById("exSettings");

  const btnExNew = document.getElementById("btnExNew");
  const btnExCheck = document.getElementById("btnExCheck");
  const btnExReset = document.getElementById("btnExReset");
  const btnExSettings = document.getElementById("btnExSettings");
  function deepCopyCols(cols){
    return cols.map(col => col.map(t => ({id:t.id, v:t.v, line:(t.line ?? null), frozen: !!t.frozen})));
  }
  function deepCopyBin(bin){
    return bin.map(t => ({id:t.id, v:t.v, line:(t.line ?? null), frozen: !!t.frozen}));
  }
  function pushUndo(){
    state.undoStack.push({
      cols: deepCopyCols(state.cols),
      bin: deepCopyBin(state.bin),
      exchange: state.exchange ? {
        focusCol: state.exchange.focusCol,
        leftCol: state.exchange.leftCol,
        snapshotCols: deepCopyCols(state.exchange.snapshotCols),
        snapshotBin: deepCopyBin(state.exchange.snapshotBin),
        focusIds: Array.from(state.exchange.focusIds || []),
        leftBaseIds: Array.from(state.exchange.leftBaseIds || []),
        nextIdSnapshot: state.exchange.nextIdSnapshot
      } : null,
      nextId: state.nextId,
      showBigValue: state.showBigValue,
      showColValues: state.showColValues,
      showMillions: state.showMillions});
    updateUndoBtn();
  }
  function undo(){
    const snap = state.undoStack.pop();
    if(!snap) return;
    state.cols = deepCopyCols(snap.cols);
    state.bin  = deepCopyBin(snap.bin);
    state.exchange = snap.exchange ? {
      focusCol: snap.exchange.focusCol,
      leftCol: snap.exchange.leftCol,
      snapshotCols: deepCopyCols(snap.exchange.snapshotCols),
      snapshotBin: deepCopyBin(snap.exchange.snapshotBin),
      focusIds: new Set(snap.exchange.focusIds || []),
      leftBaseIds: new Set(snap.exchange.leftBaseIds || []),
      nextIdSnapshot: snap.exchange.nextIdSnapshot
    } : null;
    state.nextId = snap.nextId;
    state.showBigValue = snap.showBigValue;
    state.showColValues = snap.showColValues;
    state.showMillions = !!snap.showMillions;
renderTray();
    render();
  }
  function clearUndo(){ state.undoStack = []; updateUndoBtn(); }
  function updateUndoBtn(){ btnUndo.classList.toggle("disabled", state.undoStack.length === 0); }

  function makeTokenEl(v){
    const el = document.createElement("div");
    el.className = "token";
    el.textContent = String(v);
    el.dataset.value = String(v);
    return el;
  }

  function renderTray(){
    tray.innerHTML = "";
    const values = [0,1,2,3,4,5,6,7,8,9];
    for(const v of values){
      const t = makeTokenEl(v);
      t.dataset.source = "tray";
      tray.appendChild(t);
      enableDrag(t, {type:"tray"});
    }
  }

  function sumCol(i, filterFn){
    const arr = state.cols[i];
    if(!filterFn) return arr.reduce((a,t)=>a+t.v,0);
    return arr.reduce((a,t)=>a + (filterFn(t)?t.v:0),0);
  }
  function totalValue(filterFn){
    let total = 0;
    for(let i=0;i<COL_COUNT;i++) total += sumCol(i, filterFn) * placeValue(i);
    return total;
  }

  // Fige / défige des jetons (multiplication par lignes)
  function freezeCurrentLineTokens(lineIndex){
    for(let i=0;i<COL_COUNT;i++){
      for(const tok of state.cols[i]){
        if(tok.line == null){
          tok.line = lineIndex;
          tok.frozen = true;
        }
      }
    }
  }
  function setFrozenAll(on){
    for(let i=0;i<COL_COUNT;i++){
      for(const tok of state.cols[i]) tok.frozen = !!on;
    }
  }

  function formatGrouped(n){ return n.toLocaleString("fr-FR"); }

  // ===== Multiplication : capture / restauration des lignes en jetons =====
  // Snapshot d'une "ligne" : un chiffre par colonne (null si vide)
  function snapshotDigitsFromBoard(){
    const out = Array(COL_COUNT).fill(null);
    for(let i=0;i<COL_COUNT;i++){
      const arr = state.cols[i];
      if(arr.length === 1){
        out[i] = arr[0].v;
      }else{
        // La validation est bloquée tant qu'il reste des échanges à faire.
        out[i] = null;
      }
    }
    return out;
  }

  // Charge plusieurs lignes (snapshots) dans l'abaque pour réaliser la somme finale.
  // On empile simplement les jetons : l'élève fait ensuite les échanges pour normaliser.
  
  function loadDigitsLinesIntoBoard(lines){
    // (Conservé pour compatibilité) : charge des snapshots "un chiffre par colonne".
    // IMPORTANT : on ne réinitialise pas nextId ici, sinon IDs dupliqués en fin d'exercice.
    clearBoardColsOnly();
    for(const line of (lines || [])){
      if(!line) continue;
      for(let i=0;i<COL_COUNT;i++){
        const v = line[i];
        if(typeof v === "number"){
          addTokenToCol(i, v);
        }
      }
    }
  }


  // ✅ Exercice : on n'autorise la validation que si tous les échanges nécessaires ont été faits
  function firstVisibleColIndex(){
    // Millions OFF -> on masque les 3 colonnes de gauche (millions)
    return state.showMillions ? 0 : 3;
  }
  function pendingExchangeCols(){
    const cols = [];
    const first = firstVisibleColIndex();
    const ex = state.ex;
    const isLines = !!(ex && state.exCfg && state.exCfg.mode !== "direct" && ex.stage === "lines");

    for(let i=first;i<COL_COUNT;i++){
      const arrAll = state.cols[i];
      const arr = isLines ? arrAll.filter(t => t.line == null) : arrAll;
      if(arr.length > 1) cols.push(i);
      else if(arr.length === 1 && arr[0].v >= 10) cols.push(i);
    }
    return cols;
  }
  function updateExCheckBtnState(){
    if(!btnExCheck) return;
    let disabled = false;
    let title = "";

    if(!state.ex){
      disabled = true;
    }else if(state.exchange){
      disabled = true;
      title = "Termine l'échange avant de valider.";
    }else{
      const pending = pendingExchangeCols();
      if(pending.length){
        disabled = true;
        title = "Fais les échanges avant de valider.";
      }
    
      if(!disabled && state.exCfg.mode !== "direct" && state.ex && state.ex.solved){
        disabled = true;
        title = "Exercice terminé. Clique sur Nouveau pour recommencer.";
      }}

    btnExCheck.classList.toggle("disabled", disabled);
    btnExCheck.disabled = disabled;
    btnExCheck.title = title;
  }


  // ====== Exercices : Multiplications ======
  function visibleDigitsCount(){
    // Millions OFF -> 6 colonnes visibles (milliers + unités)
    return state.showMillions ? 9 : 6;
  }
  function maxRepresentable(){
    return Math.pow(10, visibleDigitsCount()) - 1;
  }
  function randInt(min, max){
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  function clearBoardHard(){
    state.cols = Array.from({length: COL_COUNT}, () => []);
    state.bin = [];
    state.exchange = null;
    state.nextId = 1;
  }


  function clearBoardColsOnly(){
    // On garde le bac (bin) et le compteur d'IDs : indispensable pour éviter des IDs dupliqués
    // quand on enchaîne plusieurs lignes de multiplication.
    state.cols = Array.from({length: COL_COUNT}, () => []);
    state.exchange = null;
  }

  function loadColsLinesIntoBoard(linesCols){
    // Charge plusieurs lignes (colonnes de jetons) dans l'abaque (somme finale).
    // On empile simplement : l'élève fait ensuite les échanges pour normaliser.
    state.cols = Array.from({length: COL_COUNT}, () => []);
    for(const cols of (linesCols || [])){
      if(!cols) continue;
      for(let i=0;i<COL_COUNT;i++){
        const arr = cols[i] || [];
        for(const tok of arr){
          state.cols[i].push({id: tok.id, v: tok.v});
        }
      }
    }
    // s'assure que nextId reste strictement au-dessus des IDs existants
    let maxId = 0;
    for(let i=0;i<COL_COUNT;i++){
      for(const tok of state.cols[i]) maxId = Math.max(maxId, tok.id || 0);
    }
    state.nextId = Math.max(state.nextId, maxId + 1);
    state.exchange = null;
  }


  // (Conservé) pose un nombre sur le plateau (utile pour des variantes futures)
  function setBoardToNumber(n, includeZeros, digitsLimit){
    clearBoardHard();

    const maxDigits = Math.min(digitsLimit || visibleDigitsCount(), visibleDigitsCount());
    const firstCol = COL_COUNT - maxDigits;

    // repère la première colonne (à gauche) où le nombre a un chiffre non nul (dans la zone visible)
    let leftMostNonZero = null;
    for(let i=firstCol;i<COL_COUNT;i++){
      const pv = placeValue(i);
      const digit = Math.floor(n / pv) % 10;
      if(digit !== 0){
        leftMostNonZero = i;
        break;
      }
    }
    if(leftMostNonZero === null) leftMostNonZero = COL_COUNT - 1;

    // place les jetons chiffre par chiffre (un jeton par colonne)
    for(let i=COL_COUNT-1;i>=firstCol;i--){
      const pv = placeValue(i);
      const digit = Math.floor(n / pv) % 10;

      if(digit === 0){
        if(!includeZeros) continue;
        if(i < leftMostNonZero) continue;
      }
      addTokenToCol(i, digit);
    }
  }


  function hasZeroDigit(n){
    return String(n).includes("0");
  }

  function digitsOfNumber(n){
    return String(n).split("").map(ch => Number(ch));
  }

  function numberFromDigits(arr){
    return Number(arr.join(""));
  }

  function randomDigits(count, {noZero=false, maxDigit=9}){
    const out = [];
    for(let i=0;i<count;i++){
      const minD = (i === 0) ? 1 : 0;
      let d;
      let tries = 0;
      do{
        d = randInt(minD, maxDigit);
        tries++;
        if(tries > 50) break;
      }while(noZero && d === 0);
      out.push(d);
    }
    return out;
  }

  function generateMultiplication(){
    const cfg = state.exCfg;

    const maxDigits = visibleDigitsCount();
    const aDigits = Math.min(cfg.aDigits, maxDigits);
    const bDigits = Math.min(cfg.bDigits, maxDigits);

    const maxN = maxRepresentable();

    // Contrainte "sans retenue" : éviter les retenues dans les multiplications par chiffre
    // => pour chaque chiffre d du multiplicateur, on veut a_digit * d <= 9.
    // On applique une contrainte simple via le max digit du multiplicateur.
    const triesMax = 400;
    for(let t=0;t<triesMax;t++){
      // Choix du multiplicateur (B)
      const bArr = randomDigits(bDigits, {noZero:false, maxDigit:9});
      if(!cfg.zeros && bArr.includes(0)) continue;
      const b = numberFromDigits(bArr);

      // Si "sans retenue" : on calcule le max digit non nul
      let maxBD = 9;
      if(cfg.carry === "none"){
        const nonZero = bArr.filter(d => d !== 0);
        maxBD = nonZero.length ? Math.max(...nonZero) : 0;
      }

      // Choix du multiplicande (A)
      let aArr;
      if(cfg.carry === "none" && maxBD > 1){
        const maxAD = Math.floor(9 / maxBD); // garantit a_digit * maxBD <= 9
        if(maxAD < 1) continue;
        aArr = randomDigits(aDigits, {noZero:false, maxDigit:Math.min(9, maxAD)});
        // premier chiffre non nul assuré par randomDigits()
      }else{
        aArr = randomDigits(aDigits, {noZero:false, maxDigit:9});
      }
      if(!cfg.zeros && aArr.includes(0)) continue;

      const a = numberFromDigits(aArr);
      const expected = a * b;

      if(expected > maxN) continue;

      if(cfg.carry === "none"){
        // Vérifie aussi qu’il n’y aura pas de retenue lors de la somme finale des lignes
        const digitsBRev = String(b).split("").map(ch => Number(ch)).reverse();
        let ok = true;
        for(let p=0;p<maxDigits;p++){
          let s = 0;
          for(let i=0;i<digitsBRev.length;i++){
            const v = a * digitsBRev[i] * Math.pow(10, i);
            s += Math.floor(v / Math.pow(10, p)) % 10;
          }
          if(s >= 10){ ok = false; break; }
        }
        if(!ok) continue;
      }


      // évite des exercices trop triviaux
      if(a === 0 || b === 0) continue;

      return {a, b, expected};
    }

    // fallback (devrait être rare) : petit produit garanti
    return {a: 12, b: 34, expected: 408};
  }

  function placeNameForStep(step){
    const names = [
      "unités",
      "dizaines",
      "centaines",
      "milliers",
      "dizaines de milliers",
      "centaines de milliers",
      "millions",
      "dizaines de millions",
      "centaines de millions"
    ];
    return names[step] || ("10^" + step);
  }

  function escapeHTML(str){
    return String(str)
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;");
  }

  function clearExerciseSolution(){
    exCarry.textContent = "";
    exResult.textContent = "";
    exResult.className = "exResult";
    if(exResult) exResult.dataset.keep = "";
  }

  function multiplierDigitsHTML(sb, stage, stepIndex){
    // sb: string du multiplicateur (sans espaces)
    // stage: "lines" | "final" | "direct"
    // stepIndex: nombre de chiffres déjà validés (en partant des unités)
    const L = sb.length;
    let html = "";
    let currentPos = -1;
    if(stage === "lines"){
      currentPos = L - 1 - stepIndex;
    }
    for(let i=0;i<L;i++){
      let cls = "mulDigit";
      if(stage === "lines"){
        if(i > currentPos) cls += " processed";
        if(i === currentPos) cls += " current";
      }else if(stage === "final"){
        cls += " processed";
      }
      html += `<span class="${cls}">${escapeHTML(sb[i])}</span>`;
    }
    return html;
  }

  function formatVerticalMultiplicationHTML(ex){
    const sa = String(ex.a);
    const sb = String(ex.b);
    const expected = ex.expected;

    // largeur : max entre facteurs, lignes partielles et résultat
    const digitsB = sb.split("").map(ch => Number(ch)).reverse(); // unités -> ...
    const partialVals = digitsB.map((d, i) => ex.a * d * Math.pow(10, i));
    const maxLen = Math.max(
      sa.length,
      sb.length,
      String(expected).length,
      ...partialVals.map(v => String(v).length)
    );

    const stage = ex.stage;
    const stepIndex = ex.stepIndex;

    const line1 = "  " + sa.padStart(maxLen, " ");
    const padB = " ".repeat(Math.max(0, maxLen - sb.length));
    const line2 = `× ${padB}` + multiplierDigitsHTML(sb, stage, stepIndex);
    const sep = "—".repeat(maxLen + 2);

    const lines = [line1, line2, sep];

    if(stage === "direct"){
      // En mode direct : on montre la multiplication posée + une ligne résultat (placeholder)
      lines.push("  " + "·".repeat(maxLen));
      return lines.join("\n");
    }

    // Lignes partielles : on affiche celles déjà validées, puis des placeholders
    for(let i=0;i<digitsB.length;i++){
      const v = ex.partials[i];
      const txt = (typeof v === "number") ? String(v) : "·".repeat(maxLen);
      lines.push("  " + txt.padStart(maxLen, " "));
    }
    lines.push(sep);

    // Résultat final (placeholder tant que non validé)
    const resLine = (ex.stage === "final" && ex.solved) ? String(expected) : "·".repeat(maxLen);
    lines.push("  " + resLine.padStart(maxLen, " "));

    return lines.join("\n");
  }

  // ===== Tableau de multiplication (DANS l'abaque) =====
  // Affiche la multiplication posée + les lignes validées directement dans le grand tableau,
  // au-dessus de la zone où l'élève dépose ses jetons.
  // ===== Tableau de multiplication (DANS l’abaque) =====
  // Affiche la multiplication posée directement dans le grand tableau,
  // puis les lignes en "jetons" : celles déjà validées sont figées,
  // la ligne en cours reflète l’état actuel de l’abaque.
  // ===== Tableau de multiplication (DANS l’abaque) =====
  // Affiche la multiplication posée directement dans le grand tableau,
  // puis les lignes en "jetons" : celles déjà validées sont figées,
  // la ligne en cours reflète l’état actuel de l’abaque.
  
  function renderOpTable(){
    const colEls = [...document.querySelectorAll(".col")];
    if(colEls.length === 0) return;

    // Si pas d'exercice : on vide l'affichage de l'opération.
    if(!state.ex){
      for(let colIndex=0; colIndex<COL_COUNT; colIndex++){
        const calc = colEls[colIndex].querySelector(".colCalc");
        if(calc) calc.innerHTML = "";
      }
      return;
    }

    const ex = state.ex;
    const cfg = state.exCfg;

    const sa = String(ex.a);
    const sb = String(ex.b);
    const digitsBRev = sb.split("").map(ch => Number(ch)).reverse(); // unités -> ...

    // On pad à COL_COUNT pour aligner visuellement aux colonnes de l'abaque
    const aDigitsStr = sa.padStart(COL_COUNT, " ").slice(-COL_COUNT);
    const bDigitsStr = sb.padStart(COL_COUNT, " ").slice(-COL_COUNT);

    // Position du chiffre actif du multiplicateur (ligne du bas)
    // ex.stepIndex = 0 => unités (col la plus à droite)
    const focusIndexFromRight = (cfg.mode !== "direct" && ex.stage === "lines") ? ex.stepIndex : null;
    const focusPos = (typeof focusIndexFromRight === "number") ? (COL_COUNT - 1 - focusIndexFromRight) : null;

    function cellsForNumberStr(s, sign){
      return Array.from({length: COL_COUNT}, (_,i) => {
        const ch = s[i];
        const prefix = (sign && i === 0) ? `<span class="calcSign">${escapeHTML(sign)}</span>` : "";
        if(ch === " ") return prefix;
        // Mise en évidence seulement sur la ligne du bas (multiplicateur)
        let extra = "";
        if(sign === "×" && focusPos !== null){
          if(i === focusPos) extra = " focus";
          else if(i > focusPos) extra = " done";
        }
        return prefix + `<span class="calcDigit${extra}">${escapeHTML(ch)}</span>`;
      });
    }

    function cellsForSavedTokensLine(cols){
      const cells = Array(COL_COUNT).fill("");
      if(!cols) return cells;
      for(let i=0;i<COL_COUNT;i++){
        const arr = cols[i] || [];
        if(!arr.length) continue;
        cells[i] = miniPileHTML(arr.map(t => t.v));
      }
      return cells;
    }

    const rows = [];
    rows.push({cls:"hdr", cells: cellsForNumberStr(aDigitsStr, "")});
    rows.push({cls:"hdr", ruleAfter:true, cells: cellsForNumberStr(bDigitsStr, "×")});
    for(let colIndex=0; colIndex<COL_COUNT; colIndex++){
      const calc = colEls[colIndex].querySelector(".colCalc");
      calc.innerHTML = "";
      for(const row of rows){
        const r = document.createElement("div");
        r.className = "calcRow";
        if(row.ruleAfter) r.classList.add("ruleAfter");
        if(row.cls) r.classList.add(row.cls);
        r.innerHTML = row.cells[colIndex] || "";
        calc.appendChild(r);
      }
    }
  }

  function buildSolutionText(ex){
    const sa = String(ex.a);
    const sb = String(ex.b);
    const expected = ex.expected;

    const digitsB = sb.split("").map(ch => Number(ch)).reverse(); // unités -> ...
    const partialVals = digitsB.map((d, i) => ex.a * d * Math.pow(10, i));
    const maxLen = Math.max(
      sa.length,
      sb.length,
      String(expected).length,
      ...partialVals.map(v => String(v).length)
    );

    const lines = [];
    lines.push("  " + sa.padStart(maxLen, " "));
    lines.push("× " + sb.padStart(maxLen, " "));
    lines.push("—".repeat(maxLen + 2));
    partialVals.forEach(v => lines.push("  " + String(v).padStart(maxLen, " ")));
    lines.push("—".repeat(maxLen + 2));
    lines.push("  " + String(expected).padStart(maxLen, " "));
    return lines.join("\n");
  }

  function setPillsActive(){
    const cfg = state.exCfg;

    document.querySelectorAll(".pill[data-mode]").forEach(b=>{
      b.classList.toggle("active", b.dataset.mode === cfg.mode);
    });
    document.querySelectorAll(".pill[data-adigits]").forEach(b=>{
      b.classList.toggle("active", Number(b.dataset.adigits) === cfg.aDigits);
    });
    document.querySelectorAll(".pill[data-bdigits]").forEach(b=>{
      b.classList.toggle("active", Number(b.dataset.bdigits) === cfg.bDigits);
    });
    document.querySelectorAll(".pill[data-carry]").forEach(b=>{
      b.classList.toggle("active", b.dataset.carry === cfg.carry);
    });
    document.querySelectorAll(".pill[data-zeros]").forEach(b=>{
      const isOn = (b.dataset.zeros === "on");
      b.classList.toggle("active", isOn === cfg.zeros);
    });
  }

  function updateExerciseUI(){
    if(!state.ex) return;

    const ex = state.ex;
    const cfg = state.exCfg;

    // Sous-titre + texte d'aide
    if(cfg.mode === "direct"){
      exSub.textContent = `Direct • ${ex.a} × ${ex.b}`;
    }else if(ex.stage === "lines"){
      const sb = String(ex.b);
      const digitsB = sb.split("").map(ch => Number(ch)).reverse();
      const d = digitsB[ex.stepIndex];
      exSub.textContent = `Étape ${ex.stepIndex+1}/${digitsB.length} • ×${d} (${placeNameForStep(ex.stepIndex)})`;
    }else{
      exSub.textContent = "Somme finale • additionne les lignes puis valide";
    }

    // Bouton principal
    if(cfg.mode === "direct" || ex.stage === "final"){
      btnExCheck.textContent = "Valider résultat";
    }else{
      btnExCheck.textContent = "Valider ligne";
    }
    // Libellé du bouton "Valider" selon le mode / l'étape
    if(btnExCheck){
      if(cfg.mode === "direct"){
        btnExCheck.textContent = "Valider le produit";
      }else if(ex.stage === "lines"){
        btnExCheck.textContent = "Valider la ligne";
      }else{
        btnExCheck.textContent = (ex.solved ? "✅ Terminé" : "Valider la somme");
      }
    }

    // Problème (HTML pour la mise en évidence des chiffres)
    // Multiplication posée affichée dans le tableau (en haut)
    exProblem.innerHTML = "";
    renderOpTable();

    // Solution (vide tant qu’on ne veut pas l’afficher)
    // exResult est utilisé comme "solution" après une erreur, sinon on le laisse vide.
    if(!exResult.dataset.keep){
      exResult.textContent = "";
      exResult.className = "exResult";
    }

    // État du bouton valider (retient/échange)
    updateExCheckBtnState();
  }

  function newExercise(){
    if(state.exchange) exitExchange();

    // clamp selon colonnes visibles
    const maxD = visibleDigitsCount();
    state.exCfg.aDigits = Math.min(state.exCfg.aDigits, maxD);
    state.exCfg.bDigits = Math.min(state.exCfg.bDigits, maxD);

    const {a, b, expected} = generateMultiplication();

    clearBoardHard();

    const stage = (state.exCfg.mode === "direct") ? "direct" : "lines";
    state.ex = {
      a, b, expected,
      stage,
      stepIndex: 0,
      partials: [],
      partialCols: [],
      partialDigits: [],
      solved: false,
      snapshotCols: deepCopyCols(state.cols),
      snapshotBin: deepCopyBin(state.bin),
      nextIdSnapshot: state.nextId
    };

    exFeedback.textContent = "";
    exFeedback.className = "exFeedback";
    clearExerciseSolution();
    if(exResult) exResult.dataset.keep = "";

    render();
    updateExerciseUI();
    clearUndo();
  }

  function resetExercise(){
    if(!state.ex) return;
    if(state.exchange) exitExchange();

    state.cols = deepCopyCols(state.ex.snapshotCols);
    state.bin  = deepCopyBin(state.ex.snapshotBin);
    state.nextId = state.ex.nextIdSnapshot;
    state.exchange = null;

    // reset étapes
    if(state.exCfg.mode === "direct"){
      state.ex.stage = "direct";
      state.ex.solved = false;
    }else{
      state.ex.stage = "lines";
      state.ex.stepIndex = 0;
      state.ex.partials = [];
      state.ex.partialCols = [];
      state.ex.partialDigits = [];
      state.ex.solved = false;
    }

    exFeedback.textContent = "";
    exFeedback.className = "exFeedback";
    clearExerciseSolution();
    if(exResult) exResult.dataset.keep = "";

    render();
    updateExerciseUI();
    clearUndo();
  }

  function checkExercise(){
    if(!state.ex) return;

    if(state.exchange){
      exFeedback.textContent = "Termine d’abord l’échange (Valider/Annuler).";
      exFeedback.className = "exFeedback no";
      exerciseCard.classList.add("shake");
      setTimeout(() => exerciseCard.classList.remove("shake"), 280);
      return;
    }

    // On refuse la validation si des échanges restent à faire.
    const pending = pendingExchangeCols();
    if(pending.length){
      exFeedback.textContent = "❗ Fais les échanges avant de valider.";
      exFeedback.className = "exFeedback no";
      exerciseCard.classList.add("shake");
      setTimeout(() => exerciseCard.classList.remove("shake"), 280);
      return;
    }

    const ex = state.ex;
    const cfg = state.exCfg;
    const val = (cfg.mode !== "direct" && ex.stage === "lines") ? totalValue(t => t.line == null) : totalValue();

    // Nettoie l'affichage "solution" par défaut
    exResult.textContent = "";
    exResult.className = "exResult";
    exResult.dataset.keep = "";

    // Mode direct : on valide directement le produit
    if(cfg.mode === "direct" || ex.stage === "direct"){
      if(val === ex.expected){
        ex.solved = true;
        exFeedback.textContent = "✅ Bonne réponse !";
        exFeedback.className = "exFeedback ok";
      }else{
        exFeedback.textContent = "❌ Mauvaise réponse… On recommence.";
        exFeedback.className = "exFeedback no";
        exResult.textContent = buildSolutionText(ex);
        exResult.className = "exResult show";
        exResult.dataset.keep = "1";

        exerciseCard.classList.add("shake");
        setTimeout(() => exerciseCard.classList.remove("shake"), 280);
        setTimeout(() => resetExercise(), 900);
      }
      updateExerciseUI();
      return;
    }

    // Étapes (lignes)
    const sb = String(ex.b);
    const digitsB = sb.split("").map(ch => Number(ch)).reverse(); // unités -> ...
    
    if(ex.stage === "lines"){
      const d = digitsB[ex.stepIndex];
      const expectedLine = ex.a * d * Math.pow(10, ex.stepIndex);

      if(val === expectedLine){
        ex.partials[ex.stepIndex] = expectedLine;

        // ✅ On fige les jetons de la ligne courante (sans les effacer)
        freezeCurrentLineTokens(ex.stepIndex);

        ex.stepIndex += 1;

        if(ex.stepIndex >= digitsB.length){
          ex.stage = "final";
          // ✅ On déverrouille tout pour faire la somme finale
          setFrozenAll(false);
          ex.solved = false;
          exFeedback.textContent = "✅ Lignes terminées. Fais maintenant la somme finale (échanges).";
          exFeedback.className = "exFeedback ok";
        }else{
          exFeedback.textContent = "✅ Ligne verrouillée. Passe à la suivante.";
          exFeedback.className = "exFeedback ok";
        }

        render();
        updateExerciseUI();
        clearUndo();
        return;
      }else{
        exFeedback.textContent = "❌ Ce n’est pas la bonne ligne.";
        exFeedback.className = "exFeedback no";
        exerciseCard.classList.add("shake");
        setTimeout(() => exerciseCard.classList.remove("shake"), 280);
        return;
      }
    }

    // Somme finale
    if(ex.stage === "final"){
      if(val === ex.expected){
        ex.solved = true;
        exFeedback.textContent = "✅ Bonne réponse !";
        exFeedback.className = "exFeedback ok";
        updateExerciseUI();
      }else{
        exFeedback.textContent = "❌ Mauvaise réponse… On recommence.";
        exFeedback.className = "exFeedback no";
        exResult.textContent = buildSolutionText(ex);
        exResult.className = "exResult show";
        exResult.dataset.keep = "1";

        exerciseCard.classList.add("shake");
        setTimeout(() => exerciseCard.classList.remove("shake"), 280);

        setTimeout(() => resetExercise(), 900);
      }
    }
  }

  function applyTopUI(){
    if(btnBigValue) btnBigValue.textContent = "Affichage : " + (state.showBigValue ? "ON" : "OFF");
    btnColValues.textContent = "Valeurs : " + (state.showColValues ? "ON" : "OFF");
    btnMillions.textContent = "Millions : " + (state.showMillions ? "ON" : "OFF");
document.body.classList.toggle("noMillions", !state.showMillions);
    document.body.classList.toggle("withMillions", state.showMillions);
    document.body.classList.add("noArches");
bigValueOutside.style.display = state.showBigValue ? "flex" : "none";
    if(state.showBigValue) bigValueOutside.textContent = formatGrouped(totalValue());

    document.querySelectorAll(".colValueTop").forEach(el => {
      el.style.display = state.showColValues ? "block" : "none";
    });
  }

  function buildBoard(){
    board.innerHTML = "";
    for(let i=0;i<COL_COUNT;i++){
      if(i>0 && (i % 3 === 0)){
        const sep = document.createElement("div");
        sep.className = "groupSep";
        sep.dataset.boundary = String(i/3);
        board.appendChild(sep);
      }

      const col = document.createElement("div");
      col.className = "col";
      col.dataset.colIndex = String(i);
      col.dataset.group = String(Math.floor(i/3));


      const head = document.createElement("div");
      head.className = "colHeader";

      const lab = document.createElement("div");
      lab.className = "colLabel";
      lab.textContent = LABELS[i % 3];

      const valTop = document.createElement("div");
      valTop.className = "colValueTop";
      valTop.textContent = placeValueShort(i);

      head.appendChild(lab);
      head.appendChild(valTop);

      const calc = document.createElement("div");
      calc.className = "colCalc";

      const body = document.createElement("div");
      body.className = "colBody";

      col.appendChild(head);
      col.appendChild(calc);
      col.appendChild(body);

      board.appendChild(col);
    }
  }

  function positionResolveBar(){
    if(!trashZone || !resolveBar) return;
    const tz = trashZone.getBoundingClientRect();

    // #resolveBar est en position: fixed -> coordonnées viewport
    const vw = window.innerWidth || document.documentElement.clientWidth;
    const vh = window.innerHeight || document.documentElement.clientHeight;

    // On force la même largeur que la Zone d’échange
    const targetW = Math.max(120, Math.min(tz.width, vw - 16));
    resolveBar.style.width = targetW + "px";

    // Mesure après width
    const barH = resolveBar.offsetHeight || 60;

    let left = tz.left;
    // si la zone est trop à droite (petits écrans), on clamp
    left = Math.max(8, Math.min(left, vw - targetW - 8));

    let top = tz.top - barH - 10;
    top = Math.max(8, Math.min(top, vh - barH - 8));

    resolveBar.style.left = left + "px";
    resolveBar.style.top  = top + "px";
    resolveBar.style.right = "auto";
  }


  function positionExerciseCard(){
  if(!exerciseCard || !trashZone) return;

  const tz = trashZone.getBoundingClientRect();
  const vw = window.innerWidth || document.documentElement.clientWidth;
  const vh = window.innerHeight || document.documentElement.clientHeight;
  const headerH = document.querySelector("header")?.getBoundingClientRect().height || 0;

  // même largeur que la zone d’échange
  const targetW = Math.max(220, Math.min(tz.width, vw - 16));
  exerciseCard.style.width = targetW + "px";

  // mesure après width
  const cardH = exerciseCard.offsetHeight || 140;

  let left = tz.left;
  left = Math.max(8, Math.min(left, vw - targetW - 8));

  // ✅ Sur tablette : on fixe la carte sous l’en-tête, et la Zone d’échange se place en dessous.
  let top = headerH + 10;
  top = Math.max(headerH + 10, Math.min(top, vh - cardH - 8));

  exerciseCard.style.left = left + "px";
  exerciseCard.style.top  = top + "px";
  exerciseCard.style.right = "auto";
}


  
function setReserveRight(px){
  const v = (px || 0) + "px";
  board.style.right = v;
  if(boardTopEl) boardTopEl.style.right = v;
  if(retLayerEl) retLayerEl.style.right = v;
}

function positionTrashZone(){
  if(!trashZone) return;
  const wrapRect = boardWrap.getBoundingClientRect();

  // ✅ En mode DIRECT : la Zone d’échange devient une grande zone en BAS (plein largeur),
  // ce qui réutilise tout l’espace "vide" sous les colonnes et améliore l’usage tablette.
  const isDirect = document.body.classList.contains("directMul");

  // ✅ Sur tablette / écran étroit : on dock la Zone d’échange en bas.
  // Sur écran large (PC), on garde la Zone d’échange à droite (comportement habituel).
  const vw = window.innerWidth || document.documentElement.clientWidth;
  const dockBottom = isDirect && vw <= 980;

  // uniquement les colonnes visibles (utile quand on masque "Millions")
  const cols = [...document.querySelectorAll(".col")].filter(c => c.offsetParent !== null);

  if(dockBottom){
    // On libère la droite : les colonnes peuvent prendre toute la largeur
    setReserveRight(0);
    void board.offsetWidth;

    // Bas des colonnes (contenu utile) -> la zone commence juste en dessous
    let contentBottom = 120;
    if(cols.length){
      contentBottom = Math.max(...cols.map(c => c.getBoundingClientRect().bottom)) - wrapRect.top;
    }

    let top = contentBottom + 10;

    // Sous la carte exercice, si elle est affichée
    if(exerciseCard && exerciseCard.style.display !== "none"){
      const cr = exerciseCard.getBoundingClientRect();
      const minTop = (cr.bottom - wrapRect.top) + 12;
      top = Math.max(top, minTop);
    }

    // clamp pour garantir une zone utilisable
    const maxTop = Math.max(6, wrapRect.height - 120 - 10);
    top = Math.min(top, maxTop);

    const left = 10;
    const width = Math.max(180, wrapRect.width - 20);
    const height = Math.max(120, (wrapRect.height - top) - 10);

    trashZone.style.left = left + "px";
    trashZone.style.top  = top + "px";
    trashZone.style.width = width + "px";
    trashZone.style.height = height + "px";
    return;
  }

  // --- Mode "classique" (non direct) : zone à droite ---
  // Choix largeur de zone (un peu plus étroite quand Millions ON)
  const zoneW = state.showMillions
    ? Math.max(160, Math.min(260, Math.round(wrapRect.width * 0.19)))
    : Math.max(180, Math.min(300, Math.round(wrapRect.width * 0.22)));

  // ✅ On réserve à droite AVANT de mesurer la position des colonnes
  setReserveRight(zoneW + 10);
  // force un reflow pour que les mesures soient cohérentes
  void board.offsetWidth;

  if(cols.length === 0) return;
  const last = cols[cols.length - 1].getBoundingClientRect();

  // top aligné sur les colonnes
  let top  = (last.top - wrapRect.top) + 6;

  // ✅ La carte Exercice est en haut à droite : on met la Zone d’échange EN DESSOUS (sinon ça se superpose)
  if(exerciseCard && exerciseCard.style.display !== "none"){
    const cr = exerciseCard.getBoundingClientRect();
    const minTop = (cr.bottom - wrapRect.top) + 12;
    top = Math.max(top, minTop);
  }

  // clamp pour garantir une zone utilisable
  const maxTop = Math.max(6, wrapRect.height - 120 - 10);
  top = Math.min(top, maxTop);

  // Zone d'échange à droite, largeur fixe
  const left  = wrapRect.width - zoneW - 10;
  const height = Math.max(120, (wrapRect.height - top) - 10);

  trashZone.style.left = left + "px";
  trashZone.style.top  = top + "px";
  trashZone.style.width = zoneW + "px";
  trashZone.style.height = height + "px";
}
  window.addEventListener("resize", () => { positionTrashZone(); if(state.exchange){ positionResolveBar(); } positionExerciseCard(); });
  window.addEventListener("scroll", () => { positionTrashZone(); if(state.exchange){ positionResolveBar(); } positionExerciseCard(); }, {passive:true});

  function renderBin(){
    if(!binTokens) return;
    binTokens.innerHTML = "";
    binTokens.classList.toggle('overlap', state.bin.length >= 4);
    for(const tok of state.bin){
      const el = makeTokenEl(tok.v);
      el.dataset.source = "bin";
      el.dataset.id = String(tok.id);
      binTokens.appendChild(el);
      enableDrag(el, {type:"bin", id:tok.id});
    }
  }

  function tokenById(colIndex, id){
    return state.cols[colIndex].find(t => t.id === id) || null;
  }
  function binTokenById(id){
    return state.bin.find(t => t.id === id) || null;
  }

  function isColAllowed(colIndex){
    // ✅ Échange libre : toutes les colonnes sont autorisées
    return true;
  }

  function isTokenDraggable(fromType, colIndex, tok){
    if(!state.exchange) return true;
    if(fromType === "bin") return true;

    // ✅ ÉCHANGE LIBRE (transaction globale) :
    // si l'échange a été déclenché par dépôt dans la zone (startFreeExchange),
    // on ne bride RIEN : on peut déplacer autant de jetons que l'on veut, de n'importe où,
    // puis valider/rollback en une fois.
    if(typeof state.exchange.focusCol !== "number" || typeof state.exchange.leftCol !== "number"){
      return true;
    }

    // Mode ancien (échange guidé colonne N <-> N-1) : on conserve la logique de verrouillage.
    const {focusCol, leftCol, leftBaseIds} = state.exchange;

    if(colIndex === focusCol) return true;

    // colonne de gauche : on bloque uniquement les jetons qui étaient déjà là au départ
    if(colIndex === leftCol){
      return !(leftBaseIds && leftBaseIds.has(tok.id));
    }

    return false;
  }

  function render(){
    // ✅ Important : on applique d'abord l'état d'affichage (classe noMillions)
    // afin que les calculs de position (getBoundingClientRect) se fassent
    // sur la mise en page réellement visible.
    applyTopUI();
    const colEls = [...document.querySelectorAll(".col")];

    for(const colEl of colEls){
      const i = Number(colEl.dataset.colIndex);
      const body = colEl.querySelector(".colBody");
      body.innerHTML = "";

      const lineMode = !!(state.ex && state.exCfg && state.exCfg.mode !== "direct" && state.ex.stage === "lines");

      if(lineMode){
        body.classList.add("lineMode");

        const ex = state.ex;
        const digitsB = String(ex.b).split("");
        const lineCount = digitsB.length;
        const activeLine = ex.stepIndex;

        // 1) Création des "cases" fixes (une par ligne de produit partiel)
        const slots = [];
        for(let li=0; li<lineCount; li++){
          const slot = document.createElement("div");
          slot.className = "lineSlot";
          slot.dataset.line = String(li);
          if(li < activeLine) slot.classList.add("lockedRow");
          if(li === activeLine) slot.classList.add("activeRow");
          body.appendChild(slot);
          slots.push(slot);
        }

        // 2) Répartition des jetons par ligne : évite que les chiffres de la 2e ligne
        //    "remontent" quand la 1re ligne est vide dans une colonne.
        const groups = Array.from({length: lineCount}, () => []);
        for(const tok of state.cols[i]){
          let li = (tok.line == null) ? activeLine : tok.line;
          if(typeof li !== "number" || li < 0 || li >= lineCount) li = activeLine;
          groups[li].push(tok);
        }

        // 3) Rendu : jetons superposés dans la case, mais la case garde une hauteur fixe
        for(let li=0; li<lineCount; li++){
          const arr = groups[li];
          const slot = slots[li];
          const n = arr.length;

          for(let k=0; k<n; k++){
            const tok = arr[k];
            const el = makeTokenEl(tok.v);
            el.dataset.id = String(tok.id);
            el.dataset.source = "col";
            el.dataset.colIndex = String(i);

            if(state.exchange){
              const draggable = isTokenDraggable("col", i, tok);
              el.classList.toggle("locked", !draggable);
              // Repère visuel : uniquement les jetons présents AU DÉPART dans la colonne cliquée
              if(i === state.exchange.focusCol && state.exchange.focusIds && state.exchange.focusIds.has(tok.id)){
                el.classList.add("focusSeed");
              }
              if(i === state.exchange.leftCol && state.exchange.leftBaseIds && state.exchange.leftBaseIds.has(tok.id)){
                el.classList.add("leftSeed");
              }
            } else {
              el.classList.remove("locked","focusSeed","leftSeed");
            }

            if(tok.frozen){ el.classList.add("frozen"); }

            // Superposition légère si plusieurs jetons dans la même case (avant échanges)
            const offset = (n <= 1) ? 0 : (k - (n - 1) / 2) * 8;
            el.style.transform = `translate(-50%, -50%) translateY(${offset}px)`;

            slot.appendChild(el);
            enableDrag(el, {type:"col", colIndex:i, id:tok.id});
          }
        }
      }else{
        body.classList.remove("lineMode");

        // Mode direct : pile compacte (comme les cases en mode étapes)
        const pile = document.createElement("div");
        pile.className = "pileSlot";
        body.appendChild(pile);

        const arr = state.cols[i];
        const n = arr.length;

        for(let k=0; k<n; k++){
          const tok = arr[k];
          const el = makeTokenEl(tok.v);
          el.dataset.id = String(tok.id);
          el.dataset.source = "col";
          el.dataset.colIndex = String(i);

          if(state.exchange){
            const draggable = isTokenDraggable("col", i, tok);
            el.classList.toggle("locked", !draggable);
            if(i === state.exchange.focusCol && state.exchange.focusIds && state.exchange.focusIds.has(tok.id)){
              el.classList.add("focusSeed");
            }
            if(i === state.exchange.leftCol && state.exchange.leftBaseIds && state.exchange.leftBaseIds.has(tok.id)){
              el.classList.add("leftSeed");
            }
          } else {
            el.classList.remove("locked","focusSeed","leftSeed");
          }

          if(tok.frozen){ el.classList.add("frozen"); }

          // Superposition : même logique que dans le fichier "étapes" (pile centrée)
          const offset = (n <= 1) ? 0 : (k - (n - 1) / 2) * 8;
          el.style.transform = `translate(-50%, -50%) translateY(${offset}px)`;
          el.style.zIndex = String(100 + k);

          pile.appendChild(el);
          enableDrag(el, {type:"col", colIndex:i, id:tok.id});
        }
}

      colEl.classList.toggle("has2", state.cols[i].length >= 2);

      colEl.classList.toggle("noEx", (!state.showMillions && i === 3));

      if(state.exchange){
        // ✅ Échange libre : on ne grise pas / on ne verrouille rien
        colEl.classList.remove("locked","focus");
      }else{
        colEl.classList.remove("locked","focus");
      }
    }    renderBin();

    // Tableau de multiplication dans l'abaque
    renderOpTable();

    // ✅ Mise en page en 2 passes :
    // 1) on positionne la Zone d’échange (pour connaître largeur/left)
    // 2) on positionne la carte Exercice
    // 3) on repositionne la Zone d’échange sous la carte (sinon superposition)
    positionTrashZone();
    positionExerciseCard();
    positionTrashZone();
    positionResolveBar();
    positionExerciseCard();

    applyExchangeUI();
    updateUndoBtn();
    updateExCheckBtnState();
  }

  function isOverTrash(x,y){
    if(!trashZone) return false;
    const r = trashZone.getBoundingClientRect();
    return x>=r.left && x<=r.right && y>=r.top && y<=r.bottom;
  }
  function setTrashActive(on){
    if(!trashZone) return;
    trashZone.classList.toggle("active", !!on);
  }

  function enableDrag(el, from){
    el.onpointerdown = (e) => {
      if(e.button !== 0 && e.pointerType !== "touch") return;
      e.preventDefault();

      const rect = el.getBoundingClientRect();
      const v = Number(el.dataset.value);

      let dragEl;
      let tokenId = null;
      let originalEl = null;

      if(from.type === "tray"){
        dragEl = makeTokenEl(v);
        dragEl.style.position = "fixed";
        dragEl.style.left = rect.left + "px";
        dragEl.style.top = rect.top + "px";
        dragEl.style.zIndex = 1000;
        dragEl.style.pointerEvents = "none";
        document.body.appendChild(dragEl);
      } else if(from.type === "col"){
        tokenId = Number(el.dataset.id);
        const tok = tokenById(from.colIndex, tokenId);
        if(!tok) return;
        if(state.exchange && !isTokenDraggable("col", from.colIndex, tok)) return;

        dragEl = makeTokenEl(v);
        dragEl.style.position = "fixed";
        dragEl.style.left = rect.left + "px";
        dragEl.style.top = rect.top + "px";
        dragEl.style.zIndex = 1000;
        dragEl.style.pointerEvents = "none";
        document.body.appendChild(dragEl);

        originalEl = el;
        originalEl.style.visibility = "hidden";
      } else { // bin
        tokenId = Number(el.dataset.id);
        const tok = binTokenById(tokenId);
        if(!tok) return;

        dragEl = makeTokenEl(v);
        dragEl.style.position = "fixed";
        dragEl.style.left = rect.left + "px";
        dragEl.style.top = rect.top + "px";
        dragEl.style.zIndex = 1000;
        dragEl.style.pointerEvents = "none";
        document.body.appendChild(dragEl);

        originalEl = el;
        originalEl.style.visibility = "hidden";
      }

      state.dragging = {
        el: dragEl,
        v,
        id: tokenId,
        from,
        originalEl,
        offsetX: e.clientX - rect.left,
        offsetY: e.clientY - rect.top
      };

      el.setPointerCapture?.(e.pointerId);
      window.addEventListener("pointermove", onMove, {passive:false});
      window.addEventListener("pointerup", onUp, {passive:false});
    };
  }

  function onMove(e){
    if(!state.dragging) return;
    e.preventDefault();
    const d = state.dragging;
    d.el.style.left = (e.clientX - d.offsetX) + "px";
    d.el.style.top  = (e.clientY - d.offsetY) + "px";
    setTrashActive(isOverTrash(e.clientX, e.clientY));
  }

  function findDropColumn(x,y){
    const cols = [...document.querySelectorAll(".col")];
    for(const col of cols){
      const rect = col.getBoundingClientRect();
      if(x>=rect.left && x<=rect.right && y>=rect.top && y<=rect.bottom){
        const idx = Number(col.dataset.colIndex);
        if(state.exchange && !isColAllowed(idx)) return null;
        return idx;
      }
    }
    return null;
  }

  function addTokenToCol(colIndex, v){
    state.cols[colIndex].push({id: state.nextId++, v, line: null, frozen:false});
  }
  function removeToken(fromCol, id){
    const arr = state.cols[fromCol];
    const k = arr.findIndex(t => t.id === id);
    if(k >= 0) return arr.splice(k,1)[0];
    return null;
  }
  function moveToken(fromCol, toCol, id){
    const tok = removeToken(fromCol, id);
    if(tok) state.cols[toCol].push(tok);
  }
  function removeTokenFromBin(id){
    const k = state.bin.findIndex(t => t.id === id);
    if(k >= 0) return state.bin.splice(k,1)[0];
    return null;
  }

  function onUp(e){
    if(!state.dragging) return;
    e.preventDefault();

    const d = state.dragging;
    const overBin = isOverTrash(e.clientX, e.clientY);
    const dropCol = overBin ? null : findDropColumn(e.clientX, e.clientY);

    let didChange = false;

    if(dropCol !== null){
      if(d.from.type === "tray"){
        pushUndo();
        addTokenToCol(dropCol, d.v);
        didChange = true;
      } else if(d.from.type === "col"){
        if(d.from.colIndex !== dropCol){
          pushUndo();
          moveToken(d.from.colIndex, dropCol, d.id);
          didChange = true;
        }
      } else { // bin -> col
        pushUndo();
        const tok = removeTokenFromBin(d.id);
        if(tok){
          state.cols[dropCol].push(tok);
          didChange = true;
        }
      }
    } else if(overBin){
      if(d.from.type === "col"){
        // ✅ Démarre l'échange libre au premier dépôt dans la zone
        if(!state.exchange) startFreeExchange();

        pushUndo();
        const tok = removeToken(d.from.colIndex, d.id);
        if(tok){
          state.bin.push(tok);
          didChange = true;
        }
      }
    } else {
      if(d.from.type === "col"){
        if(!state.exchange){
          pushUndo();
          removeToken(d.from.colIndex, d.id);
          didChange = true;
        }
      }
    }

    d.el.remove();
    setTrashActive(false);

    if(!didChange && d.originalEl){
      d.originalEl.style.visibility = "";
    }

    state.dragging = null;
    window.removeEventListener("pointermove", onMove);
    window.removeEventListener("pointerup", onUp);

    render();
  }

  function applyExchangeUI(){
    // ✅ Échange libre : pas d'écran gris / pas de verrouillage du plateau
    overlay.style.display = "none";

    if(!state.exchange){
      resolveBar.style.display = "none";
      btnExitResolve.style.display = "none";
      return;
    }

    resolveBar.style.display = "flex";
    btnExitResolve.style.display = "inline-flex";

    // Position once measurable (prevents weird placement)
    resolveBar.style.visibility = "hidden";
    requestAnimationFrame(() => {
      positionTrashZone();
      positionResolveBar();
      positionExerciseCard();
      resolveBar.style.visibility = "visible";
    });
  }

  
  function startFreeExchange(){
    if(state.exchange) return;

    state.exchange = {
      snapshotCols: deepCopyCols(state.cols),
      snapshotBin: deepCopyBin(state.bin),
      nextIdSnapshot: state.nextId
    };

    resolveTxt.textContent =
      "Échange libre : dépose n'importe quels jetons dans la Zone d’échange (à droite), " +
      "fais tes échanges (dans une ou plusieurs colonnes), puis clique « Valider l’échange ».";
  }

function enterExchange(focusCol){
    const leftCol = focusCol - 1;
    if(leftCol < 0) return;
    if(state.exchange) return;

    // ✅ Si "Millions" est masqué, on empêche l’échange qui aurait besoin d’une colonne invisible (col 3 -> col 2)
    if(!state.showMillions && leftCol < 3) return;

    state.exchange = {
      focusCol,
      leftCol,
      focusIds: new Set(state.cols[focusCol].map(t=>t.id)),
      leftBaseIds: new Set(state.cols[leftCol].map(t=>t.id)),
      snapshotCols: deepCopyCols(state.cols),
      snapshotBin: deepCopyBin(state.bin),
      nextIdSnapshot: state.nextId
    };

    resolveTxt.textContent =
      "Échange : dépose dans la zone d’échange (à droite) les jetons que tu remplaces, puis place les nouveaux jetons dans les 2 colonnes. " +
      "Clique « Valider l'échange » quand tu as fini.";

    render();
  }

  function rollbackExchange(){
    const snap = state.exchange;
    state.cols = deepCopyCols(snap.snapshotCols);
    state.bin  = deepCopyBin(snap.snapshotBin);
    state.nextId = snap.nextIdSnapshot;
    state.exchange = null;
    render();
  }

  function twoColValue(cols, leftCol, focusCol){
    const a = cols[leftCol].reduce((s,t)=>s+t.v,0) * placeValue(leftCol);
    const b = cols[focusCol].reduce((s,t)=>s+t.v,0) * placeValue(focusCol);
    return a+b;
  }

  function validateExchange(){
    if(!state.exchange) return;

    const {snapshotCols} = state.exchange;

    const totalOf = (cols) => {
      let total = 0;
      for(let i=0;i<COL_COUNT;i++){
        const s = cols[i].reduce((a,t)=>a+t.v,0);
        total += s * placeValue(i);
      }
      return total;
    };

    const before = totalOf(snapshotCols);
    const after  = totalOf(state.cols);

    const changed = JSON.stringify(state.cols) !== JSON.stringify(snapshotCols);

    // ✅ Échange libre : on valide si la valeur totale du plateau est conservée
    // (on autorise les échanges en plusieurs étapes ; la normalisation est vérifiée au moment de "Valider" l'exercice)
    if(after === before && changed){
      pushUndo();
      state.bin = [];
      state.exchange = null;
      render();
      return;
    }

    resolveBar.classList.add("shake");
    setTimeout(() => resolveBar.classList.remove("shake"), 280);
    rollbackExchange();
  }

  function exitExchange(){
    if(!state.exchange) return;
    rollbackExchange();
  }

  // ✅ Exercices : boutons + réglages
  btnExNew.addEventListener("click", () => newExercise());
  btnExReset.addEventListener("click", () => resetExercise());
  btnExCheck.addEventListener("click", () => checkExercise());
  btnExSettings.addEventListener("click", () => {
    const on = (exSettings.style.display !== "none");
    exSettings.style.display = on ? "none" : "flex";

    // ✅ IMPORTANT : ouvrir/fermer les réglages change la hauteur de la carte Exercice.
    // La Zone d’échange est positionnée *en dessous* de cette carte (minTop = cr.bottom).
    // Donc il faut recalculer immédiatement la Zone d’échange (sinon elle reste petite
    // jusqu’au prochain déplacement d’un jeton qui déclenche render()).
    const relayout = () => {
      positionExerciseCard();
      positionTrashZone();
      if(state.exchange) positionResolveBar();
    };

    // On le fait sur 2 frames pour être sûr que le navigateur a appliqué le nouveau layout.
    requestAnimationFrame(() => {
      relayout();
      requestAnimationFrame(relayout);
    });
  });

  document.querySelectorAll(".pill").forEach(btn => {
    btn.addEventListener("click", () => {
      if(btn.dataset.mode)    state.exCfg.mode    = btn.dataset.mode;
      if(btn.dataset.adigits) state.exCfg.aDigits = Number(btn.dataset.adigits);
      if(btn.dataset.bdigits) state.exCfg.bDigits = Number(btn.dataset.bdigits);
      if(btn.dataset.carry)   state.exCfg.carry   = btn.dataset.carry;
      if(btn.dataset.zeros)   state.exCfg.zeros   = (btn.dataset.zeros === "on");
      setPillsActive();
      newExercise();
    });
  });


  // Buttons
  btnUndo.addEventListener("click", () => undo());

  btnClear.addEventListener("click", () => {
    pushUndo();
    state.cols = Array.from({length: COL_COUNT}, () => []);
    state.bin = [];
    state.exchange = null;
    state.nextId = 1;
    render();
    clearUndo();
  });

  if(btnBigValue){
    btnBigValue.addEventListener("click", () => {
      pushUndo();
      state.showBigValue = !state.showBigValue;
      render();
    });
  }
  btnColValues.addEventListener("click", () => {
    pushUndo();
    state.showColValues = !state.showColValues;
    render();
  });


btnMillions.addEventListener("click", () => {
  // si on est en mode échange, on sort proprement avant de changer la vue
  if(state.exchange) exitExchange();
  pushUndo();
  state.showMillions = !state.showMillions;
  render();

  // ✅ Important : la mise en page (colonnes affichées/masquées + réserves à droite)
  // peut être appliquée "après" ce render() côté navigateur.
  // On recalcule donc les positions au prochain frame pour éviter que la Zone d’échange
  // reste à l’ancienne place jusqu’au prochain déplacement d’un jeton.
  requestAnimationFrame(() => {
    positionTrashZone();
    positionResolveBar();
    positionExerciseCard();
  });
});

  btnValidate.addEventListener("click", validateExchange);
  btnCancel.addEventListener("click", exitExchange);
  btnExitResolve.addEventListener("click", exitExchange);

  btnFullscreen.addEventListener("click", async () => {
    try{
      if(!document.fullscreenElement){
        await document.documentElement.requestFullscreen();
      }else{
        await document.exitFullscreen();
      }
    }catch(e){}
  });

  buildBoard();
  renderTray();
  clearUndo();

  // ✅ Exercice affiché dès l’ouverture
  setPillsActive();
  newExercise();

  // ✅ Stabilisation des positions (tablette / resize)
  requestAnimationFrame(() => {
    positionExerciseCard();
    positionTrashZone();
    positionResolveBar();
    requestAnimationFrame(() => {
      positionExerciseCard();
      positionTrashZone();
      positionResolveBar();
    });
  });

})();
</script>


</body>
</html>
