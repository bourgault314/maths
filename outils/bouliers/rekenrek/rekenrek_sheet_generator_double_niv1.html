<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>GÉNÉRATEUR REKENREK — COMPLET</title>
  <style>
    :root {
      --ink: #111827;
      --sub: #94a3b8;
      --bg: #f8fafc;
      --panel: #ffffff;
      --accent: #2563eb;
      --border: #cbd5e1;
      --grid-line: #d9d9d9; 
      --ok: #16a34a;
      
      --page-w: 210mm;
      --page-h: 297mm;
      --page-margin-top: 10mm;
      --page-margin-bot: 20mm;
      --page-margin-x: 10mm;
      
      --cols: 5;
      --rows: 6;
    }
    
    * { box-sizing: border-box; }
    body { margin: 0; font-family: 'Segoe UI', system-ui, sans-serif; background: var(--bg); color: var(--ink); display: flex; height: 100vh; overflow: hidden; }

    /* --- SIDEBAR --- */
    aside {
      width: 360px;
      background: var(--panel);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      z-index: 10;
      box-shadow: 2px 0 10px rgba(0,0,0,0.05);
    }

    .sb-header { padding: 15px 20px; border-bottom: 1px solid var(--border); background: #fff; }
    .sb-title { font-size: 18px; font-weight: 800; color: var(--accent); margin: 0; text-transform: uppercase; }
    
    .sb-scroll { flex: 1; overflow-y: auto; padding: 20px; display: flex; flex-direction: column; gap: 20px; }
    
    .section { }
    .sec-title { font-size: 11px; text-transform: uppercase; color: #64748b; font-weight: 800; margin-bottom: 8px; border-bottom: 2px solid #f1f5f9; padding-bottom: 4px; }
    
    .control { display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px; font-size: 13px; font-weight: 600; }
    .control label { flex: 1; color: #334155; }
    
    select, input[type="number"] {
      padding: 6px 10px; border: 1px solid var(--border); border-radius: 6px;
      font-size: 13px; font-weight: 600; color: var(--ink); outline: none;
      width: 140px; background: #fff; cursor: pointer;
    }
    select:hover, input:hover { border-color: var(--accent); }
    input[type="checkbox"] { transform: scale(1.3); cursor: pointer; accent-color: var(--accent); }

    /* MODE SELECTOR (Highlight) */
    #appMode { background: #eff6ff; border-color: var(--accent); color: var(--accent); font-weight: 800; }
    
    .flags { display: flex; gap: 10px; }
    .flag-btn { font-size: 14px; font-weight: 800; cursor: pointer; opacity: 0.5; padding: 4px 10px; border-radius: 6px; background:#f1f5f9; }
    .flag-btn.active { opacity: 1; background: var(--accent); color: white; }

    /* Table Selector */
    .table-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 4px; margin-top: 5px; }
    .t-btn {
      font-size: 11px; font-weight: 700; cursor: pointer;
      border: 1px solid var(--border); border-radius: 4px;
      padding: 5px 0; text-align: center; background: #fff;
    }
    .t-btn.active { background: var(--accent); color: white; border-color: var(--accent); }

    .mix-group { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 6px; background: #f1f5f9; padding: 10px; border-radius: 8px; }
    .mix-col { display: flex; flex-direction: column; align-items: center; }
    .mix-col span { font-size: 9px; color: #64748b; margin-bottom: 4px; font-weight: bold; }
    .mix-col input { width: 100%; text-align: center; padding: 6px; font-size: 12px; }

    .actions { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px; }
    .btn { padding: 12px; border: none; border-radius: 8px; font-weight: 700; cursor: pointer; color: white; font-size: 13px; }
    .btn-new { background: var(--accent); }
    .btn-print { background: #10b981; }

    /* Hidding sections based on mode */
    .hidden { display: none !important; }

    /* --- PAGE PREVIEW --- */
    main { flex: 1; overflow: auto; padding: 20px; display: flex; justify-content: center; align-items: flex-start; background: #e2e8f0; }
    
    .page {
      width: var(--page-w); height: var(--page-h);
      background: white; box-shadow: 0 10px 30px rgba(0,0,0,0.15);
      position: relative; flex-shrink: 0;
    }
    .page-inner { 
      position: absolute; 
      top: var(--page-margin-top);
      bottom: var(--page-margin-bot);
      left: var(--page-margin-x);
      right: var(--page-margin-x);
      display: flex; flex-direction: column; 
    }
    
    .header { margin-bottom: 3mm; padding-bottom: 2mm; text-align: center; border-bottom: 2px solid #000; }
    .header h1 { margin: 0; font-size: 26px; text-transform: uppercase; font-weight: 900; color: var(--ink); letter-spacing: 1px; }
    .header p { margin: 0; font-size: 14px; color: var(--sub); font-family: 'Verdana', sans-serif; font-weight: 500; margin-top: 4px; }

    .grid {
      flex: 1; display: grid;
      grid-template-columns: repeat(var(--cols), 1fr);
      grid-template-rows: repeat(var(--rows), 1fr);
      border-top: 0.6px solid var(--grid-line); 
      border-left: 0.6px solid var(--grid-line);
      margin-top: 2mm;
    }
    .cell {
      border-right: 0.6px solid var(--grid-line); 
      border-bottom: 0.6px solid var(--grid-line);
      position: relative; 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      overflow: hidden; padding: 2px;
    }

    .rotate-wrap { width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; }
    
    /* SVG Styles */
    .rr-svg { width: 95%; height: 95%; overflow: visible; display: block; }
    
    .op-line { font-size: 19px; font-weight: 900; white-space: nowrap; font-family: system-ui; text-align: center; width: 100%; }
    .op-col { font-family: 'Courier New', monospace; font-size: 22px; font-weight: 900; line-height: 1.1; text-align: right; padding-right: 20%; width: 100%; }
    .op-col .bar { height: 2px; background: #000; margin: 4px 0; width: 100%; }

    .num-val { font-size: 34px; font-weight: 900; text-align: center; width: 100%; }
    .u-69 { text-decoration: underline; text-decoration-thickness: 3px; text-underline-offset: 5px; }

    .corr-ellipse {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      width: 70%; height: 70%; 
      border: 2px solid var(--ok);
      border-radius: 50%;
      pointer-events: none;
      z-index: 5;
    }
    .corr-text {
      position: absolute;
      bottom: 2px;
      left: 0; right: 0;
      text-align: center;
      font-size: 13px;
      font-weight: 800;
      color: #000;
      background: rgba(255,255,255,0.9);
      z-index: 6;
      border-radius: 4px;
      pointer-events: none;
    }

    @media print {
      @page { size: A4; margin: 0; } 
      body { display: block; background: white; height: auto; overflow: visible; }
      aside { display: none !important; }
      main { padding: 0; margin: 0; display: block; overflow: visible; height: auto; }
      .page { margin: 0 auto; box-shadow: none; border: none; width: 210mm; height: 297mm; overflow: hidden; page-break-after: always; }
      * { -webkit-print-color-adjust: exact; print-color-adjust: exact; }
    }
  </style>
</head>
<body>

<aside>
  <div class="sb-header">
    <h2 class="sb-title">Générateur Rekenrek</h2>
  </div>
  
  <div class="sb-scroll">
    <div class="control">
      <label>MODE DE JEU</label>
      <select id="appMode" onchange="switchMode()">
        <option value="d1">Doubles Niv. 1 (0-10)</option>
        <option value="d2">Doubles Niv. 2 (11-50)</option>
        <option value="nd">Presque Doubles</option>
        <option value="tbl">Tables Mult & Div</option>
      </select>
    </div>

    <div class="actions">
      <button class="btn btn-new" onclick="startGen()" data-i18n="btn_new">NOUVEAU TIRAGE</button>
      <button class="btn btn-print" onclick="window.print()" data-i18n="btn_print">IMPRIMER</button>
    </div>

    <div class="section">
      <div class="sec-title" data-i18n="sec_layout">Mise en page</div>
      <div class="control">
        <label data-i18n="lbl_grid">Grille</label>
        <select id="gridSize" onchange="updateMaxTargets(); startGen()">
          <option value="5x6">30 cases (5x6)</option>
          <option value="4x6">24 cases (4x6)</option>
          <option value="4x5">20 cases (4x5)</option>
          <option value="4x4">16 cases (4x4)</option>
        </select>
      </div>
      <div class="control">
        <label data-i18n="lbl_lang">Langue</label>
        <div class="flags">
          <div class="flag-btn active" onclick="setLang('fr', this)">FR</div>
          <div class="flag-btn" onclick="setLang('en', this)">EN</div>
        </div>
      </div>
    </div>

    <div class="section">
      <div class="sec-title" data-i18n="sec_content">Contenu</div>
      
      <div class="control">
        <label data-i18n="lbl_correct">Nb. Justes</label>
        <input type="number" id="targetCount" value="11" min="1" max="30" onchange="startGen()">
      </div>

      <div id="grp_tbl" class="hidden">
        <div class="control" style="display:block; margin-bottom:15px;">
          <label style="margin-bottom:6px; display:block;" data-i18n="lbl_tables">Tables</label>
          <div class="table-grid" id="tableSelector"></div>
        </div>
        <div class="control">
          <label data-i18n="lbl_range">Multiplicateurs</label>
          <select id="multRange" onchange="startGen()">
            <option value="10">0 à 10</option>
            <option value="12">0 à 12</option>
          </select>
        </div>
        <div class="control">
          <label data-i18n="lbl_order">Ordre</label>
          <select id="orderMode" onchange="startGen()">
            <option value="seq" data-i18n="opt_seq">Ordre (x0, x1...)</option>
            <option value="random" data-i18n="opt_random">Désordre</option>
          </select>
        </div>
        <div class="control">
            <label data-i18n="lbl_format">Écriture</label>
            <select id="opFormat" onchange="renderOnly()">
              <option value="MxT">M x T (6 x 2)</option>
              <option value="TxM">T x M (2 x 6)</option>
              <option value="Div">Division (12 ÷ 2)</option>
              <option value="MixMult">Mélange (x)</option>
              <option value="MixAll">Mélange (x et ÷)</option>
            </select>
        </div>
      </div>

      <div id="grp_trap" class="hidden">
        <div class="control">
            <label data-i18n="lbl_trap_style">Style Pièges</label>
            <select id="trapStyle" onchange="startGen()">
              <option value="easy" data-i18n="opt_easy">Facile</option>
              <option value="hard" data-i18n="opt_hard">Difficile</option>
            </select>
        </div>
      </div>
      
      <div class="control">
        <label data-i18n="lbl_display">Affichage</label>
        <select id="dispType" onchange="toggleMix(); startGen()">
          <option value="rr" data-i18n="opt_rr">Boulier (100%)</option>
          <option value="op" data-i18n="opt_op">Opérations (100%)</option>
          <option value="num" data-i18n="opt_num">Nombres (100%)</option>
          <option value="mix" data-i18n="opt_mix">Mélange (Auto)</option>
        </select>
      </div>
      <div id="mixPanel" style="display:none;">
        <div class="mix-group">
          <div class="mix-col"><span data-i18n="mix_b">Boulier</span><input type="number" id="ratB" value="40" oninput="calcRatio('B')"></div>
          <div class="mix-col"><span data-i18n="mix_o">Opér.</span><input type="number" id="ratO" value="30" oninput="calcRatio('O')"></div>
          <div class="mix-col"><span data-i18n="mix_n">Nombre</span><input type="number" id="ratN" value="30" disabled style="background:transparent; color:#64748b;"></div>
        </div>
      </div>
    </div>

    <div class="section">
      <div class="sec-title" data-i18n="sec_style">Style</div>
      <div class="control">
        <label data-i18n="lbl_opstyle">Opérations</label>
        <select id="opLayout" onchange="renderOnly()">
          <option value="line" data-i18n="opt_line">En ligne</option>
          <option value="col" data-i18n="opt_col">En colonne</option>
        </select>
      </div>
      <div class="control">
        <label data-i18n="lbl_beads">Billes</label>
        <select id="beadColor" onchange="renderOnly()">
          <option value="red" data-i18n="opt_red">Rouge / Blanc</option>
          <option value="blue" data-i18n="opt_blue">Rouge / Bleu</option>
        </select>
      </div>
      <div class="control">
        <label data-i18n="lbl_letters">Lettres (R)</label>
        <input type="checkbox" id="showLetters" onchange="renderOnly()">
      </div>
      <div class="control">
        <label data-i18n="lbl_rot">Rotation</label>
        <input type="checkbox" id="doRot" onchange="renderOnly()">
      </div>
      <div class="control">
        <label style="color:var(--ok); font-weight:800;" data-i18n="lbl_corr">Correction</label>
        <input type="checkbox" id="doCorr" onchange="renderOnly()">
      </div>
    </div>
  </div>
</aside>

<main>
  <div class="page">
    <div class="page-inner">
      <div class="header">
        <h1 id="h-title">TITRE DU JEU</h1>
        <p id="h-sub"></p>
      </div>
      <div class="grid" id="grid"></div>
    </div>
  </div>
</main>

<script>
/* --- CONFIG & DICTIONNAIRE --- */
const i18n = {
  fr: {
    btn_new: "NOUVEAU TIRAGE",
    btn_print: "IMPRIMER",
    sec_layout: "Mise en page",
    lbl_grid: "Grille",
    lbl_lang: "Langue",
    sec_content: "Contenu",
    lbl_correct: "Nb. Justes",
    lbl_tables: "Tables à réviser",
    lbl_range: "Multiplicateurs",
    lbl_order: "Ordre",
    opt_random: "Désordre",
    opt_seq: "Ordre (x0, x1...)",
    lbl_format: "Écriture",
    lbl_trap_style: "Difficulté",
    opt_easy: "Facile",
    opt_hard: "Difficile",
    lbl_display: "Affichage",
    opt_rr: "Boulier (100%)",
    opt_op: "Opérations (100%)",
    opt_num: "Nombres (100%)",
    opt_mix: "Mélange (Auto)",
    mix_b: "Boulier",
    mix_o: "Opér.",
    mix_n: "Nombre",
    sec_style: "Style",
    lbl_opstyle: "Opérations",
    opt_line: "En ligne",
    opt_col: "En colonne",
    lbl_beads: "Billes",
    opt_red: "Rouge / Blanc",
    opt_blue: "Rouge / Bleu",
    lbl_letters: "Lettres (Rekenrek)",
    lbl_rot: "Rotation",
    lbl_corr: "Correction",
    
    // Titles
    t_d1: "DOUBLES NIVEAU 1",
    s_d1: "Marque les doubles et écris l'égalité.",
    t_d2: "DOUBLES NIVEAU 2",
    s_d2: "",
    t_nd: "PRESQUE DOUBLES",
    s_nd: "Marque les presque doubles et écris l'égalité.",
    t_tbl: "TABLES DE MULTIPLICATION",
    s_tbl: ""
  },
  en: {
    btn_new: "SHUFFLE",
    btn_print: "PRINT",
    sec_layout: "Layout",
    lbl_grid: "Grid",
    lbl_lang: "Language",
    sec_content: "Content",
    lbl_correct: "Correct Count",
    lbl_tables: "Select Tables",
    lbl_range: "Multipliers",
    lbl_order: "Order",
    opt_random: "Random",
    opt_seq: "Sequence (x0, x1...)",
    lbl_format: "Format",
    lbl_trap_style: "Level",
    opt_easy: "Easy",
    opt_hard: "Hard",
    lbl_display: "Display",
    opt_rr: "Rekenrek (100%)",
    opt_op: "Operations (100%)",
    opt_num: "Numbers (100%)",
    opt_mix: "Mixed (Auto)",
    mix_b: "Beads",
    mix_o: "Ops",
    mix_n: "Num",
    sec_style: "Style",
    lbl_opstyle: "Operations",
    opt_line: "Linear",
    opt_col: "Column",
    lbl_beads: "Beads",
    opt_red: "Red / White",
    opt_blue: "Red / Blue",
    lbl_letters: "Letters (Rekenrek)",
    lbl_rot: "Rotation",
    lbl_corr: "Answer Key",

    t_d1: "DOUBLES LEVEL 1",
    s_d1: "Mark the doubles and write the equation.",
    t_d2: "DOUBLES LEVEL 2",
    s_d2: "",
    t_nd: "NEAR DOUBLES",
    s_nd: "Mark the near doubles and write the equation.",
    t_tbl: "MULTIPLICATION TABLES",
    s_tbl: ""
  }
};

let currentLang = 'fr';
let state = { data: [] };
let selectedTables = [2]; 

window.onload = function() {
  initTableSelector();
  calcRatio('B');
  switchMode(); // Initialize UI
};

/* --- UI HELPERS --- */
function setLang(l, el) {
  currentLang = l;
  document.querySelectorAll('.flag-btn').forEach(b => b.classList.remove('active'));
  el.classList.add('active');
  updateLangUI();
  updateTitles();
}

function updateLangUI() {
  const dict = i18n[currentLang];
  document.querySelectorAll('[data-i18n]').forEach(el => {
    const key = el.getAttribute('data-i18n');
    if(dict[key]) el.innerText = dict[key];
  });
}

function updateTitles() {
  const mode = document.getElementById('appMode').value;
  const dict = i18n[currentLang];
  let tKey = 't_' + mode;
  let sKey = 's_' + mode;
  if(mode === 'tbl') tKey = 't_tbl'; 
  
  document.getElementById('h-title').innerText = dict[tKey] || "";
  document.getElementById('h-sub').innerText = dict[sKey] || "";
}

function switchMode() {
  const mode = document.getElementById('appMode').value;
  
  // Manage visibility
  document.getElementById('grp_tbl').classList.add('hidden');
  document.getElementById('grp_trap').classList.add('hidden');
  
  if (mode === 'tbl') {
    document.getElementById('grp_tbl').classList.remove('hidden');
  } else if (mode === 'd1' || mode === 'nd') {
    document.getElementById('grp_trap').classList.remove('hidden');
  }
  
  updateTitles();
  updateMaxTargets();
  startGen();
}

function initTableSelector() {
  const container = document.getElementById('tableSelector');
  container.innerHTML = '';
  for(let i=0; i<=12; i++) {
    const btn = document.createElement('div');
    btn.className = 't-btn' + (selectedTables.includes(i) ? ' active' : '');
    btn.innerText = i;
    btn.onclick = () => toggleTable(i, btn);
    container.appendChild(btn);
  }
}

function toggleTable(n, btn) {
  if(selectedTables.includes(n)) {
    if(selectedTables.length > 1) { 
      selectedTables = selectedTables.filter(x => x !== n);
      btn.classList.remove('active');
    }
  } else {
    selectedTables.push(n);
    btn.classList.add('active');
  }
  if(document.getElementById('appMode').value === 'tbl') startGen();
}

function updateMaxTargets() {
  const [cols, rows] = document.getElementById('gridSize').value.split('x').map(Number);
  const total = cols * rows;
  const inp = document.getElementById('targetCount');
  inp.max = total;
  if(parseInt(inp.value) > total) inp.value = total;
}

function calcRatio(src) {
  let b = parseInt(document.getElementById('ratB').value)||0;
  let o = parseInt(document.getElementById('ratO').value)||0;
  if(b < 0) b = 0; if(o < 0) o = 0;
  if(b + o > 100) { if(src === 'B') o = 100 - b; else b = 100 - o; }
  let n = 100 - b - o;
  document.getElementById('ratB').value = b;
  document.getElementById('ratO').value = o;
  document.getElementById('ratN').value = n;
  if(document.getElementById('dispType').value === 'mix') startGen();
}

function toggleMix() {
  const t = document.getElementById('dispType').value;
  document.getElementById('mixPanel').style.display = (t === 'mix') ? 'block' : 'none';
}

function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}

function determineType(dispType, rB, rO) {
    if(dispType !== 'mix') return dispType;
    const roll = Math.random() * 100;
    if(roll < rB) return 'rr';
    if(roll < rB + rO) return 'op';
    return 'num';
}

/* --- LOGIC GENERATORS --- */

function startGen() {
  const mode = document.getElementById('appMode').value;
  const [cols, rows] = document.getElementById('gridSize').value.split('x').map(Number);
  document.documentElement.style.setProperty('--cols', cols);
  document.documentElement.style.setProperty('--rows', rows);
  
  const totalSlots = cols * rows;
  const targetCount = parseInt(document.getElementById('targetCount').value) || 11;
  const dispType = document.getElementById('dispType').value;
  const rB = parseInt(document.getElementById('ratB').value);
  const rO = parseInt(document.getElementById('ratO').value);
  const trapStyle = document.getElementById('trapStyle').value; // d1, nd

  state.data = [];

  // --- LOGIQUE DOUBLES NIV 1 (0-10) ---
  if(mode === 'd1') {
      let targets = [];
      const createTargetD1 = (val) => {
          let a, b;
          if (trapStyle === 'easy') {
              a = val; b = val;
          } else {
              let sum = val * 2;
              let minA = Math.max(0, sum - 10);
              let maxA = Math.min(sum, 10);
              let attempts = 0;
              do {
                  a = Math.floor(Math.random() * (maxA - minA + 1)) + minA;
                  b = sum - a;
                  attempts++;
              } while (a === b && attempts < 10 && maxA > minA);
          }
          if(Math.random()>0.5) [a,b] = [b,a];
          return { a, b, isTarget: true };
      };
      // Fill targets
      let fullDecks = Math.floor(targetCount/11);
      let rem = targetCount%11;
      for(let k=0; k<fullDecks; k++) for(let i=0;i<=10;i++) targets.push(createTargetD1(i));
      let pDeck = Array.from({length:11},(_,i)=>i);
      pDeck = shuffle(pDeck);
      for(let k=0; k<rem; k++) targets.push(createTargetD1(pDeck[k]));

      // Fill extras (Impair)
      const rand = (min,max) => Math.floor(Math.random()*(max-min+1))+min;
      for(let k=0; k<(totalSlots-targets.length); k++) {
          let a, b;
          if(Math.random()>0.5) { a=rand(0,5)*2; b=rand(0,4)*2+1; }
          else { a=rand(0,4)*2+1; b=rand(0,5)*2; }
          targets.push({ a, b, isTarget: false });
      }
      state.data = shuffle(targets);
  }

  // --- LOGIQUE DOUBLES NIV 2 (11-50) ---
  else if(mode === 'd2') {
      let targets = [];
      const createTargetD2 = (val) => ({ a: val, b: val, isTarget: true });
      
      let fullDecks = Math.floor(targetCount/40);
      let rem = targetCount%40;
      for(let k=0; k<fullDecks; k++) for(let i=11;i<=50;i++) targets.push(createTargetD2(i));
      let pDeck = Array.from({length:40},(_,i)=>i+11);
      pDeck = shuffle(pDeck);
      for(let k=0; k<rem; k++) targets.push(createTargetD2(pDeck[k]));

      // Extras (Voisins)
      const rand = (min,max) => Math.floor(Math.random()*(max-min+1))+min;
      for(let k=0; k<(totalSlots-targets.length); k++) {
          let a = rand(11,50);
          let b;
          if(a===50) b=49; else if(a===11) b=12;
          else b = (Math.random()>0.5)? a+1 : a-1;
          
          let v1=a, v2=b;
          if(Math.random()>0.5) { v1=b; v2=a; }
          targets.push({ a: v1, b: v2, isTarget: false });
      }
      state.data = shuffle(targets);
  }

  // --- LOGIQUE PRESQUE DOUBLES ---
  else if(mode === 'nd') {
      let targets = [];
      const createTargetND = (base) => {
          let a, b;
          if (trapStyle === 'easy') { // balanced in original
              a = base; b = base + 1;
          } else { // random in original
              let sum = 2 * base + 1;
              let minA = Math.max(0, sum - 10);
              let maxA = Math.min(sum, 10);
              let attempts = 0;
              do {
                  a = Math.floor(Math.random() * (maxA - minA + 1)) + minA;
                  b = sum - a;
                  attempts++;
              } while (Math.abs(a-b) === 1 && attempts < 10 && maxA - minA > 1);
          }
          if(Math.random()>0.5) [a,b] = [b,a];
          return { a, b, isTarget: true };
      };

      let fullDecks = Math.floor(targetCount/10);
      let rem = targetCount%10;
      for(let k=0; k<fullDecks; k++) for(let i=0;i<10;i++) targets.push(createTargetND(i));
      let pDeck = Array.from({length:10},(_,i)=>i);
      pDeck = shuffle(pDeck);
      for(let k=0; k<rem; k++) targets.push(createTargetND(pDeck[k]));

      // Extras
      const rand = (min,max) => Math.floor(Math.random()*(max-min+1))+min;
      for(let k=0; k<(totalSlots-targets.length); k++) {
          let a, b;
          if(trapStyle === 'easy') {
              let r = rand(0,10); a=r; b=r;
          } else {
             // Force even sum
             if(Math.random()>0.5) { a=rand(0,5)*2; b=rand(0,5)*2; }
             else { a=rand(0,4)*2+1; b=rand(0,4)*2+1; }
          }
          targets.push({ a, b, isTarget: false });
      }
      state.data = shuffle(targets);
  }

  // --- LOGIQUE TABLES ---
  else if(mode === 'tbl') {
      const multMax = parseInt(document.getElementById('multRange').value);
      const orderMode = document.getElementById('orderMode').value;
      const opFormat = document.getElementById('opFormat').value;
      const isDiv = (opFormat === 'Div' || opFormat === 'MixAll');
      const startMult = isDiv ? 1 : 0;

      let allPossible = [];
      selectedTables.sort((a,b)=>a-b);
      selectedTables.forEach(t => {
          for(let m=startMult; m<=multMax; m++) allPossible.push({ t, m, val: t*m, isTarget: true });
      });
      
      let targets = [];
      if(orderMode === 'seq') {
          for(let i=0; i<targetCount; i++) targets.push({ ...allPossible[i%allPossible.length] });
      } else {
          let deck = [];
          const numDecks = Math.ceil(targetCount / (allPossible.length||1));
          for(let k=0; k<numDecks; k++) deck = deck.concat(allPossible);
          deck = shuffle(deck);
          for(let i=0; i<targetCount; i++) targets.push({ ...deck[i] });
      }

      state.data = new Array(totalSlots).fill(null);
      
      // Placement
      let indices = Array.from({length: totalSlots}, (_, i) => i);
      let chosenIndices = (orderMode === 'seq') ? indices.slice(0, targets.length) : shuffle(indices).slice(0, targets.length);
      
      for(let i=0; i<targets.length; i++) {
          if(chosenIndices[i] < totalSlots) state.data[chosenIndices[i]] = targets[i];
      }

      // Traps
      for(let i=0; i<totalSlots; i++) {
          if(state.data[i]) continue;
          let ref = targets[Math.floor(Math.random()*targets.length)] || { val: 10 };
          let trapVal = ref.val + (Math.random()>0.5?1:-1)*(Math.random()>0.7?2:1);
          if(trapVal<0) trapVal=1;
          
          state.data[i] = { val: trapVal, isTarget: false, type: 'trap' }; // Type trap handled below
      }
  }

  // Finalize types & angles for all items
  state.data.forEach(item => {
      if(!item) return;
      item.angle = Math.random() * 360;
      if(!item.type || item.type === 'trap') item.type = determineType(dispType, rB, rO);
      
      // Special logic for Tables Ops traps
      if(mode === 'tbl' && item.type === 'op' && !item.isTarget) {
         item.t = Math.floor(Math.random()*10);
         item.m = Math.floor(Math.random()*10);
      }
  });

  renderOnly();
}

function renderOnly() {
  const grid = document.getElementById('grid');
  grid.innerHTML = '';
  const mode = document.getElementById('appMode').value;
  
  const doRot = document.getElementById('doRot').checked;
  const doCorr = document.getElementById('doCorr').checked;
  const showLetters = document.getElementById('showLetters').checked;
  const opLayout = document.getElementById('opLayout').value;
  const theme = document.getElementById('beadColor').value;
  const opFormat = (mode === 'tbl') ? document.getElementById('opFormat').value : null;

  updateTitles();

  state.data.forEach(item => {
    if(!item) { grid.appendChild(document.createElement('div')); return; }

    const cell = document.createElement('div');
    cell.className = 'cell';
    const wrap = document.createElement('div');
    wrap.className = 'rotate-wrap';
    if(doRot) wrap.style.transform = `rotate(${item.angle}deg)`;
    
    let html = '';

    // --- RENDER BOULIER ---
    if(item.type === 'rr') {
        if(mode === 'd2') {
            html = getSvgBlock(item.a, item.b, theme, showLetters);
        } else if(mode === 'tbl') {
            html = getSvgBlock(item.val, null, theme, showLetters);
        } else {
            // D1, ND
            html = getSvgLinear(item.a, item.b, theme, showLetters);
        }
    } 
    // --- RENDER OPERATION ---
    else if(item.type === 'op') {
        if(mode === 'tbl') {
            // Logic Tables Op
            let currentFmt = opFormat;
            if(opFormat === 'MixMult') currentFmt = (Math.random()>0.5)?'MxT':'TxM';
            else if(opFormat === 'MixAll') {
                let r=Math.random(); if(r<0.33)currentFmt='MxT'; else if(r<0.66)currentFmt='TxM'; else currentFmt='Div';
            }
            item.usedFmt = currentFmt;

            let t = (item.t !== undefined) ? item.t : 2; 
            let m = (item.m !== undefined) ? item.m : 2; 
            let v = item.val || (t*m);
            let txt = "";

            if(currentFmt === 'Div') {
                let div = t;
                if(!item.isTarget && selectedTables.length > 0) div = selectedTables[Math.floor(Math.random()*selectedTables.length)];
                if(div===0) div=1;
                item.divUsed = div;
                txt = `${v} ÷ ${div}`;
            } else if(currentFmt === 'TxM') txt = `${t} x ${m}`;
            else txt = `${m} x ${t}`;

            if(opLayout === 'col' && currentFmt !== 'Div') {
                let p = txt.split(' x ');
                html = `<div class="op-col"><div>${p[0]}</div><div>x ${p[1]}</div><div class="bar"></div></div>`;
            } else {
                html = `<div class="op-line">${txt} =</div>`;
            }

        } else {
            // Logic Doubles
            if(opLayout === 'col') html = `<div class="op-col"><div>${item.a}</div><div>+ ${item.b}</div><div class="bar"></div></div>`;
            else html = `<div class="op-line">${item.a} + ${item.b} =</div>`;
        }
    } 
    // --- RENDER NUMBER ---
    else if(item.type === 'num') {
        let val = (mode === 'tbl') ? item.val : (item.a + item.b);
        let dV = val;
        if([6,9,66,99].includes(val)) dV = `<span class="u-69">${val}</span>`;
        html = `<div class="num-val">${dV}</div>`;
    }
    
    wrap.innerHTML = html;
    cell.appendChild(wrap);

    // --- CORRECTION ---
    if(doCorr && item.isTarget) {
      const el = document.createElement('div');
      el.className = 'corr-ellipse';
      cell.appendChild(el);
      const txt = document.createElement('div');
      txt.className = 'corr-text';

      if(mode === 'd1') {
           let sum = item.a + item.b;
           if(Math.abs(item.a-item.b)>0) txt.innerText = `${sum/2} + ${sum/2} = ${sum}`;
           else txt.innerText = `${item.a} + ${item.b} = ${sum}`;
      } else if(mode === 'd2') {
           txt.innerText = `${item.a} + ${item.b} = ${item.a+item.b}`;
      } else if(mode === 'nd') {
           let sum = item.a + item.b;
           let h = Math.floor(sum/2);
           txt.innerText = `${h} + ${h+1} = ${sum}`;
      } else if(mode === 'tbl') {
           if(item.usedFmt === 'Div') {
               let d = item.divUsed || item.t; if(d===0)d=1;
               txt.innerText = `${item.val} ÷ ${d} = ${Math.round(item.val/d)}`;
           } else if(item.usedFmt === 'TxM') {
               txt.innerText = `${item.t} x ${item.m} = ${item.val}`;
           } else {
               txt.innerText = `${item.m} x ${item.t} = ${item.val}`;
           }
      }
      cell.appendChild(txt);
    }
    grid.appendChild(cell);
  });
}

/* --- SVG DRAWING FUNCTIONS --- */

// Pour Doubles Niv 1 & Presque Doubles (2 lignes distinctes, 0-10)
function getSvgLinear(a, b, theme, showLetters) {
  const W = 100, H = 100;
  let svg = `<svg class="rr-svg" viewBox="0 0 ${W} ${H}">`;
  const letters = "REKENREK"; 
  
  const drawRow = (n, y) => {
      let str=""; 
      const r=4.0, sp=8.5, startX=6;
      for(let i=0; i<n; i++) {
          let isF5 = (i%10)<5;
          let colMain = '#ef4444'; 
          let colSec = (theme==='blue')?'#3b82f6':'#ffffff';
          let fill = isF5 ? colMain : colSec;
          let cx = startX + i*sp;
          str += `<circle cx="${cx}" cy="${y}" r="${r}" fill="${fill}" stroke="#111827" stroke-width="0.5" />`;
          if(showLetters && i<8) {
             let tc = (fill==='#ffffff')?'black':'white';
             str+=`<text x="${cx}" y="${y}" font-size="3.5" font-family="Arial" font-weight="900" fill="${tc}" text-anchor="middle" dominant-baseline="central">${letters[i]}</text>`;
          }
      }
      return str;
  }
  svg += drawRow(a, 44);
  svg += drawRow(b, 56);
  svg += `</svg>`;
  return svg;
}

// Pour Doubles Niv 2 (11-50) & Tables (Block compact)
function getSvgBlock(a, b, theme, showLetters) {
  // b est null pour Tables, non-null pour Doubles Niv 2
  const W = 100;
  // Calcul hauteur
  let totalRows = Math.ceil(a/10);
  if(b !== null) totalRows += Math.ceil(b/10);
  
  // Parametres
  const r=4.0, sp=8.5, hRow=8.5;
  const contentH = Math.max(100, totalRows*hRow + 15);
  
  let svg = `<svg class="rr-svg" viewBox="0 0 ${W} ${contentH}" preserveAspectRatio="xMidYMid meet">`;
  const letters = "REKENREK";
  
  // Centrage block
  const grW = 9*sp + 2*r;
  const marginL = (W - grW)/2 + r;
  
  // Si Doubles Niv2, on separe les deux blocs
  // Si Table, un seul bloc
  
  let startY = 10;
  if(b !== null) {
      // Pour Doubles Niv 2: On essaie de centrer les deux blocs
      const hA = Math.ceil(a/10)*hRow;
      const hB = Math.ceil(b/10)*hRow;
      const gap = 5;
      const totH = hA + hB + gap;
      startY = (contentH - totH)/2 + (hRow/2);
  } else {
      // Pour Tables
      const totH = Math.ceil(a/10)*hRow;
      startY = (contentH - totH)/2 + (hRow/2);
  }

  const drawNum = (n, yBase) => {
      let str="";
      let full = Math.floor(n/10);
      let rem = n%10;
      let rows = Math.ceil(n/10);
      
      for(let row=0; row<rows; row++) {
          let y = yBase + row*hRow;
          let cnt = (row < full)? 10 : rem;
          // Inversion couleur table (toutes les 5 lignes) -> tables seulement
          // Mais pour Doubles Niv 2 on garde standard.
          let inverted = (b===null) ? (Math.floor(row/5)%2===1) : false;
          
          let cx = marginL;
          for(let i=0; i<cnt; i++) {
              let isF5 = (i%10)<5;
              let colMain = '#ef4444'; 
              let colSec = (theme==='blue')?'#3b82f6':'#ffffff';
              let fill;
              if(inverted) fill = isF5 ? colSec : colMain;
              else fill = isF5 ? colMain : colSec;

              str += `<circle cx="${cx}" cy="${y}" r="${r}" fill="${fill}" stroke="#111827" stroke-width="0.5" />`;
              if(showLetters && i<8) {
                 let tc = (fill==='#ffffff')?'black':'white';
                 str+=`<text x="${cx}" y="${y}" font-size="3.5" font-family="Arial" font-weight="900" fill="${tc}" text-anchor="middle" dominant-baseline="central">${letters[i]}</text>`;
              }
              cx += sp;
          }
      }
      return { html: str, height: rows*hRow };
  };

  let resA = drawNum(a, startY);
  svg += resA.html;
  
  if(b !== null) {
      let resB = drawNum(b, startY + resA.height + 5); // +5 gap
      svg += resB.html;
  }
  
  svg += `</svg>`;
  return svg;
}

</script>
</body>
</html>
