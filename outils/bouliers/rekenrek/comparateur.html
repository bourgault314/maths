<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
<title>Rekenrek Comparateur - Final V27</title>
<style>
  :root {
    --bg: #1a1a1a; --wood: #b08d57; --rod: #888; --ui: #2a2a2a;
    --accent: #0f6cf9; --success: #4caf50; --error: #f44336;
    --bead-red: radial-gradient(circle at 30% 30%, #ff5f5f, #a00);
    --bead-alt: radial-gradient(circle at 30% 30%, #ffffff, #bbb);
  }

  body.blue-mode { 
    --bead-alt: radial-gradient(circle at 30% 30%, #2196f3, #0d47a1); 
  }

  body, html { 
    margin: 0; padding: 0; width: 100%; height: 100%; 
    background: var(--bg); color: white; font-family: sans-serif;
    overflow: hidden; touch-action: none;
  }

  /* TOOLBAR */
  .toolbar {
    position: relative; width: 100%; min-height: 60px;
    background: var(--ui); display: flex; align-items: center; 
    justify-content: space-between; padding: 0 20px; box-sizing: border-box;
    box-shadow: 0 4px 10px rgba(0,0,0,0.5); z-index: 2000;
  }

  .toolbar-left { display: flex; gap: 10px; align-items: center; }

  .app-title { font-weight: bold; font-size: 24px; color: white; text-transform: uppercase; letter-spacing: 1px; }
  .score-board { display: flex; gap: 20px; font-weight: bold; font-size: 24px; }
  .score-good { color: var(--success); }
  .score-bad { color: var(--error); }

  select {
    background: #444; color: white; border: none; padding: 10px;
    border-radius: 8px; font-weight: bold; font-size: 18px; cursor: pointer;
  }

  .btn-tool {
    background: #444; color: white; border: 1px solid #555; padding: 8px 12px;
    border-radius: 8px; font-weight: bold; cursor: pointer; font-size: 16px;
  }
  .btn-tool:hover { background: #555; }
  .btn-tool.active { background: var(--accent); border-color: white; }

  /* CONTAINER PRINCIPAL */
  #main-container {
    position: relative; width: 100%; height: calc(100vh - 65px);
    display: flex; flex-direction: column; align-items: center;
    justify-content: center; overflow: hidden;
    z-index: 5;
  }

  #scaler { 
    display: flex; flex-direction: column; align-items: center; 
    transform-origin: center center; 
    margin-top: 60px; 
  }

  /* ZONE DE JEU */
  #comparison-zone { 
    display: flex; align-items: center; justify-content: center; 
    gap: 30px; 
  }

  .abacus-container { 
    position: relative; 
    display: flex; align-items: center; 
  }
  
  .abacus-label { 
    position: absolute; top: -110px; left: 0; width: 100%;
    font-size: 90px; font-weight: 900; color: white; 
    text-shadow: 0 4px 10px black; text-align: center;
    pointer-events: none;
  }

  /* CADRE BOULIER */
  .abacus-frame {
    position: relative; width: 820px;
    border-left: 30px solid var(--wood); border-right: 30px solid var(--wood);
    box-sizing: content-box; background: transparent;
  }
  .abacus-frame::before, .abacus-frame::after {
    content: ""; position: absolute; top: 0; bottom: 0; width: 30px;
    background: var(--wood); z-index: 20; pointer-events: none;
  }
  .abacus-frame::before { left: -30px; }
  .abacus-frame::after { right: -30px; }

  /* CACHE (RIDEAU) */
  .curtain {
    position: absolute; right: -30px; top: 0; bottom: 0;
    background: #111; border-left: 5px solid #333;
    z-index: 500; 
    width: 0; pointer-events: none;
    transition: width 0.3s ease-out;
  }

  .row { position: relative; height: 50px; width: 100%; overflow: hidden; }
  .rod { position: absolute; width: 100%; height: 4px; background: var(--rod); top: 50%; transform: translateY(-50%); z-index: 1; }
  
  .bead {
    position: absolute; width: 38px; height: 38px; border-radius: 50%;
    top: 50%; transform: translateY(-50%); z-index: 5;
    box-shadow: inset -3px -3px 6px rgba(0,0,0,0.4), 2px 2px 5px rgba(0,0,0,0.5);
  }
  .bead.draggable { cursor: grab; }
  .bead.draggable:active { cursor: grabbing; }
  .bead.red { background: var(--bead-red); }
  .bead.white { background: var(--bead-alt); }

  /* BOUTONS COMPARAISON */
  .comp-buttons { 
    display: flex; flex-direction: column; gap: 15px; 
    z-index: 200; align-items: center; justify-content: center;
  }
  .btn-comp {
    width: 90px; height: 90px; font-size: 55px; font-weight: 900;
    background: #333; border: 4px solid #555; color: white; border-radius: 20px;
    cursor: pointer; box-shadow: 0 8px 0 #111; transition: transform 0.1s;
  }
  .btn-comp:active { transform: translateY(4px); box-shadow: 0 4px 0 #111; }
  .btn-comp:hover { background: #444; border-color: #666; }
  
  .btn-comp.selected-ok { background: var(--success); border-color: #fff; box-shadow: 0 8px 0 #1b5e20; }
  .btn-comp.selected-bad { background: var(--error); border-color: #fff; box-shadow: 0 8px 0 #b71c1c; }

  /* OVERLAY (FEEDBACK) */
  #overlay-feedback {
    position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.90); border-radius: 30px;
    padding: 30px 50px; display: none; flex-direction: column; align-items: center; gap: 15px;
    z-index: 5000; border: 2px solid white; box-shadow: 0 0 40px rgba(0,0,0,0.8);
  }
  
  #feedback-text { font-size: 100px; font-weight: 900; color: var(--success); line-height: 1; margin-bottom: 20px; text-align: center;}
  
  #btn-next-overlay {
    background: var(--success); color: white; border: none; padding: 15px 50px;
    border-radius: 50px; font-size: 30px; font-weight: bold; cursor: pointer;
    box-shadow: 0 6px 0 #1b5e20; 
    display: flex; align-items: center; gap: 10px; transition: transform 0.1s;
  }
  #btn-next-overlay:active { transform: translateY(4px); box-shadow: 0 3px 0 #1b5e20; }

  /* CANVAS DESSIN */
  #draw-layer {
    position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
    z-index: 1000; pointer-events: none; 
  }
  #draw-layer.active { pointer-events: auto; cursor: crosshair; }

</style>
</head>
<body>

<div class="toolbar">
  <div class="toolbar-left">
    <select id="mode-select" onchange="manualLevelChange()">
      <option value="10" id="opt-10">Mode 10</option>
      <option value="20" selected>Mode 20</option>
      <option value="100">Mode 100</option>
    </select>
    <select id="level-select" onchange="manualLevelChange()">
      <option value="1">Niv 1: Rangement + Cache</option>
      <option value="2">Niv 2: Rangement + Pi√®ges</option>
      <option value="3">Niv 3: Mental (Chiffres)</option>
      <option value="4">Niv 4: D√©sordre (Proches)</option>
      <option value="5">Niv 5: Expert (Cache + D√©sordre)</option>
    </select>
    <button class="btn-tool" onclick="toggleColorMode()" id="btn-color">üîµ Bleu</button>
    <button class="btn-tool" onclick="togglePen()" id="btn-pen">‚úèÔ∏è</button>
    <button class="btn-tool" onclick="clearDraw()">üßΩ</button>
  </div>
  
  <div class="app-title">COMPARATEUR</div>

  <div class="score-board">
    <span class="score-good">‚úÖ <span id="count-good">0</span></span>
    <span class="score-bad">‚ùå <span id="count-bad">0</span></span>
  </div>
</div>

<div id="main-container">
  <div id="scaler">
    
    <div id="comparison-zone">
      <div class="abacus-container">
        <div id="label-a" class="abacus-label"></div>
        <div id="frame-a" class="abacus-frame" data-side="a">
          <div id="curtain-a" class="curtain"></div>
        </div>
      </div>

      <div class="comp-buttons">
        <button class="btn-comp" onclick="checkAnswer('>')">></button>
        <button class="btn-comp" onclick="checkAnswer('=')">=</button>
        <button class="btn-comp" onclick="checkAnswer('<')"><</button>
      </div>

      <div class="abacus-container">
        <div id="label-b" class="abacus-label"></div>
        <div id="frame-b" class="abacus-frame" data-side="b">
          <div id="curtain-b" class="curtain"></div>
        </div>
      </div>
    </div>

  </div>

  <div id="overlay-feedback">
    <div id="feedback-text">‚úÖ</div>
    <button id="btn-next-overlay" onclick="forceNextQuestion()">
      Suivant
    </button>
  </div>

</div>

<canvas id="draw-layer"></canvas>

<script>
  let valA, valB, lastA = -1, lastB = -1;
  let scoreGood = 0, scoreBad = 0;
  let isAnswered = false;
  let currentScale = 1;
  let statesA = [], statesB = [];
  let isBlue = false;
  let autoNextTimer = null;

  const BEAD_W = 38; 
  
  const frameA = document.getElementById('frame-a');
  const frameB = document.getElementById('frame-b');
  const labelA = document.getElementById('label-a');
  const labelB = document.getElementById('label-b');
  const curtainA = document.getElementById('curtain-a');
  const curtainB = document.getElementById('curtain-b');
  const overlay = document.getElementById('overlay-feedback');
  const feedbackText = document.getElementById('feedback-text');
  const btnNextOverlay = document.getElementById('btn-next-overlay');

  // --- DESSIN ---
  let isPen = false;
  const canvas = document.getElementById('draw-layer');
  const ctx = canvas.getContext('2d');

  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    ctx.lineCap = 'round'; ctx.lineJoin = 'round';
    ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 4;
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  function togglePen() {
    isPen = !isPen;
    const btn = document.getElementById('btn-pen');
    if (isPen) { btn.classList.add('active'); canvas.classList.add('active'); } 
    else { btn.classList.remove('active'); canvas.classList.remove('active'); }
  }
  function clearDraw() { ctx.clearRect(0, 0, canvas.width, canvas.height); }

  let drawing = false;
  const getPos = (e) => {
    if (e.touches && e.touches.length > 0) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    return { x: e.clientX, y: e.clientY };
  }
  const startDraw = (e) => { if (!isPen) return; drawing = true; const pos = getPos(e); ctx.beginPath(); ctx.moveTo(pos.x, pos.y); };
  const moveDraw = (e) => { if (!drawing || !isPen) return; e.preventDefault(); const pos = getPos(e); ctx.lineTo(pos.x, pos.y); ctx.stroke(); };
  const endDraw = () => drawing = false;

  canvas.addEventListener('mousedown', startDraw); canvas.addEventListener('mousemove', moveDraw); canvas.addEventListener('mouseup', endDraw);
  canvas.addEventListener('touchstart', startDraw, {passive: false}); canvas.addEventListener('touchmove', moveDraw, {passive: false}); canvas.addEventListener('touchend', endDraw);

  // --- MODE BLEU ---
  function toggleColorMode() {
    isBlue = !isBlue;
    document.body.classList.toggle('blue-mode');
    document.getElementById('btn-color').textContent = isBlue ? "‚ö™ Blanc" : "üîµ Bleu";
  }

  // --- JEU ---

  function checkLevelMode() {
    const level = parseInt(document.getElementById('level-select').value);
    const modeSelect = document.getElementById('mode-select');
    const opt10 = document.getElementById('opt-10');
    
    if (level >= 4) {
      opt10.disabled = true;
      if (modeSelect.value == "10") modeSelect.value = "20";
    } else {
      opt10.disabled = false;
    }
  }

  // Fonction appel√©e quand l'utilisateur change manuellement le niveau ou le mode
  function manualLevelChange() {
      scoreGood = 0; scoreBad = 0;
      document.getElementById('count-good').innerText = 0;
      document.getElementById('count-bad').innerText = 0;
      checkLevelMode();
      initGame();
  }

  function initGame() {
    const mode = parseInt(document.getElementById('mode-select').value);
    const level = parseInt(document.getElementById('level-select').value);
    const rowCount = mode === 10 ? 1 : (mode === 20 ? 2 : 10);
    
    // Reset
    isAnswered = false; 
    clearTimeout(autoNextTimer);
    overlay.style.display = "none";
    
    // Reset message standard
    feedbackText.innerText = "‚úÖ"; 
    feedbackText.style.fontSize = "100px";
    feedbackText.style.color = "var(--success)";
    // Plus de fl√®che ici
    btnNextOverlay.innerText = "Suivant";
    btnNextOverlay.onclick = forceNextQuestion;

    clearDraw(); 
    document.querySelectorAll('.btn-comp').forEach(b => {
        b.classList.remove('selected-ok', 'selected-bad');
    });

    do {
      valA = Math.floor(Math.random() * (mode + 1));
      valB = Math.floor(Math.random() * (mode + 1));

      // LOGIQUE DES NIVEAUX
      if (level === 2 || level === 3) {
          // NIVEAU 2 & 3 : Hasard + Cas Difficiles
          if (Math.random() < 0.4) { 
              const trapType = Math.floor(Math.random() * 4); 
              if (trapType === 0) valB = valA; 
              else if (trapType === 1) valB = valA + (Math.random()>0.5 ? 1 : -1);
              else if (trapType === 2 && mode >= 20) { 
                  let u = valA % 10; let d = Math.floor(valA / 10);
                  let mirror = u * 10 + d;
                  if (mirror <= mode && mirror !== valA) valB = mirror;
              }
              else if (trapType === 3) { 
                  if(Math.abs(valA - 5) <= 2) valB = 5 + (Math.random()>0.5?1:-1);
                  else if(Math.abs(valA - 10) <= 2) valB = 10 + (Math.random()>0.5?1:-1);
              }
          }
      } 
      else if (level === 1 || level === 4 || level === 5) {
          // NIVEAUX PROXIMITE
          let diffRange = (level === 5) ? 2 : 4; 
          let offset = Math.floor(Math.random() * (diffRange * 2 + 1)) - diffRange;
          valB = Math.max(0, Math.min(mode, valA + offset));
      }
      
      valB = Math.max(0, Math.min(mode, valB));
    } while ((valA === lastA && valB === lastB)); 
    
    lastA = valA; lastB = valB;
    statesA = Array(rowCount).fill(0); statesB = Array(rowCount).fill(0);

    const interactive = (level === 3);
    buildAbacus(frameA, rowCount, interactive, 'a');
    buildAbacus(frameB, rowCount, interactive, 'b');

    curtainA.style.width = "0"; curtainB.style.width = "0";
    labelA.innerText = ""; labelB.innerText = "";

    // CONFIGURATION VISUELLE
    if (level === 1) {
      setAbacus(frameA, valA, 'standard'); setAbacus(frameB, valB, 'standard');
      curtainA.style.width = "435px"; curtainB.style.width = "435px";
    } 
    else if (level === 2) {
      setAbacus(frameA, valA, 'standard'); setAbacus(frameB, valB, 'standard');
    } 
    else if (level === 3) {
      labelA.innerText = valA; labelB.innerText = valB;
    } 
    else if (level === 4) {
      setAbacus(frameA, valA, 'disordered'); setAbacus(frameB, valB, 'disordered');
    } 
    else if (level === 5) {
      setAbacus(frameA, valA, 'scattered'); setAbacus(frameB, valB, 'scattered');
      curtainA.style.width = "435px"; curtainB.style.width = "435px";
    }

    autoScale();
  }

  function buildAbacus(frame, rowCount, isDraggable, side) {
    frame.querySelectorAll('.row').forEach(r => r.remove());

    for (let r = 0; r < rowCount; r++) {
      const row = document.createElement('div'); row.className = 'row'; row.dataset.row = r;
      row.innerHTML = '<div class="rod"></div>';
      for (let b = 0; b < 10; b++) {
        const bead = document.createElement('div');
        const isRed = (r < 5) ? (b < 5) : (b >= 5);
        bead.className = `bead ${isRed ? 'red' : 'white'} ${isDraggable ? 'draggable' : ''}`;
        bead.dataset.idx = b;
        bead.style.left = (820 - (10 - b) * BEAD_W) + "px"; 
        
        if (isDraggable) {
            bead.onpointerdown = (e) => startDrag(e, side);
        }
        row.appendChild(bead);
      }
      frame.appendChild(row);
    }
  }

  function setAbacus(frame, total, type) {
    const rows = Array.from(frame.querySelectorAll('.row'));
    let remaining = total;
    let rowValues = Array(rows.length).fill(0);

    if (type === 'standard') {
      rows.forEach((row, i) => {
        let take = Math.min(10, remaining); remaining -= take;
        rowValues[i] = take;
      });
    } else if (type === 'disordered') {
      let indices = rows.map((_, i) => i).sort(() => Math.random() - 0.5);
      indices.forEach(i => { let take = Math.min(10, remaining); rowValues[i] = take; remaining -= take; });
    } else if (type === 'scattered') {
      while(remaining > 0) {
        let r = Math.floor(Math.random() * rows.length);
        if(rowValues[r] < 10) { rowValues[r]++; remaining--; }
      }
    }

    rows.forEach((row, i) => {
      let val = rowValues[i];
      if(frame === frameA) statesA[i] = val; else statesB[i] = val;

      row.querySelectorAll('.bead').forEach((b, idx) => {
        b.style.left = (idx < val) ? (idx * BEAD_W) + "px" : (820 - (10 - idx) * BEAD_W) + "px";
      });
    });
  }

  function checkAnswer(choice) {
    if (isAnswered) return;
    
    const correct = valA > valB ? '>' : (valA < valB ? '<' : '=');
    const btnClicked = Array.from(document.querySelectorAll('.btn-comp')).find(b => b.innerText === choice);

    if (choice === correct) {
      scoreGood++; document.getElementById('count-good').innerText = scoreGood;
      if(btnClicked) btnClicked.classList.add('selected-ok');
      
      // LEVEL UP AUTOMATIQUE (20 bonnes r√©ponses)
      if (scoreGood >= 20) {
          handleLevelUp();
          return;
      }

      curtainA.style.width = "0"; curtainB.style.width = "0";
      
      isAnswered = true;
      overlay.style.display = "flex";
      
      // Timer automatique : 1 seconde
      autoNextTimer = setTimeout(initGame, 1000);

    } else {
      scoreBad++; document.getElementById('count-bad').innerText = scoreBad;
      if(btnClicked) btnClicked.classList.add('selected-bad');
      
      setTimeout(() => {
          if(btnClicked) btnClicked.classList.remove('selected-bad');
      }, 800);
    }
  }

  function handleLevelUp() {
      const currentLevel = parseInt(document.getElementById('level-select').value);
      
      // Si niveau max atteint
      if (currentLevel >= 5) {
          feedbackText.innerText = "JEU TERMIN√â ! üèÜ";
          feedbackText.style.fontSize = "60px";
          btnNextOverlay.innerText = "Rejouer"; // Plus de fl√®che
          // Au clic, on remet tout √† z√©ro
          btnNextOverlay.onclick = () => {
              document.getElementById('level-select').value = 1;
              manualLevelChange(); // Cette fonction reset le score et relance le jeu
          };
          overlay.style.display = "flex";
          return;
      }

      // Sinon passage niveau suivant
      feedbackText.innerText = "NIVEAU SUIVANT ! üöÄ";
      feedbackText.style.fontSize = "50px";
      feedbackText.style.color = "var(--accent)";
      btnNextOverlay.style.display = "none"; // On cache le bouton, c'est auto
      overlay.style.display = "flex";

      // Pause pour lire le message
      setTimeout(() => {
          document.getElementById('level-select').value = currentLevel + 1;
          btnNextOverlay.style.display = "flex"; // R√©afficher pour la suite
          manualLevelChange(); // Reset score et start
      }, 1500);
  }

  function forceNextQuestion() { 
      if(autoNextTimer) clearTimeout(autoNextTimer);
      initGame(); 
  }

  // --- DRAG & DROP (Niveau 3) ---
  let activeDrag = null;
  function startDrag(e, side) {
    if (isPen) return; 
    const bead = e.target; 
    bead.setPointerCapture(e.pointerId);
    activeDrag = { 
        side, 
        rowIdx: parseInt(bead.parentElement.dataset.row), 
        beadIdx: parseInt(bead.dataset.idx), 
        rowEl: bead.parentElement, 
        startX: e.clientX 
    };
  }
  
  window.addEventListener('pointermove', (e) => {
    if (!activeDrag) return;
    const { side, rowIdx, beadIdx, rowEl, startX } = activeDrag;
    const state = side === 'a' ? statesA : statesB;
    const dx = (e.clientX - startX) / currentScale;
    const beads = rowEl.querySelectorAll('.bead');
    
    if (beadIdx >= state[rowIdx]) { 
        for (let i = state[rowIdx]; i <= beadIdx; i++) moveVisual(beads[i], i, dx, true); 
    } else { 
        for (let i = beadIdx; i < state[rowIdx]; i++) moveVisual(beads[i], i, dx, false); 
    }
  });

  function moveVisual(b, idx, dx, fromRight) {
    let base = fromRight ? (820 - (10 - idx) * BEAD_W) : (idx * BEAD_W);
    b.style.transition = 'none';
    let minX = idx * BEAD_W;
    let maxX = 820 - (10 - idx) * BEAD_W;
    b.style.left = Math.max(minX, Math.min(maxX, base + dx)) + "px";
  }

  window.addEventListener('pointerup', () => {
    if (!activeDrag) return;
    const { side, rowIdx, beadIdx, rowEl } = activeDrag;
    const state = side === 'a' ? statesA : statesB;
    const beads = rowEl.querySelectorAll('.bead');
    const currentPos = parseFloat(beads[beadIdx].style.left);
    
    if (beadIdx >= state[rowIdx]) { 
        if (currentPos < 410 + (beadIdx*5)) state[rowIdx] = beadIdx + 1; 
    } else { 
        if (currentPos > 410 - ((10-beadIdx)*5)) state[rowIdx] = beadIdx; 
    }
    
    activeDrag = null; 
    updateBeadsVisual(side);
  });

  function updateBeadsVisual(side) {
    const state = side === 'a' ? statesA : statesB;
    const frame = side === 'a' ? frameA : frameB;
    frame.querySelectorAll('.row').forEach((row, r) => {
      row.querySelectorAll('.bead').forEach((b, i) => {
        b.style.transition = 'left 0.2s ease-out';
        b.style.left = (i < state[r]) ? (i * BEAD_W) + "px" : (820 - (10 - i) * BEAD_W) + "px";
      });
    });
  }

  function autoScale() {
    const availableW = window.innerWidth - 40;
    const availableH = window.innerHeight - 80;
    const contentW = 1850; 
    const mode = parseInt(document.getElementById('mode-select').value);
    const contentH = mode === 100 ? 780 : 650;
    
    currentScale = Math.min(1.0, availableW / contentW, availableH / contentH);
    document.getElementById('scaler').style.transform = `scale(${currentScale})`;
  }

  window.addEventListener('resize', autoScale);
  // Support Touche Entr√©e
  document.addEventListener('keydown', (e) => {
      if(e.key === 'Enter' && isAnswered) forceNextQuestion();
  });

  initGame(); 
</script>
</body>
</html>
