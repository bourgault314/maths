<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Plateau – Bandes de fractions</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;800&display=swap" rel="stylesheet">

  <style>
    :root{
      --unitW: 420; /* largeur d'une unité */
      --stripH: 58;
      --boardBg: #ffffff;
      /* Couleur de la grille (bordures) */
      --gridColor: #000000; 
    }

    body{
      font-family: 'Fredoka', sans-serif;
      background: #ffffff;
      overflow: hidden;
      touch-action: none;
      user-select: none;
      -webkit-user-select: none;
    }

    /* --- NOUVEAU : Classe globale pour forcer la main fermée pendant le drag --- */
    body.is-dragging-global {
      cursor: grabbing !important;
    }
    body.is-dragging-global * {
      cursor: grabbing !important;
    }

    #board-container{
      position: absolute;
      inset: 0;
      overflow: hidden;
      /* RETOUR À GRAB (Main ouverte) */
      cursor: grab; 
      background: var(--boardBg);
    }
    #board-container.panning{ cursor: grabbing; }

    #board-world{
      position: absolute;
      top: 0; left: 0;
      transform-origin: 0 0;
      width: 0; height: 0;
    }

    #drawing-canvas{
      position: absolute;
      top: -2500px; 
      left: -2500px;
      pointer-events: none;
      z-index: 3000;
    }

    /* --- Jonctions "tableau" : on efface localement la double bordure puis on redessine une ligne unique --- */
    #seam-overlay{
      position: absolute;
      left: 0; top: 0;
      pointer-events: none;
      z-index: 95000; /* au-dessus des bandes */
    }
    .seam-patch, .seam-line{
      position: absolute;
      pointer-events: none;
    }
    .seam-patch{ background: var(--boardBg); }
    .seam-line{ background: var(--gridColor); }


    /* --- Demi-droite --- */
    #number-line{
      position: absolute;
      left: 0; top: 0;
      z-index: 2;
      pointer-events: none;
      opacity: 0.95;
    }
    #number-line.hidden{ display:none; }
    #number-line text{ font-family:'Fredoka', sans-serif; font-weight:800; }

    .no-scrollbar::-webkit-scrollbar{ display:none; }
    .no-scrollbar{ -ms-overflow-style:none; scrollbar-width:none; }

    /* --- Bandes / pièces --- */
    .strip{
      position: absolute;
      overflow: visible; 
      display: flex;
      align-items: stretch;
      justify-content: stretch;
      border-radius: 0px;
      box-shadow: none; 
      /* RETOUR À GRAB (Main ouverte) */
      cursor: grab;
      touch-action: none;
      transform-origin: 0 0;
      box-sizing: border-box;
      border: none;
      z-index: 10;
      perspective: 1000px;
    }
    
    .strip.dragging{ cursor: grabbing; z-index: 99000 !important; }
    .strip.selected { z-index: 88000 !important; }

    /* --- GESTION DU MASQUAGE --- */
    .strip.content-hidden .seg {
      color: transparent !important;
      text-shadow: none !important;
    }
    .strip.content-hidden .frac .bar {
      background-color: transparent !important;
    }
    .strip.content-hidden .back-one {
      color: transparent !important;
      text-shadow: none !important;
    }
    .strip.content-hidden .text-label {
      color: transparent !important;
      text-shadow: none !important;
    }

    /* --- Conteneur interne --- */
    .strip-inner{
      position: relative;
      width: 100%;
      height: 100%;
      flex: 1 1 auto;
      overflow: visible; 
      transition: transform 0.6s cubic-bezier(0.4, 0.0, 0.2, 1);
      transform-style: preserve-3d;
    }

/* --- Masques de jonctions (anti double-bordure, même en contact partiel) --- */
.seam-covers{
  position: absolute;
  top: 0;
  left: 0;
  right: -1px;
  bottom: -1px;
  pointer-events: none;
  z-index: 8; /* au-dessus des faces */
}
.seam-cover{
  position: absolute;
  background: var(--fillColor, transparent);
}


    .strip.selected .strip-inner {
      box-shadow: 0 0 0 3px rgba(59,130,246,0.85); 
    }
    
    .strip.is-back .strip-inner {
      transform: rotateY(180deg);
    }
    
    .face{
      position: absolute;
      inset: 0;
      display: flex;
      align-items: stretch;
      justify-content: stretch;
      -webkit-backface-visibility: hidden;
      backface-visibility: hidden;
      overflow: visible;

      border: none; 
      box-sizing: border-box; 
    }
    .face::after{
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      right: -1px;   /* décale la bordure droite d'1px vers l'extérieur */
      bottom: -1px;  /* décale la bordure basse d'1px vers l'extérieur */
      pointer-events: none;
      box-shadow: 
        inset var(--wL, 1px) 0 0 0 var(--gridColor),
        inset calc(var(--wR, 1px) * -1) 0 0 0 var(--gridColor),
        inset 0 var(--wT, 1px) 0 0 var(--gridColor),
        inset 0 calc(var(--wB, 1px) * -1) 0 0 var(--gridColor);
    }
    
    .face-front { z-index: 2; transform: rotateY(0deg); }
    .face-back { transform: rotateY(180deg); }

    /* Ghost drag */
    .strip.ghost{
      position: fixed;
      pointer-events: none;
      opacity: 0.96;
      z-index: 99999;
      box-shadow: 0 22px 38px rgba(0,0,0,0.30);
      transform: scale(0.98);
      transition: transform 120ms ease-out, opacity 120ms ease-out;
      overflow: hidden;
      border: 1px solid var(--gridColor);
    }
    .strip.ghost::after { content: none; }
    .strip.ghost.ready{ transform: scale(1); }

    .strip.spawn-pop{ animation: popIn 140ms ease-out; }
    @keyframes popIn{ from{ transform: scale(0.92); } to{ transform: scale(1); } }

    /* segments */
    .seg{
      flex: 1 1 auto;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight: 600;
      letter-spacing: 0;
      line-height: 1;
      text-shadow: 0 1px 0 rgba(255,255,255,0.35);
      text-align: center;
      transition: opacity 0.2s; 
    }
    .seg + .seg{ border-left: 1px dashed rgba(0,0,0,0.22); }

    /* fraction verticale */
    .frac{
      display: inline-flex;
      flex-direction: column;
      align-items: center;
      line-height: 1;
      transform: translateY(-1px);
      filter: drop-shadow(0 1px 0 rgba(255,255,255,0.35));
    }
    .frac .num, .frac .den{ font-weight: 700; }
    .frac .bar{
      width: 1.2em;
      height: 2px;
      background: rgba(0,0,0,0.65);
      border-radius: 2px;
      margin: 3px 0;
    }

    .back-one{
      font-weight: 800;
      font-size: 1.35rem;
      text-shadow: 0 2px 0 rgba(255,255,255,0.35);
    }

    .text-label {
      font-weight: 800;
      line-height: 1;
      text-align: center;
      text-shadow: 0 1px 0 rgba(255,255,255,0.4);
      white-space: nowrap;
    }
    .text-rotated {
      writing-mode: vertical-rl;
      transform: rotate(180deg);
      white-space: nowrap;
    }

    /* --- Menu gauche --- */
    .palette-item{
      padding: 6px 8px;
      border-radius: 12px;
      transition: none;
    }
    .palette-item:hover{ background: transparent; }

    .palette-label { display: none; }
    body.show-text-labels .palette-label { display: block; }

    .spawn-tile{
      height: 40px;
      flex: 0 0 auto;
      flex-shrink: 0;
      position: relative;
      border-radius: 0px;
      border: none;
      overflow: hidden;
      display: flex;
      /* Main ouverte dans le menu */
      cursor: grab;
      box-shadow:
        0 4px 10px rgba(0,0,0,0.18),
        inset 0 0 0 1px rgba(0,0,0,0.55);
      user-select: none;
      touch-action: none;
      background: transparent;
    }
    .spawn-tile:active{ cursor: grabbing; }

    .spawn-seg{ flex: 1 1 auto; display:flex; align-items:center; justify-content:center; font-weight:800; font-size: 10px; }
    .spawn-seg + .spawn-seg{ border-left: 1px dashed rgba(0,0,0,0.22); }

    .frac.menu{ transform: none; filter: none; font-size: inherit; }
    .frac.menu .bar{ width: 0.9em; height: 2px; margin: 2px 0; background: rgba(0,0,0,0.70); }

    /* Mode crayon */
    body.pen-mode #board-container{ cursor: crosshair; }
    body.pen-mode #board-container.panning{ cursor: grabbing; }
    body.pen-mode .strip{ cursor: crosshair; }
    body.pen-mode .strip.dragging{ cursor: grabbing; }

    .mode-btn {
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 13px;
      font-weight: 800;
      color: #334155; 
      transition: all 0.1s;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .mode-btn:hover { background-color: rgba(255,255,255,0.6); }
    .mode-btn.active {
      background-color: #2563eb; 
      color: #ffffff;
      box-shadow: 0 1px 2px rgba(0,0,0,0.2);
    }

    @media (max-width: 640px){
      :root{ --stripH: 52; }
    }
  </style>
</head>

<body class="h-screen w-screen flex flex-col">

  <header class="bg-blue-50 p-2 shadow-md z-30 flex flex-wrap items-center gap-3 shrink-0">
    <div class="flex items-center gap-2">
      <button id="btn-undo" class="bg-blue-100 text-blue-700 hover:bg-blue-200 p-2 rounded-lg font-bold border border-blue-200 shadow-sm active:scale-95 transition" title="Annuler">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6" />
        </svg>
      </button>

      <button id="btn-clear" class="bg-rose-100 text-rose-700 hover:bg-rose-200 p-2 rounded-lg font-bold border border-rose-200 shadow-sm active:scale-95 transition" title="Tout effacer">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
        </svg>
      </button>

      <div id="mode-selector" class="flex bg-blue-200/50 rounded-lg p-1 gap-0.5 border border-blue-200 shadow-inner">
        <button class="mode-btn active" data-mode="numeric" title="Fraction">1/2</button>
        <button class="mode-btn" data-mode="text" title="Lettres">ABC</button>
        <button class="mode-btn" data-mode="percent" title="Pourcentage">%</button>
        <button class="mode-btn" data-mode="decimal" title="Décimal">0,5</button>
        <button class="mode-btn" data-mode="empty" title="Vide (sans texte)">
            <div class="w-3.5 h-3.5 border-2 border-current rounded-sm"></div>
        </button>
      </div>

      <button id="btn-numberline" class="bg-white text-slate-800 hover:bg-slate-100 p-2 rounded-lg font-bold border border-slate-200 shadow-sm active:scale-95 transition" title="Afficher / masquer la demi-droite">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M4 14H18" />
          <path d="M18 14l-3-3" />
          <path d="M18 14l-3 3" />
          <path d="M4 10v8" />
        </svg>
      </button>

      <div class="h-8 w-px bg-slate-200 mx-1"></div>

      <button id="btn-zoom-out" class="bg-slate-100 hover:bg-slate-200 text-slate-800 px-3 py-2 rounded-lg border border-slate-200 font-bold active:scale-95 transition" title="Zoom -">−</button>
      <button id="btn-zoom-in" class="bg-slate-100 hover:bg-slate-200 text-slate-800 px-3 py-2 rounded-lg border border-slate-200 font-bold active:scale-95 transition" title="Zoom +">+</button>
      <button id="btn-reset-view" class="bg-slate-100 hover:bg-slate-200 text-slate-800 px-3 py-2 rounded-lg border border-slate-200 font-bold active:scale-95 transition" title="Recentrer">⤾</button>
    </div>

    <div id="selection-actions" class="flex items-center gap-2">
      <button id="btn-hide" disabled class="bg-slate-500 hover:bg-slate-600 disabled:bg-slate-200 text-white px-2 py-1 rounded-lg shadow-sm border border-slate-200 disabled:opacity-40 disabled:cursor-not-allowed active:scale-95 transition flex flex-col items-center gap-0.5" title="Masquer / Afficher le contenu de cette pièce">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"></path>
          <line x1="1" y1="1" x2="23" y2="23"></line>
        </svg>
        <span class="text-[10px] font-extrabold leading-none">Masquer</span>
      </button>

      <button id="btn-flip" disabled class="bg-amber-500 hover:bg-amber-600 disabled:bg-amber-200 text-white px-2 py-1 rounded-lg shadow-sm border border-amber-200 disabled:opacity-40 disabled:cursor-not-allowed active:scale-95 transition flex flex-col items-center gap-0.5" title="Retourner (double-clic aussi)">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M3 12a9 9 0 0 1 9-9"/>
          <path d="M3 4v8h8"/>
          <path d="M21 12a9 9 0 0 1-9 9"/>
          <path d="M21 20v-8h-8"/>
        </svg>
        <span class="text-[10px] font-extrabold leading-none">Retourner</span>
      </button>

      <button id="btn-separate" disabled class="bg-blue-600 hover:bg-blue-700 disabled:bg-blue-200 text-white px-2 py-1 rounded-lg shadow-sm border border-blue-200 disabled:opacity-40 disabled:cursor-not-allowed active:scale-95 transition flex flex-col items-center gap-0.5" title="Séparer la bande en pièces">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M4 4l16 16"/>
          <path d="M4 20L20 4"/>
        </svg>
        <span class="text-[10px] font-extrabold leading-none">Séparer</span>
      </button>

      <button id="btn-cut" disabled class="bg-slate-700 hover:bg-slate-800 disabled:bg-slate-200 text-white px-2 py-1 rounded-lg shadow-sm border border-slate-200 disabled:opacity-40 disabled:cursor-not-allowed active:scale-95 transition flex flex-col items-center gap-0.5" title="Couper en 2 (si le double existe)">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="6" cy="6" r="2"/>
          <circle cx="6" cy="18" r="2"/>
          <path d="M20 4L8.12 15.88"/>
          <path d="M14.47 14.48L20 20"/>
          <path d="M8.12 8.12L12 12"/>
        </svg>
        <span class="text-[10px] font-extrabold leading-none">Couper</span>
      </button>

      <button id="btn-fuse" disabled class="bg-violet-600 hover:bg-violet-700 disabled:bg-violet-200 text-white px-2 py-1 rounded-lg shadow-sm border border-violet-200 disabled:opacity-40 disabled:cursor-not-allowed active:scale-95 transition flex flex-col items-center gap-0.5" title="Fusionner des pièces alignées en une bande">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M10 13a5 5 0 0 1 0-7l1-1a5 5 0 0 1 7 7l-1 1"/>
          <path d="M14 11a5 5 0 0 1 0 7l-1 1a5 5 0 0 1-7-7l1-1"/>
        </svg>
        <span class="text-[10px] font-extrabold leading-none">Fusionner</span>
      </button>

      <button id="btn-duplicate" disabled class="bg-emerald-600 hover:bg-emerald-700 disabled:bg-emerald-200 text-white px-2 py-1 rounded-lg shadow-sm border border-emerald-200 disabled:opacity-40 disabled:cursor-not-allowed active:scale-95 transition flex flex-col items-center gap-0.5" title="Dupliquer">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <rect x="9" y="9" width="13" height="13" rx="2"/>
          <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
        </svg>
        <span class="text-[10px] font-extrabold leading-none">Dupliquer</span>
      </button>

      <button id="btn-delete" disabled class="bg-rose-600 hover:bg-rose-700 disabled:bg-rose-200 text-white px-2 py-1 rounded-lg shadow-sm border border-rose-200 disabled:opacity-40 disabled:cursor-not-allowed active:scale-95 transition flex flex-col items-center gap-0.5" title="Supprimer">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
        </svg>
        <span class="text-[10px] font-extrabold leading-none">Supprimer</span>
      </button>
    </div>

    <div class="flex items-center gap-1 bg-gray-100 p-1 rounded-lg">
      <button id="tool-hand" class="p-2 rounded bg-white shadow text-gray-700" title="Main (déplacer / sélectionner)">
        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 11.5V14m0-2.5v-6a1.5 1.5 0 113 0m-3 6a1.5 1.5 0 00-3 0v2a7.5 7.5 0 0015 0v-5a1.5 1.5 0 00-3 0m-6-3V11m0-5.5v-1a1.5 1.5 0 013 0v1m0 0V11m0-5.5a1.5 1.5 0 013 0v3m0 0V11"/>
        </svg>
      </button>

      <button id="tool-pen" class="p-2 rounded text-gray-700 hover:bg-white" title="Crayon (annoter)">
        <svg class="w-5 h-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M12 20h9" />
          <path d="M16.5 3.5a2.1 2.1 0 0 1 3 3L8 18l-4 1 1-4 11.5-11.5z" />
        </svg>
      </button>

      <button id="btn-clear-drawing" class="p-2 rounded text-rose-500 hover:bg-rose-50" title="Effacer les annotations">
        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
        </svg>
      </button>
    </div>
  </header>

  <div class="flex flex-1 overflow-hidden relative">

    <aside class="w-[340px] bg-blue-50 border-r border-blue-200 flex flex-col py-4 gap-3 z-20 shadow-lg shrink-0 overflow-y-auto no-scrollbar">
      <div class="px-3"></div>
      <div id="palette" class="px-3 flex flex-col gap-3"></div>
    </aside>

    <main class="flex-1 relative overflow-hidden">
      <div id="board-container">
        <div id="board-world">
          <div id="seam-overlay"></div>
          <canvas id="drawing-canvas"></canvas>
          <div id="number-line" class="hidden"></div>
        </div>
      </div>
    </main>

  </div>

<script>
  // --- Configuration couleurs ---
  const FRACTIONS = [
    { denom: 1,  name: 'Unité',     color: '#fff7e6', border: '#cbd5e1', text: '#111827' },
    { denom: 2,  name: 'Demi',      color: '#facc15', border: '#a16207', text: '#111827' },
    { denom: 3,  name: 'Tiers',     color: '#e9d5ff', border: '#7c3aed', text: '#111827' },
    { denom: 4,  name: 'Quart',     color: '#84cc16', border: '#3f6212', text: '#111827' },
    { denom: 5,  name: 'Cinquième', color: '#38bdf8', border: '#075985', text: '#0b1220' },
    { denom: 6,  name: 'Sixième',   color: '#f97316', border: '#9a3412', text: '#111827' },
    { denom: 8,  name: 'Huitième',  color: '#f472b6', border: '#be185d', text: '#111827' },
    { denom: 10, name: 'Dixième',   color: '#b91c1c', border: '#7f1d1d', text: '#111827' },
  ];

  let audioCtx = null;
  try{ audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }catch(_){ audioCtx = null; }

  function playSound(type){
    if (!audioCtx) return;
    if (audioCtx.state === 'suspended') audioCtx.resume().catch(()=>{});
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain); gain.connect(audioCtx.destination);
    const now = audioCtx.currentTime;
    const stop = (t)=>{ try{ osc.stop(t); }catch(_){} };
    if(type==='pop'){
      osc.type='sine';
      osc.frequency.setValueAtTime(320, now);
      osc.frequency.exponentialRampToValueAtTime(560, now+0.08);
      gain.gain.setValueAtTime(0.10, now);
      gain.gain.linearRampToValueAtTime(0, now+0.10);
      osc.start(now); stop(now+0.10);
    } else if(type==='flip'){
      osc.type='triangle';
      osc.frequency.setValueAtTime(210, now);
      osc.frequency.linearRampToValueAtTime(440, now+0.16);
      gain.gain.setValueAtTime(0.10, now);
      gain.gain.linearRampToValueAtTime(0, now+0.18);
      osc.start(now); stop(now+0.18);
    } else if(type==='whoosh'){
      osc.type='triangle';
      osc.frequency.setValueAtTime(360, now);
      osc.frequency.exponentialRampToValueAtTime(60, now+0.22);
      gain.gain.setValueAtTime(0.06, now);
      gain.gain.linearRampToValueAtTime(0, now+0.22);
      osc.start(now); stop(now+0.22);
    }
  }

  class FractionStripsApp {
    constructor(){
      this.history = [];
      this.tokens = []; 
      this.nextId = 1;
      this.topZ = 200; 
      
      this.selectedId = null;
      // 'numeric', 'text', 'percent', 'decimal', 'empty'
      this.labelMode = 'numeric';

      this.scale = 1;
      this.pan = {x: 0, y: 0};
      this.isPanning = false;
      this.panStart = {x:0, y:0};

      this.currentTool = 'hand';
      this.isDrawing = false;
      this.drawPoints = [];
      this.basePenPx = 2.55;

      this.spawnDrag = null;
      this._lastSpawnClient = {x:0, y:0};

      this.boardContainer = document.getElementById('board-container');
      this.boardWorld = document.getElementById('board-world');
      this.seamOverlay = document.getElementById('seam-overlay');
      this.palette = document.getElementById('palette');

      this.canvas = document.getElementById('drawing-canvas');
      this.ctx = this.canvas.getContext('2d');

      this.numberLineEl = document.getElementById('number-line');
      this.numberLine = {
        active: false,
        x: 0,
        y: 0,
        len: Math.max(this.unitW * 10.0, 6000),
        baselineOffset: 18,
        height: 46
      };

      this.DENOM_SET = new Set(FRACTIONS.map(f => f.denom));

      this.buildPalette();
      this.initUI();
      this.initBoardListeners();
      this.resizeCanvas();
      this.updateTransform();
      this.updateSelectionUI();
      this.updateNumberLineEl();
    }

    get unitW(){ return parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--unitW')) || 420; }
    get stripH(){ return parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--stripH')) || 58; }
    pieceW(denom){ return this.unitW / denom; }

    tokenDims(t){
      return {
        w: (t.kind === 'band') ? this.unitW : this.pieceW(t.denom),
        h: this.stripH,
      };
    }

    roundPos(v){
      return Math.round(v * 2) / 2;
    }

    saveState(){
      const snapshot = {
        tokens: this.tokens.map(t => ({
          id:t.id, 
          denom:t.denom, 
          kind:t.kind, 
          side:t.side, 
          x:t.x, 
          y:t.y, 
          z:t.z, 
          hidden: t.hidden 
        })),
        nextId: this.nextId,
        topZ: this.topZ,
        selectedId: this.selectedId,
        pan: {...this.pan},
        scale: this.scale,
        labelMode: this.labelMode
      };
      this.history.push(snapshot);
      if(this.history.length > 30) this.history.shift();
    }

    undo(){
      const snap = this.history.pop();
      if(!snap) return;
      this.clearAllTokens(false);
      this.tokens = snap.tokens.map(t => ({...t}));
      this.nextId = snap.nextId;
      this.topZ = snap.topZ || 200;
      
      this.selectedId = snap.selectedId;
      this.pan = snap.pan;
      this.scale = snap.scale;
      this.labelMode = snap.labelMode || 'numeric';
      this.updateModeUI();
      
      this.buildPalette();
      
      this.tokens.forEach(t => this.mountToken(t));
      this.updateTransform();
      this.updateSelectionUI();
      playSound('whoosh');
    }

    getTextLabel(denom){
      const map = {
        1: 'une unité', 2: 'un demi', 3: 'un tiers', 4: 'un quart',
        5: 'un cinquième', 6: 'un sixième', 8: 'un huitième', 10: 'un dixième'
      };
      return map[denom] || '';
    }

    isRotatedText(denom){
      return (denom >= 5 && denom !== 7 && denom !== 9); 
    }

    getLabelHTML(denom, isBackOfBand = false){
      if(this.labelMode === 'empty') return '';

      if(isBackOfBand){
        if(this.labelMode === 'text'){
          return `<span class="text-label" style="font-size:18px;">une unité</span>`;
        } else if(this.labelMode === 'percent'){
          return `<span class="back-one" style="font-size:22px;">100 %</span>`;
        } else {
          return `<span class="back-one">1</span>`;
        }
      }

      if(this.labelMode === 'text'){
        const txt = this.getTextLabel(denom);
        const rotated = this.isRotatedText(denom);
        let fs;
        if(rotated){
           if(denom === 6) fs = '11px';      
           else if(denom === 8) fs = '10px'; 
           else fs = '10px';                 
        } else {
           fs = (denom >= 5) ? '13px' : '15px';
        }
        const cls = rotated ? 'text-label text-rotated' : 'text-label';
        return `<span class="${cls}" style="font-size:${fs};">${txt}</span>`;
      } 
      else if(this.labelMode === 'percent'){
        const val = (100 / denom);
        const txt = val.toLocaleString('fr-FR', { maximumFractionDigits: 2 }) + ' %';
        let fs = '14px';
        if(denom >= 10) fs = '10px';
        else if(denom >= 8) fs = '10px';
        else if(denom >= 6) fs = '11px';
        else if(denom === 5) fs = '12px';
        return `<span class="text-label" style="font-size:${fs};">${txt}</span>`;
      }
      else if(this.labelMode === 'decimal'){
        const val = (1 / denom);
        const txt = val.toLocaleString('fr-FR', { maximumFractionDigits: 3 });
        let fs = '15px';
        if(denom >= 10) fs = '10px';
        else if(denom >= 8) fs = '10px';
        else if(denom >= 6) fs = '11px';
        else if(denom === 5) fs = '12px';
        return `<span class="text-label" style="font-size:${fs};">${txt}</span>`;
      }
      else {
        if(denom === 1) return `<span class="back-one">1</span>`;
        return `<span class="frac"><span class="num">1</span><span class="bar"></span><span class="den">${denom}</span></span>`;
      }
    }

    fontSizeFor(denom, kind){
      if(this.labelMode === 'empty') return 0;
      if(this.labelMode !== 'numeric') return 16;
      if(kind === 'piece'){
        if(denom >= 10) return 14;
        if(denom >= 8) return 15;
        if(denom >= 6) return 16;
        return 17;
      }
      if(denom >= 10) return 15;
      if(denom >= 8) return 16;
      if(denom >= 6) return 17;
      return 18;
    }

    buildPalette(){
      this.palette.innerHTML = '';
      FRACTIONS.forEach(f => {
        const row = document.createElement('div');
        row.className = 'palette-item flex flex-col'; 
        const label = document.createElement('div');
        label.className = 'palette-label text-xs font-bold text-slate-500 mb-1 ml-1 capitalize';
        let text = f.name;
        if(f.denom > 1 && !text.endsWith('s')) text += 's';
        label.textContent = text;
        row.appendChild(label);
        const picks = document.createElement('div');
        picks.className = 'flex items-center gap-3 flex-nowrap';
        picks.appendChild(this.makeSpawnTile(f.denom, 'band'));
        if(f.denom !== 1) picks.appendChild(this.makeSpawnTile(f.denom, 'piece'));
        row.appendChild(picks);
        this.palette.appendChild(row);
      });
    }

    getFractionConfig(denom){
      return FRACTIONS.find(f => f.denom === denom) || FRACTIONS[0];
    }

    makeSpawnTile(denom, kind){
      const cfg = this.getFractionConfig(denom);
      const tile = document.createElement('div');
      tile.className = `spawn-tile ${kind==='band' ? 'spawn-band' : 'spawn-piece'}`;
      tile.style.background = cfg.color;
      tile.style.borderColor = cfg.border;
      tile.setAttribute('draggable', 'false');
      tile.title = (kind === 'band') ? 'Ajouter une bande' : 'Ajouter une pièce';
      const menuBandW = 170;
      const w = (kind === 'band') ? menuBandW : Math.max(18, Math.round(menuBandW / denom));
      tile.style.width = w + 'px';
      
      const segCount = (kind === 'band') ? denom : 1;
      for(let i=0;i<segCount;i++){
        const seg = document.createElement('div');
        seg.className = 'spawn-seg';
        seg.style.color = cfg.text;
        
        if(this.labelMode === 'empty'){
           seg.innerHTML = '';
        } else {
           const fsMenu = (denom >= 10) ? 9 : (denom >= 8) ? 10 : (denom >= 6) ? 11 : 12;
           seg.style.fontSize = fsMenu + 'px';
           if(denom === 1){
             seg.innerHTML = `<span class="back-one" style="font-size:${Math.max(fsMenu,12)}px;color:${cfg.text}">1</span>`;
           } else {
             seg.innerHTML = `<span class="frac menu" style="color:${cfg.text};font-size:${fsMenu}px"><span class="num">1</span><span class="bar"></span><span class="den">${denom}</span></span>`;
           }
        }
        tile.appendChild(seg);
      }
      const start = (e) => this.startSpawnDrag(e, denom, kind);
      tile.addEventListener('mousedown', start);
      tile.addEventListener('touchstart', start, {passive:false});
      return tile;
    }

    buildGhostStrip(denom, kind, side){
      const cfg = this.getFractionConfig(denom);
      const el = document.createElement('div');
      el.className = 'strip ghost';
      el.style.background = cfg.color;
      el.style.borderColor = cfg.border;
      const segCount = (side === 'back') ? 1 : ((kind === 'band') ? denom : 1);
      const fs = this.fontSizeFor(denom, kind) * this.scale;
      for(let i=0;i<segCount;i++){
        const seg = document.createElement('div');
        seg.className = 'seg';
        seg.style.color = cfg.text;
        seg.style.fontSize = `${fs}px`;
        if(side === 'front'){
          seg.innerHTML = this.getLabelHTML(denom, false);
        } else {
          const isBandBack = (kind === 'band' || denom === 1);
          seg.innerHTML = this.getLabelHTML(denom, isBandBack);
        }
        el.appendChild(seg);
      }
      return el;
    }

    startSpawnDrag(e, denom, kind){
      if(e.type === 'mousedown' && e.button !== 0) return;
      e.preventDefault();
      e.stopPropagation();
      const pt = e.touches ? e.touches[0] : e;
      const cx = pt.clientX;
      const cy = pt.clientY;
      this._lastSpawnClient = {x: cx, y: cy};
      const wWorld = (kind === 'band') ? this.unitW : this.pieceW(denom);
      const hWorld = this.stripH;
      const w = wWorld * this.scale;
      const h = hWorld * this.scale;
      const ghost = this.buildGhostStrip(denom, kind, 'front');
      ghost.style.width = `${w}px`;
      ghost.style.height = `${h}px`;
      ghost.style.left = `${cx - w/2}px`;
      ghost.style.top  = `${cy - h/2}px`;
      document.body.appendChild(ghost);
      requestAnimationFrame(() => ghost.classList.add('ready'));
      
      // AJOUT : Forcer le curseur global
      document.body.classList.add('is-dragging-global');

      this.spawnDrag = { denom, kind, start: {x: cx, y: cy}, moved: false, ghost, w, h };
      const move = (ev) => this.onSpawnMove(ev);
      const end  = (ev) => this.onSpawnEnd(ev, move, end);
      document.addEventListener('mousemove', move);
      document.addEventListener('mouseup', end);
      document.addEventListener('touchmove', move, {passive:false});
      document.addEventListener('touchend', end);
      document.addEventListener('touchcancel', end);
    }

    onSpawnMove(ev){
      const sd = this.spawnDrag;
      if(!sd) return;
      ev.preventDefault();
      const pt = ev.touches ? ev.touches[0] : ev;
      const cx = pt.clientX;
      const cy = pt.clientY;
      this._lastSpawnClient = {x: cx, y: cy};
      const dist = Math.hypot(cx - sd.start.x, cy - sd.start.y);
      if(dist > 6) sd.moved = true;
      sd.ghost.style.left = `${cx - sd.w/2}px`;
      sd.ghost.style.top  = `${cy - sd.h/2}px`;
    }

    onSpawnEnd(ev, moveFn, endFn){
      const sd = this.spawnDrag;
      
      // RETRAIT : Enlever le curseur global
      document.body.classList.remove('is-dragging-global');

      if(!sd) return;
      document.removeEventListener('mousemove', moveFn);
      document.removeEventListener('mouseup', endFn);
      document.removeEventListener('touchmove', moveFn);
      document.removeEventListener('touchend', endFn);
      document.removeEventListener('touchcancel', endFn);
      const cx = (ev.changedTouches && ev.changedTouches[0]) ? ev.changedTouches[0].clientX : this._lastSpawnClient.x;
      const cy = (ev.changedTouches && ev.changedTouches[0]) ? ev.changedTouches[0].clientY : this._lastSpawnClient.y;
      const br = this.boardContainer.getBoundingClientRect();
      const insideBoard = (cx >= br.left && cx <= br.right && cy >= br.top && cy <= br.bottom);
      if(insideBoard){
        const p = this.getWorldPos(cx, cy);
        const created = this.addToken({denom: sd.denom, kind: sd.kind, x: p.x, y: p.y});
        this.snapToken(created, {silent:true});
      } else if(!sd.moved){
        const center = this.getWorldPos(br.left + br.width*0.5, br.top + br.height*0.35);
        this.addToken({denom: sd.denom, kind: sd.kind, x: center.x, y: center.y});
      }
      if(sd.ghost) sd.ghost.remove();
      this.spawnDrag = null;
    }

    updateTransform(){
      this.boardWorld.style.transform = `translate(${this.pan.x}px, ${this.pan.y}px) scale(${this.scale})`;
    }

    zoomAt(clientX, clientY, newScale){
      const oldScale = this.scale;
      const z = Math.min(Math.max(0.45, newScale), 3);
      if(z === oldScale) return;
      const r = this.boardContainer.getBoundingClientRect();
      const wx = (clientX - r.left - this.pan.x) / oldScale;
      const wy = (clientY - r.top  - this.pan.y) / oldScale;
      this.scale = z;
      this.pan.x = clientX - r.left - wx * this.scale;
      this.pan.y = clientY - r.top  - wy * this.scale;
      this.updateTransform();
    }

    setZoom(z){
      const br = this.boardContainer.getBoundingClientRect();
      this.zoomAt(br.left + br.width/2, br.top + br.height/2, z);
    }

    resetView(){
      this.pan = {x:0, y:0};
      this.scale = 1;
      this.updateTransform();
    }

    toggleNumberLine(){
      this.numberLine.active = !this.numberLine.active;
      if(this.numberLine.active){
        const br = this.boardContainer.getBoundingClientRect();
        const p = this.getWorldPos(br.left + 120, br.top + br.height * 0.72);
        this.numberLine.x = p.x;
        this.numberLine.y = p.y;
        playSound('pop');
      } else {
        playSound('whoosh');
      }
      this.updateNumberLineEl();
    }

    updateNumberLineEl(){
      if(!this.numberLineEl) return;
      if(!this.numberLine.active){
        this.numberLineEl.classList.add('hidden');
        this.numberLineEl.innerHTML = '';
        return;
      }
      const nl = this.numberLine;
      const len = Math.round(nl.len);
      const base = nl.baselineOffset;
      const H = nl.height;
      this.numberLineEl.style.left = `${nl.x}px`;
      this.numberLineEl.style.top  = `${nl.y - base}px`;
      const arrowX = len;
      const a = 12;
      const y = base;
      this.numberLineEl.classList.remove('hidden');
      this.numberLineEl.innerHTML = `
        <svg width="${len}" height="${H}" viewBox="0 0 ${len} ${H}" xmlns="http://www.w3.org/2000/svg">
          <line x1="0" y1="${y}" x2="${len}" y2="${y}" stroke="rgba(17,24,39,0.9)" stroke-width="2" stroke-linecap="round" />
          <line x1="0" y1="${y-10}" x2="0" y2="${y+10}" stroke="rgba(17,24,39,0.9)" stroke-width="2" stroke-linecap="round" />
          <polygon points="${arrowX},${y} ${arrowX-a},${y-a*0.7} ${arrowX-a},${y+a*0.7}" fill="rgba(17,24,39,0.9)" />
          <text x="2" y="${y+20}" font-size="18" font-family="Fredoka, sans-serif" font-weight="800" fill="#111827">0</text>
        </svg>
      `;
    }

    getWorldPos(clientX, clientY){
      const r = this.boardContainer.getBoundingClientRect();
      return {
        x: (clientX - r.left - this.pan.x) / this.scale,
        y: (clientY - r.top - this.pan.y) / this.scale,
      };
    }

    _bind(id, evt, fn){
      const el = document.getElementById(id);
      if(!el) return null;
      el.addEventListener(evt, fn);
      return el;
    }

    initUI(){
      this._bind('btn-undo','click', () => this.undo());
      this._bind('btn-clear','click', () => this.resetAll());
      
      const modeButtons = document.querySelectorAll('.mode-btn');
      modeButtons.forEach(btn => {
        btn.addEventListener('click', (e) => {
          const target = e.currentTarget; 
          const newMode = target.dataset.mode;
          if(newMode && newMode !== this.labelMode){
             this.setLabelMode(newMode);
          }
        });
      });

      this._bind('btn-numberline','click', () => this.toggleNumberLine());
      this._bind('btn-zoom-in','click', () => this.setZoom(this.scale + 0.15));
      this._bind('btn-zoom-out','click', () => this.setZoom(this.scale - 0.15));
      this._bind('btn-reset-view','click', () => this.resetView());
      this._bind('btn-flip','click', () => this.flipSelected());
      this._bind('btn-separate','click', () => this.separateSelected());
      this._bind('btn-cut','click', () => this.cutSelected());
      this._bind('btn-fuse','click', () => this.fuseSelected());
      this._bind('btn-duplicate','click', () => this.duplicateSelected());
      this._bind('btn-delete','click', () => this.deleteSelected());
      
      this._bind('btn-hide','click', () => this.toggleHideSelected());

      this._bind('tool-hand','click', () => this.setTool('hand'));
      this._bind('tool-pen','click', () => this.setTool('pen'));
      this._bind('btn-clear-drawing','click', () => this.clearDrawing());
      window.addEventListener('keydown', (e) => {
        if(e.key === 'Escape') this.selectToken(null);
        if((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') { e.preventDefault(); this.undo(); }
        if(e.key === 'Delete' || e.key === 'Backspace') this.deleteSelected();
      });
    }

    setLabelMode(newMode){
      this.labelMode = newMode;
      document.body.classList.toggle('show-text-labels', this.labelMode === 'text');
      this.updateModeUI();
      
      this.buildPalette();

      const selId = this.selectedId;
      this.tokens.forEach(t => { if(t._el) t._el.remove(); });
      this.tokens.forEach(t => this.mountToken(t));
      if(selId) this.selectToken(selId);
      playSound('pop');
    }

    updateModeUI(){
       const modeButtons = document.querySelectorAll('.mode-btn');
       modeButtons.forEach(btn => {
         if(btn.dataset.mode === this.labelMode) btn.classList.add('active');
         else btn.classList.remove('active');
       });
    }

    updateSelectionUI(){
      const btnFlip = document.getElementById('btn-flip');
      const btnSep  = document.getElementById('btn-separate');
      const btnCut  = document.getElementById('btn-cut');
      const btnFuse = document.getElementById('btn-fuse');
      const btnDup  = document.getElementById('btn-duplicate');
      const btnDel  = document.getElementById('btn-delete');
      const btnHide = document.getElementById('btn-hide');
      
      const s = this.selected;
      const has = !!s;
      if(btnFlip) btnFlip.disabled = !has;
      if(btnDup)  btnDup.disabled  = !has;
      if(btnDel)  btnDel.disabled  = !has;
      if(btnHide) btnHide.disabled = !has;
      
      if(btnSep)  btnSep.disabled  = !(has && s.kind === 'band'  && s.denom > 1);
      if(btnFuse) btnFuse.disabled = !(has && s.kind === 'piece' && s.denom > 1);
      if(btnCut)  btnCut.disabled  = !(has && this.canCut(s));
    }

    initBoardListeners(){
      this.boardContainer.addEventListener('wheel', (e) => {
        e.preventDefault();
        const dir = (e.deltaY > 0) ? -1 : 1;
        const step = 0.12;
        this.zoomAt(e.clientX, e.clientY, this.scale + dir * step);
      }, {passive:false});
      this.boardContainer.addEventListener('contextmenu', (e) => {
        if(this.currentTool === 'pen') e.preventDefault();
      });
      this.boardContainer.addEventListener('mousedown', (e) => {
        const isPen  = (this.currentTool === 'pen');
        const wantsPan = (!isPen && e.button === 0) || (isPen && e.button === 2);
        if(!wantsPan) return;
        if(e.target.closest('.strip')) return;
        this.isPanning = true;
        this.panStart = {x: e.clientX - this.pan.x, y: e.clientY - this.pan.y};
        this.boardContainer.classList.add('panning');
        
        // AJOUT : Curseur global pour le panning aussi
        document.body.classList.add('is-dragging-global');

        if(!isPen) this.selectToken(null);
      });
      this.boardContainer.addEventListener('mousedown', (e) => {
        if(this.currentTool === 'pen' && e.button === 0) this.startDraw(e);
      });
      window.addEventListener('mousemove', (e) => {
        if(this.isPanning){
          this.pan.x = e.clientX - this.panStart.x;
          this.pan.y = e.clientY - this.panStart.y;
          this.updateTransform();
        } else if(this.isDrawing && this.currentTool === 'pen'){
          this.draw(e);
        }
      });
      window.addEventListener('mouseup', () => {
        this.isPanning = false;
        
        // RETRAIT : Curseur global
        document.body.classList.remove('is-dragging-global');

        if(this.isDrawing && this.currentTool === 'pen') this.endDraw();
        this.isDrawing = false;
        this.boardContainer.classList.remove('panning');
      });
      window.addEventListener('resize', () => this.resizeCanvas());
    }

    mountToken(token){
      const cfg = this.getFractionConfig(token.denom);
      const el = document.createElement('div');
      el.className = 'strip';
      el.dataset.id = String(token.id);
      el.style.setProperty('--fillColor', cfg.color);
      
      const h = this.stripH;
      const w = (token.kind === 'band') ? this.unitW : this.pieceW(token.denom);

      el.style.width = `${w}px`;
      el.style.height = `${h}px`;
      el.style.left = `${token.x}px`;
      el.style.top = `${token.y}px`;
      el.style.zIndex = token.z || String(10 + token.id);

      if(token.hidden) el.classList.add('content-hidden');

      if(token.side === 'back') el.classList.add('is-back');

      const inner = document.createElement('div');
      inner.className = 'strip-inner';

      const faceFront = document.createElement('div');
      faceFront.className = 'face face-front';
      faceFront.style.background = cfg.color;

      const faceBack = document.createElement('div');
      faceBack.className = 'face face-back';
      faceBack.style.background = cfg.color;

      const segCountFront = (token.kind === 'band') ? token.denom : 1;
      for(let i=0;i<segCountFront;i++){
        const seg = document.createElement('div');
        seg.className = 'seg';
        seg.style.color = cfg.text;
        seg.style.fontSize = `${this.fontSizeFor(token.denom, token.kind)}px`;
        seg.innerHTML = this.getLabelHTML(token.denom, false);
        faceFront.appendChild(seg);
      }

      const backSeg = document.createElement('div');
      backSeg.className = 'seg';
      backSeg.style.color = cfg.text;
      
      const isBandBack = (token.kind === 'band' || token.denom === 1);
      backSeg.style.fontSize = `${this.fontSizeFor(isBandBack ? 1 : token.denom, isBandBack ? 'band' : 'piece')}px`;
      backSeg.innerHTML = this.getLabelHTML(token.denom, isBandBack);
      
      faceBack.appendChild(backSeg);

      inner.appendChild(faceFront);
      inner.appendChild(faceBack);
      el.appendChild(inner);

      // Calque dédié aux masques de jonctions (pour éviter les doubles bordures sur contact partiel)
      const seamCovers = document.createElement('div');
      seamCovers.className = 'seam-covers';
      inner.appendChild(seamCovers);
      token._seamEl = seamCovers;

      el.addEventListener('mousedown', (e) => this.handleDragStart(e));
      el.addEventListener('touchstart', (e) => this.handleDragStart(e), {passive:false});
      el.addEventListener('click', (e) => {
        e.stopPropagation();
        this.selectToken(token.id);
      });
      el.addEventListener('dblclick', (e) => {
        e.stopPropagation();
        this.selectToken(token.id);
        this.flipSelected();
      });

      let lastTap = 0;
      el.addEventListener('touchend', (e) => {
        const now = Date.now();
        if(now - lastTap < 300){
          e.preventDefault();
          this.selectToken(token.id);
          this.flipSelected();
        }
        lastTap = now;
      });

      this.boardWorld.appendChild(el);
      token._el = el;

      if(token._new){
        el.classList.add('spawn-pop');
        el.addEventListener('animationend', () => el.classList.remove('spawn-pop'), {once:true});
        delete token._new;
      }

      this.refreshTokenSelectedClass(token.id);
      this.updateSeamBorders();
    }

    refreshTokenSelectedClass(id){
      this.tokens.forEach(t => {
        if(!t._el) return;
        t._el.classList.toggle('selected', t.id === id);
      });
    }

    addToken({denom, kind, x=null, y=null}){
      this.saveState();
      playSound('pop');
      const pos = (x===null || y===null) ? {x: 40 + Math.random()*40, y: 40 + Math.random()*30} : {x, y};

      const w = (kind === 'band') ? this.unitW : this.pieceW(denom);
      const h = this.stripH;
      const rawX = pos.x - w/2;
      const rawY = pos.y - h/2;
      
      const token = {
        id: this.nextId++,
        denom,
        kind,
        side: 'front',
        x: this.roundPos(rawX),
        y: this.roundPos(rawY),
        z: ++this.topZ,
        hidden: false, 
        _new: true,
      };
      this.tokens.push(token);
      this.mountToken(token);
      this.selectToken(token.id);
      return token;
    }

    selectToken(id){
      this.selectedId = id;
      this.refreshTokenSelectedClass(id);
      this.updateSelectionUI();
    }

    get selected(){
      return this.tokens.find(t => t.id === this.selectedId) || null;
    }

    flipSelected(){
      const s = this.selected;
      if(!s) return;
      
      this.saveState();
      s.side = (s.side === 'front') ? 'back' : 'front';
      if(s._el){
        s._el.classList.toggle('is-back', s.side === 'back');
      }
      this.updateSelectionUI();
      playSound('flip');
    }

    toggleHideSelected(){
      const s = this.selected;
      if(!s) return;
      
      this.saveState();
      s.hidden = !s.hidden; 
      if(s._el){
        s._el.classList.toggle('content-hidden', s.hidden);
      }
      playSound('pop');
    }

    duplicateSelected(){
      const s = this.selected;
      if(!s) return;
      this.saveState();
      const copy = {
        id: this.nextId++,
        denom: s.denom,
        kind: s.kind,
        side: s.side,
        x: s.x + 24,
        y: s.y + 24,
        z: ++this.topZ,
        hidden: s.hidden 
      };
      this.tokens.push(copy);
      this.mountToken(copy);
      this.selectToken(copy.id);
      playSound('pop');
    }

    deleteSelected(){
      const s = this.selected;
      if(!s) return;
      this.saveState();
      if(s._el) s._el.remove();
      this.tokens = this.tokens.filter(t => t.id !== s.id);
      this.selectToken(null);
      this.updateSeamBorders();
      playSound('whoosh');
    }

    separateSelected(){
      const s = this.selected;
      if(!s || s.kind !== 'band' || s.denom <= 1) return;
      this.saveState();

      const baseX = s.x;
      const baseY = s.y;
      const denom = s.denom;
      const side = s.side;
      const wasHidden = s.hidden;

      if(s._el) s._el.remove();
      this.tokens = this.tokens.filter(t => t.id !== s.id);

      const pw = this.pieceW(denom);
      for(let i=0;i<denom;i++){
        const piece = { id: this.nextId++, denom, kind:'piece', side, x: baseX + i*pw, y: baseY, z: ++this.topZ, hidden: wasHidden };
        this.tokens.push(piece);
        this.mountToken(piece);
      }
      this.selectToken(this.tokens[this.tokens.length - denom].id);
      this.updateSeamBorders();
      playSound('pop');
    }

    fuseSelected(){
      const s = this.selected;
      if(!s || s.kind !== 'piece' || s.denom <= 1) return;

      const d = s.denom;
      const pw = this.pieceW(d);
      const yTol = 10;
      const xTol = 12;

      const rowPieces = this.tokens
        .filter(t => t.kind === 'piece' && t.denom === d && t.side === s.side && Math.abs(t.y - s.y) < yTol)
        .sort((a,b) => a.x - b.x);

      if(rowPieces.length < d){ playSound('whoosh'); return; }

      for(let start=0; start <= rowPieces.length - d; start++){
        const seq = rowPieces.slice(start, start + d);
        if(!seq.some(t => t.id === s.id)) continue;

        const baseX = seq[0].x;
        const baseY = seq[0].y;
        let ok = true;
        for(let i=0;i<d;i++){
          const expectedX = baseX + i * pw;
          if(Math.abs(seq[i].x - expectedX) > xTol) { ok = false; break; }
          if(Math.abs(seq[i].y - baseY) > yTol) { ok = false; break; }
        }
        if(!ok) continue;

        this.saveState();
        const ids = new Set(seq.map(t => t.id));
        const anyHidden = seq.some(t => t.hidden);
        
        seq.forEach(t => { if(t._el) t._el.remove(); });
        this.tokens = this.tokens.filter(t => !ids.has(t.id));

        const band = { id: this.nextId++, denom: d, kind:'band', side: s.side, x: baseX, y: baseY, z: ++this.topZ, hidden: anyHidden };
        this.tokens.push(band);
        this.mountToken(band);
        this.selectToken(band.id);
        playSound('pop');
        return;
      }

      playSound('whoosh');
    }

    canCut(t){
      if(!t) return false;
      if(t.denom <= 0) return false;
      const d2 = t.denom * 2;
      return this.DENOM_SET.has(d2);
    }

    cutSelected(){
      const s = this.selected;
      if(!s || !this.canCut(s)) return;

      const d = s.denom;
      const d2 = d * 2;
      const side = s.side;
      const x = s.x;
      const y = s.y;
      const wasHidden = s.hidden;

      this.saveState();

      if(s._el) s._el.remove();
      this.tokens = this.tokens.filter(t => t.id !== s.id);

      if(s.kind === 'band'){
        const band = { id: this.nextId++, denom: d2, kind:'band', side, x, y, z: ++this.topZ, hidden: wasHidden };
        this.tokens.push(band);
        this.mountToken(band);
        this.selectToken(band.id);
      } else {
        const pw2 = this.pieceW(d2);
        const p1 = { id: this.nextId++, denom: d2, kind:'piece', side, x: x,      y, z: ++this.topZ, hidden: wasHidden };
        const p2 = { id: this.nextId++, denom: d2, kind:'piece', side, x: x+pw2,   y, z: ++this.topZ, hidden: wasHidden };
        this.tokens.push(p1, p2);
        this.mountToken(p1);
        this.mountToken(p2);
        this.selectToken(p1.id);
      }
      this.updateSeamBorders();
      playSound('pop');
    }

    handleDragStart(e){
      const isTouch = !!e.touches;
      const btn = isTouch ? 0 : (typeof e.button === 'number' ? e.button : 0);
      const allow =
        (this.currentTool === 'hand' && (isTouch || btn === 0)) ||
        (this.currentTool === 'pen' && !isTouch && btn === 2);
      if(!allow) return;

      e.preventDefault();
      e.stopPropagation();
      const el = e.target.closest('.strip');
      if(!el) return;

      const id = parseInt(el.dataset.id, 10);
      const token = this.tokens.find(t => t.id === id);
      if(!token) return;

      this.saveState();
      
      token.z = ++this.topZ;
      if(token._el) token._el.style.zIndex = token.z;
      
      this.selectToken(token.id);

      token._el.classList.add('dragging');
      
      // AJOUT : Curseur global
      document.body.classList.add('is-dragging-global');

      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      const rect = token._el.getBoundingClientRect();
      const offset = { x: clientX - rect.left, y: clientY - rect.top };

      const move = (ev) => {
        ev.preventDefault();
        const cx = ev.touches ? ev.touches[0].clientX : ev.clientX;
        const cy = ev.touches ? ev.touches[0].clientY : ev.clientY;
        const br = this.boardContainer.getBoundingClientRect();
        const wx = (cx - br.left - this.pan.x - offset.x) / this.scale;
        let wy = (cy - br.top - this.pan.y - offset.y) / this.scale;

        const {h} = this.tokenDims(token);
        if(this.numberLine && this.numberLine.active){
          const lockThresh = 18 / this.scale;
          const dAbove = Math.abs((wy + h) - this.numberLine.y);
          const dBelow = Math.abs(wy - this.numberLine.y);
          const d = Math.min(dAbove, dBelow);
          if(d < lockThresh){
            wy = (dAbove <= dBelow) ? (this.numberLine.y - h) : this.numberLine.y;
          }
        }

        token.x = wx;
        token.y = wy;
        token._el.style.left = wx + 'px';
        token._el.style.top = wy + 'px';
        
        this.scheduleSeamUpdate();
      };

      const end = () => {
        document.removeEventListener('mousemove', move);
        document.removeEventListener('touchmove', move);
        document.removeEventListener('mouseup', end);
        document.removeEventListener('touchend', end);
        
        // RETRAIT : Curseur global
        document.body.classList.remove('is-dragging-global');

        if(token._el) token._el.classList.remove('dragging');
        this.snapToken(token);
      };

      document.addEventListener('mousemove', move);
      document.addEventListener('touchmove', move, {passive:false});
      document.addEventListener('mouseup', end);
      document.addEventListener('touchend', end);
    }

    snapToken(t, opts={}){
      if(!t) return;

      const {w, h} = this.tokenDims(t);
      const threshPx = 28;
      const thresh = threshPx / this.scale;

      let bestX = null, bestDx = Infinity, bestXPrio = 9;
      let bestY = null, bestDy = Infinity, bestYPrio = 9;

      const considerX = (nx, prio=1) => {
        const adx = Math.abs(nx - t.x);
        if(adx <= thresh && (prio < bestXPrio || (prio === bestXPrio && adx < bestDx))){
          bestXPrio = prio;
          bestDx = adx;
          bestX = nx;
        }
      };

      const considerY = (ny, prio=1) => {
        const ady = Math.abs(ny - t.y);
        if(ady <= thresh && (prio < bestYPrio || (prio === bestYPrio && ady < bestDy))){
          bestYPrio = prio;
          bestDy = ady;
          bestY = ny;
        }
      };

      const overlapLen = (a0,a1,b0,b1)=> Math.min(a1,b1) - Math.max(a0,b0);

      const xLinesFor = (o) => {
        const {w:ow} = this.tokenDims(o);
        const ox = o.x;
        const lines = [];
        if(o.kind === 'band'){
          const step = ow / o.denom;
          for(let k=0;k<=o.denom;k++) lines.push(ox + k*step);
        } else {
          lines.push(ox, ox + ow);
        }
        return lines;
      };

      if(this.numberLine && this.numberLine.active){
        considerY(this.numberLine.y - h, 0);
        considerY(this.numberLine.y, 0);
        considerX(this.numberLine.x, 0);
      }

      for(const o of this.tokens){
        if(o.id === t.id) continue;

        const od = this.tokenDims(o);
        const ox = o.x, oy = o.y, ow = od.w, oh = od.h;

        const ovY = overlapLen(t.y, t.y + h, oy, oy + oh);
        const ovX = overlapLen(t.x, t.x + w, ox, ox + ow);

        const neighX = Math.min(Math.abs(t.x - (ox + ow)), Math.abs((t.x + w) - ox));
        const neighY = Math.min(Math.abs(t.y - (oy + oh)), Math.abs((t.y + h) - oy));
        const neighborX = neighX <= thresh;
        const neighborY = neighY <= thresh;

        const prioX = (ovY > Math.min(h, oh) * 0.35 || neighborY) ? 0 : 1;
        const prioY = (ovX > Math.min(w, ow) * 0.35 || neighborX) ? 0 : 1;

        considerY(oy, prioY);
        considerY(oy - h, prioY);
        considerY(oy + oh, prioY);

        const lines = xLinesFor(o);
        for(const gx of lines){
          considerX(gx, prioX);
          considerX(gx - w, prioX);
        }
        considerX(ox + ow, prioX);
        considerX(ox - w, prioX);
      }

      let snapped = false;
      if(bestX !== null){
        t.x = bestX;
        if(t._el) t._el.style.left = t.x + 'px';
        snapped = true;
      } else {
        const rx = this.roundPos(t.x);
        if(Math.abs(rx - t.x) > 0.001){
          t.x = rx;
          if(t._el) t._el.style.left = t.x + 'px';
        }
      }

      if(bestY !== null){
        t.y = bestY;
        if(t._el) t._el.style.top = t.y + 'px';
        snapped = true;
      } else {
        const ry = this.roundPos(t.y);
        if(Math.abs(ry - t.y) > 0.001){
          t.y = ry;
          if(t._el) t._el.style.top = t.y + 'px';
        }
      }

      if(snapped && !opts.silent) playSound('pop');
      this.updateSeamBorders();
    }

    updateSeamBorders(){
      const tol = 2.2;
      const wVisible = '1px';

      // La bordure est dessinée par .face::after avec right:-1 / bottom:-1.
      // Les jonctions (2 pièces qui se touchent) peuvent donc être "doublement dessinées"
      // (même pixel, donc plus foncé). Ici on règle ça proprement :
      // 1) on efface localement le pixel de jonction (patch couleur fond),
      // 2) on redessine une seule ligne (couleur grille), segmentée sur la zone de contact.
      //
      // Avantage : pas de "marche" d'1 pixel, même si le contact est partiel.

      // Reset : bords visibles + nettoyage des anciens masques (legacy)
      for(const t of this.tokens){
        if(!t._el) continue;
        t._el.style.setProperty('--wL', wVisible);
        t._el.style.setProperty('--wR', wVisible);
        t._el.style.setProperty('--wT', wVisible);
        t._el.style.setProperty('--wB', wVisible);
        if(t._seamEl) t._seamEl.replaceChildren();
      }

      // Nettoyage overlay global
      if(this.seamOverlay) this.seamOverlay.replaceChildren();

      const dims = (t)=>this.tokenDims(t);
      const overlapLen = (a0,a1,b0,b1)=> Math.min(a1,b1) - Math.max(a0,b0);

      // Quantification identique au snap (0.5px) pour éviter les micro-trous.
      const q = (v)=> Math.round(v * 2) / 2;

      const segX = (ax0, ax1, bx0, bx1) => {
        const sx = q(Math.max(ax0, bx0));
        const ex = q(Math.min(ax1, bx1));
        if(ex - sx <= 0.5) return null;
        return { left: sx, w: Math.max(0, ex - sx) };
      };

      const segY = (ay0, ay1, by0, by1) => {
        const sy = q(Math.max(ay0, by0));
        const ey = q(Math.min(ay1, by1));
        if(ey - sy <= 0.5) return null;
        return { top: sy, h: Math.max(0, ey - sy) };
      };

      const addSeam = (css) => {
        if(!this.seamOverlay) return;

        // Patch (efface)
        const p = document.createElement('div');
        p.className = 'seam-patch';
        for(const k in css) p.style[k] = css[k];

        // Ligne (redessine une seule fois)
        const l = document.createElement('div');
        l.className = 'seam-line';
        for(const k in css) l.style[k] = css[k];

        this.seamOverlay.appendChild(p);
        this.seamOverlay.appendChild(l);
      };

      for(let i=0;i<this.tokens.length;i++){
        const aT = this.tokens[i];
        if(!aT._el) continue;
        const ad = dims(aT);
        const ax0 = aT.x, ax1 = aT.x + ad.w;
        const ay0 = aT.y, ay1 = aT.y + ad.h;

        for(let j=i+1;j<this.tokens.length;j++){
          const bT = this.tokens[j];
          if(!bT._el) continue;
          const bd = dims(bT);
          const bx0 = bT.x, bx1 = bT.x + bd.w;
          const by0 = bT.y, by1 = bT.y + bd.h;

          const ovX = overlapLen(ax0, ax1, bx0, bx1);
          const ovY = overlapLen(ay0, ay1, by0, by1);

          // -----------------------------------------
          // Horizontal : A à gauche de B => jonction verticale à x = ax1
          // -----------------------------------------
          if(Math.abs(ax1 - bx0) < tol && ovY > 0.5){
            const seg = segY(ay0, ay1, by0, by1);
            if(seg){
              addSeam({ left: `${q(ax1)}px`, top: `${seg.top}px`, width: '1px', height: `${seg.h}px` });
            }
          }
          // B à gauche de A => jonction à x = bx1
          if(Math.abs(bx1 - ax0) < tol && ovY > 0.5){
            const seg = segY(ay0, ay1, by0, by1);
            if(seg){
              addSeam({ left: `${q(bx1)}px`, top: `${seg.top}px`, width: '1px', height: `${seg.h}px` });
            }
          }

          // -----------------------------------------
          // Vertical : A au-dessus de B => jonction horizontale à y = ay1
          // -----------------------------------------
          if(Math.abs(ay1 - by0) < tol && ovX > 0.5){
            const seg = segX(ax0, ax1, bx0, bx1);
            if(seg){
              addSeam({ left: `${seg.left}px`, top: `${q(ay1)}px`, width: `${seg.w}px`, height: '1px' });
            }
          }
          // B au-dessus de A => jonction à y = by1
          if(Math.abs(by1 - ay0) < tol && ovX > 0.5){
            const seg = segX(ax0, ax1, bx0, bx1);
            if(seg){
              addSeam({ left: `${seg.left}px`, top: `${q(by1)}px`, width: `${seg.w}px`, height: '1px' });
            }
          }
        }
      }
    }


    scheduleSeamUpdate(){
      if(this._seamRAF) return;
      this._seamRAF = requestAnimationFrame(() => {
        this._seamRAF = null;
        this.updateSeamBorders();
      });
    }

    setTool(tool){
      this.currentTool = tool;
      const hand = document.getElementById('tool-hand');
      const pen  = document.getElementById('tool-pen');
      if(hand){ hand.classList.toggle('bg-white', tool==='hand'); hand.classList.toggle('shadow', tool==='hand'); }
      if(pen){  pen.classList.toggle('bg-white', tool==='pen');   pen.classList.toggle('shadow', tool==='pen'); }

      const penMode = (tool === 'pen');
      document.body.classList.toggle('pen-mode', penMode);
    }

    resizeCanvas(){
      const offset = 2500;
      const worldSize = 5000;
      const dpr = Math.min(2, window.devicePixelRatio || 1);
      this._canvasWorldSize = worldSize;
      this._canvasDpr = dpr;

      this.canvas.width = Math.round(worldSize * dpr);
      this.canvas.height = Math.round(worldSize * dpr);
      this.canvas.style.width = `${worldSize}px`;
      this.canvas.style.height = `${worldSize}px`;

      this.ctx.setTransform(dpr, 0, 0, dpr, offset * dpr, offset * dpr);
      this.ctx.lineCap = 'round';
      this.ctx.lineJoin = 'round';
      this.ctx.miterLimit = 2;
      this.ctx.strokeStyle = '#111827';
      this.ctx.imageSmoothingEnabled = true;
      this.ctx.globalCompositeOperation = 'source-over';
    }

    startDraw(e){
      this.isDrawing = true;
      this.drawPoints = [];

      const cx = e.touches ? e.touches[0].clientX : e.clientX;
      const cy = e.touches ? e.touches[0].clientY : e.clientY;
      const p = this.getWorldPos(cx, cy);

      this.ctx.lineWidth = Math.max(1.05, this.basePenPx / this.scale);
      this.drawPoints.push(p);
      this.ctx.beginPath();
      this.ctx.moveTo(p.x, p.y);
    }

    draw(e){
      e.preventDefault();
      const cx = e.touches ? e.touches[0].clientX : e.clientX;
      const cy = e.touches ? e.touches[0].clientY : e.clientY;
      const p = this.getWorldPos(cx, cy);

      this.ctx.lineWidth = Math.max(1.05, this.basePenPx / this.scale);

      const pts = this.drawPoints;
      pts.push(p);

      if(pts.length === 2){
        this.ctx.lineTo(p.x, p.y);
        this.ctx.stroke();
        return;
      }

      const p1 = pts[pts.length - 2];
      const p2 = pts[pts.length - 1];
      const midX = (p1.x + p2.x) / 2;
      const midY = (p1.y + p2.y) / 2;
      this.ctx.quadraticCurveTo(p1.x, p1.y, midX, midY);
      this.ctx.stroke();
    }

    endDraw(){
      const pts = this.drawPoints || [];
      if(!pts.length) return;
      const last = pts[pts.length - 1];
      this.ctx.lineTo(last.x, last.y);
      this.ctx.stroke();
      this.drawPoints = [];
    }

    clearDrawing(){
      this.ctx.save();
      this.ctx.setTransform(1, 0, 0, 1, 0, 0);
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      this.ctx.restore();
      
      const offset = 2500;
      const dpr = this._canvasDpr || 1;
      this.ctx.setTransform(dpr, 0, 0, dpr, offset * dpr, offset * dpr);
    }

    clearAllTokens(withHistory=true){
      if(withHistory) this.saveState();
      this.tokens.forEach(t => t._el && t._el.remove());
      this.tokens = [];
      this.selectedId = null;
      this.updateSelectionUI();
    }

    resetAll(){
      this.saveState();
      this.clearAllTokens(false);
      this.clearDrawing();
      this.resetView();
      playSound('whoosh');
    }
  }

  function runSelfTests(){
    const required = [
      'btn-undo','btn-clear','mode-selector','btn-numberline','btn-zoom-in','btn-zoom-out','btn-reset-view',
      'btn-flip','btn-separate','btn-cut','btn-fuse','btn-duplicate','btn-delete',
      'tool-hand','tool-pen','btn-clear-drawing',
      'board-container','board-world','palette','drawing-canvas','number-line'
    ];
    const missing = required.filter(id => !document.getElementById(id));
    if(missing.length){
      console.error('[SelfTest] IDs manquants:', missing);
      return { ok:false, missing };
    }

    try{
      const tmp = new FractionStripsApp();
      const okMethods = ['scheduleSeamUpdate','updateSeamBorders','addToken','snapToken','toggleNumberLine'].every(m => typeof tmp[m] === 'function');
      if(!okMethods) throw new Error('Méthodes clés manquantes');
      tmp.resetAll();
    }catch(err){
      console.error('[SelfTest] Erreur instanciation/app:', err);
      return { ok:false, missing:[], err };
    }

    console.log('[SelfTest] OK');
    return { ok:true, missing:[] };
  }

  window.addEventListener('DOMContentLoaded', () => {
    const t = runSelfTests();
    if(!t.ok) return;
    window.app = new FractionStripsApp();
    console.log('[SelfTest] App instanciée OK');
  });
</script>

</body>
</html>
