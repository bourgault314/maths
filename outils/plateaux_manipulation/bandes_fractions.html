<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Plateau – Bandes de fractions</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;800&display=swap" rel="stylesheet">

  <style>
    :root{
      --unitW: 420; /* largeur d'une unité */
      --stripH: 58;
      --boardBg: #ffffff; /* plateau blanc */
    }

    body{
      font-family: 'Fredoka', sans-serif;
      background: #ffffff;
      overflow: hidden;
      touch-action: none;
      user-select: none;
      -webkit-user-select: none;
    }

    #board-container{
      position: absolute;
      inset: 0;
      overflow: hidden;
      cursor: grab;
      background: var(--boardBg);
    }
    #board-container.panning{ cursor: grabbing; }

    #board-world{
      position: absolute;
      top: 0; left: 0;
      transform-origin: 0 0;
      width: 0; height: 0;
    }

    #drawing-canvas{
      position: absolute;
      top: 0; left: 0;
      pointer-events: none;
    }

    .no-scrollbar::-webkit-scrollbar{ display:none; }
    .no-scrollbar{ -ms-overflow-style:none; scrollbar-width:none; }

    /* --- Bandes / pièces --- */
    .strip{
      /* Contours fins noirs (sans double épaisseur quand ça colle) */
      --edgeL: rgba(0,0,0,0.55);
      --edgeR: rgba(0,0,0,0.55);
      --edgeT: rgba(0,0,0,0.55);
      --edgeB: rgba(0,0,0,0.55);

      /* anneau de sélection */
      --selRing: 0 0 0 0 rgba(59,130,246,0);

      position: absolute;
      display: flex;
      align-items: stretch;
      justify-content: stretch;
      border-radius: 0px;

      box-shadow:
        var(--selRing),
        inset 1px 0 0 var(--edgeL),
        inset -1px 0 0 var(--edgeR),
        inset 0 1px 0 var(--edgeT),
        inset 0 -1px 0 var(--edgeB);

      cursor: grab;
      touch-action: none;
      transform-origin: 0 0;
      overflow: hidden;
      box-sizing: border-box;
      border: none;
      perspective: 900px;
    }
    .strip.dragging{ cursor: grabbing; z-index: 2000 !important; }
    .strip.selected{ --selRing: 0 0 0 3px rgba(59,130,246,0.85); }

    /* --- Animation de retournement --- */
    .strip-inner{
      position: relative;
      width: 100%;
      height: 100%;
      flex: 1 1 auto;
      transform-style: preserve-3d;
      transition: transform 820ms cubic-bezier(0.22, 0.8, 0.2, 1);
    }
    .strip.is-back .strip-inner{ transform: rotateX(180deg); }

    .face{
      position: absolute;
      inset: 0;
      display: flex;
      align-items: stretch;
      justify-content: stretch;
      backface-visibility: hidden;
      -webkit-backface-visibility: hidden;
    }
    .face-back{ transform: rotateX(180deg); }

    /* Ghost drag depuis menu */
    .strip.ghost{
      position: fixed;
      pointer-events: none;
      opacity: 0.96;
      z-index: 9998;
      box-shadow: 0 22px 38px rgba(0,0,0,0.30);
      transform: scale(0.98);
      transition: transform 120ms ease-out, opacity 120ms ease-out;
    }
    .strip.ghost.ready{ transform: scale(1); }

    .strip.spawn-pop{ animation: popIn 140ms ease-out; }
    @keyframes popIn{ from{ transform: scale(0.92); } to{ transform: scale(1); } }

    /* segments (les parts) */
    .seg{
      flex: 1 1 auto;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight: 600;
      letter-spacing: 0;
      line-height: 1;
      text-shadow: 0 1px 0 rgba(255,255,255,0.35);
    }
    .seg + .seg{ border-left: 1px dashed rgba(0,0,0,0.28); }

    /* fraction verticale */
    .frac{
      display: inline-flex;
      flex-direction: column;
      align-items: center;
      line-height: 1;
      transform: translateY(-1px);
      filter: drop-shadow(0 1px 0 rgba(255,255,255,0.35));
    }
    .frac .num, .frac .den{ font-weight: 700; }
    .frac .bar{
      width: 1.2em;
      height: 2px;
      background: rgba(0,0,0,0.65);
      border-radius: 2px;
      margin: 3px 0;
    }

    .back-one{
      font-weight: 800;
      font-size: 1.35rem;
      text-shadow: 0 2px 0 rgba(255,255,255,0.35);
    }

    /* --- Menu gauche (palette) --- */
    .palette-item{
      padding: 6px 8px;
      border-radius: 12px;
      transition: none;
    }
    .palette-item:hover{ background: transparent; }

    .spawn-tile{
      height: 40px;
      flex: 0 0 auto;
      flex-shrink: 0;
      position: relative;
      border-radius: 0px;
      border: none;
      overflow: hidden;
      display: flex;
      cursor: grab;
      box-shadow:
        0 4px 10px rgba(0,0,0,0.18),
        inset 0 0 0 1px rgba(0,0,0,0.55);
      user-select: none;
      touch-action: none;
      background: transparent;
    }
    .spawn-tile:active{ cursor: grabbing; }

    .spawn-seg{ flex: 1 1 auto; display:flex; align-items:center; justify-content:center; font-weight:800; font-size: 10px; }
    .spawn-seg + .spawn-seg{ border-left: 1px dashed rgba(0,0,0,0.28); }

    .frac.menu{ transform: none; filter: none; font-size: inherit; }
    .frac.menu .bar{ width: 0.9em; height: 2px; margin: 2px 0; background: rgba(0,0,0,0.70); }

    /* outils */
    #custom-cursor{ position: fixed; pointer-events:none; z-index: 9999; display:none; }
    .hide-cursor, .hide-cursor * { cursor: none !important; }

    @media (max-width: 640px){
      :root{ --stripH: 52; }
    }
  </style>
</head>

<body class="h-screen w-screen flex flex-col">

  <!-- Curseur stylo (optionnel) -->
  <div id="custom-cursor">
    <svg class="drop-shadow-lg" width="34" height="34" viewBox="0 0 34 34" fill="none">
      <path d="M27 7 L13 21" stroke="#1d4ed8" stroke-width="6" stroke-linecap="round"/>
      <path d="M13 21 L8 32" stroke="#0f172a" stroke-width="4" stroke-linecap="round"/>
      <path d="M8 32 L12 28 L16 32 Z" fill="#111827"/>
      <circle cx="8" cy="32" r="1" fill="white"/>
    </svg>
  </div>

  <!-- Barre haute -->
  <header class="bg-blue-50 p-2 shadow-md z-30 flex flex-wrap items-center gap-3 shrink-0">
    <div class="flex items-center gap-2">
      <button id="btn-undo" class="bg-blue-100 text-blue-700 hover:bg-blue-200 p-2 rounded-lg font-bold border border-blue-200 shadow-sm active:scale-95 transition" title="Annuler">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6" />
        </svg>
      </button>

      <button id="btn-clear" class="bg-rose-100 text-rose-700 hover:bg-rose-200 p-2 rounded-lg font-bold border border-rose-200 shadow-sm active:scale-95 transition" title="Tout effacer">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
        </svg>
      </button>

      <button id="btn-export-png" class="bg-emerald-100 text-emerald-700 hover:bg-emerald-200 p-2 rounded-lg font-bold border border-emerald-200 shadow-sm active:scale-95 transition" title="Exporter en PNG (photo du plateau)">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-2h6l2 2h4a2 2 0 0 1 2 2z"/>
          <circle cx="12" cy="13" r="4"/>
        </svg>
      </button>

      <div class="h-8 w-px bg-slate-200 mx-1"></div>

      <button id="btn-zoom-out" class="bg-slate-100 hover:bg-slate-200 text-slate-800 px-3 py-2 rounded-lg border border-slate-200 font-bold active:scale-95 transition" title="Zoom -">−</button>
      <button id="btn-zoom-in" class="bg-slate-100 hover:bg-slate-200 text-slate-800 px-3 py-2 rounded-lg border border-slate-200 font-bold active:scale-95 transition" title="Zoom +">+</button>
      <button id="btn-reset-view" class="bg-slate-100 hover:bg-slate-200 text-slate-800 px-3 py-2 rounded-lg border border-slate-200 font-bold active:scale-95 transition" title="Recentrer">⤾</button>
    </div>

    <!-- Actions sélection (toujours visibles, activées/désactivées) -->
    <div id="selection-actions" class="flex items-center gap-2">
      <button id="btn-flip" disabled class="bg-amber-500 hover:bg-amber-600 disabled:bg-amber-200 text-white px-2 py-1 rounded-lg shadow-sm border border-amber-200 disabled:opacity-40 disabled:cursor-not-allowed active:scale-95 transition flex flex-col items-center gap-0.5" title="Retourner (double-clic aussi)">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M3 12a9 9 0 0 1 9-9"/>
          <path d="M3 4v8h8"/>
          <path d="M21 12a9 9 0 0 1-9 9"/>
          <path d="M21 20v-8h-8"/>
        </svg>
        <span class="text-[10px] font-extrabold leading-none">Retourner</span>
      </button>

      <button id="btn-separate" disabled class="bg-blue-600 hover:bg-blue-700 disabled:bg-blue-200 text-white px-2 py-1 rounded-lg shadow-sm border border-blue-200 disabled:opacity-40 disabled:cursor-not-allowed active:scale-95 transition flex flex-col items-center gap-0.5" title="Séparer la bande en pièces">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M4 4l16 16"/>
          <path d="M4 20L20 4"/>
        </svg>
        <span class="text-[10px] font-extrabold leading-none">Séparer</span>
      </button>

      <button id="btn-cut" disabled class="bg-slate-700 hover:bg-slate-800 disabled:bg-slate-200 text-white px-2 py-1 rounded-lg shadow-sm border border-slate-200 disabled:opacity-40 disabled:cursor-not-allowed active:scale-95 transition flex flex-col items-center gap-0.5" title="Couper en 2 (si le double existe)">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="6" cy="6" r="2"/>
          <circle cx="6" cy="18" r="2"/>
          <path d="M20 4L8.12 15.88"/>
          <path d="M14.47 14.48L20 20"/>
          <path d="M8.12 8.12L12 12"/>
        </svg>
        <span class="text-[10px] font-extrabold leading-none">Couper</span>
      </button>

      <button id="btn-fuse" disabled class="bg-violet-600 hover:bg-violet-700 disabled:bg-violet-200 text-white px-2 py-1 rounded-lg shadow-sm border border-violet-200 disabled:opacity-40 disabled:cursor-not-allowed active:scale-95 transition flex flex-col items-center gap-0.5" title="Fusionner des pièces alignées en une bande">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M10 13a5 5 0 0 1 0-7l1-1a5 5 0 0 1 7 7l-1 1"/>
          <path d="M14 11a5 5 0 0 1 0 7l-1 1a5 5 0 0 1-7-7l1-1"/>
        </svg>
        <span class="text-[10px] font-extrabold leading-none">Fusionner</span>
      </button>

      <button id="btn-duplicate" disabled class="bg-emerald-600 hover:bg-emerald-700 disabled:bg-emerald-200 text-white px-2 py-1 rounded-lg shadow-sm border border-emerald-200 disabled:opacity-40 disabled:cursor-not-allowed active:scale-95 transition flex flex-col items-center gap-0.5" title="Dupliquer">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <rect x="9" y="9" width="13" height="13" rx="2"/>
          <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
        </svg>
        <span class="text-[10px] font-extrabold leading-none">Dupliquer</span>
      </button>

      <button id="btn-delete" disabled class="bg-rose-600 hover:bg-rose-700 disabled:bg-rose-200 text-white px-2 py-1 rounded-lg shadow-sm border border-rose-200 disabled:opacity-40 disabled:cursor-not-allowed active:scale-95 transition flex flex-col items-center gap-0.5" title="Supprimer">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
        </svg>
        <span class="text-[10px] font-extrabold leading-none">Supprimer</span>
      </button>
    </div>

    <!-- Outils -->
    <div class="flex items-center gap-1 bg-gray-100 p-1 rounded-lg">
      <button id="tool-hand" class="p-2 rounded bg-white shadow text-gray-700" title="Main (déplacer / sélectionner)">
        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 11.5V14m0-2.5v-6a1.5 1.5 0 113 0m-3 6a1.5 1.5 0 00-3 0v2a7.5 7.5 0 0015 0v-5a1.5 1.5 0 00-3 0m-6-3V11m0-5.5v-1a1.5 1.5 0 013 0v1m0 0V11m0-5.5a1.5 1.5 0 013 0v3m0 0V11"/></svg>
      </button>
      <button id="tool-pen" class="p-2 rounded text-gray-500 hover:bg-gray-200" title="Stylo (annoter)">
        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"/></svg>
      </button>
      <button id="btn-clear-drawing" class="p-2 rounded text-rose-500 hover:bg-rose-50" title="Effacer les annotations">
        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/></svg>
      </button>
    </div>
  </header>

  <!-- Corps: menu gauche + plateau -->
  <div class="flex flex-1 overflow-hidden relative">

    <aside class="w-[340px] bg-blue-50 border-r border-blue-200 flex flex-col py-4 gap-3 z-20 shadow-lg shrink-0 overflow-y-auto no-scrollbar">
      <div class="px-3"></div>
      <div id="palette" class="px-3 flex flex-col gap-3"></div>

      <div class="mt-2 px-3">
        <div class="text-[10px] font-bold text-slate-400 uppercase">Astuces</div>
        <ul class="text-[11px] text-slate-500 leading-snug list-disc ml-4 mt-1">
          <li>Double-clic sur une bande = retourner.</li>
          <li>Molette = zoom, glisser sur fond = déplacer le plateau.</li>
        </ul>
      </div>
    </aside>

    <main class="flex-1 relative overflow-hidden">
      <div id="board-container">
        <div id="board-world">
          <canvas id="drawing-canvas"></canvas>
        </div>
      </div>
    </main>

  </div>

<script>
  // --- Configuration couleurs ---
  const FRACTIONS = [
    { denom: 1,  name: 'Unité',     color: '#fff7e6', border: '#cbd5e1', text: '#111827' },
    { denom: 2,  name: 'Demi',      color: '#facc15', border: '#a16207', text: '#111827' },
    { denom: 3,  name: 'Tiers',     color: '#e9d5ff', border: '#7c3aed', text: '#111827' },
    { denom: 4,  name: 'Quart',     color: '#84cc16', border: '#3f6212', text: '#111827' },
    { denom: 5,  name: 'Cinquième', color: '#38bdf8', border: '#075985', text: '#0b1220' },
    { denom: 6,  name: 'Sixième',   color: '#f97316', border: '#9a3412', text: '#111827' },
    { denom: 8,  name: 'Huitième',  color: '#f472b6', border: '#be185d', text: '#111827' },
    { denom: 10, name: 'Dixième',   color: '#b91c1c', border: '#7f1d1d', text: '#111827' },
  ];

  // Audio (optionnel) – protège si indisponible
  let audioCtx = null;
  try{ audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }catch(_){ audioCtx = null; }

  function playSound(type){
    if (!audioCtx) return;
    if (audioCtx.state === 'suspended') audioCtx.resume().catch(()=>{});
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain); gain.connect(audioCtx.destination);
    const now = audioCtx.currentTime;
    const stop = (t)=>{ try{ osc.stop(t); }catch(_){} };
    if(type==='pop'){
      osc.type='sine';
      osc.frequency.setValueAtTime(320, now);
      osc.frequency.exponentialRampToValueAtTime(560, now+0.08);
      gain.gain.setValueAtTime(0.10, now);
      gain.gain.linearRampToValueAtTime(0, now+0.10);
      osc.start(now); stop(now+0.10);
    } else if(type==='flip'){
      osc.type='triangle';
      osc.frequency.setValueAtTime(210, now);
      osc.frequency.linearRampToValueAtTime(440, now+0.16);
      gain.gain.setValueAtTime(0.10, now);
      gain.gain.linearRampToValueAtTime(0, now+0.18);
      osc.start(now); stop(now+0.18);
    } else if(type==='whoosh'){
      osc.type='triangle';
      osc.frequency.setValueAtTime(360, now);
      osc.frequency.exponentialRampToValueAtTime(60, now+0.22);
      gain.gain.setValueAtTime(0.06, now);
      gain.gain.linearRampToValueAtTime(0, now+0.22);
      osc.start(now); stop(now+0.22);
    }
  }

  class FractionStripsApp {
    constructor(){
      this.history = [];
      this.tokens = []; // {id, denom, kind:'band'|'piece', side:'front'|'back', x,y, _el}
      this.nextId = 1;
      this.selectedId = null;

      this.scale = 1;
      this.pan = {x: 0, y: 0};
      this.isPanning = false;
      this.panStart = {x:0, y:0};

      this.currentTool = 'hand';
      this.isDrawing = false;
      this.lastDrawPos = {x:0,y:0};

      // Drag réaliste depuis le menu (ghost pleine taille)
      this.spawnDrag = null;
      this._lastSpawnClient = {x:0, y:0};

      this.boardContainer = document.getElementById('board-container');
      this.boardWorld = document.getElementById('board-world');
      this.palette = document.getElementById('palette');

      this.canvas = document.getElementById('drawing-canvas');
      this.ctx = this.canvas.getContext('2d');

      this.DENOM_SET = new Set(FRACTIONS.map(f => f.denom));

      this.buildPalette();
      this.initUI();
      this.initBoardListeners();
      this.resizeCanvas();
      this.updateTransform();
      this.updateSelectionUI();
    }

    // ---- Dimensions ----
    get unitW(){ return parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--unitW')) || 420; }
    get stripH(){ return parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--stripH')) || 58; }
    pieceW(denom){ return this.unitW / denom; }

    tokenDims(t){
      return {
        w: (t.kind === 'band') ? this.unitW : this.pieceW(t.denom),
        h: this.stripH,
      };
    }

    // ---- Historique ----
    saveState(){
      const snapshot = {
        tokens: this.tokens.map(t => ({id:t.id, denom:t.denom, kind:t.kind, side:t.side, x:t.x, y:t.y})),
        nextId: this.nextId,
        selectedId: this.selectedId,
        pan: {...this.pan},
        scale: this.scale,
      };
      this.history.push(snapshot);
      if(this.history.length > 30) this.history.shift();
    }

    undo(){
      const snap = this.history.pop();
      if(!snap) return;
      this.clearAllTokens(false);
      this.tokens = snap.tokens.map(t => ({...t}));
      this.nextId = snap.nextId;
      this.selectedId = snap.selectedId;
      this.pan = snap.pan;
      this.scale = snap.scale;
      this.tokens.forEach(t => this.mountToken(t));
      this.updateTransform();
      this.updateSelectionUI();
      playSound('whoosh');
    }

    // ---- Palette ----
    buildPalette(){
      this.palette.innerHTML = '';
      FRACTIONS.forEach(f => {
        const row = document.createElement('div');
        row.className = 'palette-item';

        const picks = document.createElement('div');
        picks.className = 'flex items-center gap-3 flex-nowrap';

        // Unité : uniquement la bande
        picks.appendChild(this.makeSpawnTile(f.denom, 'band'));
        if(f.denom !== 1) picks.appendChild(this.makeSpawnTile(f.denom, 'piece'));

        row.appendChild(picks);
        this.palette.appendChild(row);
      });
    }

    getFractionConfig(denom){
      return FRACTIONS.find(f => f.denom === denom) || FRACTIONS[0];
    }

    labelHTML(denom){
      if(denom === 1) return `<span class="back-one">1</span>`;
      return `
        <span class="frac">
          <span class="num">1</span>
          <span class="bar"></span>
          <span class="den">${denom}</span>
        </span>
      `;
    }

    fontSizeFor(denom, kind){
      if(kind === 'piece'){
        if(denom >= 10) return 14;
        if(denom >= 8) return 15;
        if(denom >= 6) return 16;
        return 17;
      }
      if(denom >= 10) return 15;
      if(denom >= 8) return 16;
      if(denom >= 6) return 17;
      return 18;
    }

    makeSpawnTile(denom, kind){
      const cfg = this.getFractionConfig(denom);
      const tile = document.createElement('div');
      tile.className = `spawn-tile ${kind==='band' ? 'spawn-band' : 'spawn-piece'}`;
      tile.style.background = cfg.color;
      tile.style.borderColor = cfg.border;
      tile.setAttribute('draggable', 'false');
      tile.title = (kind === 'band') ? 'Ajouter une bande' : 'Ajouter une pièce';

      // longueur horizontale dans le menu
      const menuBandW = 170;
      const w = (kind === 'band') ? menuBandW : Math.max(18, Math.round(menuBandW / denom));
      tile.style.width = w + 'px';

      const fsMenu = (denom >= 10) ? 9 : (denom >= 8) ? 10 : (denom >= 6) ? 11 : 12;

      // fraction dans chaque part
      const segCount = (kind === 'band') ? denom : 1;
      for(let i=0;i<segCount;i++){
        const seg = document.createElement('div');
        seg.className = 'spawn-seg';
        seg.style.color = cfg.text;
        seg.style.fontSize = fsMenu + 'px';

        if(denom === 1){
          seg.innerHTML = `<span class="back-one" style="font-size:${Math.max(fsMenu,12)}px;color:${cfg.text}">1</span>`;
        } else {
          seg.innerHTML = `
            <span class="frac menu" style="color:${cfg.text};font-size:${fsMenu}px">
              <span class="num">1</span>
              <span class="bar"></span>
              <span class="den">${denom}</span>
            </span>
          `;
        }
        tile.appendChild(seg);
      }

      const start = (e) => this.startSpawnDrag(e, denom, kind);
      tile.addEventListener('mousedown', start);
      tile.addEventListener('touchstart', start, {passive:false});
      return tile;
    }

    buildGhostStrip(denom, kind, side){
      const cfg = this.getFractionConfig(denom);
      const el = document.createElement('div');
      el.className = 'strip ghost';
      el.style.background = cfg.color;
      el.style.borderColor = cfg.border;

      const segCount = (side === 'back') ? 1 : ((kind === 'band') ? denom : 1);
      const fs = this.fontSizeFor(denom, kind) * this.scale;

      for(let i=0;i<segCount;i++){
        const seg = document.createElement('div');
        seg.className = 'seg';
        seg.style.color = cfg.text;
        seg.style.fontSize = `${fs}px`;

        if(side === 'front'){
          seg.innerHTML = (denom === 1) ? `<span class="back-one">1</span>` : this.labelHTML(denom);
        } else {
          // verso : bande => 1 ; pièce => 1/denom
          if(kind === 'band' || denom === 1) seg.innerHTML = `<span class="back-one" style="color:${cfg.text}">1</span>`;
          else seg.innerHTML = this.labelHTML(denom);
        }
        el.appendChild(seg);
      }
      return el;
    }

    startSpawnDrag(e, denom, kind){
      if(e.type === 'mousedown' && e.button !== 0) return;
      e.preventDefault();
      e.stopPropagation();

      const pt = e.touches ? e.touches[0] : e;
      const cx = pt.clientX;
      const cy = pt.clientY;
      this._lastSpawnClient = {x: cx, y: cy};

      const wWorld = (kind === 'band') ? this.unitW : this.pieceW(denom);
      const hWorld = this.stripH;
      const w = wWorld * this.scale;
      const h = hWorld * this.scale;

      const ghost = this.buildGhostStrip(denom, kind, 'front');
      ghost.style.width = `${w}px`;
      ghost.style.height = `${h}px`;
      ghost.style.left = `${cx - w/2}px`;
      ghost.style.top  = `${cy - h/2}px`;
      document.body.appendChild(ghost);
      requestAnimationFrame(() => ghost.classList.add('ready'));

      this.spawnDrag = { denom, kind, start: {x: cx, y: cy}, moved: false, ghost, w, h };

      const move = (ev) => this.onSpawnMove(ev);
      const end  = (ev) => this.onSpawnEnd(ev, move, end);
      document.addEventListener('mousemove', move);
      document.addEventListener('mouseup', end);
      document.addEventListener('touchmove', move, {passive:false});
      document.addEventListener('touchend', end);
      document.addEventListener('touchcancel', end);
    }

    onSpawnMove(ev){
      const sd = this.spawnDrag;
      if(!sd) return;
      ev.preventDefault();

      const pt = ev.touches ? ev.touches[0] : ev;
      const cx = pt.clientX;
      const cy = pt.clientY;
      this._lastSpawnClient = {x: cx, y: cy};

      const dist = Math.hypot(cx - sd.start.x, cy - sd.start.y);
      if(dist > 6) sd.moved = true;

      sd.ghost.style.left = `${cx - sd.w/2}px`;
      sd.ghost.style.top  = `${cy - sd.h/2}px`;
    }

    onSpawnEnd(ev, moveFn, endFn){
      const sd = this.spawnDrag;
      if(!sd) return;

      document.removeEventListener('mousemove', moveFn);
      document.removeEventListener('mouseup', endFn);
      document.removeEventListener('touchmove', moveFn);
      document.removeEventListener('touchend', endFn);
      document.removeEventListener('touchcancel', endFn);

      const cx = (ev.changedTouches && ev.changedTouches[0]) ? ev.changedTouches[0].clientX : this._lastSpawnClient.x;
      const cy = (ev.changedTouches && ev.changedTouches[0]) ? ev.changedTouches[0].clientY : this._lastSpawnClient.y;

      const br = this.boardContainer.getBoundingClientRect();
      const insideBoard = (cx >= br.left && cx <= br.right && cy >= br.top && cy <= br.bottom);

      if(insideBoard){
        // IMPORTANT: aimantation immédiate dès le premier dépôt (sans devoir re-bouger la bande)
        const p = this.getWorldPos(cx, cy);
        const created = this.addToken({denom: sd.denom, kind: sd.kind, x: p.x, y: p.y});
        this.snapToken(created, {silent:true});
      } else if(!sd.moved){
        const center = this.getWorldPos(br.left + br.width*0.5, br.top + br.height*0.35);
        this.addToken({denom: sd.denom, kind: sd.kind, x: center.x, y: center.y});
      }

      if(sd.ghost) sd.ghost.remove();
      this.spawnDrag = null;
    }

    // ---- Plateau / transformation ----
    updateTransform(){
      this.boardWorld.style.transform = `translate(${this.pan.x}px, ${this.pan.y}px) scale(${this.scale})`;
    }

    setZoom(z){
      this.scale = Math.min(Math.max(0.45, z), 3);
      this.updateTransform();
    }

    resetView(){
      this.pan = {x:0, y:0};
      this.scale = 1;
      this.updateTransform();
    }

    getWorldPos(clientX, clientY){
      const r = this.boardContainer.getBoundingClientRect();
      return {
        x: (clientX - r.left - this.pan.x) / this.scale,
        y: (clientY - r.top - this.pan.y) / this.scale,
      };
    }

    // ---- Contours "1 trait" quand ça colle ----
    updateSeamBorders(){
      const tol = 2.2;
      const edge = 'rgba(0,0,0,0.55)';
      const transparent = 'transparent';

      for(const t of this.tokens){
        if(!t._el) continue;
        t._el.style.setProperty('--edgeL', edge);
        t._el.style.setProperty('--edgeR', edge);
        t._el.style.setProperty('--edgeT', edge);
        t._el.style.setProperty('--edgeB', edge);
      }

      const dims = (t)=>this.tokenDims(t);
      const overlapLen = (a0,a1,b0,b1)=> Math.min(a1,b1) - Math.max(a0,b0);

      for(let i=0;i<this.tokens.length;i++){
        const a = this.tokens[i];
        if(!a._el) continue;
        const ad = dims(a);
        const ax0 = a.x, ax1 = a.x + ad.w;
        const ay0 = a.y, ay1 = a.y + ad.h;

        for(let j=i+1;j<this.tokens.length;j++){
          const b = this.tokens[j];
          if(!b._el) continue;
          const bd = dims(b);
          const bx0 = b.x, bx1 = b.x + bd.w;
          const by0 = b.y, by1 = b.y + bd.h;

          const ovX = overlapLen(ax0, ax1, bx0, bx1);
          const ovY = overlapLen(ay0, ay1, by0, by1);

          if(Math.abs(ax1 - bx0) < tol && ovY > Math.min(ad.h, bd.h) * 0.35){
            b._el.style.setProperty('--edgeL', transparent);
          }
          if(Math.abs(bx1 - ax0) < tol && ovY > Math.min(ad.h, bd.h) * 0.35){
            a._el.style.setProperty('--edgeL', transparent);
          }

          if(Math.abs(ay1 - by0) < tol && ovX > Math.min(ad.w, bd.w) * 0.35){
            b._el.style.setProperty('--edgeT', transparent);
          }
          if(Math.abs(by1 - ay0) < tol && ovX > Math.min(ad.w, bd.w) * 0.35){
            a._el.style.setProperty('--edgeT', transparent);
          }
        }
      }
    }

    scheduleSeamUpdate(){
      if(this._seamRAF) return;
      this._seamRAF = requestAnimationFrame(() => {
        this._seamRAF = null;
        this.updateSeamBorders();
      });
    }

    // ---- UI ----
    _bind(id, evt, fn){
      const el = document.getElementById(id);
      if(!el){
        console.warn(`[UI] Élément manquant: #${id} (listener ${evt} ignoré)`);
        return null;
      }
      el.addEventListener(evt, fn);
      return el;
    }

    initUI(){
      this._bind('btn-undo','click', () => this.undo());
      this._bind('btn-clear','click', () => this.resetAll());
      this._bind('btn-export-png','click', () => this.exportPNG());
      this._bind('btn-zoom-in','click', () => this.setZoom(this.scale + 0.15));
      this._bind('btn-zoom-out','click', () => this.setZoom(this.scale - 0.15));
      this._bind('btn-reset-view','click', () => this.resetView());

      this._bind('btn-flip','click', () => this.flipSelected());
      this._bind('btn-separate','click', () => this.separateSelected());
      this._bind('btn-cut','click', () => this.cutSelected());
      this._bind('btn-fuse','click', () => this.fuseSelected());
      this._bind('btn-duplicate','click', () => this.duplicateSelected());
      this._bind('btn-delete','click', () => this.deleteSelected());

      this._bind('tool-hand','click', () => this.setTool('hand'));
      this._bind('tool-pen','click', () => this.setTool('pen'));
      this._bind('btn-clear-drawing','click', () => this.clearDrawing());

      window.addEventListener('keydown', (e) => {
        if(e.key === 'Escape') this.selectToken(null);
        if((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') { e.preventDefault(); this.undo(); }
        if(e.key === 'Delete' || e.key === 'Backspace') this.deleteSelected();
      });
    }

    updateSelectionUI(){
      const btnFlip = document.getElementById('btn-flip');
      const btnSep  = document.getElementById('btn-separate');
      const btnCut  = document.getElementById('btn-cut');
      const btnFuse = document.getElementById('btn-fuse');
      const btnDup  = document.getElementById('btn-duplicate');
      const btnDel  = document.getElementById('btn-delete');

      const s = this.selected;
      const has = !!s;

      if(btnFlip) btnFlip.disabled = !has;
      if(btnDup)  btnDup.disabled  = !has;
      if(btnDel)  btnDel.disabled  = !has;

      if(btnSep)  btnSep.disabled  = !(has && s.kind === 'band'  && s.denom > 1);
      if(btnFuse) btnFuse.disabled = !(has && s.kind === 'piece' && s.denom > 1);
      if(btnCut)  btnCut.disabled  = !(has && this.canCut(s));
    }

    // ---- Plateau listeners ----
    initBoardListeners(){
      // zoom molette
      this.boardContainer.addEventListener('wheel', (e) => {
        e.preventDefault();
        const delta = -e.deltaY * 0.001;
        this.setZoom(this.scale + delta);
      }, {passive:false});

      // pan sur fond
      this.boardContainer.addEventListener('mousedown', (e) => {
        if(this.currentTool === 'pen') return;
        if(e.target.closest('.strip')) return;
        this.isPanning = true;
        this.panStart = {x: e.clientX - this.pan.x, y: e.clientY - this.pan.y};
        this.boardContainer.classList.add('panning');
        this.selectToken(null);
      });

      // dessin
      this.boardContainer.addEventListener('mousedown', (e) => {
        if(this.currentTool === 'pen') this.startDraw(e);
      });

      window.addEventListener('mousemove', (e) => {
        this.moveCursor(e);
        if(this.isPanning){
          this.pan.x = e.clientX - this.panStart.x;
          this.pan.y = e.clientY - this.panStart.y;
          this.updateTransform();
        } else if(this.isDrawing && this.currentTool === 'pen'){
          this.draw(e);
        }
      });

      window.addEventListener('mouseup', () => {
        this.isPanning = false;
        this.isDrawing = false;
        this.boardContainer.classList.remove('panning');
      });

      window.addEventListener('resize', () => this.resizeCanvas());
    }

    // ---- Création / rendu tokens ----
    mountToken(token){
      const cfg = this.getFractionConfig(token.denom);
      const el = document.createElement('div');
      el.className = 'strip';
      el.dataset.id = String(token.id);

      const h = this.stripH;
      const w = (token.kind === 'band') ? this.unitW : this.pieceW(token.denom);

      el.style.width = `${w}px`;
      el.style.height = `${h}px`;
      el.style.left = `${token.x}px`;
      el.style.top = `${token.y}px`;
      el.style.background = cfg.color;
      el.style.borderColor = cfg.border;
      el.style.zIndex = String(10 + token.id);

      if(token.side === 'back') el.classList.add('is-back');

      const inner = document.createElement('div');
      inner.className = 'strip-inner';

      const faceFront = document.createElement('div');
      faceFront.className = 'face face-front';

      const faceBack = document.createElement('div');
      faceBack.className = 'face face-back';

      // recto
      const segCountFront = (token.kind === 'band') ? token.denom : 1;
      for(let i=0;i<segCountFront;i++){
        const seg = document.createElement('div');
        seg.className = 'seg';
        seg.style.color = cfg.text;
        seg.style.fontSize = `${this.fontSizeFor(token.denom, token.kind)}px`;
        seg.innerHTML = (token.denom === 1) ? `<span class="back-one">1</span>` : this.labelHTML(token.denom);
        faceFront.appendChild(seg);
      }

      // verso : bande => 1, pièce => 1/denom
      const backSeg = document.createElement('div');
      backSeg.className = 'seg';
      backSeg.style.color = cfg.text;
      backSeg.style.fontSize = `${this.fontSizeFor(token.denom, token.kind)}px`;
      if(token.kind === 'band' || token.denom === 1) backSeg.innerHTML = `<span class="back-one" style="color:${cfg.text}">1</span>`;
      else backSeg.innerHTML = this.labelHTML(token.denom);
      faceBack.appendChild(backSeg);

      inner.appendChild(faceFront);
      inner.appendChild(faceBack);
      el.appendChild(inner);

      // interactions
      el.addEventListener('mousedown', (e) => this.handleDragStart(e));
      el.addEventListener('touchstart', (e) => this.handleDragStart(e), {passive:false});
      el.addEventListener('click', (e) => {
        e.stopPropagation();
        this.selectToken(token.id);
      });
      el.addEventListener('dblclick', (e) => {
        e.stopPropagation();
        this.selectToken(token.id);
        this.flipSelected();
      });

      // double-tap mobile
      let lastTap = 0;
      el.addEventListener('touchend', (e) => {
        const now = Date.now();
        if(now - lastTap < 300){
          e.preventDefault();
          this.selectToken(token.id);
          this.flipSelected();
        }
        lastTap = now;
      });

      this.boardWorld.appendChild(el);
      token._el = el;

      if(token._new){
        el.classList.add('spawn-pop');
        el.addEventListener('animationend', () => el.classList.remove('spawn-pop'), {once:true});
        delete token._new;
      }

      this.refreshTokenSelectedClass(token.id);
      this.updateSeamBorders();
    }

    refreshTokenSelectedClass(id){
      this.tokens.forEach(t => {
        if(!t._el) return;
        t._el.classList.toggle('selected', t.id === id);
      });
    }

    addToken({denom, kind, x=null, y=null}){
      this.saveState();
      playSound('pop');
      const pos = (x===null || y===null) ? {x: 40 + Math.random()*40, y: 40 + Math.random()*30} : {x, y};

      const w = (kind === 'band') ? this.unitW : this.pieceW(denom);
      const h = this.stripH;
      const token = {
        id: this.nextId++,
        denom,
        kind,
        side: 'front',
        x: pos.x - w/2,
        y: pos.y - h/2,
        _new: true,
      };
      this.tokens.push(token);
      this.mountToken(token);
      this.selectToken(token.id);
      return token;
    }

    selectToken(id){
      this.selectedId = id;
      this.refreshTokenSelectedClass(id);
      this.updateSelectionUI();
    }

    get selected(){
      return this.tokens.find(t => t.id === this.selectedId) || null;
    }

    flipSelected(){
      const s = this.selected;
      if(!s) return;
      this.saveState();
      s.side = (s.side === 'front') ? 'back' : 'front';

      if(s._el){
        requestAnimationFrame(() => {
          s._el.classList.toggle('is-back', s.side === 'back');
        });
      }

      this.updateSelectionUI();
      playSound('flip');
    }

    duplicateSelected(){
      const s = this.selected;
      if(!s) return;
      this.saveState();
      const copy = {
        id: this.nextId++,
        denom: s.denom,
        kind: s.kind,
        side: s.side,
        x: s.x + 24,
        y: s.y + 24,
      };
      this.tokens.push(copy);
      this.mountToken(copy);
      this.selectToken(copy.id);
      playSound('pop');
    }

    deleteSelected(){
      const s = this.selected;
      if(!s) return;
      this.saveState();
      if(s._el) s._el.remove();
      this.tokens = this.tokens.filter(t => t.id !== s.id);
      this.selectToken(null);
      this.updateSeamBorders();
      playSound('whoosh');
    }

    separateSelected(){
      const s = this.selected;
      if(!s || s.kind !== 'band' || s.denom <= 1) return;
      this.saveState();

      const baseX = s.x;
      const baseY = s.y;
      const denom = s.denom;
      const side = s.side;

      if(s._el) s._el.remove();
      this.tokens = this.tokens.filter(t => t.id !== s.id);

      const pw = this.pieceW(denom);
      // Pièces "collées" (pas d'explosion) : les séparations deviennent des traits pleins (contours)
      for(let i=0;i<denom;i++){
        const piece = { id: this.nextId++, denom, kind:'piece', side, x: baseX + i*pw, y: baseY };
        this.tokens.push(piece);
        this.mountToken(piece);
      }
      this.selectToken(this.tokens[this.tokens.length - denom].id);
      this.updateSeamBorders();
      playSound('pop');
    }

    fuseSelected(){
      const s = this.selected;
      if(!s || s.kind !== 'piece' || s.denom <= 1) return;

      const d = s.denom;
      const pw = this.pieceW(d);
      const yTol = 10;
      const xTol = 12;

      const rowPieces = this.tokens
        .filter(t => t.kind === 'piece' && t.denom === d && t.side === s.side && Math.abs(t.y - s.y) < yTol)
        .sort((a,b) => a.x - b.x);

      if(rowPieces.length < d){ playSound('whoosh'); return; }

      for(let start=0; start <= rowPieces.length - d; start++){
        const seq = rowPieces.slice(start, start + d);
        if(!seq.some(t => t.id === s.id)) continue;

        const baseX = seq[0].x;
        const baseY = seq[0].y;
        let ok = true;
        for(let i=0;i<d;i++){
          const expectedX = baseX + i * pw;
          if(Math.abs(seq[i].x - expectedX) > xTol) { ok = false; break; }
          if(Math.abs(seq[i].y - baseY) > yTol) { ok = false; break; }
        }
        if(!ok) continue;

        this.saveState();
        const ids = new Set(seq.map(t => t.id));
        seq.forEach(t => { if(t._el) t._el.remove(); });
        this.tokens = this.tokens.filter(t => !ids.has(t.id));

        const band = { id: this.nextId++, denom: d, kind:'band', side: s.side, x: baseX, y: baseY };
        this.tokens.push(band);
        this.mountToken(band);
        this.selectToken(band.id);
        playSound('pop');
        return;
      }

      playSound('whoosh');
    }

    // ---- Ciseaux : couper en 2 (uniquement si le double existe) ----
    canCut(t){
      if(!t) return false;
      if(t.denom <= 0) return false;
      const d2 = t.denom * 2;
      return this.DENOM_SET.has(d2);
    }

    cutSelected(){
      const s = this.selected;
      if(!s || !this.canCut(s)) return;

      const d = s.denom;
      const d2 = d * 2;
      const side = s.side;
      const x = s.x;
      const y = s.y;

      this.saveState();

      if(s._el) s._el.remove();
      this.tokens = this.tokens.filter(t => t.id !== s.id);

      if(s.kind === 'band'){
        // bande entière : devient une bande en 2d parts (même largeur totale)
        const band = { id: this.nextId++, denom: d2, kind:'band', side, x, y };
        this.tokens.push(band);
        this.mountToken(band);
        this.selectToken(band.id);
      } else {
        // pièce : devient 2 pièces de 1/(2d) qui remplissent exactement la largeur d'origine
        const pw2 = this.pieceW(d2);
        const p1 = { id: this.nextId++, denom: d2, kind:'piece', side, x: x,         y };
        const p2 = { id: this.nextId++, denom: d2, kind:'piece', side, x: x + pw2,    y };
        this.tokens.push(p1, p2);
        this.mountToken(p1);
        this.mountToken(p2);
        this.selectToken(p1.id);
      }

      this.updateSeamBorders();
      playSound('pop');
    }

    // ---- Export PNG (photo du plateau, comme à l'écran) ----
    _exportComputeEdges(){
      const tol = 2.2;
      const vis = new Map();
      for(const t of this.tokens){
        vis.set(t.id, {L:true,R:true,T:true,B:true});
      }
      const dims = (t)=>this.tokenDims(t);
      const overlapLen = (a0,a1,b0,b1)=> Math.min(a1,b1) - Math.max(a0,b0);

      for(let i=0;i<this.tokens.length;i++){
        const a = this.tokens[i];
        const ad = dims(a);
        const ax0=a.x, ax1=a.x+ad.w;
        const ay0=a.y, ay1=a.y+ad.h;

        for(let j=i+1;j<this.tokens.length;j++){
          const b = this.tokens[j];
          const bd = dims(b);
          const bx0=b.x, bx1=b.x+bd.w;
          const by0=b.y, by1=b.y+bd.h;

          const ovX = overlapLen(ax0, ax1, bx0, bx1);
          const ovY = overlapLen(ay0, ay1, by0, by1);

          if(Math.abs(ax1 - bx0) < tol && ovY > Math.min(ad.h, bd.h) * 0.35){
            vis.get(b.id).L = false;
          }
          if(Math.abs(bx1 - ax0) < tol && ovY > Math.min(ad.h, bd.h) * 0.35){
            vis.get(a.id).L = false;
          }

          if(Math.abs(ay1 - by0) < tol && ovX > Math.min(ad.w, bd.w) * 0.35){
            vis.get(b.id).T = false;
          }
          if(Math.abs(by1 - ay0) < tol && ovX > Math.min(ad.w, bd.w) * 0.35){
            vis.get(a.id).T = false;
          }
        }
      }
      return vis;
    }
    async ensureFontsReady(){
      // Assure que la police (Fredoka) est bien chargée avant un rendu canvas (export)
      try{
        if(document.fonts && document.fonts.ready){
          await document.fonts.ready;
          await document.fonts.load('800 18px Fredoka');
        }
      }catch(_){ /* ignore */ }
    }

    _drawFraction(ctx, denom, cx, cy, fontSize, color){
      ctx.save();
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      const embossText = (txt, x, y, fs, weight='800') => {
        const size = Math.max(9, fs);
        ctx.font = `${weight} ${size}px Fredoka, sans-serif`;
        // léger emboss blanc comme sur le plateau
        ctx.fillStyle = 'rgba(255,255,255,0.35)';
        ctx.fillText(txt, x, y + 1);
        ctx.fillStyle = color;
        ctx.fillText(txt, x, y);
      };

      if(denom === 1){
        embossText('1', cx, cy, fontSize * 1.05, '800');
        ctx.restore();
        return;
      }

      const fs = Math.max(9, fontSize);
      const numY = cy - fs * 0.34;
      const denY = cy + fs * 0.40;
      const barY = cy + fs * 0.02;
      const barW = fs * 1.15;

      embossText('1', cx, numY, fs, '800');

      // barre de fraction (avec emboss)
      ctx.lineCap = 'round';
      ctx.lineWidth = 2; // en "unités monde" : se scale comme à l'écran
      ctx.strokeStyle = 'rgba(255,255,255,0.35)';
      ctx.beginPath();
      ctx.moveTo(cx - barW/2, barY + 1);
      ctx.lineTo(cx + barW/2, barY + 1);
      ctx.stroke();

      ctx.strokeStyle = 'rgba(0,0,0,0.70)';
      ctx.beginPath();
      ctx.moveTo(cx - barW/2, barY);
      ctx.lineTo(cx + barW/2, barY);
      ctx.stroke();

      embossText(String(denom), cx, denY, fs, '800');
      ctx.restore();
    }

    async exportPNG(){
      await this.ensureFontsReady();
      // rendu à l'écran : on exporte le rectangle visible du plateau
      const r = this.boardContainer.getBoundingClientRect();
      const w = Math.max(1, Math.round(r.width));
      const h = Math.max(1, Math.round(r.height));
      const dpr = Math.min(2, window.devicePixelRatio || 1);

      const out = document.createElement('canvas');
      out.width = Math.round(w * dpr);
      out.height = Math.round(h * dpr);
      out.style.width = w + 'px';
      out.style.height = h + 'px';

      const ctx = out.getContext('2d');
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, w, h);

      // transform "world" -> écran
      ctx.translate(this.pan.x, this.pan.y);
      ctx.scale(this.scale, this.scale);

      // 1) annotations
      try{
        ctx.drawImage(this.canvas, 0, 0);
      }catch(_){ /* ignore */ }

      // 2) bandes/pièces
      const edgeVis = this._exportComputeEdges();
      const ordered = [...this.tokens].sort((a,b) => (a.id - b.id));

      for(const t of ordered){
        const cfg = this.getFractionConfig(t.denom);
        const {w:tw, h:th} = this.tokenDims(t);

        // fond
        ctx.fillStyle = cfg.color;
        ctx.fillRect(t.x, t.y, tw, th);

        // séparations internes (recto seulement)
        if(t.side === 'front' && t.kind === 'band' && t.denom > 1){
          ctx.save();
          ctx.strokeStyle = 'rgba(0,0,0,0.28)';
          ctx.lineWidth = 1;
          ctx.setLineDash([6, 4]);
          const step = tw / t.denom;
          for(let k=1;k<t.denom;k++){
            const gx = t.x + k*step;
            ctx.beginPath();
            ctx.moveTo(gx, t.y);
            ctx.lineTo(gx, t.y + th);
            ctx.stroke();
          }
          ctx.restore();
        }

        // texte
        const fs = this.fontSizeFor(t.denom, t.kind);
        if(t.side === 'front'){
          const segCount = (t.kind === 'band') ? t.denom : 1;
          if(segCount === 1){
            this._drawFraction(ctx, t.denom, t.x + tw/2, t.y + th/2, fs, cfg.text);
          } else {
            const step = tw / segCount;
            for(let i=0;i<segCount;i++){
              this._drawFraction(ctx, t.denom, t.x + (i+0.5)*step, t.y + th/2, fs, cfg.text);
            }
          }
        } else {
          // verso : bande => 1 ; pièce => 1/denom
          const backDen = (t.kind === 'band' || t.denom === 1) ? 1 : t.denom;
          this._drawFraction(ctx, backDen, t.x + tw/2, t.y + th/2, Math.max(fs, 16), cfg.text);
        }

        // contours fins (1 trait)
        const ev = edgeVis.get(t.id) || {L:true,R:true,T:true,B:true};
        ctx.save();
        ctx.strokeStyle = 'rgba(0,0,0,0.55)';
        ctx.lineWidth = 1;
        ctx.setLineDash([]);
        ctx.beginPath();
        if(ev.T){ ctx.moveTo(t.x, t.y); ctx.lineTo(t.x + tw, t.y); }
        if(ev.B){ ctx.moveTo(t.x, t.y + th); ctx.lineTo(t.x + tw, t.y + th); }
        if(ev.L){ ctx.moveTo(t.x, t.y); ctx.lineTo(t.x, t.y + th); }
        if(ev.R){ ctx.moveTo(t.x + tw, t.y); ctx.lineTo(t.x + tw, t.y + th); }
        ctx.stroke();
        ctx.restore();

        // sélection (anneau)
        if(t.id === this.selectedId){
          ctx.save();
          ctx.strokeStyle = 'rgba(59,130,246,0.85)';
          ctx.lineWidth = 3;
          const pad = 1.5;
          ctx.strokeRect(t.x - pad, t.y - pad, tw + 2*pad, th + 2*pad);
          ctx.restore();
        }
      }

      // download
      const stamp = new Date();
      const pad2 = (n)=>String(n).padStart(2,'0');
      const name = `plateau-fractions-${stamp.getFullYear()}-${pad2(stamp.getMonth()+1)}-${pad2(stamp.getDate())}_${pad2(stamp.getHours())}-${pad2(stamp.getMinutes())}-${pad2(stamp.getSeconds())}.png`;

      out.toBlob((blob) => {
        if(!blob) return;
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = name;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(() => URL.revokeObjectURL(url), 1000);
      }, 'image/png');
    }

    // ---- Drag tokens ----
    handleDragStart(e){
      if(this.currentTool !== 'hand') return;
      e.stopPropagation();
      const el = e.target.closest('.strip');
      if(!el) return;

      const id = parseInt(el.dataset.id, 10);
      const token = this.tokens.find(t => t.id === id);
      if(!token) return;

      this.saveState();
      this.selectToken(token.id);

      token._el.classList.add('dragging');

      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      const rect = token._el.getBoundingClientRect();
      const offset = { x: clientX - rect.left, y: clientY - rect.top };

      const move = (ev) => {
        ev.preventDefault();
        const cx = ev.touches ? ev.touches[0].clientX : ev.clientX;
        const cy = ev.touches ? ev.touches[0].clientY : ev.clientY;
        const br = this.boardContainer.getBoundingClientRect();
        const wx = (cx - br.left - this.pan.x - offset.x) / this.scale;
        const wy = (cy - br.top - this.pan.y - offset.y) / this.scale;
        token.x = wx;
        token.y = wy;
        token._el.style.left = wx + 'px';
        token._el.style.top = wy + 'px';
        this.scheduleSeamUpdate();
      };

      const end = () => {
        document.removeEventListener('mousemove', move);
        document.removeEventListener('touchmove', move);
        document.removeEventListener('mouseup', end);
        document.removeEventListener('touchend', end);
        if(token._el) token._el.classList.remove('dragging');
        this.snapToken(token);
      };

      document.addEventListener('mousemove', move);
      document.addEventListener('touchmove', move, {passive:false});
      document.addEventListener('mouseup', end);
      document.addEventListener('touchend', end);
    }

    snapToken(token, opts={}){
      const t = token;
      if(!t) return;

      const {w, h} = this.tokenDims(t);
      const threshPx = 28;
      const thresh = threshPx / this.scale;

      let bestX = null, bestDx = Infinity;
      let bestY = null, bestDy = Infinity;

      const considerX = (nx) => {
        const dx = nx - t.x;
        const adx = Math.abs(dx);
        if(adx <= thresh && adx < bestDx){ bestDx = adx; bestX = nx; }
      };
      const considerY = (ny) => {
        const dy = ny - t.y;
        const ady = Math.abs(dy);
        if(ady <= thresh && ady < bestDy){ bestDy = ady; bestY = ny; }
      };

      const xLinesFor = (o) => {
        const {w:ow} = this.tokenDims(o);
        const ox = o.x;
        const lines = [];
        if(o.kind === 'band'){
          const step = ow / o.denom;
          for(let k=0;k<=o.denom;k++) lines.push(ox + k*step);
        } else {
          lines.push(ox, ox + ow);
        }
        return lines;
      };

      for(const o of this.tokens){
        if(o.id === t.id) continue;
        const od = this.tokenDims(o);
        const ox = o.x, oy = o.y, ow = od.w, oh = od.h;

        considerY(oy);
        considerY(oy - h);
        considerY(oy + oh);

        const lines = xLinesFor(o);
        for(const gx of lines){
          considerX(gx);
          considerX(gx - w);
        }
        considerX(ox + ow);
        considerX(ox - w);
      }

      let snapped = false;
      if(bestX !== null){
        t.x = bestX;
        if(t._el) t._el.style.left = t.x + 'px';
        snapped = true;
      }
      if(bestY !== null){
        t.y = bestY;
        if(t._el) t._el.style.top = t.y + 'px';
        snapped = true;
      }

      if(snapped && !opts.silent) playSound('pop');
      this.updateSeamBorders();
    }

    // ---- Outils dessin ----
    setTool(tool){
      this.currentTool = tool;
      const hand = document.getElementById('tool-hand');
      const pen  = document.getElementById('tool-pen');
      if(hand){ hand.classList.toggle('bg-white', tool==='hand'); hand.classList.toggle('shadow', tool==='hand'); }
      if(pen){  pen.classList.toggle('bg-white', tool==='pen');   pen.classList.toggle('shadow', tool==='pen'); }

      const penMode = (tool === 'pen');
      this.boardContainer.classList.toggle('hide-cursor', penMode);
      document.getElementById('custom-cursor').style.display = penMode ? 'block' : 'none';
    }

    resizeCanvas(){
      this.canvas.width = 4000;
      this.canvas.height = 4000;
      this.canvas.style.width = '4000px';
      this.canvas.style.height = '4000px';
      this.ctx.lineWidth = 3;
      this.ctx.lineCap = 'round';
      this.ctx.strokeStyle = '#111827';
    }

    startDraw(e){
      this.isDrawing = true;
      const cx = e.touches ? e.touches[0].clientX : e.clientX;
      const cy = e.touches ? e.touches[0].clientY : e.clientY;
      const p = this.getWorldPos(cx, cy);
      this.lastDrawPos = p;
      this.ctx.beginPath();
      this.ctx.moveTo(p.x, p.y);
    }

    draw(e){
      e.preventDefault();
      const cx = e.touches ? e.touches[0].clientX : e.clientX;
      const cy = e.touches ? e.touches[0].clientY : e.clientY;
      const p = this.getWorldPos(cx, cy);
      this.ctx.lineTo(p.x, p.y);
      this.ctx.stroke();
      this.lastDrawPos = p;
    }

    clearDrawing(){
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }

    moveCursor(e){
      if(this.currentTool !== 'pen') return;
      const c = document.getElementById('custom-cursor');
      c.style.left = e.clientX + 'px';
      c.style.top = e.clientY + 'px';
      c.style.transform = 'translate(-6px,-28px)';
    }

    clearAllTokens(withHistory=true){
      if(withHistory) this.saveState();
      this.tokens.forEach(t => t._el && t._el.remove());
      this.tokens = [];
      this.selectedId = null;
      this.updateSelectionUI();
    }

    resetAll(){
      this.saveState();
      this.clearAllTokens(false);
      this.clearDrawing();
      this.resetView();
      playSound('whoosh');
    }
  }

  // --- Mini tests (sécurité) ---
  function runSelfTests(){
    const required = [
      'btn-undo','btn-clear','btn-export-png','btn-zoom-in','btn-zoom-out','btn-reset-view',
      'btn-flip','btn-separate','btn-cut','btn-fuse','btn-duplicate','btn-delete',
      'tool-hand','tool-pen','btn-clear-drawing',
      'board-container','board-world','palette','drawing-canvas'
    ];
    const missing = required.filter(id => !document.getElementById(id));
    if(missing.length){
      console.error('[SelfTest] IDs manquants:', missing);
    } else {
      console.log('[SelfTest] OK');
    }
  }

  // IMPORTANT: instancier après que le DOM est prêt (évite le null.addEventListener)
  window.addEventListener('DOMContentLoaded', () => {
    runSelfTests();
    window.app = new FractionStripsApp();
  });
</script>

</body>
</html>
