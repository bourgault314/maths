<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Plateau – Bandes de fractions</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;800&display=swap" rel="stylesheet">

  <style>
    :root{
      --unitW: 420; /* largeur d'une unité */
      --stripH: 58;
      --boardBg: #ffffff;
      /* Couleur de la grille (bordures) */
      --gridColor: rgba(0,0,0,0.6); 
    }

    body{
      font-family: 'Fredoka', sans-serif;
      background: #ffffff;
      overflow: hidden;
      touch-action: none;
      user-select: none;
      -webkit-user-select: none;
    }

    #board-container{
      position: absolute;
      inset: 0;
      overflow: hidden;
      cursor: grab;
      background: var(--boardBg);
    }
    #board-container.panning{ cursor: grabbing; }

    #board-world{
      position: absolute;
      top: 0; left: 0;
      transform-origin: 0 0;
      width: 0; height: 0;
    }

    #drawing-canvas{
      position: absolute;
      /* CORRECTION STYLO : On étend la zone de dessin vers le haut et la gauche */
      top: -4000px; 
      left: -4000px;
      pointer-events: none;
      z-index: 3000;
    }

    /* --- Demi-droite --- */
    #number-line{
      position: absolute;
      left: 0; top: 0;
      z-index: 2;
      pointer-events: none;
      opacity: 0.95;
    }
    #number-line.hidden{ display:none; }
    #number-line text{ font-family:'Fredoka', sans-serif; font-weight:800; }

    .no-scrollbar::-webkit-scrollbar{ display:none; }
    .no-scrollbar{ -ms-overflow-style:none; scrollbar-width:none; }

    /* --- Bandes / pièces --- */
    .strip{
      position: absolute;
      overflow: visible; 
      display: flex;
      align-items: stretch;
      justify-content: stretch;
      border-radius: 0px;
      box-shadow: none; 
      cursor: grab;
      touch-action: none;
      transform-origin: 0 0;
      box-sizing: border-box;
      border: none;
      z-index: 10;
    }
    .strip.dragging{ cursor: grabbing; z-index: 2000 !important; }
    
    .strip.selected{ 
      box-shadow: 0 0 0 3px rgba(59,130,246,0.85); 
      z-index: 100 !important;
    }

    /* LE "TABLEAU" : Bordure partagée via superposition */
    .strip::after {
      content: "";
      position: absolute;
      top: 0; 
      left: 0;
      width: calc(100% + 1px);
      height: calc(100% + 1px);
      border: 1px solid var(--gridColor);
      box-sizing: border-box;
      pointer-events: none;
      z-index: 50;
    }

    /* --- Conteneur interne --- */
    .strip-inner{
      position: relative;
      width: 100%;
      height: 100%;
      flex: 1 1 auto;
      overflow: hidden; 
    }
    
    .face{
      position: absolute;
      inset: 0;
      display: flex;
      align-items: stretch;
      justify-content: stretch;
    }
    
    /* GESTION DE L'AFFICHAGE FACE / DOS SANS ROTATION */
    .face-front { display: flex; }
    .face-back  { display: none; }

    .strip.is-back .face-front { display: none; }
    .strip.is-back .face-back  { display: flex; }

    /* Ghost drag */
    .strip.ghost{
      position: fixed;
      pointer-events: none;
      opacity: 0.96;
      z-index: 9998;
      box-shadow: 0 22px 38px rgba(0,0,0,0.30);
      transform: scale(0.98);
      transition: transform 120ms ease-out, opacity 120ms ease-out;
      overflow: hidden;
    }
    .strip.ghost::after { content: none; }
    .strip.ghost { border: 1px solid var(--gridColor); }
    .strip.ghost.ready{ transform: scale(1); }

    .strip.spawn-pop{ animation: popIn 140ms ease-out; }
    @keyframes popIn{ from{ transform: scale(0.92); } to{ transform: scale(1); } }

    /* segments (les parts) */
    .seg{
      flex: 1 1 auto;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight: 600;
      letter-spacing: 0;
      line-height: 1;
      text-shadow: 0 1px 0 rgba(255,255,255,0.35);
      text-align: center;
    }
    .seg + .seg{ border-left: 1px dashed rgba(0,0,0,0.22); }

    /* fraction verticale (Mode 1/2) */
    .frac{
      display: inline-flex;
      flex-direction: column;
      align-items: center;
      line-height: 1;
      transform: translateY(-1px);
      filter: drop-shadow(0 1px 0 rgba(255,255,255,0.35));
    }
    .frac .num, .frac .den{ font-weight: 700; }
    .frac .bar{
      width: 1.2em;
      height: 2px;
      background: rgba(0,0,0,0.65);
      border-radius: 2px;
      margin: 3px 0;
    }

    .back-one{
      font-weight: 800;
      font-size: 1.35rem;
      text-shadow: 0 2px 0 rgba(255,255,255,0.35);
    }

    /* Mode Texte (ABC) */
    .text-label {
      font-weight: 800;
      line-height: 1;
      text-align: center;
      text-shadow: 0 1px 0 rgba(255,255,255,0.4);
    }
    /* Rotation pour 1/5, 1/6, 1/8, 1/10 */
    .text-rotated {
      writing-mode: vertical-rl;
      transform: rotate(180deg);
      white-space: nowrap;
    }

    /* --- Menu gauche --- */
    .palette-item{
      padding: 6px 8px;
      border-radius: 12px;
      transition: none;
    }
    .palette-item:hover{ background: transparent; }

    /* Titres dans le menu (Unités, Demis...) : masqués par défaut */
    .palette-label {
      display: none;
    }
    /* ... et affichés UNIQUEMENT quand le body a la classe show-text-labels */
    body.show-text-labels .palette-label {
      display: block;
    }

    .spawn-tile{
      height: 40px;
      flex: 0 0 auto;
      flex-shrink: 0;
      position: relative;
      border-radius: 0px;
      border: none;
      overflow: hidden;
      display: flex;
      cursor: grab;
      box-shadow:
        0 4px 10px rgba(0,0,0,0.18),
        inset 0 0 0 1px rgba(0,0,0,0.55);
      user-select: none;
      touch-action: none;
      background: transparent;
    }
    .spawn-tile:active{ cursor: grabbing; }

    .spawn-seg{ flex: 1 1 auto; display:flex; align-items:center; justify-content:center; font-weight:800; font-size: 10px; }
    .spawn-seg + .spawn-seg{ border-left: 1px dashed rgba(0,0,0,0.22); }

    .frac.menu{ transform: none; filter: none; font-size: inherit; }
    .frac.menu .bar{ width: 0.9em; height: 2px; margin: 2px 0; background: rgba(0,0,0,0.70); }

    /* Mode crayon */
    body.pen-mode #board-container{ cursor: crosshair; }
    body.pen-mode #board-container.panning{ cursor: grabbing; }
    body.pen-mode .strip{ cursor: crosshair; }
    body.pen-mode .strip.dragging{ cursor: grabbing; }

    @media (max-width: 640px){
      :root{ --stripH: 52; }
    }
  </style>
</head>

<body class="h-screen w-screen flex flex-col">

  <!-- Barre haute -->
  <header class="bg-blue-50 p-2 shadow-md z-30 flex flex-wrap items-center gap-3 shrink-0">
    <div class="flex items-center gap-2">
      <button id="btn-undo" class="bg-blue-100 text-blue-700 hover:bg-blue-200 p-2 rounded-lg font-bold border border-blue-200 shadow-sm active:scale-95 transition" title="Annuler">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6" />
        </svg>
      </button>

      <button id="btn-clear" class="bg-rose-100 text-rose-700 hover:bg-rose-200 p-2 rounded-lg font-bold border border-rose-200 shadow-sm active:scale-95 transition" title="Tout effacer">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
        </svg>
      </button>

      <!-- Bouton bascule 1/2 <=> ABC -->
      <button id="btn-toggle-labels" class="bg-indigo-100 text-indigo-700 hover:bg-indigo-200 p-2 px-3 rounded-lg font-bold border border-indigo-200 shadow-sm active:scale-95 transition flex items-center gap-1" title="Changer l'affichage (Fractions / Texte)">
        <span id="label-icon-num" class="text-sm font-extrabold">1/2</span>
        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mx-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7h12m0 0l-4-4m4 4l-4 4m0 6H4m0 0l4 4m-4-4l4-4" />
        </svg>
        <span id="label-icon-txt" class="text-sm font-extrabold opacity-50">ABC</span>
      </button>

      <!-- Demi-droite (icône) -->
      <button id="btn-numberline" class="bg-white text-slate-800 hover:bg-slate-100 p-2 rounded-lg font-bold border border-slate-200 shadow-sm active:scale-95 transition" title="Afficher / masquer la demi-droite">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M4 14H18" />
          <path d="M18 14l-3-3" />
          <path d="M18 14l-3 3" />
          <path d="M4 10v8" />
        </svg>
      </button>

      <div class="h-8 w-px bg-slate-200 mx-1"></div>

      <button id="btn-zoom-out" class="bg-slate-100 hover:bg-slate-200 text-slate-800 px-3 py-2 rounded-lg border border-slate-200 font-bold active:scale-95 transition" title="Zoom -">−</button>
      <button id="btn-zoom-in" class="bg-slate-100 hover:bg-slate-200 text-slate-800 px-3 py-2 rounded-lg border border-slate-200 font-bold active:scale-95 transition" title="Zoom +">+</button>
      <button id="btn-reset-view" class="bg-slate-100 hover:bg-slate-200 text-slate-800 px-3 py-2 rounded-lg border border-slate-200 font-bold active:scale-95 transition" title="Recentrer">⤾</button>
    </div>

    <!-- Actions sélection -->
    <div id="selection-actions" class="flex items-center gap-2">
      <button id="btn-flip" disabled class="bg-amber-500 hover:bg-amber-600 disabled:bg-amber-200 text-white px-2 py-1 rounded-lg shadow-sm border border-amber-200 disabled:opacity-40 disabled:cursor-not-allowed active:scale-95 transition flex flex-col items-center gap-0.5" title="Retourner">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M3 12a9 9 0 0 1 9-9"/>
          <path d="M3 4v8h8"/>
          <path d="M21 12a9 9 0 0 1-9 9"/>
          <path d="M21 20v-8h-8"/>
        </svg>
        <span class="text-[10px] font-extrabold leading-none">Retourner</span>
      </button>

      <button id="btn-separate" disabled class="bg-blue-600 hover:bg-blue-700 disabled:bg-blue-200 text-white px-2 py-1 rounded-lg shadow-sm border border-blue-200 disabled:opacity-40 disabled:cursor-not-allowed active:scale-95 transition flex flex-col items-center gap-0.5" title="Séparer">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M4 4l16 16"/>
          <path d="M4 20L20 4"/>
        </svg>
        <span class="text-[10px] font-extrabold leading-none">Séparer</span>
      </button>

      <button id="btn-cut" disabled class="bg-slate-700 hover:bg-slate-800 disabled:bg-slate-200 text-white px-2 py-1 rounded-lg shadow-sm border border-slate-200 disabled:opacity-40 disabled:cursor-not-allowed active:scale-95 transition flex flex-col items-center gap-0.5" title="Couper">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="6" cy="6" r="2"/>
          <circle cx="6" cy="18" r="2"/>
          <path d="M20 4L8.12 15.88"/>
          <path d="M14.47 14.48L20 20"/>
          <path d="M8.12 8.12L12 12"/>
        </svg>
        <span class="text-[10px] font-extrabold leading-none">Couper</span>
      </button>

      <button id="btn-fuse" disabled class="bg-violet-600 hover:bg-violet-700 disabled:bg-violet-200 text-white px-2 py-1 rounded-lg shadow-sm border border-violet-200 disabled:opacity-40 disabled:cursor-not-allowed active:scale-95 transition flex flex-col items-center gap-0.5" title="Fusionner">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M10 13a5 5 0 0 1 0-7l1-1a5 5 0 0 1 7 7l-1 1"/>
          <path d="M14 11a5 5 0 0 1 0 7l-1 1a5 5 0 0 1-7-7l1-1"/>
        </svg>
        <span class="text-[10px] font-extrabold leading-none">Fusionner</span>
      </button>

      <button id="btn-duplicate" disabled class="bg-emerald-600 hover:bg-emerald-700 disabled:bg-emerald-200 text-white px-2 py-1 rounded-lg shadow-sm border border-emerald-200 disabled:opacity-40 disabled:cursor-not-allowed active:scale-95 transition flex flex-col items-center gap-0.5" title="Dupliquer">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <rect x="9" y="9" width="13" height="13" rx="2"/>
          <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
        </svg>
        <span class="text-[10px] font-extrabold leading-none">Dupliquer</span>
      </button>

      <button id="btn-delete" disabled class="bg-rose-600 hover:bg-rose-700 disabled:bg-rose-200 text-white px-2 py-1 rounded-lg shadow-sm border border-rose-200 disabled:opacity-40 disabled:cursor-not-allowed active:scale-95 transition flex flex-col items-center gap-0.5" title="Supprimer">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
        </svg>
        <span class="text-[10px] font-extrabold leading-none">Supprimer</span>
      </button>
    </div>

    <div class="flex items-center gap-1 bg-gray-100 p-1 rounded-lg">
      <button id="tool-hand" class="p-2 rounded bg-white shadow text-gray-700" title="Main">
        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 11.5V14m0-2.5v-6a1.5 1.5 0 113 0m-3 6a1.5 1.5 0 00-3 0v2a7.5 7.5 0 0015 0v-5a1.5 1.5 0 00-3 0m-6-3V11m0-5.5v-1a1.5 1.5 0 013 0v1m0 0V11m0-5.5a1.5 1.5 0 013 0v3m0 0V11"/>
        </svg>
      </button>

      <button id="tool-pen" class="p-2 rounded text-gray-700 hover:bg-white" title="Crayon">
        <svg class="w-5 h-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M12 20h9" />
          <path d="M16.5 3.5a2.1 2.1 0 0 1 3 3L8 18l-4 1 1-4 11.5-11.5z" />
        </svg>
      </button>

      <button id="btn-clear-drawing" class="p-2 rounded text-rose-500 hover:bg-rose-50" title="Effacer">
        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
        </svg>
      </button>
    </div>
  </header>

  <div class="flex flex-1 overflow-hidden relative">
    <aside class="w-[340px] bg-blue-50 border-r border-blue-200 flex flex-col py-4 gap-3 z-20 shadow-lg shrink-0 overflow-y-auto no-scrollbar">
      <div class="px-3"></div>
      <div id="palette" class="px-3 flex flex-col gap-3"></div>
      <div class="mt-2 px-3">
        <div class="text-[10px] font-bold text-slate-400 uppercase">Astuces</div>
        <ul class="text-[11px] text-slate-500 leading-snug list-disc ml-4 mt-1">
          <li>Double-clic sur une bande = retourner.</li>
          <li>Molette = zoom, glisser sur fond = déplacer le plateau.</li>
          <li>Crayon : clic gauche = écrire, clic droit sur une bande = la déplacer, clic droit sur le fond = déplacer le plateau.</li>
        </ul>
      </div>
    </aside>

    <main class="flex-1 relative overflow-hidden">
      <div id="board-container">
        <div id="board-world">
          <canvas id="drawing-canvas"></canvas>
          <div id="number-line" class="hidden"></div>
        </div>
      </div>
    </main>
  </div>

<script>
  const FRACTIONS = [
    { denom: 1,  name: 'Unité',     color: '#fff7e6', border: '#cbd5e1', text: '#111827' },
    { denom: 2,  name: 'Demi',      color: '#facc15', border: '#a16207', text: '#111827' },
    { denom: 3,  name: 'Tiers',     color: '#e9d5ff', border: '#7c3aed', text: '#111827' },
    { denom: 4,  name: 'Quart',     color: '#84cc16', border: '#3f6212', text: '#111827' },
    { denom: 5,  name: 'Cinquième', color: '#38bdf8', border: '#075985', text: '#0b1220' },
    { denom: 6,  name: 'Sixième',   color: '#f97316', border: '#9a3412', text: '#111827' },
    { denom: 8,  name: 'Huitième',  color: '#f472b6', border: '#be185d', text: '#111827' },
    { denom: 10, name: 'Dixième',   color: '#b91c1c', border: '#7f1d1d', text: '#111827' },
  ];

  let audioCtx = null;
  try{ audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }catch(_){ audioCtx = null; }

  function playSound(type){
    if (!audioCtx) return;
    if (audioCtx.state === 'suspended') audioCtx.resume().catch(()=>{});
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain); gain.connect(audioCtx.destination);
    const now = audioCtx.currentTime;
    const stop = (t)=>{ try{ osc.stop(t); }catch(_){} };
    if(type==='pop'){
      osc.type='sine';
      osc.frequency.setValueAtTime(320, now);
      osc.frequency.exponentialRampToValueAtTime(560, now+0.08);
      gain.gain.setValueAtTime(0.10, now);
      gain.gain.linearRampToValueAtTime(0, now+0.10);
      osc.start(now); stop(now+0.10);
    } else if(type==='flip'){
      osc.type='triangle';
      osc.frequency.setValueAtTime(210, now);
      osc.frequency.linearRampToValueAtTime(440, now+0.16);
      gain.gain.setValueAtTime(0.10, now);
      gain.gain.linearRampToValueAtTime(0, now+0.18);
      osc.start(now); stop(now+0.18);
    } else if(type==='whoosh'){
      osc.type='triangle';
      osc.frequency.setValueAtTime(360, now);
      osc.frequency.exponentialRampToValueAtTime(60, now+0.22);
      gain.gain.setValueAtTime(0.06, now);
      gain.gain.linearRampToValueAtTime(0, now+0.22);
      osc.start(now); stop(now+0.22);
    }
  }

  class FractionStripsApp {
    constructor(){
      this.history = [];
      this.tokens = []; 
      this.nextId = 1;
      this.selectedId = null;
      this.labelMode = 'numeric'; // 'numeric' | 'text'

      this.scale = 1;
      this.pan = {x: 0, y: 0};
      this.isPanning = false;
      this.panStart = {x:0, y:0};

      this.currentTool = 'hand';
      this.isDrawing = false;
      this.drawPoints = [];
      this.basePenPx = 2.55;

      this.spawnDrag = null;
      this._lastSpawnClient = {x:0, y:0};

      this.boardContainer = document.getElementById('board-container');
      this.boardWorld = document.getElementById('board-world');
      this.palette = document.getElementById('palette');

      this.canvas = document.getElementById('drawing-canvas');
      this.ctx = this.canvas.getContext('2d');

      this.numberLineEl = document.getElementById('number-line');
      this.numberLine = {
        active: false,
        x: 0, y: 0,
        len: Math.max(this.unitW * 10.0, 6000),
        baselineOffset: 18,
        height: 46
      };

      this.DENOM_SET = new Set(FRACTIONS.map(f => f.denom));

      this.buildPalette();
      this.initUI();
      this.initBoardListeners();
      this.resizeCanvas();
      this.updateTransform();
      this.updateSelectionUI();
      this.updateNumberLineEl();
    }

    get unitW(){ return parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--unitW')) || 420; }
    get stripH(){ return parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--stripH')) || 58; }
    pieceW(denom){ return this.unitW / denom; }

    tokenDims(t){
      return {
        w: (t.kind === 'band') ? this.unitW : this.pieceW(t.denom),
        h: this.stripH,
      };
    }

    roundPos(v){
      return Math.round(v * 2) / 2;
    }

    saveState(){
      const snapshot = {
        tokens: this.tokens.map(t => ({id:t.id, denom:t.denom, kind:t.kind, side:t.side, x:t.x, y:t.y})),
        nextId: this.nextId,
        selectedId: this.selectedId,
        pan: {...this.pan},
        scale: this.scale,
        labelMode: this.labelMode
      };
      this.history.push(snapshot);
      if(this.history.length > 30) this.history.shift();
    }

    undo(){
      const snap = this.history.pop();
      if(!snap) return;
      this.clearAllTokens(false);
      this.tokens = snap.tokens.map(t => ({...t}));
      this.nextId = snap.nextId;
      this.selectedId = snap.selectedId;
      this.pan = snap.pan;
      this.scale = snap.scale;
      this.labelMode = snap.labelMode || 'numeric';
      this.updateToggleBtnUI();
      this.tokens.forEach(t => this.mountToken(t));
      this.updateTransform();
      this.updateSelectionUI();
      playSound('whoosh');
    }

    // --- Texte / Labels ---
    getTextLabel(denom){
      const map = {
        1: 'une unité',
        2: 'un demi',
        3: 'un tiers',
        4: 'un quart',
        5: 'un cinquième',
        6: 'un sixième',
        8: 'un huitième',
        10: 'un dixième'
      };
      return map[denom] || '';
    }

    isRotatedText(denom){
      return (denom >= 5 && denom !== 7 && denom !== 9); 
    }

    getLabelHTML(denom, isBackOfBand = false){
      // 1. Cas "Dos d'une bande complète" (ex: 2/2 retournée)
      if(isBackOfBand){
        if(this.labelMode === 'text'){
          // "une unité", horizontal
          return `<span class="text-label" style="font-size:18px;">une unité</span>`;
        } else {
          // "1", gros
          return `<span class="back-one">1</span>`;
        }
      }

      // 2. Cas normal (recto ou pièce détachée)
      if(this.labelMode === 'text'){
        const txt = this.getTextLabel(denom);
        const rotated = this.isRotatedText(denom);
        
        // CORRECTION TAILLE DE POLICE
        // "un cinquième" et "un dixième" (5 et 10) réduits un peu plus
        let fs;
        if(rotated){
           if(denom === 5 || denom === 10) fs = '10px'; // Réduit pour 5 et 10
           else fs = '12px';
        } else {
           // Horizontal
           fs = (denom >= 5) ? '13px' : '15px';
        }

        const cls = rotated ? 'text-label text-rotated' : 'text-label';
        return `<span class="${cls}" style="font-size:${fs};">${txt}</span>`;
      } else {
        // Mode numérique (1/2)
        if(denom === 1) return `<span class="back-one">1</span>`;
        return `<span class="frac"><span class="num">1</span><span class="bar"></span><span class="den">${denom}</span></span>`;
      }
    }

    fontSizeFor(denom, kind){
      // Utilisé pour la taille du conteneur de police, ajustement fin
      if(this.labelMode === 'text') return 16;
      if(kind === 'piece'){
        if(denom >= 10) return 14;
        if(denom >= 8) return 15;
        if(denom >= 6) return 16;
        return 17;
      }
      if(denom >= 10) return 15;
      if(denom >= 8) return 16;
      if(denom >= 6) return 17;
      return 18;
    }

    // --- Palette ---
    buildPalette(){
      this.palette.innerHTML = '';
      FRACTIONS.forEach(f => {
        // Conteneur de la ligne (Label + Bandes)
        const row = document.createElement('div');
        row.className = 'palette-item flex flex-col'; // flex-col pour empiler le label et les tuiles

        // Label au-dessus (invisible par défaut via CSS .palette-label)
        const label = document.createElement('div');
        // On ajoute la classe palette-label
        label.className = 'palette-label text-xs font-bold text-slate-500 mb-1 ml-1 capitalize';
        
        let text = f.name;
        // Pluriel simple si dénominateur > 1
        if(f.denom > 1 && !text.endsWith('s')) text += 's';
        
        label.textContent = text;
        row.appendChild(label);

        // Conteneur des tuiles
        const picks = document.createElement('div');
        picks.className = 'flex items-center gap-3 flex-nowrap';
        picks.appendChild(this.makeSpawnTile(f.denom, 'band'));
        if(f.denom !== 1) picks.appendChild(this.makeSpawnTile(f.denom, 'piece'));

        row.appendChild(picks);
        this.palette.appendChild(row);
      });
    }

    getFractionConfig(denom){
      return FRACTIONS.find(f => f.denom === denom) || FRACTIONS[0];
    }

    makeSpawnTile(denom, kind){
      const cfg = this.getFractionConfig(denom);
      const tile = document.createElement('div');
      tile.className = `spawn-tile ${kind==='band' ? 'spawn-band' : 'spawn-piece'}`;
      tile.style.background = cfg.color;
      tile.style.borderColor = cfg.border;
      tile.setAttribute('draggable', 'false');
      tile.title = (kind === 'band') ? 'Ajouter une bande' : 'Ajouter une pièce';
      const menuBandW = 170;
      const w = (kind === 'band') ? menuBandW : Math.max(18, Math.round(menuBandW / denom));
      tile.style.width = w + 'px';
      const fsMenu = (denom >= 10) ? 9 : (denom >= 8) ? 10 : (denom >= 6) ? 11 : 12;
      const segCount = (kind === 'band') ? denom : 1;
      for(let i=0;i<segCount;i++){
        const seg = document.createElement('div');
        seg.className = 'spawn-seg';
        seg.style.color = cfg.text;
        seg.style.fontSize = fsMenu + 'px';
        
        // Dans le menu, on garde l'affichage numérique classique (plus compact)
        if(denom === 1){
          seg.innerHTML = `<span class="back-one" style="font-size:${Math.max(fsMenu,12)}px;color:${cfg.text}">1</span>`;
        } else {
          seg.innerHTML = `<span class="frac menu" style="color:${cfg.text};font-size:${fsMenu}px"><span class="num">1</span><span class="bar"></span><span class="den">${denom}</span></span>`;
        }
        tile.appendChild(seg);
      }
      const start = (e) => this.startSpawnDrag(e, denom, kind);
      tile.addEventListener('mousedown', start);
      tile.addEventListener('touchstart', start, {passive:false});
      return tile;
    }

    buildGhostStrip(denom, kind, side){
      const cfg = this.getFractionConfig(denom);
      const el = document.createElement('div');
      el.className = 'strip ghost';
      el.style.background = cfg.color;
      el.style.borderColor = cfg.border;
      const segCount = (side === 'back') ? 1 : ((kind === 'band') ? denom : 1);
      const fs = this.fontSizeFor(denom, kind) * this.scale;
      for(let i=0;i<segCount;i++){
        const seg = document.createElement('div');
        seg.className = 'seg';
        seg.style.color = cfg.text;
        seg.style.fontSize = `${fs}px`;
        
        // Ghost suit le mode actuel
        if(side === 'front'){
          seg.innerHTML = this.getLabelHTML(denom, false);
        } else {
          // Back ghost
          const isBandBack = (kind === 'band' || denom === 1);
          seg.innerHTML = this.getLabelHTML(denom, isBandBack);
        }
        el.appendChild(seg);
      }
      return el;
    }

    startSpawnDrag(e, denom, kind){
      if(e.type === 'mousedown' && e.button !== 0) return;
      e.preventDefault();
      e.stopPropagation();
      const pt = e.touches ? e.touches[0] : e;
      const cx = pt.clientX;
      const cy = pt.clientY;
      this._lastSpawnClient = {x: cx, y: cy};
      const wWorld = (kind === 'band') ? this.unitW : this.pieceW(denom);
      const hWorld = this.stripH;
      const w = wWorld * this.scale;
      const h = hWorld * this.scale;
      const ghost = this.buildGhostStrip(denom, kind, 'front');
      ghost.style.width = `${w}px`;
      ghost.style.height = `${h}px`;
      ghost.style.left = `${cx - w/2}px`;
      ghost.style.top  = `${cy - h/2}px`;
      document.body.appendChild(ghost);
      requestAnimationFrame(() => ghost.classList.add('ready'));
      this.spawnDrag = { denom, kind, start: {x: cx, y: cy}, moved: false, ghost, w, h };
      const move = (ev) => this.onSpawnMove(ev);
      const end  = (ev) => this.onSpawnEnd(ev, move, end);
      document.addEventListener('mousemove', move);
      document.addEventListener('mouseup', end);
      document.addEventListener('touchmove', move, {passive:false});
      document.addEventListener('touchend', end);
      document.addEventListener('touchcancel', end);
    }

    onSpawnMove(ev){
      const sd = this.spawnDrag;
      if(!sd) return;
      ev.preventDefault();
      const pt = ev.touches ? ev.touches[0] : ev;
      const cx = pt.clientX;
      const cy = pt.clientY;
      this._lastSpawnClient = {x: cx, y: cy};
      const dist = Math.hypot(cx - sd.start.x, cy - sd.start.y);
      if(dist > 6) sd.moved = true;
      sd.ghost.style.left = `${cx - sd.w/2}px`;
      sd.ghost.style.top  = `${cy - sd.h/2}px`;
    }

    onSpawnEnd(ev, moveFn, endFn){
      const sd = this.spawnDrag;
      if(!sd) return;
      document.removeEventListener('mousemove', moveFn);
      document.removeEventListener('mouseup', endFn);
      document.removeEventListener('touchmove', moveFn);
      document.removeEventListener('touchend', endFn);
      document.removeEventListener('touchcancel', endFn);
      const cx = (ev.changedTouches && ev.changedTouches[0]) ? ev.changedTouches[0].clientX : this._lastSpawnClient.x;
      const cy = (ev.changedTouches && ev.changedTouches[0]) ? ev.changedTouches[0].clientY : this._lastSpawnClient.y;
      const br = this.boardContainer.getBoundingClientRect();
      const insideBoard = (cx >= br.left && cx <= br.right && cy >= br.top && cy <= br.bottom);
      if(insideBoard){
        const p = this.getWorldPos(cx, cy);
        const created = this.addToken({denom: sd.denom, kind: sd.kind, x: p.x, y: p.y});
        this.snapToken(created, {silent:true});
      } else if(!sd.moved){
        const center = this.getWorldPos(br.left + br.width*0.5, br.top + br.height*0.35);
        this.addToken({denom: sd.denom, kind: sd.kind, x: center.x, y: center.y});
      }
      if(sd.ghost) sd.ghost.remove();
      this.spawnDrag = null;
    }

    updateTransform(){
      this.boardWorld.style.transform = `translate(${this.pan.x}px, ${this.pan.y}px) scale(${this.scale})`;
    }

    zoomAt(clientX, clientY, newScale){
      const oldScale = this.scale;
      const z = Math.min(Math.max(0.45, newScale), 3);
      if(z === oldScale) return;
      const r = this.boardContainer.getBoundingClientRect();
      const wx = (clientX - r.left - this.pan.x) / oldScale;
      const wy = (clientY - r.top  - this.pan.y) / oldScale;
      this.scale = z;
      this.pan.x = clientX - r.left - wx * this.scale;
      this.pan.y = clientY - r.top  - wy * this.scale;
      this.updateTransform();
    }

    setZoom(z){
      const br = this.boardContainer.getBoundingClientRect();
      this.zoomAt(br.left + br.width/2, br.top + br.height/2, z);
    }

    resetView(){
      this.pan = {x:0, y:0};
      this.scale = 1;
      this.updateTransform();
    }

    toggleNumberLine(){
      this.numberLine.active = !this.numberLine.active;
      if(this.numberLine.active){
        const br = this.boardContainer.getBoundingClientRect();
        const p = this.getWorldPos(br.left + 120, br.top + br.height * 0.72);
        this.numberLine.x = p.x;
        this.numberLine.y = p.y;
        playSound('pop');
      } else {
        playSound('whoosh');
      }
      this.updateNumberLineEl();
    }

    updateNumberLineEl(){
      if(!this.numberLineEl) return;
      if(!this.numberLine.active){
        this.numberLineEl.classList.add('hidden');
        this.numberLineEl.innerHTML = '';
        return;
      }
      const nl = this.numberLine;
      const len = Math.round(nl.len);
      const base = nl.baselineOffset;
      const H = nl.height;
      this.numberLineEl.style.left = `${nl.x}px`;
      this.numberLineEl.style.top  = `${nl.y - base}px`;
      const arrowX = len;
      const a = 12;
      const y = base;
      this.numberLineEl.classList.remove('hidden');
      this.numberLineEl.innerHTML = `
        <svg width="${len}" height="${H}" viewBox="0 0 ${len} ${H}" xmlns="http://www.w3.org/2000/svg">
          <line x1="0" y1="${y}" x2="${len}" y2="${y}" stroke="rgba(17,24,39,0.9)" stroke-width="2" stroke-linecap="round" />
          <line x1="0" y1="${y-10}" x2="0" y2="${y+10}" stroke="rgba(17,24,39,0.9)" stroke-width="2" stroke-linecap="round" />
          <polygon points="${arrowX},${y} ${arrowX-a},${y-a*0.7} ${arrowX-a},${y+a*0.7}" fill="rgba(17,24,39,0.9)" />
          <text x="2" y="${y+20}" font-size="18" font-family="Fredoka, sans-serif" font-weight="800" fill="#111827">0</text>
        </svg>
      `;
    }

    getWorldPos(clientX, clientY){
      const r = this.boardContainer.getBoundingClientRect();
      return {
        x: (clientX - r.left - this.pan.x) / this.scale,
        y: (clientY - r.top - this.pan.y) / this.scale,
      };
    }

    _bind(id, evt, fn){
      const el = document.getElementById(id);
      if(!el) return null;
      el.addEventListener(evt, fn);
      return el;
    }

    initUI(){
      this._bind('btn-undo','click', () => this.undo());
      this._bind('btn-clear','click', () => this.resetAll());
      // Plus d'export PNG ici
      
      this._bind('btn-toggle-labels','click', () => this.toggleLabelMode());

      this._bind('btn-numberline','click', () => this.toggleNumberLine());
      this._bind('btn-zoom-in','click', () => this.setZoom(this.scale + 0.15));
      this._bind('btn-zoom-out','click', () => this.setZoom(this.scale - 0.15));
      this._bind('btn-reset-view','click', () => this.resetView());
      this._bind('btn-flip','click', () => this.flipSelected());
      this._bind('btn-separate','click', () => this.separateSelected());
      this._bind('btn-cut','click', () => this.cutSelected());
      this._bind('btn-fuse','click', () => this.fuseSelected());
      this._bind('btn-duplicate','click', () => this.duplicateSelected());
      this._bind('btn-delete','click', () => this.deleteSelected());
      this._bind('tool-hand','click', () => this.setTool('hand'));
      this._bind('tool-pen','click', () => this.setTool('pen'));
      this._bind('btn-clear-drawing','click', () => this.clearDrawing());
      window.addEventListener('keydown', (e) => {
        if(e.key === 'Escape') this.selectToken(null);
        if((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') { e.preventDefault(); this.undo(); }
        if(e.key === 'Delete' || e.key === 'Backspace') this.deleteSelected();
      });
    }

    toggleLabelMode(){
      this.labelMode = (this.labelMode === 'numeric') ? 'text' : 'numeric';
      document.body.classList.toggle('show-text-labels', this.labelMode === 'text');
      this.updateToggleBtnUI();
      const selId = this.selectedId;
      this.tokens.forEach(t => { if(t._el) t._el.remove(); });
      this.tokens.forEach(t => this.mountToken(t));
      if(selId) this.selectToken(selId);
      playSound('pop');
    }

    updateToggleBtnUI(){
      const numSpan = document.getElementById('label-icon-num');
      const txtSpan = document.getElementById('label-icon-txt');
      if(!numSpan || !txtSpan) return;
      if(this.labelMode === 'numeric'){
        numSpan.style.opacity = '1';
        txtSpan.style.opacity = '0.4';
      } else {
        numSpan.style.opacity = '0.4';
        txtSpan.style.opacity = '1';
      }
    }

    updateSelectionUI(){
      const btnFlip = document.getElementById('btn-flip');
      const btnSep  = document.getElementById('btn-separate');
      const btnCut  = document.getElementById('btn-cut');
      const btnFuse = document.getElementById('btn-fuse');
      const btnDup  = document.getElementById('btn-duplicate');
      const btnDel  = document.getElementById('btn-delete');
      const s = this.selected;
      const has = !!s;
      if(btnFlip) btnFlip.disabled = !has;
      if(btnDup)  btnDup.disabled  = !has;
      if(btnDel)  btnDel.disabled  = !has;
      if(btnSep)  btnSep.disabled  = !(has && s.kind === 'band'  && s.denom > 1);
      if(btnFuse) btnFuse.disabled = !(has && s.kind === 'piece' && s.denom > 1);
      if(btnCut)  btnCut.disabled  = !(has && this.canCut(s));
    }

    initBoardListeners(){
      this.boardContainer.addEventListener('wheel', (e) => {
        e.preventDefault();
        const dir = (e.deltaY > 0) ? -1 : 1;
        const step = 0.12;
        this.zoomAt(e.clientX, e.clientY, this.scale + dir * step);
      }, {passive:false});
      this.boardContainer.addEventListener('contextmenu', (e) => {
        if(this.currentTool === 'pen') e.preventDefault();
      });
      this.boardContainer.addEventListener('mousedown', (e) => {
        const isPen  = (this.currentTool === 'pen');
        const wantsPan = (!isPen && e.button === 0) || (isPen && e.button === 2);
        if(!wantsPan) return;
        if(e.target.closest('.strip')) return;
        this.isPanning = true;
        this.panStart = {x: e.clientX - this.pan.x, y: e.clientY - this.pan.y};
        this.boardContainer.classList.add('panning');
        if(!isPen) this.selectToken(null);
      });
      this.boardContainer.addEventListener('mousedown', (e) => {
        if(this.currentTool === 'pen' && e.button === 0) this.startDraw(e);
      });
      window.addEventListener('mousemove', (e) => {
        if(this.isPanning){
          this.pan.x = e.clientX - this.panStart.x;
          this.pan.y = e.clientY - this.panStart.y;
          this.updateTransform();
        } else if(this.isDrawing && this.currentTool === 'pen'){
          this.draw(e);
        }
      });
      window.addEventListener('mouseup', () => {
        this.isPanning = false;
        if(this.isDrawing && this.currentTool === 'pen') this.endDraw();
        this.isDrawing = false;
        this.boardContainer.classList.remove('panning');
      });
      window.addEventListener('resize', () => this.resizeCanvas());
    }

    mountToken(token){
      const cfg = this.getFractionConfig(token.denom);
      const el = document.createElement('div');
      el.className = 'strip';
      el.dataset.id = String(token.id);
      const h = this.stripH;
      const w = (token.kind === 'band') ? this.unitW : this.pieceW(token.denom);
      el.style.width = `${w}px`;
      el.style.height = `${h}px`;
      el.style.left = `${token.x}px`;
      el.style.top = `${token.y}px`;
      el.style.background = cfg.color;
      el.style.zIndex = String(10 + token.id);
      
      // Pas de rotation 3D animée
      // On utilise simplement display:none pour switch
      if(token.side === 'back') el.classList.add('is-back');
      
      const inner = document.createElement('div');
      inner.className = 'strip-inner';
      
      const faceFront = document.createElement('div');
      faceFront.className = 'face face-front';
      const faceBack = document.createElement('div');
      faceBack.className = 'face face-back';
      
      // RECTO
      const segCountFront = (token.kind === 'band') ? token.denom : 1;
      for(let i=0;i<segCountFront;i++){
        const seg = document.createElement('div');
        seg.className = 'seg';
        seg.style.color = cfg.text;
        seg.style.fontSize = `${this.fontSizeFor(token.denom, token.kind)}px`;
        seg.innerHTML = this.getLabelHTML(token.denom, false);
        faceFront.appendChild(seg);
      }

      // VERSO
      // Une seule case pour le verso
      const backSeg = document.createElement('div');
      backSeg.className = 'seg';
      backSeg.style.color = cfg.text;
      
      const isBandBack = (token.kind === 'band' || token.denom === 1);
      backSeg.style.fontSize = `${this.fontSizeFor(isBandBack ? 1 : token.denom, isBandBack ? 'band' : 'piece')}px`;
      backSeg.innerHTML = this.getLabelHTML(token.denom, isBandBack);
      
      faceBack.appendChild(backSeg);
      
      inner.appendChild(faceFront);
      inner.appendChild(faceBack);
      el.appendChild(inner);

      el.addEventListener('mousedown', (e) => this.handleDragStart(e));
      el.addEventListener('touchstart', (e) => this.handleDragStart(e), {passive:false});
      el.addEventListener('click', (e) => {
        e.stopPropagation();
        this.selectToken(token.id);
      });
      el.addEventListener('dblclick', (e) => {
        e.stopPropagation();
        this.selectToken(token.id);
        this.flipSelected();
      });
      let lastTap = 0;
      el.addEventListener('touchend', (e) => {
        const now = Date.now();
        if(now - lastTap < 300){
          e.preventDefault();
          this.selectToken(token.id);
          this.flipSelected();
        }
        lastTap = now;
      });
      this.boardWorld.appendChild(el);
      token._el = el;
      if(token._new){
        el.classList.add('spawn-pop');
        el.addEventListener('animationend', () => el.classList.remove('spawn-pop'), {once:true});
        delete token._new;
      }
      this.refreshTokenSelectedClass(token.id);
      // CORRECTION: plus d'appel à updateSeamBorders ici, c'est géré par CSS
    }

    refreshTokenSelectedClass(id){
      this.tokens.forEach(t => {
        if(!t._el) return;
        t._el.classList.toggle('selected', t.id === id);
      });
    }

    addToken({denom, kind, x=null, y=null}){
      this.saveState();
      playSound('pop');
      const pos = (x===null || y===null) ? {x: 40 + Math.random()*40, y: 40 + Math.random()*30} : {x, y};
      const w = (kind === 'band') ? this.unitW : this.pieceW(denom);
      const h = this.stripH;
      // FIXE: Définition de rawX et rawY avant utilisation
      const rawX = pos.x - w/2;
      const rawY = pos.y - h/2;
      
      const token = {
        id: this.nextId++,
        denom,
        kind,
        side: 'front',
        x: this.roundPos(rawX),
        y: this.roundPos(rawY),
        _new: true,
      };
      this.tokens.push(token);
      this.mountToken(token);
      this.selectToken(token.id);
      return token;
    }

    selectToken(id){
      this.selectedId = id;
      this.refreshTokenSelectedClass(id);
      this.updateSelectionUI();
    }

    get selected(){
      return this.tokens.find(t => t.id === this.selectedId) || null;
    }

    flipSelected(){
      const s = this.selected;
      if(!s) return;
      if(s.kind !== 'band') return;
      this.saveState();
      s.side = (s.side === 'front') ? 'back' : 'front';
      if(s._el){
        s._el.classList.toggle('is-back', s.side === 'back');
      }
      this.updateSelectionUI();
      playSound('flip');
    }

    duplicateSelected(){
      const s = this.selected;
      if(!s) return;
      this.saveState();
      const copy = {
        id: this.nextId++,
        denom: s.denom,
        kind: s.kind,
        side: s.side,
        x: s.x + 24,
        y: s.y + 24,
      };
      this.tokens.push(copy);
      this.mountToken(copy);
      this.selectToken(copy.id);
      playSound('pop');
    }

    deleteSelected(){
      const s = this.selected;
      if(!s) return;
      this.saveState();
      if(s._el) s._el.remove();
      this.tokens = this.tokens.filter(t => t.id !== s.id);
      this.selectToken(null);
      // CORRECTION: plus d'appel à updateSeamBorders
      playSound('whoosh');
    }

    separateSelected(){
      const s = this.selected;
      if(!s || s.kind !== 'band' || s.denom <= 1) return;
      this.saveState();
      const baseX = s.x;
      const baseY = s.y;
      const denom = s.denom;
      const side = s.side;
      if(s._el) s._el.remove();
      this.tokens = this.tokens.filter(t => t.id !== s.id);
      const pw = this.pieceW(denom);
      for(let i=0;i<denom;i++){
        const piece = { id: this.nextId++, denom, kind:'piece', side, x: baseX + i*pw, y: baseY };
        this.tokens.push(piece);
        this.mountToken(piece);
      }
      this.selectToken(this.tokens[this.tokens.length - denom].id);
      // CORRECTION: plus d'appel à updateSeamBorders
      playSound('pop');
    }

    fuseSelected(){
      const s = this.selected;
      if(!s || s.kind !== 'piece' || s.denom <= 1) return;
      const d = s.denom;
      const pw = this.pieceW(d);
      const yTol = 10;
      const xTol = 12;
      const rowPieces = this.tokens
        .filter(t => t.kind === 'piece' && t.denom === d && t.side === s.side && Math.abs(t.y - s.y) < yTol)
        .sort((a,b) => a.x - b.x);
      if(rowPieces.length < d){ playSound('whoosh'); return; }
      for(let start=0; start <= rowPieces.length - d; start++){
        const seq = rowPieces.slice(start, start + d);
        if(!seq.some(t => t.id === s.id)) continue;
        const baseX = seq[0].x;
        const baseY = seq[0].y;
        let ok = true;
        for(let i=0;i<d;i++){
          const expectedX = baseX + i * pw;
          if(Math.abs(seq[i].x - expectedX) > xTol) { ok = false; break; }
          if(Math.abs(seq[i].y - baseY) > yTol) { ok = false; break; }
        }
        if(!ok) continue;
        this.saveState();
        const ids = new Set(seq.map(t => t.id));
        seq.forEach(t => { if(t._el) t._el.remove(); });
        this.tokens = this.tokens.filter(t => !ids.has(t.id));
        const band = { id: this.nextId++, denom: d, kind:'band', side: s.side, x: baseX, y: baseY };
        this.tokens.push(band);
        this.mountToken(band);
        this.selectToken(band.id);
        playSound('pop');
        return;
      }
      playSound('whoosh');
    }

    canCut(t){
      if(!t) return false;
      if(t.denom <= 0) return false;
      const d2 = t.denom * 2;
      return this.DENOM_SET.has(d2);
    }

    cutSelected(){
      const s = this.selected;
      if(!s || !this.canCut(s)) return;
      const d = s.denom;
      const d2 = d * 2;
      const side = s.side;
      const x = s.x;
      const y = s.y;
      this.saveState();
      if(s._el) s._el.remove();
      this.tokens = this.tokens.filter(t => t.id !== s.id);
      if(s.kind === 'band'){
        const band = { id: this.nextId++, denom: d2, kind:'band', side, x, y };
        this.tokens.push(band);
        this.mountToken(band);
        this.selectToken(band.id);
      } else {
        const pw2 = this.pieceW(d2);
        const p1 = { id: this.nextId++, denom: d2, kind:'piece', side, x: x,      y };
        const p2 = { id: this.nextId++, denom: d2, kind:'piece', side, x: x+pw2,   y };
        this.tokens.push(p1, p2);
        this.mountToken(p1);
        this.mountToken(p2);
        this.selectToken(p1.id);
      }
      // CORRECTION: plus d'appel à updateSeamBorders
      playSound('pop');
    }

    handleDragStart(e){
      const isTouch = !!e.touches;
      const btn = isTouch ? 0 : (typeof e.button === 'number' ? e.button : 0);
      const allow =
        (this.currentTool === 'hand' && (isTouch || btn === 0)) ||
        (this.currentTool === 'pen' && !isTouch && btn === 2);
      if(!allow) return;
      e.preventDefault();
      e.stopPropagation();
      const el = e.target.closest('.strip');
      if(!el) return;
      const id = parseInt(el.dataset.id, 10);
      const token = this.tokens.find(t => t.id === id);
      if(!token) return;
      this.saveState();
      this.selectToken(token.id);
      token._el.classList.add('dragging');
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      const rect = token._el.getBoundingClientRect();
      const offset = { x: clientX - rect.left, y: clientY - rect.top };
      const move = (ev) => {
        ev.preventDefault();
        const cx = ev.touches ? ev.touches[0].clientX : ev.clientX;
        const cy = ev.touches ? ev.touches[0].clientY : ev.clientY;
        const br = this.boardContainer.getBoundingClientRect();
        const wx = (cx - br.left - this.pan.x - offset.x) / this.scale;
        let wy = (cy - br.top - this.pan.y - offset.y) / this.scale;
        const {h} = this.tokenDims(token);
        if(this.numberLine && this.numberLine.active){
          const lockThresh = 18 / this.scale;
          const dAbove = Math.abs((wy + h) - this.numberLine.y);
          const dBelow = Math.abs(wy - this.numberLine.y);
          const d = Math.min(dAbove, dBelow);
          if(d < lockThresh){
            wy = (dAbove <= dBelow) ? (this.numberLine.y - h) : this.numberLine.y;
          }
        }
        token.x = wx;
        token.y = wy;
        token._el.style.left = wx + 'px';
        token._el.style.top = wy + 'px';
      };
      const end = () => {
        document.removeEventListener('mousemove', move);
        document.removeEventListener('touchmove', move);
        document.removeEventListener('mouseup', end);
        document.removeEventListener('touchend', end);
        if(token._el) token._el.classList.remove('dragging');
        this.snapToken(token);
      };
      document.addEventListener('mousemove', move);
      document.addEventListener('touchmove', move, {passive:false});
      document.addEventListener('mouseup', end);
      document.addEventListener('touchend', end);
    }

    snapToken(t, opts={}){
      if(!t) return;
      const {w, h} = this.tokenDims(t);
      const threshPx = 28;
      const thresh = threshPx / this.scale;
      let bestX = null, bestDx = Infinity, bestXPrio = 9;
      let bestY = null, bestDy = Infinity, bestYPrio = 9;

      const considerX = (nx, prio=1) => {
        const adx = Math.abs(nx - t.x);
        if(adx <= thresh && (prio < bestXPrio || (prio === bestXPrio && adx < bestDx))){
          bestXPrio = prio;
          bestDx = adx;
          bestX = nx;
        }
      };
      const considerY = (ny, prio=1) => {
        const ady = Math.abs(ny - t.y);
        if(ady <= thresh && (prio < bestYPrio || (prio === bestYPrio && ady < bestDy))){
          bestYPrio = prio;
          bestDy = ady;
          bestY = ny;
        }
      };

      const overlapLen = (a0,a1,b0,b1)=> Math.min(a1,b1) - Math.max(a0,b0);
      const xLinesFor = (o) => {
        const {w:ow} = this.tokenDims(o);
        const ox = o.x;
        const lines = [];
        if(o.kind === 'band'){
          const step = ow / o.denom;
          for(let k=0;k<=o.denom;k++) lines.push(ox + k*step);
        } else {
          lines.push(ox, ox + ow);
        }
        return lines;
      };

      if(this.numberLine && this.numberLine.active){
        considerY(this.numberLine.y - h, 0);
        considerY(this.numberLine.y, 0);
        considerX(this.numberLine.x, 0);
      }

      for(const o of this.tokens){
        if(o.id === t.id) continue;
        const od = this.tokenDims(o);
        const ox = o.x, oy = o.y, ow = od.w, oh = od.h;
        const ovY = overlapLen(t.y, t.y + h, oy, oy + oh);
        const ovX = overlapLen(t.x, t.x + w, ox, ox + ow);
        const neighX = Math.min(Math.abs(t.x - (ox + ow)), Math.abs((t.x + w) - ox));
        const neighY = Math.min(Math.abs(t.y - (oy + oh)), Math.abs((t.y + h) - oy));
        const neighborX = neighX <= thresh;
        const neighborY = neighY <= thresh;
        const prioX = (ovY > Math.min(h, oh) * 0.35 || neighborY) ? 0 : 1;
        const prioY = (ovX > Math.min(w, ow) * 0.35 || neighborX) ? 0 : 1;
        considerY(oy, prioY);
        considerY(oy - h, prioY);
        considerY(oy + oh, prioY);
        const lines = xLinesFor(o);
        for(const gx of lines){
          considerX(gx, prioX);
          considerX(gx - w, prioX);
        }
        considerX(ox + ow, prioX);
        considerX(ox - w, prioX);
      }

      let snapped = false;
      if(bestX !== null){
        t.x = bestX;
        if(t._el) t._el.style.left = t.x + 'px';
        snapped = true;
      } else {
        const rx = this.roundPos(t.x);
        if(Math.abs(rx - t.x) > 0.001){
          t.x = rx;
          if(t._el) t._el.style.left = t.x + 'px';
        }
      }

      if(bestY !== null){
        t.y = bestY;
        if(t._el) t._el.style.top = t.y + 'px';
        snapped = true;
      } else {
        const ry = this.roundPos(t.y);
        if(Math.abs(ry - t.y) > 0.001){
          t.y = ry;
          if(t._el) t._el.style.top = t.y + 'px';
        }
      }

      if(snapped && !opts.silent) playSound('pop');
    }

    setTool(tool){
      this.currentTool = tool;
      const hand = document.getElementById('tool-hand');
      const pen  = document.getElementById('tool-pen');
      if(hand){ hand.classList.toggle('bg-white', tool==='hand'); hand.classList.toggle('shadow', tool==='hand'); }
      if(pen){  pen.classList.toggle('bg-white', tool==='pen');   pen.classList.toggle('shadow', tool==='pen'); }

      const penMode = (tool === 'pen');
      document.body.classList.toggle('pen-mode', penMode);
    }

    resizeCanvas(){
      const worldSize = 4000;
      const dpr = Math.min(2, window.devicePixelRatio || 1);
      this._canvasWorldSize = worldSize;
      this._canvasDpr = dpr;
      this.canvas.width = Math.round(worldSize * dpr);
      this.canvas.height = Math.round(worldSize * dpr);
      this.canvas.style.width = `${worldSize}px`;
      this.canvas.style.height = `${worldSize}px`;
      const offset = 2000;
      this.ctx.setTransform(dpr, 0, 0, dpr, offset * dpr, offset * dpr);
      this.ctx.lineCap = 'round';
      this.ctx.lineJoin = 'round';
      this.ctx.miterLimit = 2;
      this.ctx.strokeStyle = '#111827';
      this.ctx.imageSmoothingEnabled = true;
      this.ctx.globalCompositeOperation = 'source-over';
    }

    startDraw(e){
      this.isDrawing = true;
      this.drawPoints = [];
      const cx = e.touches ? e.touches[0].clientX : e.clientX;
      const cy = e.touches ? e.touches[0].clientY : e.clientY;
      const p = this.getWorldPos(cx, cy);
      this.ctx.lineWidth = Math.max(1.05, this.basePenPx / this.scale);
      this.drawPoints.push(p);
      this.ctx.beginPath();
      this.ctx.moveTo(p.x, p.y);
    }

    draw(e){
      e.preventDefault();
      const cx = e.touches ? e.touches[0].clientX : e.clientX;
      const cy = e.touches ? e.touches[0].clientY : e.clientY;
      const p = this.getWorldPos(cx, cy);
      this.ctx.lineWidth = Math.max(1.05, this.basePenPx / this.scale);
      const pts = this.drawPoints;
      pts.push(p);
      if(pts.length === 2){
        this.ctx.lineTo(p.x, p.y);
        this.ctx.stroke();
        return;
      }
      const p1 = pts[pts.length - 2];
      const p2 = pts[pts.length - 1];
      const midX = (p1.x + p2.x) / 2;
      const midY = (p1.y + p2.y) / 2;
      this.ctx.quadraticCurveTo(p1.x, p1.y, midX, midY);
      this.ctx.stroke();
    }

    endDraw(){
      const pts = this.drawPoints || [];
      if(!pts.length) return;
      const last = pts[pts.length - 1];
      this.ctx.lineTo(last.x, last.y);
      this.ctx.stroke();
      this.drawPoints = [];
    }

    clearDrawing(){
      this.ctx.save();
      this.ctx.setTransform(1, 0, 0, 1, 0, 0);
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      this.ctx.restore();
      const offset = 2000;
      const dpr = this._canvasDpr || 1;
      this.ctx.setTransform(dpr, 0, 0, dpr, offset * dpr, offset * dpr);
    }

    clearAllTokens(withHistory=true){
      if(withHistory) this.saveState();
      this.tokens.forEach(t => t._el && t._el.remove());
      this.tokens = [];
      this.selectedId = null;
      this.updateSelectionUI();
    }

    resetAll(){
      this.saveState();
      this.clearAllTokens(false);
      this.clearDrawing();
      this.resetView();
      playSound('whoosh');
    }
  }

  function runSelfTests(){
    const required = [
      'btn-undo','btn-clear','btn-toggle-labels','btn-numberline','btn-zoom-in','btn-zoom-out','btn-reset-view',
      'btn-flip','btn-separate','btn-cut','btn-fuse','btn-duplicate','btn-delete',
      'tool-hand','tool-pen','btn-clear-drawing',
      'board-container','board-world','palette','drawing-canvas','number-line'
    ];
    const missing = required.filter(id => !document.getElementById(id));
    if(missing.length){
      console.error('[SelfTest] IDs manquants:', missing);
      return { ok:false, missing };
    }
    try{
      const tmp = new FractionStripsApp();
      // On retire updateSeamBorders car cette méthode n'est plus utilisée (CSS ::after)
      const okMethods = ['addToken','snapToken','toggleNumberLine'].every(m => typeof tmp[m] === 'function');
      if(!okMethods) throw new Error('Méthodes clés manquantes');
      tmp.resetAll();
    }catch(err){
      console.error('[SelfTest] Erreur instanciation/app:', err);
      return { ok:false, missing:[], err };
    }
    console.log('[SelfTest] OK');
    return { ok:true, missing:[] };
  }

  window.addEventListener('DOMContentLoaded', () => {
    const t = runSelfTests();
    if(!t.ok) return;
    window.app = new FractionStripsApp();
    console.log('[SelfTest] App instanciée OK');
  });
</script>

</body>
</html>
