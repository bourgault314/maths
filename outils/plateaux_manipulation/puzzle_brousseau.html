<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Puzzle de Brousseau ‚Äî manipulation</title>
<style>
  :root{
    --bg:#ffffff;
    --grid:#e5e7eb;
    --ink:#0f172a;
    --stroke:#0f172a;
    --measure:#b91c1c;
    --toolbar:#ffffff;
    --border:#cbd5e1;
    --btn:#ffffff;
    --btnHover:#f1f5f9;
    --primaryBg:#e0f2fe;
    --primaryInk:#0369a1;
    --shadow: 0 2px 10px rgba(0,0,0,.06);
  }
  html,body{height:100%; margin:0;}
  body{
    font-family: "Segoe UI", system-ui, -apple-system, Arial, sans-serif;
    background: var(--bg);
    color: var(--ink);
    overflow:hidden;
  }
  .toolbar{
    height:64px;
    display:flex;
    align-items:center;
    justify-content:space-between;
    padding:0 14px;
    background:var(--toolbar);
    border-bottom:1px solid var(--border);
    box-shadow: var(--shadow);
    gap:10px;
  }
  .group{display:flex; align-items:center; gap:10px; flex-wrap:wrap;}
  .sep{width:1px; height:28px; background:var(--border); margin:0 2px;}
  .btn{
    border:1px solid var(--border);
    background:var(--btn);
    color:#334155;
    padding:9px 12px;
    border-radius:10px;
    font-weight:650;
    cursor:pointer;
    display:inline-flex;
    align-items:center;
    gap:6px;
    box-shadow: 0 1px 2px rgba(0,0,0,.05);
    user-select:none;
  }
  .btn:hover{background:var(--btnHover); border-color:#94a3b8;}
  .btn.primary{
    background:var(--primaryBg);
    color:var(--primaryInk);
    border-color:#bae6fd;
  }
  .btn.primary:hover{background:#bae6fd;}
  .btn.active{
    background:#3b82f6;
    color:white;
    border-color:#3b82f6;
  }
  .btn.wrong.active{background:#ef4444; border-color:#ef4444; color:white;}
  .btn.correct.active{background:#10b981; border-color:#10b981; color:white;}
  .seg{
    display:flex;
    background: rgba(148,163,184,.18);
    padding:3px;
    border-radius:12px;
    gap:3px;
  }
  .seg button{
    border:none;
    background:transparent;
    padding:8px 12px;
    border-radius:10px;
    cursor:pointer;
    font-weight:750;
    color:var(--ink);
    white-space:nowrap;
  }
  .seg button:hover{background:rgba(0,0,0,.04);}
  .seg button.active{
    background:#3b82f6;
    color:white;
  }
  .seg button.wrong.active{background:#ef4444;}
  .seg button.correct.active{background:#10b981;}
  .canvas{
    height: calc(100% - 64px);
    position:relative;
    background: var(--bg);
  }
  svg#stage{width:100%; height:100%; display:block;}
  .piece path{
    stroke: var(--stroke);
    stroke-width: 1.4;
    stroke-linejoin:round;
    vector-effect: non-scaling-stroke;
  }
  .piece:hover path{filter: brightness(0.98); stroke-width: 1.9;}
  .label{
    fill: var(--measure);
    font-weight:800;
    font-size: 14px;
    pointer-events:none;
    user-select:none;
    paint-order: stroke;
    stroke: rgba(255,255,255,.75);
    stroke-width: 3px;
  }
  .num{
    fill:#111827;
    font-weight:900;
    font-size: 18px;
    pointer-events:none;
    user-select:none;
    paint-order: stroke;
    stroke: rgba(255,255,255,.8);
    stroke-width: 3.5px;
  }
  .numRing{
    fill:#ffffff;
    stroke:#111827;
    stroke-width:2.2;
    vector-effect: non-scaling-stroke;
  }
  /* Modal √©nonc√© */
  .overlay{
    position:fixed; inset:0;
    background: rgba(255,255,255,.98);
    display:none;
    align-items:flex-start;
    justify-content:center;
    padding:18px;
    overflow:auto;
    z-index: 999;
  }
  .overlay.active{display:flex;}
  .paper{
    width: min(860px, 100%);
    background:white;
    border:1px solid #d1d5db;
    box-shadow: 0 12px 30px rgba(0,0,0,.12);
    padding:28px 30px;
    font-family: "Times New Roman", serif;
    color:#111827;
  }
  .paper h2{
    margin: 0 0 14px 0;
    text-align:center;
    text-transform: uppercase;
    letter-spacing:.04em;
    border-bottom:2px solid #111827;
    padding-bottom:10px;
  }
  .paper .topbar{
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:10px;
    margin-bottom:10px;
    font-family: "Segoe UI", system-ui, sans-serif;
  }
  .paper .close{
    border:none;
    background:transparent;
    font-size: 30px;
    cursor:pointer;
    color:#94a3b8;
    line-height:1;
  }
  .paper .close:hover{color:#ef4444;}
  .paper p{font-size: 1.08rem; line-height:1.55; margin: 14px 0;}
  .rule{
    border-left:4px solid var(--measure);
    padding-left:14px;
    margin: 12px 0 6px;
    color: var(--measure);
    font-weight: 800;
    font-family: "Segoe UI", system-ui, sans-serif;
  }
  .smallNote{font-family:"Segoe UI", system-ui, sans-serif; color:#475569; font-size:.92rem;}
  @media print{
    body{overflow:visible;}
    .toolbar, .canvas{display:none !important;}
    .overlay{display:block !important; position:static; background:white; padding:0;}
    .paper{box-shadow:none; border:none; padding:0;}
    .paper .topbar{display:none;}
    /* √©l√©ments utiles √† l'√©cran mais inutiles sur la feuille */
    .noPrint{display:none !important;}
  }

  /* Silhouette (r√©f√©rence) */
  .refOutline{
    fill:none;
    stroke:#000;
    stroke-width:2.2;
    vector-effect: non-scaling-stroke;
    stroke-linejoin:round;
  }
  #refLayer{ pointer-events:none; }

  /* Options professeur dans l'√©nonc√© */
  .optBox{
    margin-top:16px;
    padding:12px 14px;
    border:1px solid #e5e7eb;
    border-radius:12px;
    background:#f9fafb;
  }
  .optTitle{ font-weight:800; margin-bottom:8px; }
  .optLine{ display:block; margin-bottom:10px; }
  .optRow{ display:flex; gap:14px; flex-wrap:wrap; align-items:center; }
  .optRow select{ padding:6px 8px; border:1px solid #d1d5db; border-radius:10px; background:#fff; }
  .optRow input[type="range"]{ width:220px; vertical-align:middle; }
  .optHint{ margin-top:10px; color:#374151; font-size:.98rem; }
</style>
</head>
<body>

<div class="toolbar">
  <div class="group">
    <button class="btn" id="btnEnonce">üìÑ √ânonc√©</button>
    <button class="btn" id="btnFS">‚õ∂ Plein √©cran</button>
    <span class="sep"></span>

    <button class="btn active" id="mOrig" title="Affiche le puzzle original (assembl√©)">Original</button>
    <button class="btn" id="mAdd" title="Mode +3 cm : les pi√®ces s'√©cartent un peu pour voir les jonctions">+3 cm</button>

    <span class="sep"></span>

    <button class="btn" id="btnAgrandir">Agrandir 4‚Üí7</button>
    <button class="btn" id="btnReduire">R√©duire 5‚Üí4</button>

    <span class="sep"></span>

    <button class="btn" id="btnLong">Longueurs : OFF</button>
    <button class="btn" id="btnRef">R√©f√©rence : OFF</button>
  </div>

  <div class="group">
    <span class="sep"></span>
    <button class="btn" id="btnReset">R√©initialiser</button>
  </div>
</div>

<div class="canvas">
  <svg id="stage" xmlns="http://www.w3.org/2000/svg"></svg>
</div>

<!-- Modal √©nonc√© -->
<div id="overlay" class="overlay" aria-hidden="true">
  <div class="paper">
    <div class="topbar">
      <button class="btn" id="btnPrintInEnonce">üñ®Ô∏è Imprimer</button>
      <button class="close" id="closeOverlay" aria-label="Fermer">√ó</button>
    </div>
    <h2>AGRANDISSEMENT ET R√âDUCTION</h2>

    <h3 style="margin:18px 0 8px; font-size:1.28rem;">Le puzzle de Rousseau</h3>

    <div style="display:flex; gap:25px; align-items:flex-start; flex-wrap:wrap; margin: 12px 0 8px;">
      <div style="flex:0 0 auto;">
        <svg width="350" height="350" viewBox="0 0 420 420" style="border:1px solid #e5e7eb; background:#fff; display:block;">
          <g id="paperPuzzle" transform="translate(0,0)"></g>
        </svg>
      </div>

      <div style="flex:1 1 320px; font-size:1.08rem; line-height:1.55;">
        <p style="margin-top:0;">
          <strong>A) AGRANDISSEMENT :</strong> L‚Äôobjectif est de <strong>construire</strong> un agrandissement du puzzle, de telle mani√®re que le segment qui mesure 4&nbsp;cm sur le puzzle original mesure 7&nbsp;cm sur le puzzle agrandi.
        </p>
        <div class="rule">
          R√®gle : Le segment qui mesure 4&nbsp;cm sur le puzzle original mesure 7&nbsp;cm sur le puzzle agrandi.
        
        <div class="optBox noPrint">
          <div class="optTitle">Option professeur (comparaison d‚Äôangles)</div>
          <label class="optLine"><input type="checkbox" id="refToggle"> Afficher le puzzle original en silhouette sur la sc√®ne</label>
          <div class="optRow">
            <label>Position :
              <select id="refSide">
                <option value="left">√† gauche</option>
                <option value="right">√† droite</option>
              </select>
            </label>
            <label>Opacit√© :
              <input type="range" id="refOpacity" min="0.12" max="0.6" step="0.04" value="0.28">
            </label>
          </div>
          <div class="optHint">Astuce : prends une pi√®ce agrandie ou r√©duite et superpose-la sur la silhouette pour v√©rifier que les angles sont conserv√©s.</div>
        </div>

        </div>

        <p style="margin-top:26px;">
          <strong>B) R√âDUCTION :</strong> Le puzzle de Rousseau ci-contre doit √™tre r√©duit.
        </p>
        <div class="rule">
          R√®gle : Les segments qui mesurent 5&nbsp;cm sur le puzzle original mesurent 4&nbsp;cm sur le puzzle r√©duit.
        </div>
      </div>
    </div>

    <h3 style="margin:18px 0 8px; font-size:1.28rem;">Question</h3>

    <p style="margin-top:6px;">
      Comparez les <strong>angles</strong> du puzzle original avec ceux du puzzle agrandi, puis avec ceux du puzzle r√©duit.<br/>
      <strong>Que remarques-tu&nbsp;?</strong>
    </p>
  </div>
</div>

<script>
/* =========================
   Donn√©es (en cm) ‚Äî puzzle original
   Rep√®re : (0,0) en bas-gauche du carr√©
========================= */

const PIECES = [
  {
    id:"p1", fill:"#fca5a5",
    pts:[[0,0],[4,0],[4,9],[0,5]],
    num:{x:1.9,y:3.3, t:"1"},
    labels:[
      {x:2, y:-0.25, L:4, a:0},
      {x:-0.7, y:2.5, L:5, a:-90},
      {x:3.65, y:4.55, L:9, a:-90}
    ]
  },
  {
    id:"p2", fill:"#fdba74",
    pts:[[0,5],[4,9],[6,11],[0,11]],
    num:{x:2.1,y:8.4, t:"2"},
    labels:[
      {x:-0.7, y:8.0, L:6, a:-90},
      {x:3.0, y:11.35, L:6, a:0}
    ]
  },
  {
    id:"p3", fill:"#fcd34d",
    pts:[[6,11],[11,11],[11,9],[4,9]],
    num:{x:8.3,y:10.2, t:"3"},
    labels:[
      {x:8.5, y:11.35, L:5, a:0},
      {x:11.75, y:10.0, L:2, a:90},
      {x:7.45, y:9.25, L:7, a:0}
    ]
  },
  {
    id:"p4", fill:"#86efac",
    pts:[[4,0],[6,0],[6,7],[4,9]],
    num:{x:5.0,y:4.0, t:"4"},
    labels:[
      {x:5.0, y:-0.25, L:2, a:0},
      {x:6.35, y:3.6, L:7, a:-90}
    ]
  },
  {
    id:"p5", fill:"#93c5fd",
    pts:[[6,0],[11,0],[11,2],[6,7]],
    num:{x:8.6,y:2.7, t:"5"},
    labels:[
      {x:8.5, y:-0.25, L:5, a:0},
      {x:11.75, y:1.05, L:2, a:90}
    ]
  },
  {
    id:"p6", fill:"#c4b5fd",
    pts:[[4,9],[11,9],[11,2],[6,7]],
    num:{x:8.0,y:6.8, t:"6"},
    labels:[
      {x:11.75, y:5.55, L:7, a:90}
    ]
  }
];

const MEASURED_EDGE_BY_KEY = new Map();

function edgeKey(p, q){
  const a = `${p[0]},${p[1]}`;
  const b = `${q[0]},${q[1]}`;
  return (a < b) ? `${a}|${b}` : `${b}|${a}`;
}

function buildMeasuredEdges(){
  for(const piece of PIECES){
    const pts = piece.pts;
    const n = pts.length;
    piece._edgeKeys = new Array(n);
    piece._edgeInfoBase = new Array(n);
    for(let i=0;i<n;i++){
      const j = (i+1)%n;
      const p = pts[i], q = pts[j];
      const dx = q[0]-p[0];
      const dy = q[1]-p[1];
      piece._edgeKeys[i] = edgeKey(p,q);
      piece._edgeInfoBase[i] = {
        mx:(p[0]+q[0])/2,
        my:(p[1]+q[1])/2,
        dx, dy
      };
    }
  }

  for(const piece of PIECES){
    const edges = piece._edgeInfoBase;
    const n = edges.length;
    const labs = piece.labels || [];
    for(const lab of labs){
      const a = normRot(lab.a || 0);
      const wantH = (a === 0 || a === 180);
      const wantV = (a === 90 || a === 270);

      let bestI = -1;
      let bestD = 1e18;
      for(let i=0;i<n;i++){
        const e = edges[i];
        const isH = Math.abs(e.dy) < 1e-6 && Math.abs(e.dx) > 1e-6;
        const isV = Math.abs(e.dx) < 1e-6 && Math.abs(e.dy) > 1e-6;
        if(wantH && !isH) continue;
        if(wantV && !isV) continue;
        const d = Math.hypot((lab.x - e.mx), (lab.y - e.my));
        if(d < bestD){ bestD = d; bestI = i; }
      }

      if(bestI >= 0){
        lab._edgeIndex = bestI;
        const key = piece._edgeKeys[bestI];
        if(!MEASURED_EDGE_BY_KEY.has(key)){
          MEASURED_EDGE_BY_KEY.set(key, lab.L);
        }
      }
    }
  }

  for(const piece of PIECES){
    const n = piece._edgeKeys.length;
    piece._measuredEdges = new Set();
    piece._measuredL = new Array(n).fill(null);
    for(let i=0;i<n;i++){
      const key = piece._edgeKeys[i];
      if(MEASURED_EDGE_BY_KEY.has(key)){
        const L = MEASURED_EDGE_BY_KEY.get(key);
        piece._measuredEdges.add(i);
        piece._measuredL[i] = L;
      }
    }
  }
}


function buildJunctionEdges(){
  const EPS = 1e-9;

  // Reset + base lengths
  for(const piece of PIECES){
    const n = piece.pts.length;
    piece._junctionEdge = new Array(n).fill(false);
    piece._edgeLenBase  = new Array(n).fill(null);

    for(let i=0;i<n;i++){
      const j = (i+1)%n;
      const p = piece.pts[i];
      const q = piece.pts[j];
      const dx = q[0]-p[0];
      const dy = q[1]-p[1];
      piece._edgeLenBase[i] = Math.hypot(dx,dy);
    }
  }

  const edges = [];
  for(const piece of PIECES){
    const pts = piece.pts;
    const n = pts.length;
    for(let i=0;i<n;i++){
      const j = (i+1)%n;
      const p = pts[i];
      const q = pts[j];
      const dx = q[0]-p[0];
      const dy = q[1]-p[1];

      // On ne garde que les ar√™tes horizontales / verticales pour les jonctions
      if(Math.abs(dy) <= EPS){
        edges.push({piece, i, o:"h", c:p[1], a:Math.min(p[0],q[0]), b:Math.max(p[0],q[0])});
      }else if(Math.abs(dx) <= EPS){
        edges.push({piece, i, o:"v", c:p[0], a:Math.min(p[1],q[1]), b:Math.max(p[1],q[1])});
      }
    }
  }

  for(let i=0;i<edges.length;i++){
    for(let j=i+1;j<edges.length;j++){
      const e1 = edges[i], e2 = edges[j];
      if(e1.piece === e2.piece) continue;
      if(e1.o !== e2.o) continue;
      if(Math.abs(e1.c - e2.c) > EPS) continue;

      const overlap = Math.min(e1.b, e2.b) - Math.max(e1.a, e2.a);
      if(overlap > EPS){
        e1.piece._junctionEdge[e1.i] = true;
        e2.piece._junctionEdge[e2.i] = true;
      }
    }
  }
}



buildMeasuredEdges();
buildJunctionEdges();

let mode = "original";            // original | additive | multiplicative
let coeff = 1;
let viewScale = 1;
let showLengths = false;
let selectedId = null;

// +3 cm : √©clatement l√©ger (mode additif)
let addSnapshot = null;
let addTouched = false;

const stage = document.getElementById("stage");

let refLayer = null;
let piecesLayer = null;
let labelsLayer = null;

let showReference = false;       // silhouette du puzzle original
let referenceSide = "right";      // "left" | "right"
let referenceOpacity = 0.28;     // 0..1
let _pendingBaseShift = null;    // {tx,ty} base avant toggle R√©f√©rence
const REF_GAP_CM = 1.5;          // √©cart entre les 2 puzzles (en cm)

function ensureLayers(){
  if(refLayer && piecesLayer && labelsLayer) return;

  refLayer = document.createElementNS("http://www.w3.org/2000/svg","g");
  refLayer.setAttribute("id","refLayer");
  refLayer.style.pointerEvents = "none";

  piecesLayer = document.createElementNS("http://www.w3.org/2000/svg","g");
  piecesLayer.setAttribute("id","piecesLayer");

  labelsLayer = document.createElementNS("http://www.w3.org/2000/svg","g");
  labelsLayer.setAttribute("id","labelsLayer");
  labelsLayer.style.pointerEvents = "none";

  stage.appendChild(refLayer);
  stage.appendChild(piecesLayer);
  stage.appendChild(labelsLayer);
}

function centroidPolygon(pts){
  let A = 0, Cx = 0, Cy = 0;
  const n = pts.length;
  for(let i=0;i<n;i++){
    const [x0,y0] = pts[i];
    const [x1,y1] = pts[(i+1)%n];
    const cross = x0*y1 - x1*y0;
    A += cross;
    Cx += (x0 + x1) * cross;
    Cy += (y0 + y1) * cross;
  }
  A *= 0.5;
  if(Math.abs(A) < 1e-9){
    let x=0,y=0;
    for(const p of pts){ x+=p[0]; y+=p[1]; }
    return [x/pts.length, y/pts.length];
  }
  Cx /= (6*A);
  Cy /= (6*A);
  return [Cx, Cy];
}

let PX_PER_CM = 40;

function recomputePxPerCm(){
  const w = stage.clientWidth || stage.getBoundingClientRect().width || 1000;
  const h = stage.clientHeight || stage.getBoundingClientRect().height || 700;
  const margin = 80;
  const kMax = 7/4;
  const puzzleCm = 11;

  // Par d√©faut : on garantit que l'agrandissement max (√ó7/4) rentre √† l'√©cran.
  // Si la "r√©f√©rence" est activ√©e, on pr√©voit 2 puzzles c√¥te √† c√¥te (original + agrandi max).
  const gapCm = showReference ? REF_GAP_CM : 0;
  const widthNeed = showReference ? (puzzleCm * (kMax + 1) + gapCm) : (puzzleCm * kMax);

  let ppcm = Math.min(
    (w - 2*margin) / widthNeed,
    (h - 2*margin) / (puzzleCm * kMax)
  );

  if(!isFinite(ppcm) || ppcm <= 0) ppcm = 40;
  ppcm = Math.max(22, Math.min(72, ppcm));
  PX_PER_CM = ppcm;
}

function toPx(cm){ return cm * PX_PER_CM; }
function cmToStage(p){ return [toPx(p[0]), toPx(-p[1])]; }

function placeLabelConsistent(ptsCm, lx, ly, ang){
  const off = 0.22;
  const a = ang || 0;

  if(a === 0){
    const ys = Array.from(new Set(ptsCm.map(p=>p[1])));
    let best = ys[0], bestd = Infinity;
    for(const y of ys){
      const d = Math.abs(ly - y);
      if(d < bestd){ bestd = d; best = y; }
    }
    const sign = (ly >= best) ? 1 : -1;
    return [lx, best + sign*off];
  }

  if(Math.abs(a) === 90){
    const xs = Array.from(new Set(ptsCm.map(p=>p[0])));
    let best = xs[0], bestd = Infinity;
    for(const x of xs){
      const d = Math.abs(lx - x);
      if(d < bestd){ bestd = d; best = x; }
    }
    const sign = (lx >= best) ? 1 : -1;
    return [best + sign*off, ly];
  }

  return [lx, ly];
}


function buildLengthLabels(piece, ptsCm){
  const labs = [];
  const n = ptsCm.length;
  const declared = piece.labels || [];

  const off = 0.22 * ((mode==="multiplicative") ? coeff : 1);

  // Map declared labels by the matched edge index
  const declByEdge = new Map();
  for(const lab of declared){
    if(lab && typeof lab._edgeIndex === "number"){
      declByEdge.set(lab._edgeIndex, lab);
    }
  }

  const measuredL = piece._measuredL || [];
  const junction = piece._junctionEdge || [];
  const edgeLenBase = piece._edgeLenBase || [];

  for(let i=0;i<n;i++){
    const src = declByEdge.get(i);
    let L = measuredL[i];

    if(L == null && src && src.L != null) L = src.L;
    if(L == null && junction[i]) L = edgeLenBase[i];
    if(L == null) continue;

    const kind = src ? "decl" : "auto";

    const p = ptsCm[i];
    const q = ptsCm[(i+1)%n];
    const dx = q[0]-p[0];
    const dy = q[1]-p[1];

    // Deux normales possibles
    let nx1 = dy,  ny1 = -dx;
    let nx2 = -dy, ny2 = dx;
    const norm1 = Math.hypot(nx1,ny1) || 1;
    const norm2 = Math.hypot(nx2,ny2) || 1;
    nx1/=norm1; ny1/=norm1;
    nx2/=norm2; ny2/=norm2;

    const mx0 = (p[0]+q[0])/2;
    const my0 = (p[1]+q[1])/2;

    // Choisir le c√¥t√© voulu :
    // - si label d√©clar√© : m√™me c√¥t√© qu'avant (via position "historique")
    // - sinon : c√¥t√© ext√©rieur (loin du centro√Øde)
    let chooseNx = nx1, chooseNy = ny1;
    if(src){
      const rx = (mode==="multiplicative") ? ((src.x||0) * coeff) : (src.x||0);
      const ry = (mode==="multiplicative") ? ((src.y||0) * coeff) : (src.y||0);
      const vx = rx - mx0;
      const vy = ry - my0;
      const dot1 = vx*nx1 + vy*ny1;
      const dot2 = vx*nx2 + vy*ny2;
      chooseNx = (dot1 >= dot2) ? nx1 : nx2;
      chooseNy = (dot1 >= dot2) ? ny1 : ny2;
    }else{
      const [cx,cy] = centroidPolygon(ptsCm);
      const vx = cx - mx0;
      const vy = cy - my0;
      const dot1 = vx*nx1 + vy*ny1;
      const dot2 = vx*nx2 + vy*ny2;
      // vx,vy point inward: choose the normal that points outward (smaller dot)
      chooseNx = (dot1 <= dot2) ? nx1 : nx2;
      chooseNy = (dot1 <= dot2) ? ny1 : ny2;
    }

    let a = 0;
    if(src){
      a = src.a || 0;
    }else{
      a = (Math.abs(dy) > Math.abs(dx)) ? -90 : 0;
    }

    labs.push({
      x: mx0 + chooseNx*off,
      y: my0 + chooseNy*off,
      rot: normRot(a),
      L: L,
      edgeIndex: i,
      kind: kind
    });
  }

  return labs;
}

function buildAxisMapFromEdges(pts, axis, add){
  const n = pts.length;
  const nodes = new Set();
  const constraints = []; // [a,b,delta] : mapped(b) - mapped(a) = delta

  for(let i=0;i<n;i++){
    const [x1,y1] = pts[i];
    const [x2,y2] = pts[(i+1)%n];

    if(axis === "x"){
      nodes.add(x1); nodes.add(x2);
      if(Math.abs(y2 - y1) < 1e-9 && Math.abs(x2 - x1) > 1e-9){
        const baseLen = Math.abs(x2 - x1);
        const newLen  = baseLen + add;
        const sign    = (x2 > x1) ? 1 : -1;
        constraints.push([x1, x2, sign * newLen]);
      }
    }else{
      nodes.add(y1); nodes.add(y2);
      if(Math.abs(x2 - x1) < 1e-9 && Math.abs(y2 - y1) > 1e-9){
        const baseLen = Math.abs(y2 - y1);
        const newLen  = baseLen + add;
        const sign    = (y2 > y1) ? 1 : -1;
        constraints.push([y1, y2, sign * newLen]);
      }
    }
  }

  const nodeArr = [...nodes].sort((a,b)=>a-b);
  const adj = new Map();
  for(const v of nodeArr) adj.set(v, []);
  for(const [a,b,delta] of constraints){
    if(!adj.has(a)) adj.set(a, []);
    if(!adj.has(b)) adj.set(b, []);
    adj.get(a).push([b, delta]);
    adj.get(b).push([a, -delta]);
  }

  const anchor = nodeArr.length ? nodeArr[0] : 0;
  const map = new Map();
  map.set(anchor, anchor);

  const q = [anchor];
  while(q.length){
    const u = q.shift();
    const uVal = map.get(u);
    const neigh = adj.get(u) || [];
    for(const [v,delta] of neigh){
      const val = uVal + delta;
      if(!map.has(v)){
        map.set(v, val);
        q.push(v);
      }else{
        // Si conflit (rare ici), on garde la premi√®re valeur.
      }
    }
  }

  // Compl√®te les valeurs non contraintes (souvent des points sur des diagonales)
  const assigned = nodeArr.filter(v=>map.has(v));
  if(assigned.length === 1){
    const a = assigned[0];
    const aVal = map.get(a);
    for(const v of nodeArr){
      if(!map.has(v)) map.set(v, aVal + (v - a));
    }
  }else if(assigned.length >= 2){
    for(const v of nodeArr){
      if(map.has(v)) continue;

      let lo = null, hi = null;
      for(let i=0;i<assigned.length;i++){
        const vv = assigned[i];
        if(vv < v) lo = vv;
        if(vv > v){ hi = vv; break; }
      }
      if(lo === null){ lo = assigned[0]; hi = assigned[1]; }
      else if(hi === null){ hi = assigned[assigned.length-1]; lo = assigned[assigned.length-2]; }

      const denom = (hi - lo) || 1;
      const t = (v - lo) / denom;
      const out = map.get(lo) + t * (map.get(hi) - map.get(lo));
      map.set(v, out);
    }
  }

  return map;
}

function additivePointsFromBase(basePts, add){
  const xMap = buildAxisMapFromEdges(basePts, "x", add);
  const yMap = buildAxisMapFromEdges(basePts, "y", add);
  return basePts.map(([x,y])=>[
    xMap.has(x) ? xMap.get(x) : x,
    yMap.has(y) ? yMap.get(y) : y
  ]);
}

function pointsFor(piece){
  const base = piece.pts.map(p => [p[0], p[1]]);
  if(mode === "original") return base;

  if(mode === "additive"){
    const add = 3;
    return additivePointsFromBase(base, add);
  }

  if(mode === "multiplicative"){
    const k = coeff;
    return base.map(([x,y])=>[x*k, y*k]);
  }

  return base;
}

function clearStage(){
  stage.innerHTML = "";
  refLayer = null;
  piecesLayer = null;
  labelsLayer = null;
}

function lengthText(v){
  let s;
  if(Math.abs(v - Math.round(v)) < 1e-9){
    s = String(Math.round(v));
  }else{
    s = v.toFixed(2).replace(".",",");
    // trim trailing zeros (e.g. 2,50 -> 2,5 ; 2,00 -> 2)
    s = s.replace(/0+$/,"").replace(/,$/,"");
  }
  return s + " cm";
}

function labelValue(L){
  if(mode === "original") return L;
  if(mode === "additive") return L + 3;
  if(mode === "multiplicative") return L * coeff;
  return L;
}

function addPiece(piece, initial){
  ensureLayers();
  const g = document.createElementNS("http://www.w3.org/2000/svg","g");
  g.classList.add("piece");
  g.dataset.id = piece.id;
  g.style.cursor = "grab";

  const ptsCm = pointsFor(piece);
  const pts = ptsCm.map(cmToStage);

  let d = `M ${pts[0][0]} ${pts[0][1]}`;
  for(let i=1;i<pts.length;i++) d += ` L ${pts[i][0]} ${pts[i][1]}`;
  d += " Z";

  const path = document.createElementNS("http://www.w3.org/2000/svg","path");
  path.setAttribute("d", d);
  path.setAttribute("fill", piece.fill);
  g.appendChild(path);

  const [ccmX, ccmY] = centroidPolygon(ptsCm);
  const [cpx, cpy] = cmToStage([ccmX, ccmY]);
  g._cx = cpx;
  g._cy = cpy;

  g._verts = pts;

  g._snapLocal = pts.map(p=>[p[0],p[1]]);

  const ring = document.createElementNS("http://www.w3.org/2000/svg","circle");
  ring.setAttribute("cx", cpx);
  ring.setAttribute("cy", cpy);
  ring.setAttribute("r", 15);
  ring.setAttribute("class","numRing");
  g.appendChild(ring);

  const num = document.createElementNS("http://www.w3.org/2000/svg","text");
  num.setAttribute("x", cpx);
  num.setAttribute("y", cpy + 6);
  num.setAttribute("text-anchor","middle");
  num.setAttribute("class","num");
  num.textContent = piece.num.t;
  g.appendChild(num);

  const lg = document.createElementNS("http://www.w3.org/2000/svg","g");
  g._labels = lg;


  if(showLengths){
    const labs = buildLengthLabels(piece, ptsCm);
    for(const lab of labs){
      const labelValueCm = labelValue(lab.L);
      const [px,py] = cmToStage([lab.x, lab.y]);

      const t = document.createElementNS("http://www.w3.org/2000/svg","text");
      t.setAttribute("x", px);
      t.setAttribute("y", py);
      t.setAttribute("text-anchor","middle");
      t.setAttribute("class","label lenLabel");
      t.dataset.pieceId = piece.id;
      t.dataset.edgeIndex = String(lab.edgeIndex);
      t.dataset.kind = lab.kind;
      t.textContent = lengthText(labelValueCm);

      if(lab.rot){
        t.setAttribute("transform", `rotate(${lab.rot} ${px} ${py})`);
      }
      lg.appendChild(t);
    }
  }

  g._tx = initial.tx;
  g._ty = initial.ty;
  g._rot = initial.rot || 0;
  applyTransform(g);

  g.addEventListener("pointerdown", onPieceDown);
  piecesLayer.appendChild(g);
  labelsLayer.appendChild(lg);
}



let _labelsRAF = 0;

function updateLabelVisibility(){
  if(!showLengths) return;
  const labels = Array.from(document.querySelectorAll("text.lenLabel"));
  if(!labels.length) return;

  // default: show everything
  for(const t of labels){ t.style.display = ""; }

  // Build segment descriptors in stage coordinates
  const segs = [];
  for(const t of labels){
    const pid = t.dataset.pieceId;
    const ei = parseInt(t.dataset.edgeIndex, 10);
    if(!pid || !Number.isFinite(ei)) continue;

    const g = document.querySelector(`.piece[data-id="${pid}"]`);
    if(!g || !g._verts) continue;
    const n = g._verts.length;
    if(ei < 0 || ei >= n) continue;

    const v0 = g._verts[ei];
    const v1 = g._verts[(ei+1)%n];
    const p = transformedPoint(g, v0[0], v0[1]);
    const q = transformedPoint(g, v1[0], v1[1]);

    const dx = q.x - p.x;
    const dy = q.y - p.y;
    const absDx = Math.abs(dx);
    const absDy = Math.abs(dy);

    const o = (absDx >= absDy) ? "h" : "v";
    const c = (o==="h") ? ((p.y+q.y)/2) : ((p.x+q.x)/2);
    const a = (o==="h") ? Math.min(p.x,q.x) : Math.min(p.y,q.y);
    const b = (o==="h") ? Math.max(p.x,q.x) : Math.max(p.y,q.y);

    segs.push({
      t,
      pid,
      kind: t.dataset.kind || "auto",
      o, c, a, b
    });
  }

  const EPS = 1.0; // px tolerance

  // Compare segments that lie on the same line and overlap
  for(let i=0;i<segs.length;i++){
    for(let j=i+1;j<segs.length;j++){
      const s1 = segs[i], s2 = segs[j];
      if(s1.pid === s2.pid) continue;
      if(s1.o !== s2.o) continue;
      if(Math.abs(s1.c - s2.c) > EPS) continue;

      const overlap = Math.min(s1.b, s2.b) - Math.max(s1.a, s2.a);
      if(overlap <= EPS) continue;

      const sameEnds = (Math.abs(s1.a - s2.a) <= EPS && Math.abs(s1.b - s2.b) <= EPS);

      // 1) Segment identique : garder un seul label (priorit√© au d√©clar√©)
      if(sameEnds){
        if(s1.kind==="decl" && s2.kind!=="decl"){ s2.t.style.display="none"; continue; }
        if(s2.kind==="decl" && s1.kind!=="decl"){ s1.t.style.display="none"; continue; }
        if((s1.pid||"").localeCompare(s2.pid||"") <= 0) s2.t.style.display="none";
        else s1.t.style.display="none";
        continue;
      }

      // 2) Recouvrement partiel : ne pas afficher un label auto si √ßa recouvre un label d√©clar√©
      if(s1.kind==="decl" && s2.kind==="auto"){ s2.t.style.display="none"; continue; }
      if(s2.kind==="decl" && s1.kind==="auto"){ s1.t.style.display="none"; continue; }

      // 3) Deux labels auto : si l'un est contenu dans l'autre, masquer le plus petit
      const s1In2 = (s1.a >= s2.a - EPS && s1.b <= s2.b + EPS);
      const s2In1 = (s2.a >= s1.a - EPS && s2.b <= s1.b + EPS);
      if(s1In2 && !s2In1){ s1.t.style.display="none"; continue; }
      if(s2In1 && !s1In2){ s2.t.style.display="none"; continue; }

      // 4) Cas rare : recouvrement crois√© -> masquer le plus court (moins lisible)
      const len1 = s1.b - s1.a;
      const len2 = s2.b - s2.a;
      if(len1 < len2) s1.t.style.display="none";
      else s2.t.style.display="none";
    }
  }
}

function markLabelsDirty(){
  if(!showLengths) return;
  if(_labelsRAF) return;
  _labelsRAF = requestAnimationFrame(()=>{
    _labelsRAF = 0;
    updateLabelVisibility();
  });
}

function applyTransform(g){
  const id = g.dataset.id;
  const isSel = (id === selectedId);
  g.style.filter = isSel ? "drop-shadow(0 6px 10px rgba(0,0,0,.22))" : "none";
  const tf = `translate(${g._tx} ${g._ty}) rotate(${g._rot} ${g._cx} ${g._cy})`;
  g.setAttribute("transform", tf);
  if(g._labels){
    g._labels.setAttribute("transform", tf);
  }
  markLabelsDirty();
}

function normRot(r){
  return (((r % 360) + 360) % 360);
}
function getAllPieceEls(){
  return Array.from(document.querySelectorAll(".piece"));
}

function transformedPoint(g, x, y){
  const m = g.getCTM();
  return {x: m.a*x + m.c*y + m.e, y: m.b*x + m.d*y + m.f};
}
function transformedCenter(g){
  return transformedPoint(g, g._cx, g._cy);
}
function transformedVerts(g){
  const m = g.getCTM();
  const out = [];
  if(!g._verts) return out;
  for(const [x,y] of g._verts){
    out.push({x: m.a*x + m.c*y + m.e, y: m.b*x + m.d*y + m.f});
  }
  return out;
}

function transformedSnapPoints(g){
  const m = g.getCTM();
  if(!m) return [];
  const pts = g._snapLocal || [];
  const out = [];
  for(const [x,y] of pts){
    out.push({
      x: m.a*x + m.c*y + m.e,
      y: m.b*x + m.d*y + m.f
    });
  }
  return out;
}

function countAligned(ptsA, ptsB, eps){
  let c = 0;
  for(const p of ptsA){
    for(const q of ptsB){
      if(Math.hypot(q.x-p.x, q.y-p.y) <= eps){ c++; break; }
    }
  }
  return c;
}

function snapToOtherPieces(g, allowSameTxTy){
  const EPS = 10;
  const ptsG = transformedSnapPoints(g);
  if(ptsG.length === 0) return false;

  const others = getAllPieceEls().filter(h=>h!==g);

  let best = null;
  for(const h of others){
    const ptsH = transformedSnapPoints(h);
    if(ptsH.length === 0) continue;

    for(const pg of ptsG){
      for(const ph of ptsH){
        const dx = ph.x - pg.x;
        const dy = ph.y - pg.y;
        const d = Math.hypot(dx,dy);
        if(d <= EPS){
          if(!best || d < best.d){
            best = {d, dx, dy, h};
          }
        }
      }
    }
  }

  if(!best) return false;

  const testPts = ptsG.map(p => ({x:p.x + best.dx, y:p.y + best.dy}));
  const aligned = countAligned(testPts, transformedSnapPoints(best.h), EPS);

  if(aligned >= 2 || best.d <= 12){
    g._tx += best.dx;
    g._ty += best.dy;
    applyTransform(g);
    return true;
  }
  return false;
}

function updateViewScale(){
  viewScale = 1;
}

function computeDualLayout(){
  const w = stage.clientWidth || stage.getBoundingClientRect().width;
  const h = stage.clientHeight || stage.getBoundingClientRect().height;

  updateViewScale();
  const effCur = (mode==="multiplicative") ? (coeff * viewScale) : 1;

  const curW = toPx(11 * effCur);
  const curH = toPx(11 * effCur);
  const refW = toPx(11);
  const refH = toPx(11);
  const gap = toPx(REF_GAP_CM);

  const bboxW = curW + refW + gap;
  const M = 20;

  // Objectif : puzzles proches (√©cart ~1‚Äì2 cm) et "au milieu" pour manipuler facilement.
  // On centre donc le couple (puzzle courant + r√©f√©rence) horizontalement, avec un √©cart fixe.
  let left = (w - bboxW) / 2;
  if(!isFinite(left)) left = M;
  left = Math.max(M, left);
  if(left + bboxW > w - M){
    left = Math.max(M, (w - M) - bboxW);
  }

  let curTx, refTx;
  if(referenceSide === "left"){
    refTx = left;
    curTx = left + refW + gap;
  }else{
    curTx = left;
    refTx = left + curW + gap;
  }

  // Centrage vertical : chaque puzzle est centr√© dans la hauteur disponible.
  const curTy = (h/2) + (curH/2);
  const refTy = (h/2) + (refH/2);

  return {refTx, curTx, refTy, curTy, curW, curH, refW, refH, gap, bboxW};
}


function ptsToPathCm(ptsCm){
  const [x0,y0] = cmToStage(ptsCm[0]);
  let d = `M ${x0} ${y0}`;
  for(let i=1;i<ptsCm.length;i++){
    const [x,y] = cmToStage(ptsCm[i]);
    d += ` L ${x} ${y}`;
  }
  return d + " Z";
}

function drawReferenceLayer(){
  ensureLayers();
  if(!refLayer) return;
  refLayer.innerHTML = "";

  if(!showReference) return;

  const lay = computeDualLayout();
  refLayer.setAttribute("transform", `translate(${lay.refTx} ${lay.refTy})`);
  refLayer.style.opacity = String(referenceOpacity);

  for(const p of PIECES){
    const path = document.createElementNS("http://www.w3.org/2000/svg","path");
    path.setAttribute("d", ptsToPathCm(p.pts));
    path.setAttribute("class","refOutline");
    refLayer.appendChild(path);
  }
}

function assembledPositions(){
  if(showReference){
    const lay = computeDualLayout();
    const pos = {};
    for(const piece of PIECES){
      pos[piece.id] = { tx: lay.curTx, ty: lay.curTy, rot: 0 };
    }
    return pos;
  }

    const w = stage.clientWidth || stage.getBoundingClientRect().width;
    const h = stage.clientHeight || stage.getBoundingClientRect().height;

    updateViewScale();
    const eff = (mode==="multiplicative") ? (coeff * viewScale) : 1;

    const puzzleW = toPx(11 * eff);
    const puzzleH = toPx(11 * eff);

    const M = 20;
    const extraTop = toPx(0.55 * eff);
    const extraBottom = toPx(0.35 * eff);

    const bboxW = puzzleW;
    const bboxH = puzzleH + extraTop + extraBottom;

    let left = (w - bboxW) / 2;
    let top = (h - bboxH) / 2 + extraTop; // top = sommet du carr√© (pas du bbox)

    // Petit confort visuel : on descend tr√®s l√©g√®rement l'ensemble au d√©part.
    top += 10;

    left = Math.max(M, left);
    top = Math.max(M + extraTop, top);

    const bboxBottom = top + puzzleH + extraBottom;
    if(bboxBottom > h - M){
      top -= (bboxBottom - (h - M));
    }
    top = Math.max(M + extraTop, top);

    const baseTx = left;
    const baseTy = top + puzzleH;

    const pos = {};
    for(const piece of PIECES){
      pos[piece.id] = { tx: baseTx, ty: baseTy, rot: 0 };
    }
    return pos;
}

let currentPositions = assembledPositions();

/* Interaction */
let drag = {active:false, id:null, startX:0, startY:0, baseTx:0, baseTy:0};

function bringToFront(g){ piecesLayer.appendChild(g); if(g._labels){ labelsLayer.appendChild(g._labels); } }

function selectPiece(id){
  selectedId = id;
  getAllPieceEls().forEach(g=>{
    const isSel = (g.dataset.id === id);
    g.style.opacity = isSel ? "1" : "1";
    applyTransform(g);
  });
}

function onPieceDown(e){
  if(e.button !== undefined && e.button !== 0) return;
  const g = e.currentTarget;
  bringToFront(g);
  selectPiece(g.dataset.id);

  drag.active = true;
  drag.id = g.dataset.id;
  drag.startX = e.clientX;
  drag.startY = e.clientY;
  drag.baseTx = g._tx;
  drag.baseTy = g._ty;

  g.style.cursor = "grabbing";
  g.setPointerCapture(e.pointerId);

  g.addEventListener("pointermove", onPieceMove);
  g.addEventListener("pointerup", onPieceUp);
  g.addEventListener("pointercancel", onPieceUp);
}

function onPieceMove(e){
  if(!drag.active) return;
  const g = e.currentTarget;
  const dx = e.clientX - drag.startX;
  const dy = e.clientY - drag.startY;
  g._tx = drag.baseTx + dx;
  g._ty = drag.baseTy + dy;
  applyTransform(g);
}

function onPieceUp(e){
  const g = e.currentTarget;
  drag.active = false;
  g.removeEventListener("pointermove", onPieceMove);
  g.removeEventListener("pointerup", onPieceUp);
  g.removeEventListener("pointercancel", onPieceUp);
  try{ g.releasePointerCapture(e.pointerId); }catch(_){ }

  const id = g.dataset.id;
  if(mode==="additive") addTouched = true;

  let snapped = snapToOtherPieces(g, true);

  if(!snapped){
    const tgt = assembledPositions()[id];
    const okRot = normRot(g._rot) === 0;
    if(tgt && okRot){
      const HARD = 55;
      const dx = g._tx - tgt.tx;
      const dy = g._ty - tgt.ty;
      if(Math.hypot(dx,dy) < HARD){
        g._tx = tgt.tx;
        g._ty = tgt.ty;
        g._rot = 0;
        applyTransform(g);
      }
    }
  }
  currentPositions[id] = {tx:g._tx, ty:g._ty, rot:g._rot};
}

/* UI */

/* UI */
function capturePositionsFromDOM(){
  const out = {};
  document.querySelectorAll(".piece").forEach(g=>{
    out[g.dataset.id] = {tx:g._tx, ty:g._ty, rot:g._rot || 0};
  });
  return out;
}

function applyPositions(pos){
  if(!pos) return;
  document.querySelectorAll(".piece").forEach(g=>{
    const p = pos[g.dataset.id];
    if(!p) return;
    g._tx = p.tx; g._ty = p.ty; g._rot = p.rot || 0;
    applyTransform(g);
    currentPositions[g.dataset.id] = {tx:g._tx, ty:g._ty, rot:g._rot};
  });
}

function applyAdditiveScatter(){
  const base = assembledPositions();
  const center = {x:5.5, y:5.5};
  const scatterCm = 3.6;

  for(const piece of PIECES){
    const [cx, cy] = centroidPolygon(piece.pts);
    let vx = cx - center.x;
    let vy = cy - center.y;
    let L = Math.hypot(vx, vy);
    if(L < 1e-6){ L = 1; vx = 1; vy = 0; }
    vx /= L; vy /= L;

    const dx = toPx(vx * scatterCm);
    const dy = toPx(-vy * scatterCm);

    const g = document.querySelector(`.piece[data-id="${piece.id}"]`);
    if(!g) continue;

    g._tx = base[piece.id].tx + dx;
    g._ty = base[piece.id].ty + dy;
    g._rot = 0;
    applyTransform(g);
    currentPositions[piece.id] = {tx:g._tx, ty:g._ty, rot:g._rot};
  }

  nudgeAllPiecesIntoView();
}

function setMode(newMode){
  const prevMode = mode;

  if(newMode==="additive" && prevMode!=="additive"){
    addSnapshot = capturePositionsFromDOM();
    addTouched = false;
  }

  const leavingAdd = (prevMode==="additive" && newMode!=="additive");

  mode = newMode;
  const bO = document.getElementById("mOrig");
  const bA = document.getElementById("mAdd");

  [bO,bA].forEach(b=>{ if(b) b.classList.remove("active","wrong","correct"); });

  if(mode==="original"){ if(bO) bO.classList.add("active"); }
  if(mode==="additive"){ if(bA) bA.classList.add("active","wrong"); }

  redrawKeepingPositions();

  if(mode==="additive"){
    applyAdditiveScatter();
  }else if(leavingAdd){
    if(addSnapshot && !addTouched){
      applyPositions(addSnapshot);
    }
    addSnapshot = null;
    addTouched = false;
  }
}

function redrawKeepingPositions(){
  updateViewScale();
  const existing = {};
  document.querySelectorAll(".piece").forEach(g=>{
    existing[g.dataset.id] = {tx:g._tx, ty:g._ty, rot:g._rot};
  });
  clearStage();
  for(const p of PIECES){
    const init = existing[p.id] || currentPositions[p.id] || {tx:80,ty:80,rot:0};
    addPiece(p, init);
  }
  // Si la r√©f√©rence est activ√©e : on garde le centrage vertical (puzzle au milieu)
  // entre le puzzle courant et la silhouette, m√™me quand on change d'√©chelle.
  // On ne force l'alignement que si les pi√®ces sont encore "assembl√©es" (toutes au m√™me tx/ty),
  // pour √©viter de d√©placer un puzzle que l'enseignant aurait d√©j√† √©clat√© volontairement.
  if(showReference){
    const lay = computeDualLayout();
    const id0 = PIECES[0].id;
    const g0 = document.querySelector('.piece[data-id="'+id0+'"]');
    if(g0){
      let assembledLike = true;
      const eps = 1.5;
      document.querySelectorAll(".piece").forEach(g=>{
        if(Math.abs((g._tx||0) - (g0._tx||0)) > eps || Math.abs((g._ty||0) - (g0._ty||0)) > eps){
          assembledLike = false;
        }
      });
      if(assembledLike){
        const dx = lay.curTx - g0._tx;
        const dy = lay.curTy - g0._ty;
        if(isFinite(dx) && isFinite(dy) && (Math.abs(dx) > 0.5 || Math.abs(dy) > 0.5)){
          document.querySelectorAll(".piece").forEach(g=>{
            if(typeof g._tx === "number" && typeof g._ty === "number"){
              g._tx += dx;
              g._ty += dy;
              applyTransform(g);
              currentPositions[g.dataset.id] = {tx:g._tx, ty:g._ty, rot:g._rot || 0};
            }
          });
        }
      }
    }
  }
  drawReferenceLayer();
  if(selectedId) selectPiece(selectedId);
  markLabelsDirty();
}

function nudgeAllPiecesIntoView(){
  const rect = stage.getBoundingClientRect();
  const w = rect.width || stage.clientWidth || 1000;
  const h = rect.height || stage.clientHeight || 700;
  const margin = 16;

  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

  function addElBBox(el){
    if(!el) return;
    let bb;
    try{ bb = el.getBBox(); }catch(_){ return; }
    const m = el.getCTM();
    if(!m) return;

    const corners = [
      {x: bb.x, y: bb.y},
      {x: bb.x + bb.width, y: bb.y},
      {x: bb.x + bb.width, y: bb.y + bb.height},
      {x: bb.x, y: bb.y + bb.height}
    ];

    for(const c of corners){
      const x = m.a*c.x + m.c*c.y + m.e;
      const y = m.b*c.x + m.d*c.y + m.f;
      if(x < minX) minX = x;
      if(y < minY) minY = y;
      if(x > maxX) maxX = x;
      if(y > maxY) maxY = y;
    }
  }

  const pieces = getAllPieceEls();
  for(const g of pieces){
    addElBBox(g);
    if(g._labels) addElBBox(g._labels);
  }
  if(!isFinite(minX)) return;

  let dx = 0;
  if(minX < margin) dx = (margin - minX);
  if(maxX + dx > w - margin) dx = ((w - margin) - maxX);

  let dy = 0;
  if(minY < margin) dy += (margin - minY);
  if(maxY + dy > h - margin) dy += ((h - margin) - (maxY + dy));

  if(Math.abs(dx) < 0.5 && Math.abs(dy) < 0.5) return;

  document.querySelectorAll('.piece').forEach(g=>{
    g._tx += dx;
    g._ty += dy;
    applyTransform(g);
    currentPositions[g.dataset.id] = {tx:g._tx, ty:g._ty, rot:g._rot};
  });
}

/* --- PATCHL5 : stabilit√© plein √©cran / resize ---
   Probl√®me observ√© : apr√®s entr√©e/sortie plein √©cran (ou resize), le recalcul de PX_PER_CM
   change l'√©chelle, mais les translations (tx/ty) restaient en "anciens pixels".
   Du coup la figure pouvait sortir du viewport jusqu'√† recliquer sur Agrandir/R√©duire.
   Solution minimaliste : √† chaque changement de viewport, on:
   1) attend que le layout soit stabilis√© (2 frames)
   2) recalcule PX_PER_CM
   3) rescaille les positions existantes par le ratio de PX_PER_CM
   4) redessine et on "nudge" pour garantir que tout reste visible
*/
let _viewportRAF = null;
function scheduleViewportReflow(){
  if(_viewportRAF) cancelAnimationFrame(_viewportRAF);
  _viewportRAF = requestAnimationFrame(()=>{
    _viewportRAF = requestAnimationFrame(()=>{
      _viewportRAF = null;
      if(typeof stage === "undefined") return;

      const hasPieces = !!document.querySelector(".piece");
      const oldPP = PX_PER_CM;
      recomputePxPerCm();
      if(!hasPieces) return;

      const ratio = PX_PER_CM / oldPP;
      if(isFinite(ratio) && Math.abs(ratio - 1) > 1e-6){
        document.querySelectorAll(".piece").forEach(g=>{
          if(typeof g._tx === "number" && typeof g._ty === "number"){
            g._tx *= ratio;
            g._ty *= ratio;
            applyTransform(g);
            currentPositions[g.dataset.id] = {tx:g._tx, ty:g._ty, rot:g._rot || 0};
          }
        });
      }
      redrawKeepingPositions();
      // Si on vient de basculer l'affichage R√©f√©rence, on translate toutes les pi√®ces d'un m√™me delta
      // pour que le puzzle "courant" se place automatiquement √† c√¥t√© de la silhouette (sans superposition).
      if(_pendingBaseShift){
        const after = getAssembledBase();
        const beforeScaled = { tx: _pendingBaseShift.tx * ratio, ty: _pendingBaseShift.ty * ratio };
        const dx = after.tx - beforeScaled.tx;
        const dy = after.ty - beforeScaled.ty;

        if(isFinite(dx) && isFinite(dy) && (Math.abs(dx) > 0.5 || Math.abs(dy) > 0.5)){
          document.querySelectorAll(".piece").forEach(g=>{
            if(typeof g._tx === "number" && typeof g._ty === "number"){
              g._tx += dx;
              g._ty += dy;
              applyTransform(g);
              currentPositions[g.dataset.id] = {tx:g._tx, ty:g._ty, rot:g._rot || 0};
            }
          });
        }
        _pendingBaseShift = null;
        drawReferenceLayer();
      }

      nudgeAllPiecesIntoView();
    });
  });
}


function resetAssembled(){
  const pos = assembledPositions();
  document.querySelectorAll(".piece").forEach(g=>{
    const p = pos[g.dataset.id];
    g._tx = p.tx; g._ty = p.ty; g._rot = 0;
    applyTransform(g);
    currentPositions[g.dataset.id] = {tx:g._tx, ty:g._ty, rot:g._rot};
  });
  drawReferenceLayer();
  markLabelsDirty();
}

function setAgrandissement(){ coeff = 7/4; setMode("multiplicative"); nudgeAllPiecesIntoView(); }
function setReduction(){ coeff = 4/5; setMode("multiplicative"); nudgeAllPiecesIntoView(); }

function toggleLengths(){
  showLengths = !showLengths;
  document.getElementById("btnLong").textContent = "Longueurs : " + (showLengths ? "ON" : "OFF");
  redrawKeepingPositions();
}


function syncReferenceUI(){
  const btn = document.getElementById("btnRef");
  if(btn) btn.textContent = "R√©f√©rence : " + (showReference ? "ON" : "OFF");

  const cb = document.getElementById("refToggle");
  if(cb) cb.checked = !!showReference;

  const side = document.getElementById("refSide");
  if(side) side.value = referenceSide;

  const op = document.getElementById("refOpacity");
  if(op) op.value = String(referenceOpacity);
}

function getAssembledBase(){
  const pos = assembledPositions();
  const id0 = PIECES[0].id;
  const any = pos[id0];
  return {tx:any.tx, ty:any.ty};
}

function setShowReference(v){
  const want = !!v;
  if(want === showReference) return;

  // On m√©morise o√π le puzzle "courant" est cens√© se placer (en pixels) AVANT le toggle,
  // pour pouvoir d√©placer toutes les pi√®ces en bloc et √©viter tout chevauchement.
  _pendingBaseShift = getAssembledBase();

  showReference = want;
  syncReferenceUI();
  scheduleViewportReflow();
}

function setReferenceSide(v){
  referenceSide = (v === "right") ? "right" : "left";
  syncReferenceUI();
  redrawKeepingPositions();
  nudgeAllPiecesIntoView();
}

function setReferenceOpacity(v){
  const n = Number(v);
  if(!isFinite(n)) return;
  referenceOpacity = Math.max(0.05, Math.min(0.95, n));
  if(refLayer) refLayer.style.opacity = String(referenceOpacity);
  syncReferenceUI();
}


// Modal
const overlay = document.getElementById("overlay");
function openOverlay(){
  overlay.classList.add("active");
  overlay.setAttribute("aria-hidden","false");
  syncReferenceUI();
}
function closeOverlay(){
  overlay.classList.remove("active");
  overlay.setAttribute("aria-hidden","true");
}

function printEnonce(){
  openOverlay();
  setTimeout(()=>{ window.print(); }, 60);
}

document.getElementById("mOrig").addEventListener("click", ()=>{ coeff=1; setMode("original"); });
document.getElementById("mAdd").addEventListener("click", ()=>{ setMode("additive"); });
document.getElementById("btnAgrandir").addEventListener("click", setAgrandissement);
document.getElementById("btnReduire").addEventListener("click", setReduction);
document.getElementById("btnReset").addEventListener("click", resetAssembled);
document.getElementById("btnLong").addEventListener("click", toggleLengths);
const btnRef = document.getElementById("btnRef");
if(btnRef) btnRef.addEventListener("click", ()=> setShowReference(!showReference));
document.getElementById("btnEnonce").addEventListener("click", openOverlay);
const btnPrint = document.getElementById("btnPrint");
if(btnPrint) btnPrint.addEventListener("click", printEnonce);
const btnPrintInEnonce = document.getElementById("btnPrintInEnonce");
if(btnPrintInEnonce) btnPrintInEnonce.addEventListener("click", printEnonce);
document.getElementById("closeOverlay").addEventListener("click", closeOverlay);


const refToggle = document.getElementById("refToggle");
if(refToggle) refToggle.addEventListener("change", ()=> setShowReference(refToggle.checked));

const refSide = document.getElementById("refSide");
if(refSide) refSide.addEventListener("change", ()=> setReferenceSide(refSide.value));

const refOpacity = document.getElementById("refOpacity");
if(refOpacity) refOpacity.addEventListener("input", ()=> setReferenceOpacity(refOpacity.value));


document.getElementById("btnFS").addEventListener("click", ()=>{
  try{
    if(!document.fullscreenElement){
      (document.documentElement.requestFullscreen || document.documentElement.webkitRequestFullscreen || function(){}).call(document.documentElement);
    }else{
      (document.exitFullscreen || document.webkitExitFullscreen || function(){}).call(document);
    }
  }catch(e){}
});
document.addEventListener("fullscreenchange", scheduleViewportReflow);
window.addEventListener("orientationchange", scheduleViewportReflow);
document.addEventListener("webkitfullscreenchange", scheduleViewportReflow);
overlay.addEventListener("click", (e)=>{ if(e.target === overlay) closeOverlay(); });

/* Puzzle dans l‚Äô√©nonc√© */
function drawPaperPuzzle(){
  const g = document.getElementById("paperPuzzle");
  g.innerHTML = "";

  const VB = 420;
  const minX = -0.45, maxX = 11.45;
  const minY = -11.5,  maxY = 0;
  const scale = 31;
  const tx = (VB - (maxX - minX) * scale) / 2 - (minX * scale);
  const ty = (VB - (maxY - minY) * scale) / 2 - (minY * scale);

  const outline = document.createElementNS("http://www.w3.org/2000/svg","g");
  outline.setAttribute("transform", `translate(${tx} ${ty}) scale(${scale} ${-scale})`);
  outline.setAttribute("fill","none");
  outline.setAttribute("stroke","#111827");
  outline.setAttribute("stroke-width","0.08");
  outline.setAttribute("stroke-linejoin","round");

  for(const p of PIECES){
    const pts = p.pts;
    let d = `M ${pts[0][0]} ${pts[0][1]}`;
    for(let i=1;i<pts.length;i++) d += ` L ${pts[i][0]} ${pts[i][1]}`;
    d += " Z";
    const path = document.createElementNS("http://www.w3.org/2000/svg","path");
    path.setAttribute("d", d);
    outline.appendChild(path);
  }
  g.appendChild(outline);

  const txtG = document.createElementNS("http://www.w3.org/2000/svg","g");
  txtG.setAttribute("font-family","Arial");
  txtG.setAttribute("font-size","16");
  txtG.setAttribute("fill","#111827");
  txtG.setAttribute("text-anchor","middle");

  const texts = [
    {x:2, y:-0.28, t:"4 cm"},
    {x:5, y:-0.28, t:"2 cm"},
    {x:8.50, y:-0.28, t:"5 cm"},
    {x:-0.28, y:-2.50, t:"5 cm", r:-90},
    {x:-0.28, y:-8.00, t:"6 cm", r:-90},
    {x:3.00, y:-11.28, t:"6 cm"},
    {x:8.50, y:-11.28, t:"5 cm"},
    {x:11.28, y:-10.00, t:"2 cm", r:90},
    {x:11.28, y:-5.50, t:"7 cm", r:90},
    {x:11.28, y:-1.00, t:"2 cm", r:90},
    {x:3.72, y:-4.50, t:"9 cm", r:-90, anchor:"end"},
    {x:6.62, y:-3.50, t:"7 cm", r:-90, anchor:"middle"},
    {x:7.50, y:-9.28, t:"7 cm"}
  ];

  for(const item of texts){
    const t = document.createElementNS("http://www.w3.org/2000/svg","text");
    t.textContent = item.t;
    const px = tx + item.x*scale;
    const py = ty + item.y*scale;
    t.setAttribute("x", px);
    t.setAttribute("y", py);
    if(item.anchor) t.setAttribute("text-anchor", item.anchor);
    if(item.r){
      t.setAttribute("transform", `rotate(${item.r} ${px} ${py})`);
    }
    txtG.appendChild(t);
  }
  g.appendChild(txtG);
}

function init(){
  drawPaperPuzzle();
  clearStage();
  recomputePxPerCm();
  currentPositions = assembledPositions();
  for(const p of PIECES) addPiece(p, currentPositions[p.id]);
  drawReferenceLayer();
  selectPiece("p1");
  syncReferenceUI();
}
requestAnimationFrame(init);

window.addEventListener("resize", scheduleViewportReflow);
</script>

</body>
</html>
