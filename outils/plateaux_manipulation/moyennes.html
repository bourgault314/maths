<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Outil : La Moyenne (D√©cimaux)</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;800&display=swap" rel="stylesheet">
    
    <style>
        body {
            font-family: 'Fredoka', sans-serif;
            background-color: #ffffff;
            overflow: hidden;
            touch-action: none;
            user-select: none;
        }

        .tool-btn { transition: all 0.2s cubic-bezier(0.34, 1.56, 0.64, 1); }
        .tool-btn:active { transform: scale(0.9); }
        .tool-btn.active {
            background-color: #dbeafe; border-color: #3b82f6; color: #1d4ed8;
        }
        .tool-btn.active-scissors {
            background-color: #fef3c7; border-color: #d97706; color: #d97706;
        }

        #layer-container {
            position: relative; flex: 1; overflow: hidden; background-color: white;
            touch-action: none;
            user-select: none;
        
        }
        canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; touch-action: none;
        }
        
        #setup-modal {
            position: absolute; inset: 0; z-index: 50;
            background: rgba(255,255,255,0.98);
            display: flex; justify-content: center; align-items: center;
        }

        .victory-text { 
            color: #16a34a !important;
            font-weight: 800;
            font-size: clamp(1.4rem, 2.0vw + 0.9rem, 2.4rem);
            line-height: 1.15;
            text-align: center;
        }
    </style>
</head>
<body class="h-screen w-screen flex flex-col overflow-hidden text-slate-700">

    <div id="setup-modal">
        <div class="bg-white p-8 rounded-2xl shadow-2xl border-2 border-slate-100 max-w-md w-full text-center">
            <h2 class="text-2xl font-bold text-slate-800 mb-2">Calcul de Moyenne</h2>
            <p class="text-slate-500 mb-6 text-sm">Entre les hauteurs des piles.</p>
            
            <input type="text" id="numbers-input" 
                   class="w-full text-2xl font-bold text-center p-4 bg-slate-50 border-2 border-slate-200 rounded-xl focus:border-blue-500 focus:outline-none mb-6 text-slate-700 placeholder-slate-400"
                   placeholder="ex : 12 9,5 14,25 16" autocomplete="off">
            
            
            
    <div class="flex items-center gap-3 mb-4">
        <label for="gen-count" class="text-sm text-slate-600 font-bold shrink-0">Nb de piles</label>
        <input id="gen-count" type="number" min="2" max="15" value="5"
               class="w-24 text-center font-bold bg-slate-50 border-2 border-slate-200 rounded-xl p-2 focus:border-blue-500 focus:outline-none text-slate-700">
        <div class="flex-1"></div>
    </div>

    <div class="grid grid-cols-2 gap-2 mb-4">
        <button onclick="fillExample('integers')" class="bg-slate-100 hover:bg-slate-200 text-slate-700 font-bold py-2 rounded-xl transition active:scale-95" title="G√©n√®re un exemple solvable avec des entiers">
            üé≤ Exemple (entiers)
        </button>
        <button onclick="fillExample('decimals')" class="bg-slate-100 hover:bg-slate-200 text-slate-700 font-bold py-2 rounded-xl transition active:scale-95" title="G√©n√®re un exemple solvable avec des d√©cimaux au quart pr√®s">
            ‚ú® Exemple (d√©cimaux)
        </button>
    </div>

<button onclick="startGame()" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-4 rounded-xl text-lg transition-transform active:scale-95 shadow-lg shadow-blue-200">
                Construire les piles
            </button>
            <p id="error-msg" class="text-rose-500 text-sm mt-4 hidden"></p>
        </div>
    </div>

    <header class="bg-white shadow-sm z-30 flex flex-col shrink-0 relative">
        <div class="flex items-center justify-between p-2 gap-2 w-full border-b border-slate-100 min-h-[86px]">
            <div class="flex gap-2 shrink-0">
                <button onclick="resetSetup()" class="tool-btn bg-slate-100 hover:bg-slate-200 text-slate-600 p-2 rounded-xl font-bold flex items-center gap-2" title="Recommencer">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" /></svg>
                    <span class="hidden sm:inline text-sm">Nouveau</span>
                </button>
                
                <button onclick="undo()" class="tool-btn bg-slate-100 hover:bg-slate-200 text-slate-600 p-2 rounded-xl font-bold flex items-center gap-2" title="Annuler la derni√®re action">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6" />
                    </svg>
                    <span class="hidden sm:inline text-sm">Annuler</span>
                </button>

                
    <!-- Boutons de Zoom + Plein √©cran -->
    <div class="flex items-center bg-slate-100 rounded-xl p-1 ml-2 border border-slate-200">
        <button onclick="adjustZoom(-0.1)" class="tool-btn p-2 rounded-lg text-slate-600 hover:bg-white" title="D√©zoomer">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 12H4" />
            </svg>
        </button>
        <button onclick="adjustZoom(0.1)" class="tool-btn p-2 rounded-lg text-slate-600 hover:bg-white" title="Zoomer">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4" />
            </svg>
        </button>

        <div class="w-px h-6 bg-slate-300 mx-1"></div>

        <button onclick="toggleFullscreen()" id="toggle-fullscreen" class="tool-btn p-2 rounded-lg text-slate-600 hover:bg-white" title="Plein √©cran">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 3H5a2 2 0 00-2 2v3m0 8v3a2 2 0 002 2h3m8-18h3a2 2 0 012 2v3m0 8v3a2 2 0 01-2 2h-3" />
            </svg>
        </button>
    </div>
</div>

            <div class="flex-1 flex flex-col justify-center items-center pointer-events-none px-2 text-center overflow-hidden">
                <span id="header-title" class="text-slate-800 font-bold text-xl leading-tight w-full px-2 whitespace-normal">√âgaliser les piles</span>
                <span id="header-subtitle" class="text-xs text-slate-400 font-bold uppercase tracking-wider">D√©place ou coupe les blocs</span>
            </div>

            <div class="flex items-center gap-2 bg-slate-100 p-1 rounded-xl border border-slate-200 shrink-0">
                <button onclick="setTool('hand')" id="tool-hand" class="tool-btn active p-2 rounded-lg" title="D√©placer">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 11.5V14m0-2.5v-6a1.5 1.5 0 113 0m-3 6a1.5 1.5 0 00-3 0v2a7.5 7.5 0 0015 0v-5a1.5 1.5 0 00-3 0m-6-3V11m0-5.5v-1a1.5 1.5 0 013 0v1m0 0V11m0-5.5a1.5 1.5 0 013 0v3m0 0V11" /></svg>
                </button>
                
                <button onclick="setTool('scissors')" id="tool-scissors" class="tool-btn text-amber-600 hover:bg-amber-50 p-2 rounded-lg" title="Couper (Max 1/4)">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.121 14.121L19 19m-7-7l7-7m-7 7l-2.879 2.879M12 12L9.121 9.121m0 5.758a3 3 0 10-4.243 4.243 3 3 0 004.243-4.243zm0-5.758a3 3 0 10-4.243-4.243 3 3 0 004.243 4.243z" />
                    </svg>
                </button>

                
<div class="w-px h-6 bg-slate-300 mx-1"></div>

<button onclick="setTool('pen')" id="tool-pen" class="tool-btn text-blue-600 hover:bg-blue-50 p-2 rounded-lg" title="Stylo">
    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <!-- Stylo (simple, lisible) -->
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16.862 4.487l1.687-1.687a1.875 1.875 0 112.652 2.652L9.44 17.213a4.5 4.5 0 01-1.897 1.13l-2.685.8.8-2.685a4.5 4.5 0 011.13-1.897L16.862 4.487z" />
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19.5 7.5l-3-3" />
    </svg>
</button>

<button onclick="undoDraw()" id="btn-undo-draw" class="tool-btn text-slate-600 hover:bg-slate-200 p-2 rounded-lg" title="Annuler le dernier trait du stylo">
    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <!-- M√™me style que le bouton Annuler -->
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6" />
    </svg>
</button>

<button onclick="clearDrawings()" id="btn-clear-draw" class="tool-btn text-slate-600 hover:bg-slate-200 p-2 rounded-lg" title="Effacer tous les traits">
    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
    </svg>
</button>

            </div>
        </div>
    </header>

    <div class="flex flex-1 overflow-hidden relative">
        <main id="layer-container">
            <canvas id="main-canvas"></canvas>
            <canvas id="drawing-canvas"></canvas>
        </main>
    </div>

    <script>
        const state = {
            stacks: [], // Liste de listes : [[1,1,1], [1,0.5,0.5]]
            history: [], // Pour stocker les √©tats pr√©c√©dents
            initialValues: [],
            tool: 'hand', // 'hand', 'scissors', 'pen'
            dragging: null,
            blockSize: 60,
            baseBlockSize: 60, // Taille de r√©f√©rence calcul√©e auto
            zoom: 1.0,         // Facteur de zoom manuel
            baseY: 0,
            targetAverage: 0,
            isWin: false,
            projection: true,
            drawStrokes: []
        };

        const canvasMain = document.getElementById('main-canvas');
        const ctxMain = canvasMain.getContext('2d');
        const canvasDraw = document.getElementById('drawing-canvas');
        const ctxDraw = canvasDraw.getContext('2d');
        const container = document.getElementById('layer-container');

        /* --- SETUP --- */
        
        /* --- OUTILS DE FORMAT / PARSE (au quart pr√®s) --- */
        function parseFrenchNumber(token) {
            if (!token) return NaN;
            const t = token.replace(',', '.');
            const v = parseFloat(t);
            return Number.isFinite(v) ? v : NaN;
        }
        function isQuarterNumber(v) {
            const q = v * 4;
            return Math.abs(q - Math.round(q)) < 1e-9;
        }
        function formatFR(v) {
            // Values in this tool are constrained to multiples of 1/4.
            // Format safely without trimming integer trailing zeros (e.g. 10 must stay 10).
            const q = Math.round(v * 4);
            const intPart = (q >= 0) ? Math.floor(q / 4) : Math.ceil(q / 4);
            const rem = ((q % 4) + 4) % 4; // 0..3
            let s;
            if (rem === 0) s = String(intPart);
            else if (rem === 1) s = String(intPart) + ".25";
            else if (rem === 2) s = String(intPart) + ".5";
            else s = String(intPart) + ".75";
            return s.replace('.', ',');
        }
        function buildStackFromValue(v) {
            const q = Math.round(v * 4);
            const stack = [];
            let remaining = q;
            while (remaining >= 4) { stack.push(1); remaining -= 4; }
            if (remaining >= 2) { stack.push(0.5); remaining -= 2; }
            if (remaining >= 1) { stack.push(0.25); remaining -= 1; }
            return stack;
        }
        function averageIsRepresentable(numbers) {
            const sumQ = numbers.reduce((a,b)=>a + Math.round(b*4), 0);
            return (sumQ % numbers.length) === 0;
        }
        
function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

function fillExample(mode) {
    const inputEl = document.getElementById('numbers-input');
    const errorMsg = document.getElementById('error-msg');
    const countEl = document.getElementById('gen-count');
    const n = clamp(parseInt(countEl?.value || "5", 10) || 5, 2, 15);

    const maxValQ = 80; // 20 * 4 (on travaille en quarts)

    const randInt = (a,b) => a + Math.floor(Math.random() * (b - a + 1));

    // Choix d'une moyenne cible (en quarts) avec une pr√©f√©rence pour des valeurs "notes sur 20",
    // y compris parfois proches de 20.
    function pickAvgQ() {
        if (mode === 'integers') {
            // 0..20 par pas de 1  => 0..80 par pas de 4
            const hi = (Math.random() < 0.35); // parfois proche de 20
            const minQ = hi ? 60 : 8;   // 15 ou 2
            const maxQ = hi ? 76 : 72;  // 20 ou 18
            const a = Math.floor(minQ / 4);
            const b = Math.floor(maxQ / 4);
            return randInt(a,b) * 4;
        } else {
            const hi = (Math.random() < 0.35);
            const minQ = hi ? 60 : 8;   // 15 ou 2
            const maxQ = hi ? 79 : 72;  // 20 ou 18
            return randInt(minQ, maxQ);
        }
    }

    // G√©n√©ration "par construction" : on part de n piles √©gales √† la moyenne
    // puis on effectue des transferts de quarts entre piles (la somme reste constante
    // donc la moyenne est toujours atteignable avec des blocs ‚â• 1/4).
    function buildByTransfers() {
        const avgQ = pickAvgQ();
        const valuesQ = Array(n).fill(avgQ);

        const steps = clamp(Math.round(n * 1.6), 4, 24);
        let moved = false;

        for (let s = 0; s < steps; s++) {
            let i = randInt(0, n-1);
            let j = randInt(0, n-1);
            if (i === j) continue;

            // Taille du transfert (en quarts)
            let tQ;
            if (mode === 'integers') {
                // transferts de 1 √† 5 unit√©s (=> 4..20 quarts)
                tQ = 4 * randInt(1, 5);
            } else {
                // transferts de 0,25 √† 2 unit√©s (=> 1..8 quarts)
                tQ = randInt(1, 8);
            }

            // Choisir le sens : j donne √† i
            if (valuesQ[i] + tQ <= maxValQ && valuesQ[j] - tQ >= 0) {
                valuesQ[i] += tQ;
                valuesQ[j] -= tQ;
                moved = true;
            }
        }

        // Assurer qu'il y a au moins un au-dessus et un en-dessous de la moyenne
        const hasAbove = valuesQ.some(vq => vq > avgQ);
        const hasBelow = valuesQ.some(vq => vq < avgQ);

        if (!(hasAbove && hasBelow)) {
            // On force un petit √©cart contr√¥l√©
            const i = randInt(0, n-1);
            let j = randInt(0, n-1);
            if (j === i) j = (j+1) % n;

            const tQ = (mode === 'integers') ? 4 : 1; // 1 unit√© ou 0,25
            if (valuesQ[i] + tQ <= maxValQ && valuesQ[j] - tQ >= 0) {
                valuesQ[i] += tQ;
                valuesQ[j] -= tQ;
                moved = true;
            }
        }

        // Si on n'a pas boug√© (cas tr√®s rare), on fait un exemple d√©terministe simple
        if (!moved) {
            const base = (mode === 'integers') ? 48 : 49; // 12 ou 12,25
            const v = Array(n).fill(base);
            // cr√©er un √©cart
            if (n >= 2) {
                v[0] += (mode === 'integers') ? 4 : 1;
                v[1] -= (mode === 'integers') ? 4 : 1;
            }
            return v;
        }

        return valuesQ;
    }

    const valuesQ = buildByTransfers();

    // Convertir en nombres d√©cimaux (0.25, 0.5, etc.) et √©crire dans l'input
    const values = valuesQ.map(vq => vq / 4);
    inputEl.value = values.map(formatFR).join(' ');
    if (errorMsg) errorMsg.classList.add('hidden');
}

function startGame() {
            const input = document.getElementById('numbers-input').value;
            const errorMsg = document.getElementById('error-msg');
            
            if (!input) {
                 errorMsg.textContent = "Entre quelques nombres.";
                 errorMsg.classList.remove('hidden');
                 return;
            }

            const rawTokens = input.trim().split(/\s+/).filter(Boolean);
            const numbers = rawTokens.map(parseFrenchNumber).filter(n => Number.isFinite(n) && n >= 0);

            if (numbers.length !== rawTokens.length) {
                errorMsg.textContent = "Format invalide. Exemple : 12 9,5 14,25 16";
                errorMsg.classList.remove('hidden');
                return;
            }

            const bad = numbers.find(n => !isQuarterNumber(n));
            if (bad !== undefined) {
                errorMsg.textContent = "Ce mod√®le accepte uniquement des nombres au quart pr√®s (0 ; 0,25 ; 0,5 ; 0,75 ; ‚Ä¶).";
                errorMsg.classList.remove('hidden');
                return;
            }

            if (numbers.length < 2) {
                errorMsg.textContent = "Il faut au moins 2 piles.";
                errorMsg.classList.remove('hidden');
                return;
            }
            if (numbers.length > 15) {
                errorMsg.textContent = "Trop de colonnes (max 15).";
                errorMsg.classList.remove('hidden');
                return;
            }

            
            if (!averageIsRepresentable(numbers)) {
                const sum = numbers.reduce((a,b)=>a+b,0);
                const avg = sum / numbers.length;
                errorMsg.textContent = `Avec ces nombres, la moyenne vaut ${formatFR(avg)} : elle n'est pas au quart pr√®s, donc on ne pourra pas l'atteindre exactement avec des blocs ‚â• 1/4.`;
                errorMsg.classList.remove('hidden');
                return;
            }
state.initialValues = [...numbers];
            state.stacks = numbers.map(buildStackFromValue);
            state.history = []; 
            state.zoom = 1.0; // Reset du zoom au d√©marrage
            
            const totalSum = numbers.reduce((a, b) => a + b, 0);
            state.targetAverage = totalSum / numbers.length;
            state.isWin = false;

            const title = document.getElementById('header-title');
            title.textContent = "√âgaliser les piles";
            title.className = "text-slate-800 font-bold text-xl leading-tight w-full px-2 whitespace-normal"; 
            document.getElementById('header-subtitle').textContent = "D√©place ou coupe les blocs";
            document.getElementById('setup-modal').style.display = 'none';
            errorMsg.classList.add('hidden');
            
            setTool('hand');
            calculateFixedScale();
            checkWin(); // On v√©rifie tout de suite si c'est d√©j√† gagn√© (ex: 10 10)
            render(); 
        }

        function resetSetup() {
            document.getElementById('setup-modal').style.display = 'flex';
            document.getElementById('numbers-input').value = ""; 
            clearDrawings();
        }

        /* --- √âCHELLE & ZOOM --- */
        function calculateFixedScale() {
            const rect = container.getBoundingClientRect();
            
            // Hauteur max : on r√©duit drastiquement la marge pour utiliser l'espace vide du haut
            const maxVal = Math.max(...state.initialValues, 1);
            const scaleHeightInBlocks = maxVal + 0.8; 
            
            // Hauteur dispo : on r√©duit la marge fixe (header + padding bas)
            const bottomPad = 70; // marge pour les nombres en bas (mode projection toujours actif)
            const topPad = 20;
            const availableHeight = rect.height - (bottomPad + topPad);
            let sizeByHeight = Math.floor(availableHeight / scaleHeightInBlocks);

            // Largeur dispo
            const maxCol = Math.max(state.stacks.length, 1);
            const availableWidth = rect.width - 40;
            
            // √âCART : 1 bloc entier
            const gapFactor = 1.0;
            const totalUnitsWidth = maxCol + (maxCol - 1) * gapFactor;
            
            let sizeByWidth = Math.floor(availableWidth / totalUnitsWidth); 

            // Calcul de la taille de base "optimale" pour l'√©cran
            state.baseBlockSize = Math.min(400, sizeByWidth, sizeByHeight);
            
            // Application du zoom manuel par dessus
            state.blockSize = state.baseBlockSize * state.zoom;
            
            state.baseY = rect.height - bottomPad;

            const dpr = window.devicePixelRatio || 1;
            [canvasMain, canvasDraw].forEach(c => {
                c.width = rect.width * dpr;
                c.height = rect.height * dpr;
                c.style.width = rect.width + 'px';
                c.style.height = rect.height + 'px';
                c.getContext('2d').setTransform(dpr, 0, 0, dpr, 0, 0);
            });
            redrawStrokes();
        }

        function adjustZoom(delta) {
            state.zoom += delta;
            // Limites du zoom (0.5x √† 2.0x)
            state.zoom = Math.max(0.5, Math.min(state.zoom, 2.0));
            
            // Recalcul avec le nouveau zoom
            calculateFixedScale();
            render();
        }
        

        /* --- PLEIN √âCRAN --- */
        function toggleFullscreen() {
            try {
                if (!document.fullscreenElement) {
                    (document.documentElement.requestFullscreen || document.documentElement.webkitRequestFullscreen || document.documentElement.msRequestFullscreen).call(document.documentElement);
                } else {
                    (document.exitFullscreen || document.webkitExitFullscreen || document.msExitFullscreen).call(document);
                }
            } catch (e) {
                // Rien : certains navigateurs bloquent si ce n'est pas un clic utilisateur
            }
        }
        document.addEventListener('fullscreenchange', () => {
            const btn = document.getElementById('toggle-fullscreen');
            if (!btn) return;
            btn.classList.toggle('active', !!document.fullscreenElement);
        });

        window.addEventListener('resize', () => {
            if(state.stacks.length > 0) {
                calculateFixedScale();
                render();
            }
        });

        /* --- RENDU --- */
        function render() {
            const w = canvasMain.width / (window.devicePixelRatio || 1);
            const h = canvasMain.height / (window.devicePixelRatio || 1);
            ctxMain.clearRect(0, 0, w, h);

            // SOL (ligne au sol)
            const groundLW = 4; // mode projection toujours actif
            const groundY = state.baseY; // les blocs reposent ici
            const lineY = groundY + groundLW / 2; // ligne l√©g√®rement sous les blocs (√©vite que le trait "mange" la base)
            ctxMain.beginPath();
            ctxMain.moveTo(0, lineY);
            ctxMain.lineTo(w, lineY);
            ctxMain.strokeStyle = "#0f172a";
            ctxMain.lineWidth = groundLW;
            ctxMain.stroke();

            if (state.stacks.length === 0) return;

            const bs = state.blockSize;
            const gap = bs * 1.0; // √âCART : 1 bloc entier
            const totalWidth = state.stacks.length * bs + (state.stacks.length - 1) * gap;
            const startX = (w - totalWidth) / 2;

            state.stacks.forEach((stack, i) => {
                const x = startX + i * (bs + gap);
                let currentY = state.baseY;

                const totalHeight = stack.reduce((a,b) => a+b, 0);

                // Ombre
                if (totalHeight > 0) {
                    ctxMain.fillStyle = "rgba(0,0,0,0.1)";
                    ctxMain.beginPath();
                    ctxMain.ellipse(x + bs/2, state.baseY, bs * 0.45, 4, 0, 0, Math.PI * 2);
                    ctxMain.fill();
                }

                // Dessin des blocs
                stack.forEach((val, idx) => {
                    // Si drag, on cache l'original
                    if (state.dragging && state.dragging.sourceCol === i && idx === stack.length - 1) return;

                    const blockH = val * bs;
                    drawBlock(ctxMain, x, currentY - blockH, bs, blockH, getBlockColor(idx, val), val);
                    if (idx < stack.length - 1) {
                        ctxMain.beginPath();
                        ctxMain.moveTo(x + bs*0.08, currentY - blockH);
                        ctxMain.lineTo(x + bs*0.92, currentY - blockH);
                        ctxMain.strokeStyle = "rgba(15,23,42,0.25)";
                        ctxMain.lineWidth = state.projection ? 2 : 1;
                        ctxMain.stroke();
                    }
                    currentY -= blockH; 
                });

                
// Chiffre (sous le sol)
ctxMain.fillStyle = "#0f172a";
const fontSize = Math.min(38, Math.max(22, bs * 0.34));
ctxMain.font = `800 ${fontSize}px Fredoka`;
ctxMain.textAlign = "center";
ctxMain.textBaseline = "top";
const displayNum = totalHeight;
const labelY = Math.min(h - fontSize - 6, state.baseY + groundLW + 10);
ctxMain.fillText(formatFR(displayNum), x + bs/2, labelY);

});

            // Drag
            if (state.dragging) {
                const dragH = state.dragging.value * bs;
                ctxMain.shadowColor = "rgba(0,0,0,0.2)";
                ctxMain.shadowBlur = 20; ctxMain.shadowOffsetY = 20;
                drawBlock(ctxMain, state.dragging.currentX - bs/2, state.dragging.currentY - dragH/2, bs, dragH, "#3b82f6", state.dragging.value);
                ctxMain.shadowColor = "transparent"; ctxMain.shadowBlur = 0;
            }
        }

        function adjustHex(hex, amt) {
            const h = hex.replace('#','');
            const num = parseInt(h, 16);
            let r = (num >> 16) & 255;
            let g = (num >> 8) & 255;
            let b = num & 255;
            r = Math.min(255, Math.max(0, r + amt));
            g = Math.min(255, Math.max(0, g + amt));
            b = Math.min(255, Math.max(0, b + amt));
            return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }
        function getBlockColor(idx, val) {
            const base = "#60a5fa";
            let amt = (idx % 2 === 0) ? 10 : -10;
            if (val < 1) amt -= 10;
            return adjustHex(base, amt);
        }

        function drawBlock(ctx, x, y, width, height, color, val) {
            // Remplissage (l√©ger volume, mais sans "flou" ni halo)
            const grad = ctx.createLinearGradient(x, y, x, y + height);
            grad.addColorStop(0, adjustHex(color, 10));
            grad.addColorStop(1, adjustHex(color, -10));
            ctx.fillStyle = grad;

            // Arrondi adaptatif (moins arrondi si c'est une tranche fine)
            const r = Math.min(width * 0.12, height * 0.35);

            ctx.beginPath();
            ctx.roundRect(x, y, width, height, r);
            ctx.fill();

            // Contour net (plus franc au vid√©oprojecteur)
            ctx.lineJoin = "round";
            ctx.lineCap = "round";
            ctx.strokeStyle = "rgba(0,0,0,0.65)";
            ctx.lineWidth = 2.2;
            ctx.stroke();

            
            // Rep√®res visuels pour les fractions (texture nette, sans flou)
            if (val && val < 1) {
                ctx.save();
                ctx.beginPath();
                ctx.roundRect(x, y, width, height, r);
                ctx.clip();

                const baseAlpha = 0.34;
                ctx.strokeStyle = `rgba(0, 0, 0, ${baseAlpha})`;
                ctx.lineWidth = Math.max(1.4, Math.min(3.0, width * 0.02));

                const spacing = (val === 0.5)
                    ? Math.max(10, Math.min(26, width / 6))
                    : Math.max(8, Math.min(22, width / 8));

                // Hachures diagonales /
                for (let i = -height; i < width + height; i += spacing) {
                    ctx.beginPath();
                    ctx.moveTo(x + i, y + height);
                    ctx.lineTo(x + i + height, y);
                    ctx.stroke();
                }

                // Pour 1/4 : double hachure (croisillons discrets)
                if (val === 0.25) {
                    ctx.strokeStyle = `rgba(0, 0, 0, ${baseAlpha * 0.85})`;
                    for (let i = -height; i < width + height; i += spacing) {
                        ctx.beginPath();
                        ctx.moveTo(x + i, y);
                        ctx.lineTo(x + i + height, y + height);
                        ctx.stroke();
                    }
                }

                ctx.restore();
            }

// Relief par √©tage (traits nets, pas d'ombre floue)
            ctx.save();
            ctx.beginPath();
            ctx.roundRect(x, y, width, height, r);
            ctx.clip();

            // Liser√© de lumi√®re en haut
            ctx.strokeStyle = "rgba(255,255,255,0.35)";
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x + 1, y + 1);
            ctx.lineTo(x + width - 1, y + 1);
            ctx.stroke();

            // Liser√© d'ombre en bas
            ctx.strokeStyle = "rgba(0,0,0,0.20)";
            ctx.beginPath();
            ctx.moveTo(x + 1, y + height - 1);
            ctx.lineTo(x + width - 1, y + height - 1);
            ctx.stroke();

            ctx.restore();

            // Etiquette interne (¬Ω / ¬º) ‚Äî seulement si √ßa tient correctement
            if (val === 0.5 || val === 0.25) {
                const label = (val === 0.5) ? "¬Ω" : "¬º";
                const fontSize = Math.max(8, Math.min(height * 0.85, width * 0.22, 26));
                if (height >= 10 && width >= 28) {
                    ctx.save();
                    ctx.font = `700 ${fontSize}px Fredoka, Arial, sans-serif`;
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    const cx = x + width / 2;
                    const cy = y + height / 2;

                    // Contraste vid√©oprojecteur : blanc + contour sombre
                    ctx.lineWidth = Math.max(1.6, fontSize * 0.12);
                    ctx.strokeStyle = "rgba(0,0,0,0.55)";
                    ctx.fillStyle = "rgba(255,255,255,0.88)";
                    ctx.strokeText(label, cx, cy);
                    ctx.fillText(label, cx, cy);
                    ctx.restore();
                }
            }

        }

        /* --- LOGIQUE JEU --- */
        
        // Sauvegarde l'√©tat actuel dans l'historique
        function saveState() {
            // Copie profonde des piles pour ne pas garder la r√©f√©rence
            const stacksCopy = JSON.parse(JSON.stringify(state.stacks));
            state.history.push(stacksCopy);
            // On peut limiter l'historique si on veut (ex: 50 derniers coups), mais pas oblig√© ici.
        }

        function undo() {
            if (state.history.length === 0) return;
            
            // On r√©cup√®re le dernier √©tat
            const previousStacks = state.history.pop();
            state.stacks = previousStacks;
            
            // On v√©rifie la victoire au cas o√π on revient sur un √©tat gagnant
            checkWin();
            calculateFixedScale(); // On recalcule l'√©chelle au cas o√π les valeurs changent drastiquement
            render();
        }

        function getColFromX(x) {
            const w = canvasMain.width / (window.devicePixelRatio || 1);
            const bs = state.blockSize;
            const gap = bs * 1.0; // MAJ : 1 bloc d'√©cart
            const totalWidth = state.stacks.length * bs + (state.stacks.length - 1) * gap;
            const startX = (w - totalWidth) / 2;

            for (let i = 0; i < state.stacks.length; i++) {
                const colX = startX + i * (bs + gap);
                if (x >= colX && x <= colX + bs) return i;
            }
            return -1;
        }

        function handleStart(x, y) {
            if (state.isWin && state.tool !== 'pen') return;

            if (state.tool === 'pen') {
                startDraw({x,y});
                return;
            }

            const colIdx = getColFromX(x);
            if (colIdx === -1) return;
            
            const stack = state.stacks[colIdx];
            if (stack.length === 0) return;

            const bs = state.blockSize;
            const totalHeightVal = stack.reduce((a,b)=>a+b,0);
            const topY = state.baseY - totalHeightVal * bs;
            
            const lastVal = stack[stack.length - 1];
            const lastBlockHeight = lastVal * bs;
            
            // Hitbox sur le bloc du haut
            if (y >= topY && y <= topY + lastBlockHeight) {
                
                if (state.tool === 'hand') {
                    state.dragging = {
                        sourceCol: colIdx,
                        value: lastVal,
                        currentX: x, currentY: y
                    };
                } else if (state.tool === 'scissors') {
                    // On sauvegarde AVANT de couper
                    saveState();
                    cutBlock(colIdx);
                    checkWin();
                }
                render();
            }
        }

        function cutBlock(colIdx) {
            const stack = state.stacks[colIdx];
            const val = stack.pop(); 
            
            // VERROUILLAGE : Si c'est d√©j√† un quart (0.25) ou moins, on ne coupe plus !
            if (val <= 0.25) {
                stack.push(val); // On remet le bloc intact
                // On pourrait ajouter un son ou un effet visuel de "refus" ici
            } else {
                // Sinon on coupe en deux
                const half = val / 2;
                stack.push(half, half);
            }
        }

        function handleMove(x, y) {
            if (state.tool === 'pen') {
                draw({x,y});
                return;
            }
            if (state.dragging) {
                state.dragging.currentX = x;
                state.dragging.currentY = y;
                render();
            }
        }

        function handleEnd() {
            if (state.tool === 'pen') {
                stopDraw();
                return;
            }
            if (!state.dragging) return;
            
            const dropColIdx = getColFromX(state.dragging.currentX);
            
            if (dropColIdx !== -1) {
                if (dropColIdx !== state.dragging.sourceCol) {
                    // On sauvegarde AVANT de valider le d√©placement
                    saveState();
                    
                    state.stacks[state.dragging.sourceCol].pop();
                    state.stacks[dropColIdx].push(state.dragging.value);
                    checkWin();
                }
            }
            state.dragging = null;
            render();
        }

        function checkWin() {
            const heights = state.stacks.map(s => s.reduce((a,b)=>a+b,0));
            const first = heights[0];
            // Petite tol√©rance pour les calculs flottants (ex: 8.5 vs 8.49999)
            const allEqual = heights.every(h => Math.abs(h - first) < 1e-9);
            
            const title = document.getElementById('header-title');
            const sub = document.getElementById('header-subtitle');
            
            
if (allEqual) {
    state.isWin = true;
    const avg = first;
    title.classList.add('victory-text');

    const originalStr = state.initialValues.map(formatFR).join(' ; ');
    title.innerHTML = `BRAVO ! <span class="block">Moyenne = ${formatFR(avg)}</span>`;
    sub.innerText = `de ${originalStr}`;
} else {
                 state.isWin = false;
                 title.classList.remove('victory-text');
                 title.innerText = "√âgaliser les piles";
                 sub.innerText = `D√©place ou coupe les blocs`;
            }
        }

        /* --- OUTILS --- */
        function setTool(t) {
            state.tool = t;
            const handBtn = document.getElementById('tool-hand');
            const sciBtn = document.getElementById('tool-scissors');
            const penBtn = document.getElementById('tool-pen');

            handBtn.classList.remove('active', 'bg-slate-200');
            sciBtn.classList.remove('active-scissors', 'bg-amber-100');
            penBtn.classList.remove('active', 'bg-blue-100');
            
            canvasDraw.style.pointerEvents = (t === 'pen') ? 'auto' : 'none';

            if (t === 'hand') handBtn.classList.add('active', 'bg-slate-200');
            else if (t === 'scissors') sciBtn.classList.add('active-scissors', 'bg-amber-100');
            else {
                penBtn.classList.add('active', 'bg-blue-100');
                ctxDraw.strokeStyle = '#2563eb';
                ctxDraw.lineWidth = 4;
                ctxDraw.lineCap = 'round';
            }
        }
        /* --- INPUTS --- */
        function getPos(e) {
            const rect = container.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return { x: clientX - rect.left, y: clientY - rect.top };
        }
        // Gestion unifi√©e (souris / tactile / stylet) via Pointer Events quand dispo
        if (window.PointerEvent) {
            container.addEventListener('pointerdown', e => {
                e.preventDefault();
                const p = getPos(e);
                handleStart(p.x, p.y);
                // Capture pour continuer √† recevoir les mouvements m√™me si on sort du conteneur
                try { container.setPointerCapture(e.pointerId); } catch(_) {}
            }, { passive: false });

            container.addEventListener('pointermove', e => {
                e.preventDefault();
                const p = getPos(e);
                handleMove(p.x, p.y);
            }, { passive: false });

            const endPointer = e => {
                e.preventDefault();
                handleEnd();
            };
            container.addEventListener('pointerup', endPointer, { passive: false });
            container.addEventListener('pointercancel', endPointer, { passive: false });
        } else {
            // Fallback anciens navigateurs
            container.addEventListener('mousedown', e => handleStart(getPos(e).x, getPos(e).y));
            window.addEventListener('mousemove', e => handleMove(getPos(e).x, getPos(e).y));
            window.addEventListener('mouseup', handleEnd);

            container.addEventListener('touchstart', e => {
                const p = getPos(e); handleStart(p.x, p.y);
            }, {passive: false});
            container.addEventListener('touchmove', e => {
                e.preventDefault(); const p = getPos(e); handleMove(p.x, p.y);
            }, {passive: false});
            container.addEventListener('touchend', handleEnd);
        }

        /* --- DESSIN --- */
        let isDrawing = false;
        let lastDrawX = 0, lastDrawY = 0;
        let currentStroke = null;
        function startDraw(pos) {
            isDrawing = true;
            lastDrawX = pos.x; lastDrawY = pos.y;
            currentStroke = [{x:lastDrawX, y:lastDrawY}];
            ctxDraw.beginPath();
            ctxDraw.moveTo(lastDrawX, lastDrawY);
        }
        function draw(pos) {
            if (!isDrawing) return;
            ctxDraw.lineTo(pos.x, pos.y);
            ctxDraw.stroke();
            lastDrawX = pos.x; lastDrawY = pos.y;
            if (currentStroke) currentStroke.push({x:lastDrawX, y:lastDrawY});
        }
        function stopDraw() {
            if (isDrawing && currentStroke && currentStroke.length > 1) {
                state.drawStrokes.push(currentStroke);
            }
            currentStroke = null;
            isDrawing = false;
        }
        function redrawStrokes() {
            ctxDraw.clearRect(0, 0, canvasDraw.width, canvasDraw.height);
            // Style du stylo (mode projection toujours actif)
            ctxDraw.strokeStyle = "#2563eb";
            ctxDraw.lineWidth = 4;
            ctxDraw.lineCap = "round";
            state.drawStrokes.forEach(stroke => {
                if (!stroke || stroke.length < 2) return;
                ctxDraw.beginPath();
                ctxDraw.moveTo(stroke[0].x, stroke[0].y);
                for (let i = 1; i < stroke.length; i++) ctxDraw.lineTo(stroke[i].x, stroke[i].y);
                ctxDraw.stroke();
            });
        }
        function undoDraw() {
            if (isDrawing) return;
            if (state.drawStrokes.length === 0) return;
            state.drawStrokes.pop();
            redrawStrokes();
        }
        function clearDrawings() {
            state.drawStrokes = [];
            currentStroke = null;
            ctxDraw.clearRect(0, 0, canvasDraw.width, canvasDraw.height);
        }

    </script>
</body>
</html>
