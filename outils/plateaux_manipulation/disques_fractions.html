<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Plateau – Disques de fractions</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;800&display=swap" rel="stylesheet">

  <style>

    :root{
      --diskD: 240;          /* diamètre d'un disque */
      --boardBg: #ffffff;    /* plateau blanc */
    }

    body{
      font-family: 'Fredoka', sans-serif;
      background: #ffffff;
      overflow: hidden;
      touch-action: none;
      user-select: none;
      -webkit-user-select: none;
    }

    #board-container{
      position: absolute;
      inset: 0;
      overflow: hidden;
      cursor: grab;
      background: var(--boardBg);
    }
    #board-container.panning{ cursor: grabbing; }

    /* PATCH D3 : rectangle de sélection (marquee) */
    .marquee-box{
      position: absolute;
      border: 1px dashed rgba(59,130,246,0.9);
      background: rgba(59,130,246,0.10);
      pointer-events: none;
      z-index: 9998;
      box-sizing: border-box;
    }


    #board-world{
      position: absolute;
      top: 0; left: 0;
      transform-origin: 0 0;
      width: 0; height: 0;
    }

    #drawing-canvas{
      position: absolute;
      top: 0; left: 0;
      pointer-events: none;
      z-index: 999999; /* toujours au-dessus des disques */
    }

    /* En mode stylo : évite scroll/zoom navigateur (tablette/stylet) */
    #board-container.pen-active{
      touch-action: none;
    }

    .no-scrollbar::-webkit-scrollbar{ display:none; }
    .no-scrollbar{ -ms-overflow-style:none; scrollbar-width:none; }

    /* --- Disques / pièces --- */
    .strip{
      /* anneau de sélection */
      --selRing: 0 0 0 0 rgba(59,130,246,0);

      position: absolute;
      border-radius: 9999px;
      box-shadow: var(--selRing);

      cursor: grab;
      touch-action: none;
      transform-origin: 0 0;
      overflow: visible;
      box-sizing: border-box;
      border: none;
      perspective: 900px;
      background: transparent;
    }
    .strip.dragging{ cursor: grabbing; z-index: 2000 !important; }
    /* Sélection : désormais gérée par le tracé SVG (.sel-outline) pour TOUS les types
       (y compris les disques), afin que le contour bleu suive aussi l'animation de retournement. */
    /* .strip.is-disk.selected{ --selRing: 0 0 0 3px rgba(59,130,246,0.85); } */

    @keyframes snapPop{
      0%{ transform: scale(1); }
      55%{ transform: scale(1.05); }
      100%{ transform: scale(1); }
    }
    .strip.snap-pop{ animation: snapPop 160ms ease-out; transform-origin: 50% 50%; }

    /* --- Animation de retournement --- */
    .strip-inner{
      position: relative;
      width: 100%;
      height: 100%;
      flex: 1 1 auto;
      transform-style: preserve-3d;
      transition: transform 820ms cubic-bezier(0.22, 0.8, 0.2, 1);
    }
    .strip.is-back .strip-inner{ transform: rotateX(180deg); }

    .face{
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      backface-visibility: hidden;
      -webkit-backface-visibility: hidden;
    }
    .face-back{ transform: rotateX(180deg); }

    .token-svg{ width: 100%; height: 100%; display:block; overflow: visible; }
    .sel-outline{ opacity: 0; transition: opacity 120ms ease; }
    .strip.selected .sel-outline{ opacity: 1; }

    /* Ghost drag depuis menu */
    .strip.ghost{
      position: fixed;
      pointer-events: none;
      opacity: 0.96;
      z-index: 9998;
      box-shadow: 0 22px 38px rgba(0,0,0,0.30);
      transform: scale(0.98);
      transition: transform 120ms ease-out, opacity 120ms ease-out;
    }
    .strip.ghost.ready{ transform: scale(1); }

    .strip.spawn-pop{ animation: popIn 140ms ease-out; }
    @keyframes popIn{ from{ transform: scale(0.92); } to{ transform: scale(1); } }

    /* fraction verticale (utilisée dans le menu) */
    .frac{
      display: inline-flex;
      flex-direction: column;
      align-items: center;
      line-height: 1;
      transform: translateY(-1px);
      filter: drop-shadow(0 1px 0 rgba(255,255,255,0.35));
    }
    .frac .num, .frac .den{ font-weight: 700; }
    .frac .bar{
      width: 1.2em;
      height: 2px;
      background: rgba(0,0,0,0.65);
      border-radius: 2px;
      /* + d'espace sous la barre (le dénominateur ne doit pas être collé) */
      margin: 3px 0 6px 0;
    }
    .frac .den{ margin-top: 1px; }

    /* Ajustement spécifique pour les fractions dans le menu (dénominateur un peu plus proche) */
    .frac.menu .bar{ margin: 3px 0 4px 0; }
    .frac.menu .den{ margin-top: 0px; transform: translateY(-1px); }

    .back-one{
      font-weight: 800;
      font-size: 1.35rem;
      text-shadow: 0 2px 0 rgba(255,255,255,0.35);
    }

    /* --- Menu gauche (palette) --- */
    .palette-item{
      padding: 6px 8px;
      border-radius: 12px;
      transition: none;
    }
    .palette-item:hover{ background: transparent; }

    .spawn-tile{
      height: 44px;
      width: 44px;
      flex: 0 0 auto;
      flex-shrink: 0;
      position: relative;
      border-radius: 9999px;
      border: none;
      overflow: visible;
      display: flex;
      cursor: grab;
      box-shadow:
        0 4px 10px rgba(0,0,0,0.18);
      user-select: none;
      touch-action: none;
      background: transparent;
    }
    .spawn-tile:active{ cursor: grabbing; }

    .spawn-tile .mini-svg{ width: 44px; height: 44px; display:block; }

    .frac.menu{ transform: none; filter: none; font-size: inherit; }
    .frac.menu .bar{ width: 0.9em; height: 2px; margin: 3px 0 4px 0; background: rgba(0,0,0,0.70); }
    .frac.menu .den{ margin-top: 0px; transform: translateY(-1px); }

    /* poignées de rotation (sur les secteurs) */
    .rotate-handle{ opacity: 0; transition: opacity 120ms ease; cursor: grab; }
    .strip.selected .rotate-handle{ opacity: 1; }

    /* outils */
    #custom-cursor{ position: fixed; pointer-events:none; z-index: 9999; display:none; transform: translate(-50%, -50%); }
    .hide-cursor, .hide-cursor * { cursor: none !important; }

    /* Boutons de mode actifs */
    .mode-btn.active {
      background-color: #ffffff;
      color: #1d4ed8;
      box-shadow: 0 1px 2px rgba(0,0,0,0.1);
      border-color: #bfdbfe;
    }
    .mode-btn {
      color: #64748b;
      border: 1px solid transparent;
    }
    .mode-btn:hover:not(.active) {
      background-color: #f1f5f9;
      color: #475569;
    }

    @media (max-width: 640px){
      :root{ --diskD: 220; }
    }

  
    /* Curseur fermé pendant le drag depuis le menu (évite le retour en 'grab' sur le plateau) */
    body.menu-dragging, body.menu-dragging * { cursor: grabbing !important; }
</style>
</head>

<body class="h-screen w-screen flex flex-col">

  <div id="custom-cursor">
    <!-- Curseur "petite croix" pour le mode stylo -->
    <svg class="drop-shadow" width="20" height="20" viewBox="0 0 20 20" fill="none" aria-hidden="true">
      <path d="M10 2 V18" stroke="#1d4ed8" stroke-width="2.5" stroke-linecap="round"/>
      <path d="M2 10 H18" stroke="#1d4ed8" stroke-width="2.5" stroke-linecap="round"/>
    </svg>
  </div>

  <header class="bg-blue-50 p-2 shadow-md z-30 flex flex-wrap items-center gap-3 shrink-0">
    <div class="flex items-center gap-2">
      <button id="btn-undo" class="bg-blue-100 text-blue-700 hover:bg-blue-200 p-2 rounded-lg font-bold border border-blue-200 shadow-sm active:scale-95 transition" title="Annuler">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6" />
        </svg>
      </button>

      <button id="btn-clear" class="bg-rose-100 text-rose-700 hover:bg-rose-200 p-2 rounded-lg font-bold border border-rose-200 shadow-sm active:scale-95 transition" title="Tout effacer">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
        </svg>
      </button>

      <div class="h-8 w-px bg-slate-200 mx-1"></div>

      <button id="btn-zoom-out" class="bg-slate-100 hover:bg-slate-200 text-slate-800 px-3 py-2 rounded-lg border border-slate-200 font-bold active:scale-95 transition" title="Zoom -">−</button>
      <button id="btn-zoom-in" class="bg-slate-100 hover:bg-slate-200 text-slate-800 px-3 py-2 rounded-lg border border-slate-200 font-bold active:scale-95 transition" title="Zoom +">+</button>
      <button id="btn-reset-view" class="bg-slate-100 hover:bg-slate-200 text-slate-800 px-3 py-2 rounded-lg border border-slate-200 font-bold active:scale-95 transition" title="Recentrer">⤾</button>
      
      <div class="h-8 w-px bg-slate-200 mx-1"></div>

      <div class="flex items-center bg-slate-100 p-1 rounded-lg border border-slate-200">
        <button id="mode-frac"    class="mode-btn px-2 py-1.5 rounded-md text-xs font-bold transition-all active:scale-95" title="Fraction (1/2)">1/2</button>
        <button id="mode-word"    class="mode-btn px-2 py-1.5 rounded-md text-xs font-bold transition-all active:scale-95" title="Lettres (un demi)">Abc</button>
        <button id="mode-percent" class="mode-btn px-2 py-1.5 rounded-md text-xs font-bold transition-all active:scale-95" title="Pourcentage (50%)">%</button>
        <button id="mode-angle"   class="mode-btn px-2 py-1.5 rounded-md text-xs font-bold transition-all active:scale-95" title="Angle (180°)">Angle</button>
        <button id="mode-empty"   class="mode-btn px-2 py-1.5 rounded-md text-xs font-bold transition-all active:scale-95" title="Vide (pas de texte)">Vide</button>
      </div>
    </div>

    <div id="selection-actions" class="flex items-center gap-2">
      
      <button id="btn-hide-label" disabled class="bg-indigo-500 hover:bg-indigo-600 disabled:bg-indigo-200 text-white px-2 py-1 rounded-lg shadow-sm border border-indigo-200 disabled:opacity-40 disabled:cursor-not-allowed active:scale-95 transition flex flex-col items-center gap-0.5" title="Masquer/Afficher l'écriture">
        <svg id="icon-eye-open" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display:block">
          <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
          <circle cx="12" cy="12" r="3"></circle>
        </svg>
        <svg id="icon-eye-closed" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display:none">
          <path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"></path>
          <line x1="1" y1="1" x2="23" y2="23"></line>
        </svg>
        <span class="text-[10px] font-extrabold leading-none">Masquer</span>
      </button>

      <button id="btn-flip" disabled class="bg-amber-500 hover:bg-amber-600 disabled:bg-amber-200 text-white px-2 py-1 rounded-lg shadow-sm border border-amber-200 disabled:opacity-40 disabled:cursor-not-allowed active:scale-95 transition flex flex-col items-center gap-0.5" title="Retourner (double-clic aussi)">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M3 12a9 9 0 0 1 9-9"/>
          <path d="M3 4v8h8"/>
          <path d="M21 12a9 9 0 0 1-9 9"/>
          <path d="M21 20v-8h-8"/>
        </svg>
        <span class="text-[10px] font-extrabold leading-none">Retourner</span>
      </button>

      <button id="btn-separate" disabled class="bg-blue-600 hover:bg-blue-700 disabled:bg-blue-200 text-white px-2 py-1 rounded-lg shadow-sm border border-blue-200 disabled:opacity-40 disabled:cursor-not-allowed active:scale-95 transition flex flex-col items-center gap-0.5" title="Séparer le disque en secteurs">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M4 4l16 16"/>
          <path d="M4 20L20 4"/>
        </svg>
        <span class="text-[10px] font-extrabold leading-none">Séparer</span>
      </button>

      <button id="btn-cut" disabled class="bg-slate-700 hover:bg-slate-800 disabled:bg-slate-200 text-white px-2 py-1 rounded-lg shadow-sm border border-slate-200 disabled:opacity-40 disabled:cursor-not-allowed active:scale-95 transition flex flex-col items-center gap-0.5" title="Couper en 2 (si le double existe)">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="6" cy="6" r="2"/>
          <circle cx="6" cy="18" r="2"/>
          <path d="M20 4L8.12 15.88"/>
          <path d="M14.47 14.48L20 20"/>
          <path d="M8.12 8.12L12 12"/>
        </svg>
        <span class="text-[10px] font-extrabold leading-none">Couper</span>
      </button>

      <button id="btn-fuse" disabled class="bg-violet-600 hover:bg-violet-700 disabled:bg-violet-200 text-white px-2 py-1 rounded-lg shadow-sm border border-violet-200 disabled:opacity-40 disabled:cursor-not-allowed active:scale-95 transition flex flex-col items-center gap-0.5" title="Fusionner : secteurs alignés (D4) + somme vers 1/2 ou unité (D5)">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M10 13a5 5 0 0 1 0-7l1-1a5 5 0 0 1 7 7l-1 1"/>
          <path d="M14 11a5 5 0 0 1 0 7l-1 1a5 5 0 0 1-7-7l1-1"/>
        </svg>
        <span class="text-[10px] font-extrabold leading-none">Fusionner</span>
      </button>

      <button id="btn-duplicate" disabled class="bg-emerald-600 hover:bg-emerald-700 disabled:bg-emerald-200 text-white px-2 py-1 rounded-lg shadow-sm border border-emerald-200 disabled:opacity-40 disabled:cursor-not-allowed active:scale-95 transition flex flex-col items-center gap-0.5" title="Dupliquer">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <rect x="9" y="9" width="13" height="13" rx="2"/>
          <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
        </svg>
        <span class="text-[10px] font-extrabold leading-none">Dupliquer</span>
      </button>

      <button id="btn-delete" disabled class="bg-rose-600 hover:bg-rose-700 disabled:bg-rose-200 text-white px-2 py-1 rounded-lg shadow-sm border border-rose-200 disabled:opacity-40 disabled:cursor-not-allowed active:scale-95 transition flex flex-col items-center gap-0.5" title="Supprimer">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
        </svg>
        <span class="text-[10px] font-extrabold leading-none">Supprimer</span>
      </button>
    </div>

    <div class="flex items-center gap-1 bg-gray-100 p-1 rounded-lg">
      <button id="tool-hand" class="p-2 rounded bg-white shadow text-gray-700" title="Main (déplacer / sélectionner)">
        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 11.5V14m0-2.5v-6a1.5 1.5 0 113 0m-3 6a1.5 1.5 0 00-3 0v2a7.5 7.5 0 0015 0v-5a1.5 1.5 0 00-3 0m-6-3V11m0-5.5v-1a1.5 1.5 0 013 0v1m0 0V11m0-5.5a1.5 1.5 0 013 0v3m0 0V11"/></svg>
      </button>
      <button id="tool-pen" class="p-2 rounded text-gray-500 hover:bg-gray-200" title="Stylo (annoter)">
        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" aria-hidden="true">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 20h9"/>
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16.5 3.5a2.1 2.1 0 0 1 3 3L8 18l-4 1 1-4 11.5-11.5z"/>
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 5l4 4"/>
        </svg>
    </button>
      <button id="btn-clear-drawing" class="p-2 rounded text-rose-500 hover:bg-rose-50" title="Effacer les annotations">
        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/></svg>
      </button>
    </div>

    <div class="ml-auto flex items-center gap-2">
      <div id="global-controls" class="flex items-center gap-2">
        <button id="btn-session" class="bg-slate-100 hover:bg-slate-200 text-slate-700 rounded-lg px-3 py-2 text-xs font-extrabold border border-slate-200 shadow-sm active:scale-95 transition" title="Séances (enregistrer / charger)">
          Séance
        </button>
        <button id="btn-help" class="bg-slate-100 hover:bg-slate-200 text-slate-700 rounded-lg px-3 py-2 text-xs font-extrabold border border-slate-200 shadow-sm active:scale-95 transition" title="Aide (F1 / ?)">
          Aide
        </button>
        <button id="btn-sound" class="bg-slate-100 hover:bg-slate-200 text-slate-700 rounded-lg px-3 py-2 text-xs font-extrabold border border-slate-200 shadow-sm active:scale-95 transition" title="Son ON/OFF">
          Son : ON
        </button>
        <button id="btn-fullscreen" class="bg-slate-100 hover:bg-slate-200 text-slate-700 rounded-lg px-3 py-2 text-xs font-extrabold border border-slate-200 shadow-sm active:scale-95 transition" title="Plein écran">
          <span class="inline-flex items-center gap-1.5">
            <svg id="ico-fs-enter" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="w-4 h-4" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" style="width:16px;height:16px">
              <path d="M8 3H5a2 2 0 0 0-2 2v3"/>
              <path d="M16 3h3a2 2 0 0 1 2 2v3"/>
              <path d="M8 21H5a2 2 0 0 1-2-2v-3"/>
              <path d="M16 21h3a2 2 0 0 0 2-2v-3"/>
            </svg>
            <svg id="ico-fs-exit" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="w-4 h-4 hidden" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" style="width:16px;height:16px">
              <path d="M5 5l4 4"/>
              <path d="M9 9H7"/>
              <path d="M9 9V7"/>

              <path d="M19 5l-4 4"/>
              <path d="M15 9h2"/>
              <path d="M15 9V7"/>

              <path d="M5 19l4-4"/>
              <path d="M9 15H7"/>
              <path d="M9 15v2"/>

              <path d="M19 19l-4-4"/>
              <path d="M15 15h2"/>
              <path d="M15 15v2"/>
            </svg>
            <span id="lbl-fullscreen">Plein écran</span>
          </span>
        
        </button>
      </div>

      
    </div>

  </header>

  <div class="flex flex-1 overflow-hidden relative">

    <aside id="sidebar" class="w-[270px] bg-blue-50 border-r border-blue-200 flex flex-col cursor-grab py-4 gap-3 z-20 shadow-lg shrink-0 overflow-y-auto no-scrollbar">
      <div class="px-3"></div>
      <div id="palette" class="px-3 flex flex-col gap-3"></div>
</aside>

    <main class="flex-1 relative overflow-hidden">
      <div id="board-container">
        <div id="board-world">
          <canvas id="drawing-canvas"></canvas>
        </div>
      </div>
    </main>

  </div>



  <!-- Modales (Aide / Séance) -->
  <div id="modal-help" class="fixed inset-0 z-50 hidden">
    <div class="absolute inset-0 bg-black/40" data-close="modal-help"></div>
    <div class="relative mx-auto mt-16 w-[min(92vw,720px)] bg-white rounded-2xl shadow-2xl border border-slate-200 overflow-hidden">
      <div class="flex items-center justify-between px-4 py-3 bg-slate-50 border-b border-slate-200">
        <div class="font-extrabold text-slate-800">Aide</div>
        <button id="btn-close-help" class="px-3 py-1.5 rounded-lg bg-slate-100 hover:bg-slate-200 border border-slate-200 text-slate-700 text-xs font-extrabold">Fermer (Esc)</button>
      </div>
      <div class="p-4 text-sm text-slate-700 leading-relaxed space-y-3">
        <div class="text-slate-600">
          Raccourcis (clavier) :
        </div>
        <ul class="list-disc pl-5 space-y-1">
          <li><b>Ctrl/Cmd + Z</b> : annuler la dernière action (Undo)</li>
          <li><b>Suppr / Backspace</b> : supprimer la sélection</li>
          <li><b>Échap</b> : fermer cette aide / fermer “Séance” / désélectionner</li>
          <li><b>D</b> : dupliquer la sélection</li>
          <li><b>1</b> : créer l’unité (si dispo)</li>
          <li><b>2,3,4,5,6,8</b> : créer une pièce 1/n (si dispo)</li>
          <li><b>0</b> : créer 1/10 (si dispo)</li>
          <li><b>F1</b> ou <b>?</b> : ouvrir/fermer l’aide</li>
        </ul>

        <div class="text-slate-600">
          Souris / gestes :
        </div>
        <ul class="list-disc pl-5 space-y-1">
          <li><b>Molette</b> : zoom (centré sur le pointeur)</li>
          <li><b>Glisser sur le fond</b> : déplacer le plateau</li>
          <li><b>Double-clic</b> sur un disque/secteur : retourner</li>
        </ul>

        <div class="text-[12px] text-slate-500">
          Note : la “Séance” sauvegarde les objets + la caméra (pan/zoom) + quelques états (son, mode d’étiquettes). Le dessin crayon sera ajouté plus tard (PATCH D2).
        </div>
      </div>
    </div>
  </div>

  <div id="modal-session" class="fixed inset-0 z-50 hidden">
    <div class="absolute inset-0 bg-black/40" data-close="modal-session"></div>
    <div class="relative mx-auto mt-16 w-[min(92vw,820px)] bg-white rounded-2xl shadow-2xl border border-slate-200 overflow-hidden">
      <div class="flex items-center justify-between px-4 py-3 bg-slate-50 border-b border-slate-200">
        <div class="font-extrabold text-slate-800">Séance</div>
        <button id="btn-close-session" class="px-3 py-1.5 rounded-lg bg-slate-100 hover:bg-slate-200 border border-slate-200 text-slate-700 text-xs font-extrabold">Fermer (Esc)</button>
      </div>

      <div class="p-4 text-sm text-slate-700 space-y-4">
        <div class="grid grid-cols-1 md:grid-cols-3 gap-3">
          <div class="md:col-span-1 space-y-2">
            <div class="text-xs font-extrabold text-slate-500 uppercase">Séances enregistrées</div>
            <select id="session-select" class="w-full p-2 rounded-lg border border-slate-200 bg-white">
              <option value="">(aucune)</option>
            </select>
            <div id="session-meta" class="text-[12px] text-slate-500"></div>
          </div>

          <div class="md:col-span-2 space-y-2">
            <div class="text-xs font-extrabold text-slate-500 uppercase">Enregistrer / Charger</div>

            <div class="flex flex-col sm:flex-row gap-2">
              <input id="session-name" type="text" class="flex-1 p-2 rounded-lg border border-slate-200" placeholder="Nom de séance (ex : 5e - exo 3)">
              <button id="btn-session-save" class="px-3 py-2 rounded-lg bg-emerald-600 hover:bg-emerald-700 text-white text-xs font-extrabold shadow-sm">Enregistrer</button>
            </div>

            <div class="flex flex-wrap gap-2">
              <button id="btn-session-load" class="px-3 py-2 rounded-lg bg-indigo-600 hover:bg-indigo-700 text-white text-xs font-extrabold shadow-sm">Charger</button>
              <button id="btn-session-delete" class="px-3 py-2 rounded-lg bg-rose-600 hover:bg-rose-700 text-white text-xs font-extrabold shadow-sm">Supprimer</button>
              <div class="w-px bg-slate-200 mx-1 hidden sm:block"></div>
              <button id="btn-session-export" class="px-3 py-2 rounded-lg bg-slate-100 hover:bg-slate-200 border border-slate-200 text-slate-700 text-xs font-extrabold shadow-sm">Exporter JSON</button>
              <button id="btn-session-import" class="px-3 py-2 rounded-lg bg-slate-100 hover:bg-slate-200 border border-slate-200 text-slate-700 text-xs font-extrabold shadow-sm">Importer JSON</button>
            </div>

            <div class="text-[12px] text-slate-500">
              Stockage : navigateur (localStorage) + import/export fichier JSON.
              <span class="text-slate-400">Le dessin crayon n’est pas inclus pour l’instant.</span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <input id="session-import-file" type="file" accept="application/json" class="hidden" />
  </div>
<script>

  // --- Configuration couleurs ---
  const FRACTIONS = [
    { denom: 1,  name: 'Unité',     color: '#fff7e6', border: '#cbd5e1', text: '#111827' },
    { denom: 2,  name: 'Demi',      color: '#facc15', border: '#a16207', text: '#111827' },
    { denom: 3,  name: 'Tiers',     color: '#e9d5ff', border: '#7c3aed', text: '#111827' },
    { denom: 4,  name: 'Quart',     color: '#84cc16', border: '#3f6212', text: '#111827' },
    { denom: 5,  name: 'Cinquième', color: '#38bdf8', border: '#075985', text: '#0b1220' },
    { denom: 6,  name: 'Sixième',   color: '#f97316', border: '#9a3412', text: '#111827' },
    { denom: 8,  name: 'Huitième',  color: '#f472b6', border: '#be185d', text: '#111827' },
    { denom: 10, name: 'Dixième',   color: '#b91c1c', border: '#7f1d1d', text: '#111827' },
  ];

  // Audio (optionnel) – protège si indisponible
  let audioCtx = null;
  try{ audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }catch(_){ audioCtx = null; }

  // Son ON/OFF
  let SOUND_ENABLED = true;

  function playSound(type){
    if (!audioCtx) return;
    if (!SOUND_ENABLED) return;
    if (audioCtx.state === 'suspended') audioCtx.resume().catch(()=>{});
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain); gain.connect(audioCtx.destination);
    const now = audioCtx.currentTime;
    const stop = (t)=>{ try{ osc.stop(t); }catch(_){} };
    if(type==='pop'){
      osc.type='sine';
      osc.frequency.setValueAtTime(320, now);
      osc.frequency.exponentialRampToValueAtTime(560, now+0.08);
      gain.gain.setValueAtTime(0.10, now);
      gain.gain.linearRampToValueAtTime(0, now+0.10);
      osc.start(now); stop(now+0.10);
    } else if(type==='flip'){
      osc.type='triangle';
      osc.frequency.setValueAtTime(210, now);
      osc.frequency.linearRampToValueAtTime(440, now+0.16);
      gain.gain.setValueAtTime(0.10, now);
      gain.gain.linearRampToValueAtTime(0, now+0.18);
      osc.start(now); stop(now+0.18);
    } else if(type==='whoosh'){
      osc.type='triangle';
      osc.frequency.setValueAtTime(360, now);
      osc.frequency.exponentialRampToValueAtTime(60, now+0.22);
      gain.gain.setValueAtTime(0.06, now);
      gain.gain.linearRampToValueAtTime(0, now+0.22);
      osc.start(now); stop(now+0.22);
    }
  }

  class FractionDisksApp {
    constructor(){
      this.history = [];
      // token: {id, denom, kind:'disk'|'piece', side:'front'|'back', x,y, rot?, slot?, hideLabel?, _el}
      this.tokens = [];
      this.nextId = 1;
      this.selectedId = null;
      this.selectedIds = new Set();
      this._suppressClickUntil = 0;
      this._isMarquee = false;
      this._marqueeEl = null;
      this._marqueeStartClient = null;


      // Ordre d'empilement (z-index dynamique : la dernière pièce manipulée reste au-dessus)
      this.zTop = 0;

      this.scale = 1;
      this.pan = {x: 0, y: 0};
      this.isPanning = false;
      this.panStart = {x:0, y:0};

      this.currentTool = 'hand';
      this.isDrawing = false;
      this.lastDrawPos = {x:0,y:0};

      // PATCH D2 : crayon pro (strokes + pointer events + rAF)
      this.strokes = [];                 // [{color,width,pts:[[x,y,p?],...]}]
      this._activeStroke = null;
      this._drawQueue = [];
      this._drawRAF = 0;
      this._drawCache = null;            // {left,top,panX,panY,scale}
      this._activeDrawPointerId = null;
      this._lastStrokePt = {x:0,y:0};


      // Modes: 'frac' | 'word' | 'percent' | 'angle' | 'empty'
      this.labelMode = 'frac';

      // Drag depuis le menu (ghost)
      this.spawnDrag = null;
      this._lastSpawnClient = {x:0, y:0};
      // Dernière position connue du curseur (pour zoom centré au pointeur)
      this.lastPointerClient = {x: 0, y: 0};
      // Curseur forcé pendant un drag depuis le menu (évite le retour à la flèche au survol du menu)
      this._bodyCursorPrev = '';


      // ---- PATCH D1 : état UI / modales / séances ----
      this.soundEnabled = true;
      this.SESSIONS_KEY = 'fraction_disks_sessions_v1';
      this.PREFS_KEY = 'fraction_disks_prefs_v1';
      this._helpOpen = false;
      this._sessionOpen = false;


      this.boardContainer = document.getElementById('board-container');
      this.boardWorld = document.getElementById('board-world');
      this.palette = document.getElementById('palette');

      this.canvas = document.getElementById('drawing-canvas');
      this.ctx = this.canvas.getContext('2d');

      this.DENOM_SET = new Set(FRACTIONS.map(f => f.denom));

      this.buildPalette();
      this.initUI();
      // PATCH D1 : prefs (son)
      const prefs = this._loadPrefs();
      if(typeof prefs.soundEnabled === 'boolean') this.setSoundEnabled(!!prefs.soundEnabled, true);
      this.initBoardListeners();
      this.resizeCanvas();
      this.updateTransform();
      this.updateSelectionUI();
      this.setLabelMode('frac'); // set initial UI state
    }

    // ---- Dimensions ----
    get diskD(){ return parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--diskD')) || 240; }
    tokenDims(_t){ return { w: this.diskD, h: this.diskD }; }

    // ---- Historique ----
    saveState(){
      const snapshot = {
        tokens: this.tokens.map(t => ({
          id:t.id, denom:t.denom, kind:t.kind, side:t.side, x:t.x, y:t.y, z: (typeof t.z === 'number') ? t.z : null,
          rot: (typeof t.rot === 'number') ? t.rot : 0,
          slot: (typeof t.slot === 'number') ? t.slot : null,
          hideLabel: !!t.hideLabel
        })),
        nextId: this.nextId,
        selectedId: this.selectedId,
        pan: {...this.pan},
        scale: this.scale,
      };
      this.history.push(snapshot);
      if(this.history.length > 30) this.history.shift();
    }

    undo(){
      const snap = this.history.pop();
      if(!snap) return;
      this.clearAllTokens(false);
      this.tokens = snap.tokens.map(t => ({...t}));
      this.nextId = snap.nextId;
      this.selectedId = snap.selectedId;
      this.pan = snap.pan;
      this.scale = snap.scale;

      // Réinitialise l'empilement
      this.zTop = Math.max(0, ...this.tokens.map(t => (typeof t.z === 'number') ? t.z : 0));
      this.tokens.forEach(t => this.mountToken(t));
      this.updateTransform();
      this.updateSelectionUI();
      playSound('whoosh');
    }

    // ---- Palette ----

    buildPalette(){
      this.palette.innerHTML = '';
      FRACTIONS.forEach(f => {
        const row = document.createElement('div');
        row.className = 'palette-item';

        const line = document.createElement('div');
        line.className = 'flex items-center gap-3';

        const picks = document.createElement('div');
        picks.className = 'flex items-center gap-3 flex-nowrap';

        picks.appendChild(this.makeSpawnTile(f.denom, 'disk'));
        if(f.denom !== 1) picks.appendChild(this.makeSpawnTile(f.denom, 'piece'));

        const label = document.createElement('div');
        label.className = 'text-sm font-extrabold text-slate-700 flex items-center gap-2 select-none';
        label.innerHTML = this._menuFractionHTML(f.denom);

        line.appendChild(picks);
        line.appendChild(label);
        row.appendChild(line);
        this.palette.appendChild(row);
      });
    }

    _menuFractionHTML(denom){
      // Empty: on cache totalement le texte du menu
      if(this.labelMode === 'empty'){
        return ``;
      }

      if(this.labelMode === 'percent'){
        const val = (100 / denom);
        // parseFloat retire les zéros inutiles (.00)
        const txt = parseFloat(val.toFixed(2)) + '%';
        return `<span class="font-extrabold">${txt}</span>`;
      }

      if(this.labelMode === 'angle'){
        const val = (360 / denom);
        // "arrondis au 10e" -> 1 chiffre après la virgule
        const txt = Number(val.toFixed(1)) + '°'; 
        return `<span class="font-extrabold">${txt}</span>`;
      }

      if(this.labelMode === 'word'){
        if(denom === 1) return `<span class="font-extrabold">1</span>`;
        return `<span class="font-extrabold">${this.wordInlineForDenom(denom)}</span>`;
      }
      
      // Frac mode
      if(denom === 1) return `<span class="font-extrabold">1</span>`;
      return `<span class="frac menu"><span class="num">1</span><span class="bar"></span><span class="den">${denom}</span></span>`;
    }

    wordInlineForDenom(denom){
      if(denom === 1) return '1';
      const map = {
        2: 'demi',
        3: 'tiers',
        4: 'quart',
        5: 'cinquième',
        6: 'sixième',
        8: 'huitième',
        10:'dixième'
      };
      const w = map[denom] || `${denom}e`;
      return `un ${w}`;
    }

    wordLinesForDenom(denom){
      if(denom === 1) return ['1'];
      const inline = this.wordInlineForDenom(denom);
      const parts = inline.split(' ');
      if(parts.length >= 2) return [parts[0], parts.slice(1).join(' ')];
      return [inline];
    }

    // Gestion du mode d'affichage
    setLabelMode(mode){
      this.labelMode = mode;
      this.updateModeButtonsUI();
      this.buildPalette(); // Rebuild menu labels
      this.updateSidebarWidth(); // Menu adaptatif selon le mode d'affichage
      // Update tokens on board
      for(const t of this.tokens){
        if(t._el) this._renderToken(t);
      }
    }

    updateModeButtonsUI(){
      const modes = ['frac','word','percent','angle','empty'];
      modes.forEach(m => {
        const btn = document.getElementById(`mode-${m}`);
        if(btn){
          if(m === this.labelMode) btn.classList.add('active');
          else btn.classList.remove('active');
        }

      });
    }

    updateSidebarWidth(){
      const sb = document.getElementById('sidebar');
      if(!sb) return;
      const isWide = (this.labelMode === 'word');
      const w = isWide ? 250 : 230; // px (ABC un peu plus large pour eviter le retour a la ligne)
      sb.style.width = w + 'px';
      sb.style.minWidth = w + 'px';
    }


    getFractionConfig(denom){
      return FRACTIONS.find(f => f.denom === denom) || FRACTIONS[0];
    }

    fontSizeFor(denom, kind){
      if(kind === 'piece'){
        if(denom >= 10) return 14; 
        if(denom === 9)  return 15;
        if(denom === 8)  return 17;
        if(denom === 7)  return 17;
        if(denom === 6)  return 18;
        if(denom === 5)  return 19;
        if(denom === 4)  return 20;
        if(denom === 3)  return 21;
        if(denom === 2)  return 22;
        return 18;
      }
      if(denom >= 10) return 13;
      if(denom === 9)  return 14;
      if(denom === 8)  return 15;
      if(denom === 7)  return 16;
      if(denom === 6)  return 17;
      if(denom === 5)  return 17;
      if(denom === 4)  return 18;
      if(denom === 3)  return 19;
      if(denom === 2)  return 20;
      return 17;
    }

    // --- Géométrie ---
    _startAngleRad(){ return -Math.PI/2; }

    _normAngle0to2pi(a){
      const two = Math.PI*2;
      a = a % two;
      if(a < 0) a += two;
      return a;
    }

    _angleInArc(angle, start, end){
      // Compare en [0,2pi)
      const a = this._normAngle0to2pi(angle);
      const s = this._normAngle0to2pi(start);
      const e = this._normAngle0to2pi(end);
      if(s <= e) return a >= s && a <= e;
      return a >= s || a <= e;
    }

    _sectorPath(cx, cy, r, start, end){
      const p1x = cx + r*Math.cos(start);
      const p1y = cy + r*Math.sin(start);
      const p2x = cx + r*Math.cos(end);
      const p2y = cy + r*Math.sin(end);
      const delta = this._normAngle0to2pi(end - start);
      const largeArc = delta > Math.PI ? 1 : 0;
      return `M ${cx} ${cy} L ${p1x} ${p1y} A ${r} ${r} 0 ${largeArc} 1 ${p2x} ${p2y} Z`;
    }

    _fractionSVG(denom, x, y, fs, color){
      const barW = fs * 1.05;
      if(denom === 1){
        return `
          <g font-family="Fredoka, sans-serif" text-anchor="middle" font-weight="800">
            <text x="${x}" y="${y+1}" font-size="${fs*1.15}" fill="rgba(255,255,255,0.35)">1</text>
            <text x="${x}" y="${y}"   font-size="${fs*1.15}" fill="${color}">1</text>
          </g>
        `;
      }
      // PATCH D6 : chiffres plus proches de la barre
      const numY = y - fs*0.44;
      const barY = y - fs*0.03;
      const denY = y + fs*0.98;
      return `
        <g font-family="Fredoka, sans-serif" text-anchor="middle" font-weight="800">
          <text x="${x}" y="${numY+1}" font-size="${fs}" fill="rgba(255,255,255,0.35)">1</text>
          <text x="${x}" y="${numY}"   font-size="${fs}" fill="${color}">1</text>

          <line x1="${x-barW/2}" y1="${barY+1}" x2="${x+barW/2}" y2="${barY+1}" stroke="rgba(255,255,255,0.35)" stroke-width="2" stroke-linecap="round" />
          <line x1="${x-barW/2}" y1="${barY}"   x2="${x+barW/2}" y2="${barY}"   stroke="rgba(0,0,0,0.70)" stroke-width="2" stroke-linecap="round" />

          <text x="${x}" y="${denY+1}" font-size="${fs}" fill="rgba(255,255,255,0.35)">${denom}</text>
          <text x="${x}" y="${denY}"   font-size="${fs}" fill="${color}">${denom}</text>
        </g>
      `;
    }

    _wordSVG(denom, x, y, fs, color){
      if(denom === 1){
        return this._fractionSVG(1, x, y, fs, color);
      }
      const lines = this.wordLinesForDenom(denom);
      const sf = (denom >= 10) ? 0.62 : (denom >= 8) ? 0.66 : (denom >= 6) ? 0.70 : (denom >= 5) ? 0.74 : 0.82;
      const f = fs * sf;

      if(lines.length === 1){
        const t = lines[0];
        return `
          <g font-family="Fredoka, sans-serif" text-anchor="middle" font-weight="900" style="pointer-events:none">
            <text x="${x}" y="${y+1}" font-size="${f}" fill="rgba(255,255,255,0.35)">${t}</text>
            <text x="${x}" y="${y}"   font-size="${f}" fill="${color}">${t}</text>
          </g>
        `;
      }
      const l1 = lines[0];
      const l2 = lines[1];
      const y1 = y - f*0.12;
      const y2 = y + f*0.98;
      return `
        <g font-family="Fredoka, sans-serif" text-anchor="middle" font-weight="900" style="pointer-events:none">
          <text x="${x}" y="${y1+1}" font-size="${f}" fill="rgba(255,255,255,0.35)">${l1}</text>
          <text x="${x}" y="${y1}"   font-size="${f}" fill="${color}">${l1}</text>
          <text x="${x}" y="${y2+1}" font-size="${f}" fill="rgba(255,255,255,0.35)">${l2}</text>
          <text x="${x}" y="${y2}"   font-size="${f}" fill="${color}">${l2}</text>
        </g>
      `;
    }

    _textSVG(txt, x, y, fs, color){
      // Helper pour afficher du texte simple (%, angle)
      // On réduit un peu la police si c'est long
      const str = String(txt);
      let f = fs;
      if(str.length >= 6) f = fs * 0.75;
      else if(str.length >= 4) f = fs * 0.85;

      return `
        <g font-family="Fredoka, sans-serif" text-anchor="middle" font-weight="900" style="pointer-events:none">
          <text x="${x}" y="${y+1}" font-size="${f}" fill="rgba(255,255,255,0.35)">${str}</text>
          <text x="${x}" y="${y}"   font-size="${f}" fill="${color}">${str}</text>
        </g>
      `;
    }

    _labelSVG(denom, x, y, fs, color){
      if(this.labelMode === 'empty') return '';

      if(this.labelMode === 'word'){
        return this._wordSVG(denom, x, y, fs, color);
      }
      if(this.labelMode === 'percent'){
        const val = (100 / denom);
        // parseFloat retire les .00
        const txt = parseFloat(val.toFixed(2)) + '%'; 
        return this._textSVG(txt, x, y, fs, color);
      }
      if(this.labelMode === 'angle'){
        const val = (360 / denom);
        // arrondi au 10e
        const txt = Number(val.toFixed(1)) + '°';
        return this._textSVG(txt, x, y, fs, color);
      }
      // default: frac
      return this._fractionSVG(denom, x, y, fs, color);
    }

    _tokenSVGMarkup(token, face){
      const D = this.diskD;
      const R = D/2;
      const cx = R, cy = R;
      const cfg = this.getFractionConfig(token.denom);
      const border = 'rgba(0,0,0,0.55)';
      const fs = this.fontSizeFor(token.denom, token.kind);
      const start = this._startAngleRad();
      const step = (token.denom > 0) ? (Math.PI*2/token.denom) : (Math.PI*2);

      const isBackFace = (face === 'back');
      // Pour l'affichage de la valeur
      const showDen = token.denom;

      // Logique spécifique pour le verso (le '1')
      const getBackLabel = () => {
        if(this.labelMode === 'empty') return '';
        if(this.labelMode === 'percent') return '100%';
        if(this.labelMode === 'angle') return '360°';
        return 1;
      };

      if(token.kind === 'disk'){
        let lines = '';
        let labels = '';

        const circle = `<circle cx="${cx}" cy="${cy}" r="${R-0.8}" fill="${cfg.color}" stroke="${border}" stroke-width="1.2" />`;

        if(!isBackFace && token.denom > 1){
          // traits
          for(let k=0;k<token.denom;k++){
            const a = start + k*step;
            const x2 = cx + (R-2)*Math.cos(a);
            const y2 = cy + (R-2)*Math.sin(a);
            lines += `<line x1="${cx}" y1="${cy}" x2="${x2}" y2="${y2}" stroke="rgba(0,0,0,0.28)" stroke-width="1" stroke-dasharray="6 4" stroke-linecap="round" />`;
          }
          // étiquettes (seulement si non masquées par le bouton Oeil)
          if(!token.hideLabel){
            // Rapprocher le texte du centre pour les demis (denom=2)
            let rr = R * 0.62;
            if(token.denom === 2) rr = R * 0.45;
            for(let i=0;i<token.denom;i++){
              const mid = start + (i+0.5)*step;
              const tx = cx + rr*Math.cos(mid);
              const ty = cy + rr*Math.sin(mid);
              labels += this._labelSVG(showDen, tx, ty, fs, cfg.text);
            }
          }
        } else {
          // verso (ou denom=1)
          if(!token.hideLabel){
            const bl = getBackLabel();
            if(bl !== ''){
               if(typeof bl === 'number') labels += this._labelSVG(bl, cx, cy, Math.max(16, fs*1.25), cfg.text);
               else labels += this._textSVG(bl, cx, cy, Math.max(16, fs*1.25), cfg.text);
            }
          }
        }

        return `
          <svg class="token-svg" viewBox="0 0 ${D} ${D}" xmlns="http://www.w3.org/2000/svg">
            ${circle}
            ${lines}
            ${labels}
            <circle class="sel-outline" cx="${cx}" cy="${cy}" r="${R-2}" fill="none" stroke="rgba(59,130,246,0.85)" stroke-width="4" />
          </svg>
        `;
      }

      // piece
      const rotDeg = (typeof token.rot === 'number') ? token.rot : 0;
      const rotRad = rotDeg * Math.PI/180;
      const a0 = start + rotRad;
      const a1 = a0 + step;
      const path = this._sectorPath(cx, cy, R-1.2, a0, a1);
      const mid = a0 + step/2;
      
      // MODIFICATION ICI : Rapprochement du centre pour les demis (denom=2)
      let rr = R * 0.62;
      if(token.denom === 2) rr = R * 0.45;

      const tx = cx + rr*Math.cos(mid);
      const ty = cy + rr*Math.sin(mid);

      const handleR = 5.2;
      const hrH = R - 14;
      const h1x = cx + hrH*Math.cos(a0);
      const h1y = cy + hrH*Math.sin(a0);
      const h2x = cx + hrH*Math.cos(a1);
      const h2y = cy + hrH*Math.sin(a1);
      const handles = `
        <circle class="rotate-handle" data-handle="a0" cx="${h1x}" cy="${h1y}" r="${handleR}" fill="rgba(255,255,255,0.95)" stroke="rgba(0,0,0,0.55)" stroke-width="1.2" />
        <circle class="rotate-handle" data-handle="a1" cx="${h2x}" cy="${h2y}" r="${handleR}" fill="rgba(255,255,255,0.95)" stroke="rgba(0,0,0,0.55)" stroke-width="1.2" />
      `;

      let pieceLabel = '';
      if(!token.hideLabel){
         pieceLabel = this._labelSVG(showDen, tx, ty, fs, cfg.text);
      }

      return `
        <svg class="token-svg" viewBox="0 0 ${D} ${D}" xmlns="http://www.w3.org/2000/svg">
          <path d="${path}" fill="${cfg.color}" stroke="${border}" stroke-width="1.2" />
          <path class="sel-outline" d="${path}" fill="none" stroke="rgba(59,130,246,0.85)" stroke-width="4" stroke-linejoin="round" />
          ${pieceLabel}
          ${handles}
        </svg>
      `;
    }

    makeSpawnTile(denom, kind){
      const cfg = this.getFractionConfig(denom);
      const tile = document.createElement('div');
      tile.className = `spawn-tile ${kind==='disk' ? 'spawn-disk' : 'spawn-piece'}`;
      tile.setAttribute('draggable', 'false');
      tile.title = (kind === 'disk') ? 'Ajouter un disque' : 'Ajouter une pièce';

      // mini preview
      const D = 44;
      const R = D/2;
      const cx = R, cy = R;
      const start = -Math.PI/2;
      const step = (denom > 0) ? (Math.PI*2/denom) : (Math.PI*2);

      let inner = '';
      if(kind === 'disk'){
        inner += `<circle cx="${cx}" cy="${cy}" r="${R-1.1}" fill="${cfg.color}" stroke="rgba(0,0,0,0.55)" stroke-width="1.2" />`;
        if(denom > 1){
          for(let k=0;k<denom;k++){
            const a = start + k*step;
            const x2 = cx + (R-2)*Math.cos(a);
            const y2 = cy + (R-2)*Math.sin(a);
            inner += `<line x1="${cx}" y1="${cy}" x2="${x2}" y2="${y2}" stroke="rgba(0,0,0,0.20)" stroke-width="1" stroke-dasharray="4 3" />`;
          }
        }
      } else {
        const a0 = start;
        const a1 = start + step;
        const path = this._sectorPath(cx, cy, R-1.5, a0, a1);
        inner += `<circle cx="${cx}" cy="${cy}" r="${R-1.1}" fill="rgba(255,255,255,0)" stroke="rgba(0,0,0,0.10)" stroke-width="1" />`;
        inner += `<path d="${path}" fill="${cfg.color}" stroke="rgba(0,0,0,0.55)" stroke-width="1.2" />`;
      }

      tile.innerHTML = `
        <svg class="mini-svg" viewBox="0 0 ${D} ${D}" xmlns="http://www.w3.org/2000/svg">
          ${inner}
        </svg>
      `;

      const startFn = (e) => this.startSpawnDrag(e, denom, kind);
      tile.addEventListener('mousedown', startFn);
      tile.addEventListener('touchstart', startFn, {passive:false});
      return tile;
    }

    buildGhostToken(denom, kind){
      const el = document.createElement('div');
      el.className = 'strip ghost';
      const t = {id:-1, denom, kind, side:'front', x:0, y:0, rot:0};
      el.innerHTML = `
        <div class="strip-inner">
          <div class="face face-front">${this._tokenSVGMarkup(t,'front')}</div>
          <div class="face face-back">${this._tokenSVGMarkup(t,'back')}</div>
        </div>
      `;
      return el;
    }

    startSpawnDrag(e, denom, kind){
      if(e.type === 'mousedown' && e.button !== 0) return;
      e.preventDefault();
      e.stopPropagation();

      const pt = e.touches ? e.touches[0] : e;
      const cx = pt.clientX;
      const cy = pt.clientY;
      this._lastSpawnClient = {x: cx, y: cy};

      const wWorld = this.diskD;
      const hWorld = this.diskD;
      const w = wWorld * this.scale;
      const h = hWorld * this.scale;

      const ghost = this.buildGhostToken(denom, kind);
      ghost.style.width = `${w}px`;
      ghost.style.height = `${h}px`;
      ghost.style.left = `${cx - w/2}px`;
      ghost.style.top  = `${cy - h/2}px`;
      document.body.appendChild(ghost);
      requestAnimationFrame(() => ghost.classList.add('ready'));

      this.spawnDrag = { denom, kind, start: {x: cx, y: cy}, moved: false, ghost, w, h };
      // Force un curseur « grab » partout pendant le drag (sinon, sur le menu ça redevient la flèche)
      this._bodyCursorPrev = document.body.style.cursor || '';
      document.body.style.cursor = 'grabbing';
      document.body.classList.add('menu-dragging');


      const move = (ev) => this.onSpawnMove(ev);
      const end  = (ev) => this.onSpawnEnd(ev, move, end);
      document.addEventListener('mousemove', move);
      document.addEventListener('mouseup', end);
      document.addEventListener('touchmove', move, {passive:false});
      document.addEventListener('touchend', end);
      document.addEventListener('touchcancel', end);
    }

    onSpawnMove(ev){
      const sd = this.spawnDrag;
      if(!sd) return;
      ev.preventDefault();

      const pt = ev.touches ? ev.touches[0] : ev;
      const cx = pt.clientX;
      const cy = pt.clientY;
      this._lastSpawnClient = {x: cx, y: cy};

      const dist = Math.hypot(cx - sd.start.x, cy - sd.start.y);
      if(dist > 6) sd.moved = true;

      sd.ghost.style.left = `${cx - sd.w/2}px`;
      sd.ghost.style.top  = `${cy - sd.h/2}px`;
    }

    onSpawnEnd(ev, moveFn, endFn){
      const sd = this.spawnDrag;
      if(!sd) return;

      document.removeEventListener('mousemove', moveFn);
      document.removeEventListener('mouseup', endFn);
      document.removeEventListener('touchmove', moveFn);
      document.removeEventListener('touchend', endFn);
      document.removeEventListener('touchcancel', endFn);

      const cx = (ev.changedTouches && ev.changedTouches[0]) ? ev.changedTouches[0].clientX : this._lastSpawnClient.x;
      const cy = (ev.changedTouches && ev.changedTouches[0]) ? ev.changedTouches[0].clientY : this._lastSpawnClient.y;

      const br = this.boardContainer.getBoundingClientRect();
      const insideBoard = (cx >= br.left && cx <= br.right && cy >= br.top && cy <= br.bottom);

      if(insideBoard){
        const p = this.getWorldPos(cx, cy);
        const created = this.addToken({denom: sd.denom, kind: sd.kind, x: p.x, y: p.y});
        created._pointerWorld = p;
        this.snapToken(created, {silent:true});
      } else if(!sd.moved){
        const center = this.getWorldPos(br.left + br.width*0.5, br.top + br.height*0.35);
        this.addToken({denom: sd.denom, kind: sd.kind, x: center.x, y: center.y});
      }

      if(sd.ghost) sd.ghost.remove();
      // Restaure le curseur après le drag depuis le menu
      document.body.classList.remove('menu-dragging');
      document.body.style.cursor = this._bodyCursorPrev || '';
      this._bodyCursorPrev = '';

      this.spawnDrag = null;
    }

    // ---- Plateau / transformation ----
    updateTransform(){
      this.boardWorld.style.transform = `translate(${this.pan.x}px, ${this.pan.y}px) scale(${this.scale})`;
    }

    _getZoomFocus(){
      const r = this.boardContainer.getBoundingClientRect();
      const lp = this.lastPointerClient || {x: r.left + r.width/2, y: r.top + r.height/2};
      const inside = lp.x >= r.left && lp.x <= r.right && lp.y >= r.top && lp.y <= r.bottom;
      return inside ? lp : {x: r.left + r.width/2, y: r.top + r.height/2};
    }

    setZoom(z, clientX=null, clientY=null){
      const oldScale = this.scale;
      const newScale = Math.min(Math.max(0.45, z), 3);
      if(newScale === oldScale) return;

      // Zoom centré sur le pointeur (si fourni) : garde le point sous le curseur au même endroit à l'écran
      if(typeof clientX === 'number' && typeof clientY === 'number'){
        const r = this.boardContainer.getBoundingClientRect();
        const wx = (clientX - r.left - this.pan.x) / oldScale;
        const wy = (clientY - r.top  - this.pan.y) / oldScale;
        this.scale = newScale;
        this.pan.x = (clientX - r.left) - wx * newScale;
        this.pan.y = (clientY - r.top)  - wy * newScale;
      }else{
        this.scale = newScale;
      }

      this.updateTransform();
    }

    resetView(){
      this.pan = {x:0, y:0};
      this.scale = 1;
      this.updateTransform();
    }

    getWorldPos(clientX, clientY){
      const r = this.boardContainer.getBoundingClientRect();
      return {
        x: (clientX - r.left - this.pan.x) / this.scale,
        y: (clientY - r.top - this.pan.y) / this.scale,
      };
    }

    // ---- UI ----
    _bind(id, evt, fn){
      const el = document.getElementById(id);
      if(!el){
        // console.warn(`[UI] Élément manquant: #${id} (listener ${evt} ignoré)`);
        return null;
      }
      el.addEventListener(evt, fn);
      return el;
    }

    initUI(){
      this._bind('btn-undo','click', () => this.undo());
      this._bind('btn-clear','click', () => this.resetAll());
      this._bind('btn-zoom-in','click', () => { const f = this._getZoomFocus(); this.setZoom(this.scale + 0.15, f.x, f.y); });
      this._bind('btn-zoom-out','click', () => { const f = this._getZoomFocus(); this.setZoom(this.scale - 0.15, f.x, f.y); });
      this._bind('btn-reset-view','click', () => this.resetView());
      
      // Modes
      this._bind('mode-frac', 'click', () => this.setLabelMode('frac'));
      this._bind('mode-word', 'click', () => this.setLabelMode('word'));
      this._bind('mode-percent', 'click', () => this.setLabelMode('percent'));
      this._bind('mode-angle', 'click', () => this.setLabelMode('angle'));
      this._bind('mode-empty', 'click', () => this.setLabelMode('empty'));

      // Actions selection
      this._bind('btn-hide-label', 'click', () => this.toggleTokenLabel());
      this._bind('btn-flip','click', () => this.flipSelected());
      this._bind('btn-separate','click', () => this.separateSelected());
      this._bind('btn-cut','click', () => this.cutSelected());
      this._bind('btn-fuse','click', () => this.fuseSelected());
      this._bind('btn-duplicate','click', () => this.duplicateSelected());
      this._bind('btn-delete','click', () => this.deleteSelected());

      this._bind('tool-hand','click', () => this.setTool('hand'));
      this._bind('tool-pen','click', () => this.setTool('pen'));
      this._bind('btn-clear-drawing','click', () => this.clearDrawing());


      // PATCH D1 : nouveaux boutons
      this._bind('btn-session','click', () => this.toggleSessionModal());
      this._bind('btn-help','click', () => this.toggleHelpModal());
      this._bind('btn-sound','click', () => this.toggleSound());
      this._bind('btn-fullscreen','click', () => this.toggleFullscreen());

      // Modales : clic hors panneau = fermer
      this._bindModalBackdropClose('modal-help');
      this._bindModalBackdropClose('modal-session');

      // Import fichier JSON
      this._bind('btn-session-import','click', () => this._triggerImportFile());
      const f = document.getElementById('session-import-file');
      if(f){
        f.addEventListener('change', () => this._handleImportFile(f));
      }

      // Prépare la liste des séances
      this.refreshSessionSelect();
      this.updateSoundUI();
      this.updateFullscreenUI();
      document.addEventListener('fullscreenchange', () => this.updateFullscreenUI());

      window.addEventListener('keydown', (e) => {
        if(this._shouldIgnoreKey(e)) return;

        const k = e.key;

        // Aide (F1 / ?)
        if(k === 'F1' || k === '?'){
          e.preventDefault();
          this.toggleHelpModal();
          return;
        }

        // Escape : ferme modales sinon désélectionne
        if(k === 'Escape'){
          if(this._closeAnyModal()){
            e.preventDefault();
            return;
          }
          this.selectToken(null);
          return;
        }

        // Undo (PATCH D2 : en mode stylo, Ctrl/Cmd+Z annule le dernier trait)
        if((e.ctrlKey || e.metaKey) && !e.shiftKey && k.toLowerCase() === 'z'){
          e.preventDefault();
          if(this.currentTool === 'pen' && Array.isArray(this.strokes) && this.strokes.length){
            this.undoDrawing();
          }else{
            this.undo();
          }
          return;
        }

        // Delete selection
        if(k === 'Delete' || k === 'Backspace'){
          e.preventDefault();
          this.deleteSelected();
          return;
        }

        // Dupliquer
        if(!e.ctrlKey && !e.metaKey && !e.altKey && k.toLowerCase() === 'd'){
          e.preventDefault();
          this.duplicateSelected();
          return;
        }

        // Raccourcis "chiffres" (AZERTY-friendly) : création rapide
        if(!e.ctrlKey && !e.metaKey && !e.altKey){
          // AZERTY-friendly : on utilise la touche physique (e.code) plutôt que le caractère (e.key)
          const code = e.code || '';
          const digit = code.startsWith('Digit') ? code.slice(5) : (code.startsWith('Numpad') ? code.slice(6) : null);
          if(!digit){
            // pas une touche numérique : ne pas interférer avec les autres raccourcis
          }else{

          const p = this._getKeyboardSpawnPos();

          // 1 => unité (disque)
          if(digit === '1'){
            if(this.DENOM_SET.has(1)) this.addToken({denom: 1, kind: 'disk', x: p.x, y: p.y});
            return;
          }

          // 0 => 1/10 (pièce)
          if(digit === '0'){
            if(this.DENOM_SET.has(10)) this.addToken({denom: 10, kind: 'piece', x: p.x, y: p.y});
            return;
          }

          // 2,3,4,5,6,8 => pièce 1/n
          const map = { '2':2, '3':3, '4':4, '5':5, '6':6, '8':8 };
          if(map[digit]){
            const d = map[digit];
            if(this.DENOM_SET.has(d)) this.addToken({denom: d, kind: 'piece', x: p.x, y: p.y});
            return;
          }
        } // fin else(digit)
      } // fin if(!ctrl/meta/alt)
        });
    }

    // ---- PATCH D1 : Helpers clavier ----
    _shouldIgnoreKey(e){
      const t = e.target;
      if(!t) return false;
      const tag = (t.tagName || '').toUpperCase();
      // Ne pas voler les touches quand on tape dans un champ
      if(tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return true;
      if(t.isContentEditable) return true;
      return false;
    }

    _getKeyboardSpawnPos(){
      // Place les créations clavier au centre visible du plateau (coordonnées monde)
      const r = this.boardContainer.getBoundingClientRect();
      const cx = r.left + r.width/2;
      const cy = r.top  + r.height/2;
      return this.getWorldPos(cx, cy);
    }


    // ---- PATCH D1 : Modales (Aide / Séance) ----
    _getModal(id){ return document.getElementById(id); }

    _setModalOpen(id, open){
      const m = this._getModal(id);
      if(!m) return;
      m.classList.toggle('hidden', !open);
      if(id === 'modal-help') this._helpOpen = open;
      if(id === 'modal-session') this._sessionOpen = open;
    }

    _closeAnyModal(){
      if(this._helpOpen){ this._setModalOpen('modal-help', false); return true; }
      if(this._sessionOpen){ this._setModalOpen('modal-session', false); return true; }
      return false;
    }

    toggleHelpModal(){
      const open = !this._helpOpen;
      if(open && this._sessionOpen) this._setModalOpen('modal-session', false);
      this._setModalOpen('modal-help', open);
    }

    toggleSessionModal(){
      const open = !this._sessionOpen;
      if(open && this._helpOpen) this._setModalOpen('modal-help', false);
      this._setModalOpen('modal-session', open);
      if(open) this.refreshSessionSelect();
    }

    _bindModalBackdropClose(modalId){
      const m = this._getModal(modalId);
      if(!m) return;
      m.addEventListener('click', (e) => {
        const tgt = e.target;
        if(tgt && tgt.dataset && tgt.dataset.close === modalId){
          this._setModalOpen(modalId, false);
        }
      });
      if(modalId === 'modal-help'){
        const b = document.getElementById('btn-close-help');
        if(b) b.addEventListener('click', () => this._setModalOpen('modal-help', false));
      }
      if(modalId === 'modal-session'){
        const b = document.getElementById('btn-close-session');
        if(b) b.addEventListener('click', () => this._setModalOpen('modal-session', false));
      }
    }

    // ---- PATCH D1 : Son ON/OFF ----
    _loadPrefs(){
      try{
        const raw = localStorage.getItem(this.PREFS_KEY);
        if(!raw) return {};
        const o = JSON.parse(raw);
        return (o && typeof o === 'object') ? o : {};
      }catch(_){ return {}; }
    }

    _savePrefs(p){
      try{ localStorage.setItem(this.PREFS_KEY, JSON.stringify(p||{})); }catch(_){}
    }

    setSoundEnabled(on, silent=false){
      this.soundEnabled = !!on;
      // variable globale utilisée par playSound()
      try{ SOUND_ENABLED = this.soundEnabled; }catch(_){}
      this.updateSoundUI();
      const prefs = this._loadPrefs();
      prefs.soundEnabled = this.soundEnabled;
      this._savePrefs(prefs);
      if(!silent) playSound('pop');
    }

    toggleSound(){
      this.setSoundEnabled(!this.soundEnabled);
    }

    updateSoundUI(){
      const b = document.getElementById('btn-sound');
      if(!b) return;
      b.textContent = this.soundEnabled ? 'Son : ON' : 'Son : OFF';
      b.classList.toggle('bg-rose-100', !this.soundEnabled);
      b.classList.toggle('text-rose-700', !this.soundEnabled);
    }

    // ---- PATCH D1 : Plein écran ----
    async toggleFullscreen(){
      try{
        if(!document.fullscreenElement){
          await document.documentElement.requestFullscreen();
        }else{
          await document.exitFullscreen();
        }
      }catch(_){}
      this.updateFullscreenUI();
    }

    updateFullscreenUI(){
      const b = document.getElementById('btn-fullscreen');
      if(!b) return;
      const on = !!document.fullscreenElement;

      const lbl = document.getElementById('lbl-fullscreen');
      const enter = document.getElementById('ico-fs-enter');
      const exit = document.getElementById('ico-fs-exit');

      // Texte volontairement court et constant (évite d’élargir le menu)
      if(lbl) lbl.textContent = 'Plein écran';

      if(enter) enter.classList.toggle('hidden', on);
      if(exit) exit.classList.toggle('hidden', !on);

      b.title = on ? 'Quitter plein écran' : 'Plein écran';
      b.setAttribute('aria-label', b.title);
      b.setAttribute('aria-pressed', on ? 'true' : 'false');
    }

    // ---- PATCH D1 : Séances (localStorage + JSON import/export) ----
    _loadSessionsStore(){
      try{
        const raw = localStorage.getItem(this.SESSIONS_KEY);
        if(!raw) return {};
        const obj = JSON.parse(raw);
        return (obj && typeof obj === 'object') ? obj : {};
      }catch(_){ return {}; }
    }

    _saveSessionsStore(store){
      try{ localStorage.setItem(this.SESSIONS_KEY, JSON.stringify(store||{})); }catch(_){}
    }

    serializeSession(){
      return {
        version: 2,
        app: 'disques_fractions',
        savedAt: new Date().toISOString(),
        labelMode: this.labelMode,
        soundEnabled: this.soundEnabled,
        pan: {...this.pan},
        scale: this.scale,
        nextId: this.nextId,
        tokens: this.tokens.map(t => ({
          id: t.id,
          z: (typeof t.z === 'number') ? t.z : null,
          denom: t.denom,
          kind: t.kind,
          side: t.side,
          x: t.x, y: t.y,
          rot: (typeof t.rot === 'number') ? t.rot : 0,
          slot: (typeof t.slot === 'number') ? t.slot : null,
          hideLabel: !!t.hideLabel
        })),
        drawing: { strokes: Array.isArray(this.strokes) ? this.strokes : [] }
      };
    }

    applySession(data, opts={}){
      const withHistory = (opts.withHistory !== false);
      if(!data || !Array.isArray(data.tokens)) return false;

      if(withHistory) this.saveState();

      // Ne touche pas au moteur de bordures / rendu : on remonte les tokens via mountToken()
      this.clearAllTokens(false);

      this.tokens = data.tokens.map(t => ({...t}));
      // nextId : fallback si absent
      const maxId = Math.max(0, ...this.tokens.map(t => Number(t.id)||0));
      this.nextId = Number(data.nextId) || (maxId + 1);

      // Empilement
      this.zTop = Math.max(0, ...this.tokens.map(t => (typeof t.z === 'number') ? t.z : 0));

      // Monte les éléments DOM
      this.tokens.forEach(t => this.mountToken(t));

      // Caméra
      this.pan = (data.pan && typeof data.pan === 'object') ? {...data.pan} : {x:0,y:0};
      this.scale = (typeof data.scale === 'number') ? data.scale : 1;

      // États UI
      const lm = data.labelMode || 'frac';
      this.setLabelMode(lm);
      if(typeof data.soundEnabled === 'boolean') this.setSoundEnabled(data.soundEnabled, true);


      // PATCH D2 : restaure les annotations si présentes
      if(data.drawing && Array.isArray(data.drawing.strokes)){
        // clone léger pour éviter d'écrire dans la source
        this.strokes = data.drawing.strokes.map(s => ({
          color: s.color,
          width: s.width,
          pts: Array.isArray(s.pts) ? s.pts.map(p => [p[0], p[1], p[2]||0]) : []
        }));
      }else{
        this.strokes = [];
      }
      this.redrawAllStrokes();

      this.selectToken(null);
      this.updateTransform();
      this.updateSelectionUI();
      playSound('whoosh');
      return true;
    }

    saveSessionAs(name){
      const n = (name || '').trim();
      if(!n) return false;

      const store = this._loadSessionsStore();
      store[n] = {
        meta: { name: n, updatedAt: new Date().toISOString() },
        data: this.serializeSession()
      };
      this._saveSessionsStore(store);
      this.refreshSessionSelect(n);
      return true;
    }

    loadSessionByName(name){
      const store = this._loadSessionsStore();
      const rec = store[name];
      if(!rec || !rec.data) return false;
      return this.applySession(rec.data, {withHistory:true});
    }

    deleteSessionByName(name){
      const store = this._loadSessionsStore();
      if(!store[name]) return false;
      delete store[name];
      this._saveSessionsStore(store);
      this.refreshSessionSelect('');
      return true;
    }

    refreshSessionSelect(preselectName=''){
      const sel = document.getElementById('session-select');
      const meta = document.getElementById('session-meta');
      if(!sel) return;

      const store = this._loadSessionsStore();
      const names = Object.keys(store).sort((a,b)=>a.localeCompare(b,'fr'));

      sel.innerHTML = '';
      const opt0 = document.createElement('option');
      opt0.value = '';
      opt0.textContent = names.length ? '(sélectionner...)' : '(aucune)';
      sel.appendChild(opt0);

      for(const n of names){
        const o = document.createElement('option');
        o.value = n;
        o.textContent = n;
        sel.appendChild(o);
      }

      // préselection
      if(preselectName && names.includes(preselectName)){
        sel.value = preselectName;
      }

      const updateMeta = () => {
        const v = sel.value;
        if(!meta) return;
        if(!v || !store[v] || !store[v].meta){
          meta.textContent = '';
          return;
        }
        const dt = store[v].meta.updatedAt || '';
        meta.textContent = dt ? `Dernière maj : ${dt.replace('T',' ').replace('Z','')}` : '';
      };
      sel.addEventListener('change', updateMeta);
      updateMeta();

      // Bind boutons (une seule fois, safe)
      const btnSave = document.getElementById('btn-session-save');
      const btnLoad = document.getElementById('btn-session-load');
      const btnDel  = document.getElementById('btn-session-delete');
      const btnExp  = document.getElementById('btn-session-export');
      const nameInp = document.getElementById('session-name');

      if(btnSave && !btnSave._bound){
        btnSave._bound = true;
        btnSave.addEventListener('click', () => {
          const nm = nameInp ? nameInp.value : '';
          const finalName = (nm && nm.trim()) ? nm.trim() : prompt('Nom de la séance ?', '');
          if(!finalName) return;
          this.saveSessionAs(finalName);
          if(nameInp) nameInp.value = finalName;
          playSound('pop');
        });
      }

      if(btnLoad && !btnLoad._bound){
        btnLoad._bound = true;
        btnLoad.addEventListener('click', () => {
          const v = sel.value;
          if(!v){ playSound('whoosh'); return; }
          this.loadSessionByName(v);
        });
      }

      if(btnDel && !btnDel._bound){
        btnDel._bound = true;
        btnDel.addEventListener('click', () => {
          const v = sel.value;
          if(!v) return;
          if(confirm(`Supprimer la séance “${v}” ?`)){
            this.deleteSessionByName(v);
            playSound('whoosh');
          }
        });
      }

      if(btnExp && !btnExp._bound){
        btnExp._bound = true;
        btnExp.addEventListener('click', () => this.exportSessionJSON());
      }
    }

    exportSessionJSON(){
      const data = this.serializeSession();
      const txt = JSON.stringify(data, null, 2);
      const blob = new Blob([txt], {type:'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      const stamp = new Date().toISOString().slice(0,19).replace(/[:T]/g,'-');
      a.href = url;
      a.download = `disques_fractions_${stamp}.json`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 500);
      playSound('pop');
    }

    _triggerImportFile(){
      const f = document.getElementById('session-import-file');
      if(f) f.click();
    }

    async _handleImportFile(fileInput){
      try{
        const file = fileInput.files && fileInput.files[0];
        if(!file) return;
        const txt = await file.text();
        const obj = JSON.parse(txt);
        if(this.applySession(obj, {withHistory:true})){
          // optionnel : proposer de sauvegarder
          this.refreshSessionSelect();
        }else{
          alert('JSON invalide (format séance).');
        }
      }catch(_){
        alert('Impossible d’importer ce fichier JSON.');
      }finally{
        // reset input to allow re-import same file
        try{ fileInput.value = ''; }catch(_){}
      }
    }


    updateSelectionUI(){
      const btnHide = document.getElementById('btn-hide-label');
      const iconOpen = document.getElementById('icon-eye-open');
      const iconClosed = document.getElementById('icon-eye-closed');

      const btnFlip = document.getElementById('btn-flip');
      const btnSep  = document.getElementById('btn-separate');
      const btnCut  = document.getElementById('btn-cut');
      const btnFuse = document.getElementById('btn-fuse');
      const btnDup  = document.getElementById('btn-duplicate');
      const btnDel  = document.getElementById('btn-delete');

      const count = this.selectedCount;
      const hasOne = (count === 1);
      const s = hasOne ? this.selected : null;
      const hasAny = (count > 0);

      if(btnHide){
        btnHide.disabled = !hasOne;
        if(!hasOne){
          try{
            iconOpen.style.display = 'block';
            iconClosed.style.display = 'none';
            btnHide.classList.remove('bg-rose-500', 'border-rose-300');
            btnHide.classList.add('bg-indigo-500', 'border-indigo-200');
          }catch(_){ }
        }
        if(hasOne && s && s.hideLabel){
           // Mode masqué : montrer l'oeil barré
           iconOpen.style.display = 'none';
           iconClosed.style.display = 'block';
           btnHide.classList.add('bg-rose-500', 'border-rose-300');
           btnHide.classList.remove('bg-indigo-500', 'border-indigo-200');
        } else {
           // Mode normal
           iconOpen.style.display = 'block';
           iconClosed.style.display = 'none';
           btnHide.classList.remove('bg-rose-500', 'border-rose-300');
           btnHide.classList.add('bg-indigo-500', 'border-indigo-200');
        }
      }

      if(btnFlip) btnFlip.disabled = !hasOne;
      if(btnDup)  btnDup.disabled  = !hasAny;
      if(btnDel)  btnDel.disabled  = !hasAny;

      if(btnSep)  btnSep.disabled  = !(hasOne && s && s.kind === 'disk'  && s.denom > 1);

      if(btnFuse){
        const canFuse = this._canFuseSelection();
        btnFuse.disabled = !canFuse;
        // “Apparaît” seulement quand c’est possible, sans faire bouger la barre (pas de shift UI)
        btnFuse.style.visibility = canFuse ? 'visible' : 'hidden';
      }
      if(btnCut)  btnCut.disabled  = !(hasOne && s && this.canCut(s));
    }

    // ---- Plateau listeners ----
    initBoardListeners(){
      // zoom molette
      this.boardContainer.addEventListener('wheel', (e) => {
        e.preventDefault();
        const delta = -e.deltaY * 0.001;
        this.setZoom(this.scale + delta, e.clientX, e.clientY);
      }, {passive:false});

      // empêche le menu contextuel : indispensable pour le glisser au bouton droit
      this.boardContainer.addEventListener('contextmenu', (e) => e.preventDefault());

      // pan sur fond
      this.boardContainer.addEventListener('mousedown', (e) => {
        // En mode stylo : on autorise le déplacement du plateau au bouton droit uniquement
        if(this.currentTool === 'pen' && e.button !== 2) return;
        if(e.button === 2) e.preventDefault();
        if(e.target.closest('.strip')) return;

        // PATCH D3 : rectangle de sélection (Ctrl/Cmd + drag sur fond vide)
        if((e.ctrlKey || e.metaKey) && e.button === 0){
          this._startMarquee(e);
          return;
        }
        this.isPanning = true;
        this.panStart = {x: e.clientX - this.pan.x, y: e.clientY - this.pan.y};
        this.boardContainer.classList.add('panning');
        this.selectToken(null);
      });

      // dessin (PATCH D2 : Pointer Events + stylet fluide)
      this.boardContainer.addEventListener('pointerdown', (e) => {
        // suivi curseur + point de zoom
        this.moveCursor(e);
        this.lastPointerClient = {x: e.clientX, y: e.clientY};

        if(this.currentTool !== 'pen') return;
        // Le dessin se fait au clic gauche (le bouton droit reste pour déplacer)
        if(typeof e.button === 'number' && e.button !== 0) return;

        // évite gestes navigateur (scroll/zoom) pendant le trait
        e.preventDefault();

        // un seul pointeur de dessin à la fois
        if(this._activeDrawPointerId !== null && this._activeDrawPointerId !== undefined) return;

        this._penPointerDown(e);
      }, {passive:false});

      this.boardContainer.addEventListener('pointermove', (e) => {
        this.moveCursor(e);
        this.lastPointerClient = {x: e.clientX, y: e.clientY};

        if(this.currentTool === 'pen' && this.isDrawing && this._activeDrawPointerId === e.pointerId){
          e.preventDefault();
          this._penPointerMove(e);
        }
      }, {passive:false});

      this.boardContainer.addEventListener('pointerup', (e) => {
        if(this.currentTool === 'pen' && this.isDrawing && this._activeDrawPointerId === e.pointerId){
          e.preventDefault();
          this._penPointerUp(e);
        }
      }, {passive:false});

      this.boardContainer.addEventListener('pointercancel', (e) => {
        if(this.currentTool === 'pen' && this.isDrawing && this._activeDrawPointerId === e.pointerId){
          e.preventDefault();
          this._penPointerUp(e, true);
        }
      }, {passive:false});

     window.addEventListener('mousemove', (e) => {
        this.moveCursor(e);
        this.lastPointerClient = {x: e.clientX, y: e.clientY};
        if(this.isPanning){
          this.pan.x = e.clientX - this.panStart.x;
          this.pan.y = e.clientY - this.panStart.y;
          this.updateTransform();
        }
      });

      window.addEventListener('mouseup', () => {
        this.isPanning = false;
        this.boardContainer.classList.remove('panning');
      });

      window.addEventListener('resize', () => this.resizeCanvas());
    }

    // PATCH D3 : rectangle de sélection (Ctrl/Cmd + drag sur fond vide)
    _startMarquee(e){
      if(this._isMarquee) return;
      this._isMarquee = true;

      const br = this.boardContainer.getBoundingClientRect();
      const x0 = e.clientX;
      const y0 = e.clientY;
      this._marqueeStartClient = {x:x0, y:y0};

      // Crée le rectangle visuel
      if(this._marqueeEl){
        try{ this._marqueeEl.remove(); }catch(_){}
      }
      const box = document.createElement('div');
      box.className = 'marquee-box';
      box.style.left = (x0 - br.left) + 'px';
      box.style.top  = (y0 - br.top) + 'px';
      box.style.width = '0px';
      box.style.height = '0px';
      this.boardContainer.appendChild(box);
      this._marqueeEl = box;

      const move = (ev) => {
        ev.preventDefault();
        const x1 = ev.clientX;
        const y1 = ev.clientY;
        const l = Math.min(x0, x1) - br.left;
        const t = Math.min(y0, y1) - br.top;
        const w = Math.abs(x1 - x0);
        const h = Math.abs(y1 - y0);
        box.style.left = l + 'px';
        box.style.top  = t + 'px';
        box.style.width = w + 'px';
        box.style.height = h + 'px';
      };

      const end = (ev) => {
        document.removeEventListener('mousemove', move);
        document.removeEventListener('mouseup', end);

        // Sélection dans l'espace monde
        const a = this.getWorldPos(x0, y0);
        const b = this.getWorldPos(ev.clientX, ev.clientY);
        const minX = Math.min(a.x, b.x);
        const minY = Math.min(a.y, b.y);
        const maxX = Math.max(a.x, b.x);
        const maxY = Math.max(a.y, b.y);

        const D = this.diskD;
        const R = D/2;
        const ids = [];
        for(const tkn of this.tokens){
          // Par défaut : centre du disque
          let px = tkn.x + R;
          let py = tkn.y + R;

          // PATCH S1 (sélection multiple) :
          // Pour une pièce (secteur), le centre est identique à celui du disque,
          // donc une sélection "demi-disque" ne prend rien si le centre n'est pas inclus.
          // On teste un point d'ancrage situé dans la pièce (milieu d'arc) à l'extérieur.
          if(tkn.kind === 'piece'){
            const ang = this._pieceAngles(tkn);
            const am = (ang.a0 + ang.a1) / 2;
            const rr = R * 0.66;
            px = tkn.x + R + Math.cos(am) * rr;
            py = tkn.y + R + Math.sin(am) * rr;
          }

          if(px >= minX && px <= maxX && py >= minY && py <= maxY){
            ids.push(tkn.id);
          }
        }

        // Rectangle = sélection de groupe (remplace)
        if(ids.length){
          this.setSelection(ids, ids[ids.length-1]);
        }else{
          this.selectToken(null);
        }

        if(box){
          try{ box.remove(); }catch(_){}
        }
        this._marqueeEl = null;
        this._isMarquee = false;
      };

      document.addEventListener('mousemove', move);
      document.addEventListener('mouseup', end);
    }


    // ---- Création / rendu tokens ----
    _ensureZ(token){
      if(!token) return;
      if(typeof token.z !== 'number'){
        token.z = ++this.zTop;
      }
      if(token.z > this.zTop) this.zTop = token.z;
    }

    bringToFront(token){
      if(!token) return;
      this._ensureZ(token);
      token.z = ++this.zTop;
      if(token._el) token._el.style.zIndex = String(10 + token.z);
    }

    _renderToken(token){
      if(!token._el) return;
      const {w,h} = this.tokenDims(token);
      token._el.style.width = `${w}px`;
      token._el.style.height = `${h}px`;
      token._el.style.left = `${token.x}px`;
      token._el.style.top  = `${token.y}px`;
      this._ensureZ(token);
      token._el.style.zIndex = String(10 + token.z);
      token._el.classList.toggle('is-back', token.side === 'back');

      const front = token._el.querySelector('.face-front');
      const back  = token._el.querySelector('.face-back');
      if(front) front.innerHTML = this._tokenSVGMarkup(token, 'front');
      if(back)  back.innerHTML  = this._tokenSVGMarkup(token, 'back');
    }

    mountToken(token){
      const el = document.createElement('div');
      el.className = 'strip';
      el.classList.add(token.kind === 'disk' ? 'is-disk' : 'is-piece');
      el.dataset.kind = token.kind;
      el.dataset.id = String(token.id);

      el.innerHTML = `
        <div class="strip-inner">
          <div class="face face-front"></div>
          <div class="face face-back"></div>
        </div>
      `;

      // interactions
      el.addEventListener('mousedown', (e) => this.handleDragStart(e));
      el.addEventListener('touchstart', (e) => this.handleDragStart(e), {passive:false});

      el.addEventListener('click', (e) => {
        e.stopPropagation();
        // PATCH D3 (fix): éviter le "clic fantôme" après un drag (sinon la sélection de groupe se casse)
        if(Date.now() < this._suppressClickUntil) return;

        const t = this.tokens.find(tt => tt.id === token.id);
        if(!t) return;
        const pt = e.touches ? e.touches[0] : e;
        const wp = this.getWorldPos(pt.clientX, pt.clientY);
        if(t.kind === 'piece' && !this.isPointInPiece(t, wp.x, wp.y)) return;

        // PATCH D3 (fix): clic normal sur un élément déjà dans un groupe -> garder le groupe
        const wantToggle = !!(e.ctrlKey || e.metaKey || e.shiftKey);
        const inGroup = (this.selectedIds instanceof Set) && this.selectedIds.has(t.id) && this.selectedIds.size > 1;

        if(wantToggle){
          this.toggleSelectToken(t.id);
        }else if(inGroup){
          this.selectedId = t.id;
          this.refreshTokenSelectedClass();
          this.updateSelectionUI();
        }else{
          this.selectToken(t.id);
        }
      });

      el.addEventListener('dblclick', (e) => {
        e.stopPropagation();
        const t = this.tokens.find(tt => tt.id === token.id);
        if(!t) return;
        const pt = e.touches ? e.touches[0] : e;
        const wp = this.getWorldPos(pt.clientX, pt.clientY);
        if(t.kind === 'piece' && !this.isPointInPiece(t, wp.x, wp.y)) return;
        this.selectToken(token.id);
        this.flipSelected();
      });

      // double-tap mobile
      let lastTap = 0;
      el.addEventListener('touchend', (e) => {
        const now = Date.now();
        if(now - lastTap < 300){
          e.preventDefault();
          const t = this.tokens.find(tt => tt.id === token.id);
          if(t){
            const pt = e.changedTouches ? e.changedTouches[0] : e;
            const wp = this.getWorldPos(pt.clientX, pt.clientY);
            if(t.kind !== 'piece' || this.isPointInPiece(t, wp.x, wp.y)){
              this.selectToken(token.id);
              this.flipSelected();
            }
          }
        }
        lastTap = now;
      });

      this.boardWorld.appendChild(el);
      token._el = el;
      this._renderToken(token);

      if(token._new){
        el.classList.add('spawn-pop');
        el.addEventListener('animationend', () => el.classList.remove('spawn-pop'), {once:true});
        delete token._new;
      }

      this.refreshTokenSelectedClass(token.id);
    }
    refreshTokenSelectedClass(){
      const sel = (this.selectedIds instanceof Set)
        ? this.selectedIds
        : new Set((this.selectedId === null || typeof this.selectedId === 'undefined') ? [] : [this.selectedId]);
      this.tokens.forEach(t => {
        if(!t._el) return;
        t._el.classList.toggle('selected', sel.has(t.id));
      });
    }


    addToken({denom, kind, x=null, y=null}){
      this.saveState();
      playSound('pop');
      const pos = (x===null || y===null) ? {x: 40 + Math.random()*40, y: 40 + Math.random()*30} : {x, y};

      const D = this.diskD;
      const token = {
        id: this.nextId++,
        z: ++this.zTop,
        denom,
        kind,
        side: 'front',
        x: pos.x - D/2,
        y: pos.y - D/2,
        rot: 0,
        slot: null,
        hideLabel: false,
        _new: true,
      };
      this.tokens.push(token);
      this.mountToken(token);
      this.selectToken(token.id);
      return token;
    }
    selectToken(id){
      // Sélection simple (compat)
      if(id === null || typeof id === 'undefined'){
        this.selectedIds = new Set();
        this.selectedId = null;
      }else{
        this.selectedIds = new Set([id]);
        this.selectedId = id;
      }
      this.refreshTokenSelectedClass();
      this.updateSelectionUI();
    }

    toggleSelectToken(id){
      if(id === null || typeof id === 'undefined') return;
      if(!(this.selectedIds instanceof Set)) this.selectedIds = new Set();

      if(this.selectedIds.has(id)){
        this.selectedIds.delete(id);
        if(this.selectedId === id){
          this.selectedId = this.selectedIds.size ? Array.from(this.selectedIds).slice(-1)[0] : null;
        }
      }else{
        this.selectedIds.add(id);
        this.selectedId = id;
      }

      // Si on vient de vider la sélection
      if(!this.selectedIds.size){
        this.selectedId = null;
      }

      this.refreshTokenSelectedClass();
      this.updateSelectionUI();
    }

    setSelection(ids, primaryId=null){
      const arr = Array.isArray(ids) ? ids.slice() : [];
      this.selectedIds = new Set(arr);
      if(primaryId !== null && this.selectedIds.has(primaryId)){
        this.selectedId = primaryId;
      }else{
        this.selectedId = arr.length ? arr[arr.length - 1] : null;
      }
      this.refreshTokenSelectedClass();
      this.updateSelectionUI();
    }

    get selected(){
      const id = this.selectedId;
      if(id === null || typeof id === 'undefined'){
        if(this.selectedIds instanceof Set && this.selectedIds.size){
          const first = this.selectedIds.values().next().value;
          return this.tokens.find(t => t.id === first) || null;
        }
        return null;
      }
      return this.tokens.find(t => t.id === id) || null;
    }

    get selectedCount(){
      return (this.selectedIds instanceof Set) ? this.selectedIds.size : ((this.selectedId !== null && typeof this.selectedId !== 'undefined') ? 1 : 0);
    }

    getSelectedTokens(){
      const out = [];
      if(this.selectedIds instanceof Set){
        for(const id of this.selectedIds){
          const t = this.tokens.find(tt => tt.id === id);
          if(t) out.push(t);
        }
      }else{
        const s = this.selected;
        if(s) out.push(s);
      }
      return out;
    }
toggleTokenLabel(){
      const s = this.selected;
      if(!s) return;
      this.saveState();
      s.hideLabel = !s.hideLabel;
      this._renderToken(s);
      this.updateSelectionUI();
    }

    flipSelected(){
      const s = this.selected;
      if(!s) return;
      this.saveState();
      s.side = (s.side === 'front') ? 'back' : 'front';
      if(s._el){
        requestAnimationFrame(() => {
          s._el.classList.toggle('is-back', s.side === 'back');
        });
      }
      this.updateSelectionUI();
      playSound('flip');
    }

    duplicateSelected(){
      const count = this.selectedCount;
      if(!count) return;
      this.saveState();

      const selectedTokens = this.getSelectedTokens();
      // Dupliquer dans l'ordre d'empilement (z), pour garder un rendu cohérent
      selectedTokens.sort((a,b)=> (a.z||0) - (b.z||0));

      const newIds = [];
      for(const s of selectedTokens){
        const copy = {
          id: this.nextId++,
          z: ++this.zTop,
          denom: s.denom,
          kind: s.kind,
          side: s.side,
          x: s.x + 24,
          y: s.y + 24,
          rot: (typeof s.rot === 'number') ? s.rot : 0,
          slot: (typeof s.slot === 'number') ? s.slot : null,
          hideLabel: !!s.hideLabel
        };
        this.tokens.push(copy);
        this.mountToken(copy);
        newIds.push(copy.id);
      }

      // Sélectionner les duplicatas (groupe)
      if(newIds.length === 1){
        this.selectToken(newIds[0]);
      }else{
        this.setSelection(newIds, newIds[newIds.length-1]);
      }
      playSound('pop');
    }

    deleteSelected(){
      const count = this.selectedCount;
      if(!count) return;
      this.saveState();

      const sel = (this.selectedIds instanceof Set) ? new Set(this.selectedIds) : new Set();
      if(!sel.size && this.selectedId !== null && typeof this.selectedId !== 'undefined'){
        sel.add(this.selectedId);
      }

      for(const t of this.tokens){
        if(sel.has(t.id) && t._el){
          try{ t._el.remove(); }catch(_){}
        }
      }
      this.tokens = this.tokens.filter(t => !sel.has(t.id));
      this.selectToken(null);
      playSound('whoosh');
    }

    separateSelected(){
      const s = this.selected;
      if(!s || s.kind !== 'disk' || s.denom <= 1) return;
      this.saveState();

      const baseX = s.x;
      const baseY = s.y;
      const denom = s.denom;
      const side = s.side;
      const hidden = !!s.hideLabel;

      if(s._el) s._el.remove();
      this.tokens = this.tokens.filter(t => t.id !== s.id);

      const stepDeg = 360 / denom;
      for(let i=0;i<denom;i++){
        const piece = {
          id: this.nextId++,
          z: ++this.zTop,
          denom,
          kind:'piece',
          side,
          x: baseX,
          y: baseY,
          rot: i * stepDeg,
          slot: i,
          hideLabel: hidden
        };
        this.tokens.push(piece);
        this.mountToken(piece);
      }
      this.selectToken(this.tokens[this.tokens.length - denom].id);
      playSound('pop');
    }

    _getSelectedTokensArray(){
      const ids = new Set();
      if(this.selectedIds instanceof Set){
        for(const id of this.selectedIds) ids.add(id);
      }
      if((ids.size === 0) && this.selectedId !== null && typeof this.selectedId !== 'undefined'){
        ids.add(this.selectedId);
      }
      if(!ids.size) return [];
      return this.tokens.filter(t => ids.has(t.id));
    }

    _computeFusePlanFromSelection(tokens){
      if(!Array.isArray(tokens) || tokens.length < 2) return null;

      // On fuse uniquement des "pieces" (secteurs)
      if(tokens.some(t => !t || t.kind !== 'piece')) return null;

      const d = tokens[0].denom;
      if(typeof d !== 'number' || d <= 1) return null;
      if(tokens.some(t => t.denom !== d)) return null;

      // Même position (mêmes disques reconstitués)
      const tol = 2.4;
      const baseX = tokens[0].x;
      const baseY = tokens[0].y;
      for(const t of tokens){
        if(Math.abs(t.x - baseX) > tol || Math.abs(t.y - baseY) > tol) return null;
      }

      const stepDeg = 360 / d;

      // Slots uniques (sinon ambigu)
      const slotToTok = new Map();
      for(const p of tokens){
        const slot = (typeof p.slot === 'number')
          ? p.slot
          : (typeof p.rot === 'number')
              ? (((Math.round(p.rot / stepDeg) % d) + d) % d)
              : 0;
        if(slotToTok.has(slot)) return null;
        slotToTok.set(slot, p);
      }

      const k = slotToTok.size;
      if(k !== tokens.length) return null;

      const slots = Array.from(slotToTok.keys());
      const slotSet = new Set(slots);

      // Trouver un run consécutif de longueur k (mod d)
      let startSlot = null;
      for(const s0 of slots){
        let ok = true;
        for(let i=0;i<k;i++){
          if(!slotSet.has((s0 + i) % d)){ ok = false; break; }
        }
        if(ok){ startSlot = s0; break; }
      }

      // Cas "disque complet" : pas besoin d'être consécutif si on a tous les slots
      if(startSlot === null){
        if(k === d){
          startSlot = 0;
        }else{
          return null;
        }
      }

      const side = tokens.every(t => t.side === tokens[0].side) ? tokens[0].side : 'front';
      const hideLabel = tokens.every(t => !!t.hideLabel);

      // Disque complet : d secteurs -> disque d
      if(k === d){
        return {
          kind: 'disk',
          denom: d,
          x: baseX,
          y: baseY,
          rot: 0,
          side,
          hideLabel,
          removeIds: tokens.map(t => t.id),
        };
      }

      // Fusion "fraction plus grande" :
      // k * (1/d) = 1/(d/k) => denom2 = d/k, si entier.
      if(d % k !== 0) return null;
      const denom2 = d / k;
      if(denom2 <= 1) return null; // pas de "piece" en 1

      // Vérifier que la fraction cible existe dans l'outil
      if(!FRACTIONS.some(f => f.denom === denom2)) return null;

      // Rotation de départ = rotation réelle de la première pièce du run
      const startTok = slotToTok.get(startSlot);
      let rot = (startTok && typeof startTok.rot === 'number') ? startTok.rot : (startSlot * stepDeg);
      rot = ((rot % 360) + 360) % 360;

      return {
        kind: 'piece',
        denom: denom2,
        x: baseX,
        y: baseY,
        rot,
        side,
        hideLabel,
        removeIds: tokens.map(t => t.id),
      };
    }


    _computeSumFusePlanHalfOrOne(tokens){
      // PATCH D5 : fusion par somme (uniquement vers 1/2 ou unité), sur même disque et positions canoniques.
      if(!Array.isArray(tokens) || tokens.length < 2) return null;
      if(tokens.some(t => !t || t.kind !== 'piece' || !t.denom || t.denom <= 0)) return null;

      const tol = 2.4;
      const baseX = tokens[0].x, baseY = tokens[0].y;
      for(const t of tokens){
        if(Math.abs(t.x - baseX) > tol || Math.abs(t.y - baseY) > tol) return null;
      }

      // Évite les mélanges recto/verso (sinon visuels incohérents)
      const side = tokens.every(t => t.side === tokens[0].side) ? tokens[0].side : null;
      if(!side) return null;

      const hideLabel = tokens.every(t => !!t.hideLabel);

      const gcd = (a,b)=>{ a=Math.abs(a); b=Math.abs(b); while(b){ const tmp=a%b; a=b; b=tmp; } return a||0; };
      const lcm2 = (a,b)=>{ if(!a || !b) return 0; return Math.abs((a/gcd(a,b))*b); };

      let lcm = 1;
      for(const t of tokens){
        lcm = lcm2(lcm, t.denom);
        if(!lcm) return null;
        // garde-fou : ici on n'a que 2,3,4,5,6,8,10 donc c'est petit.
        if(lcm > 3600) return null;
      }

      // Grille fine de "slots" : pas de flottants, pas de surprises
      const slotSet = new Set();
      const epsDeg = 1.2; // tolérance d'alignement (rot proche d'un cran canon)
      const norm360 = (deg)=>{ deg = deg % 360; if(deg < 0) deg += 360; return deg; };
      const angDiff = (a,b)=>{
        const d = Math.abs(norm360(a) - norm360(b));
        return Math.min(d, 360 - d);
      };

      for(const t of tokens){
        const denom = t.denom;
        const stepDeg = 360 / denom;
        const len = lcm / denom;
        if(!Number.isFinite(len) || len <= 0) return null;

        let slotDen = null;
        if(typeof t.slot === 'number' && t.slot !== null){
          slotDen = ((t.slot % denom) + denom) % denom;
        }else{
          const rot = (typeof t.rot === 'number') ? t.rot : 0;
          const r = norm360(rot);
          const s = ((Math.round(r / stepDeg) % denom) + denom) % denom;
          const target = s * stepDeg;
          if(angDiff(r, target) > epsDeg) return null; // pas sur la grille -> pas de fusion par somme
          slotDen = s;
        }

        const start = slotDen * len;
        for(let i=0;i<len;i++){
          const k = (start + i) % lcm;
          if(slotSet.has(k)) return null; // chevauchement
          slotSet.add(k);
        }
      }

      const expected = tokens.reduce((acc, t) => acc + (lcm / t.denom), 0);
      const total = slotSet.size;
      if(total !== expected) return null;

      // helper : run consécutif de longueur L (modulo lcm). Retourne startSlot ou null.
      const hasRun = (L)=>{
        if(L <= 0) return null;
        if(L === lcm) return 0;
        const slots = Array.from(slotSet.values());
        for(const s0 of slots){
          let ok = true;
          for(let i=0;i<L;i++){
            if(!slotSet.has((s0 + i) % lcm)){ ok = false; break; }
          }
          if(ok) return s0;
        }
        return null;
      };

      // Somme = 1 -> unité (disque denom=1)
      if(total === lcm){
        if(!FRACTIONS.some(f => f.denom === 1)) return null;
        return {
          kind: 'disk',
          denom: 1,
          x: baseX,
          y: baseY,
          rot: 0,
          side,
          hideLabel,
          removeIds: tokens.map(t => t.id),
        };
      }

      // Somme = 1/2 -> pièce 1/2 (arc contigu uniquement)
      if(lcm % 2 === 0 && total === (lcm / 2)){
        if(!FRACTIONS.some(f => f.denom === 2)) return null;
        const startSlot = hasRun(lcm/2);
        if(startSlot === null) return null;
        const rot = norm360(startSlot * (360 / lcm));
        return {
          kind: 'piece',
          denom: 2,
          x: baseX,
          y: baseY,
          rot,
          side,
          hideLabel,
          removeIds: tokens.map(t => t.id),
        };
      }

      return null;
    }

    _applyFusePlan(plan){
      if(!plan || !plan.removeIds || !plan.removeIds.length) return;

      this.saveState();
      playSound('pop');

      const remove = new Set(plan.removeIds);

      // Retire DOM + tokens
      for(const t of this.tokens){
        if(remove.has(t.id) && t._el){
          try{ t._el.remove(); }catch(_){}
        }
      }
      this.tokens = this.tokens.filter(t => !remove.has(t.id));

      // Crée le token fusionné (sans refacto du moteur)
      const token = {
        id: this.nextId++,
        z: ++this.zTop,
        denom: plan.denom,
        kind: plan.kind,
        side: plan.side || 'front',
        x: plan.x,
        y: plan.y,
        rot: (typeof plan.rot === 'number') ? plan.rot : 0,
        slot: null,
        hideLabel: !!plan.hideLabel,
        _new: true,
      };

      this.tokens.push(token);
      this.mountToken(token);
      this._renderToken(token);
      this.selectToken(token.id);
      this.updateSelectionUI();
    }

    _canFuseSelection(){
      const toks = this._getSelectedTokensArray();
      if(!toks.length) return false;

      // Fusion basée sur sélection (multi)
      const plan = this._computeFusePlanFromSelection(toks);
      if(plan) return true;

      // PATCH D5 : fusion par somme (uniquement vers 1/2 ou unité)
      const sumPlan = this._computeSumFusePlanHalfOrOne(toks);
      if(sumPlan) return true;

      // Fallback : comportement historique (1 pièce sélectionnée, et toutes les pièces autour existent)
      if(toks.length === 1){
        const s = toks[0];
        if(!s || s.kind !== 'piece' || s.denom <= 1) return false;

        const d = s.denom;
        const tol = 2.4;
        const baseX = s.x, baseY = s.y;
        const group = this.tokens.filter(t => t.kind === 'piece' && t.denom === d &&
          Math.abs(t.x - baseX) < tol && Math.abs(t.y - baseY) < tol);
        if(group.length < d) return false;

        const stepDeg = 360 / d;
        const slotSet = new Set();
        for(const p of group){
          const slot = (typeof p.slot === 'number') ? p.slot :
            (typeof p.rot === 'number') ? (((Math.round(p.rot/stepDeg) % d) + d) % d) : 0;
          slotSet.add(slot);
          if(slotSet.size >= d) break;
        }
        return slotSet.size >= d;
      }

      return false;
    }


    fuseSelected(){
      // PATCH D4 : fusion par sélection (multi) -> fraction plus grande ou disque complet
      const selTokens = this._getSelectedTokensArray();
      const plan = this._computeFusePlanFromSelection(selTokens);
      if(plan){
        this._applyFusePlan(plan);
        return;
      }

      // PATCH D5 : fusion par somme (1/2 ou unité)
      const sumPlan = this._computeSumFusePlanHalfOrOne(selTokens);
      if(sumPlan){
        this._applyFusePlan(sumPlan);
        return;
      }

      const s = this.selected;
      if(!s || s.kind !== 'piece' || s.denom <= 1) return;

      const d = s.denom;
      const tol = 2.4;
      const baseX = s.x;
      const baseY = s.y;

      const group = this.tokens
        .filter(t => t.kind === 'piece' && t.denom === d  && Math.abs(t.x - baseX) < tol && Math.abs(t.y - baseY) < tol);

      if(group.length < d){ playSound('whoosh'); return; }

      // slot unique
      const stepDeg = 360 / d;
      const slotToPiece = new Map();
      for(const p of group){
        const slot = (typeof p.slot === 'number') ? p.slot : (typeof p.rot === 'number') ? (Math.round(p.rot / stepDeg) % d + d) % d : 0;
        // prioriser la pièce sélectionnée si collision
        if(!slotToPiece.has(slot) || p.id === s.id){
          slotToPiece.set(slot, p);
        }
      }

      if(slotToPiece.size < d){ playSound('whoosh'); return; }

      this.saveState();
      const ids = new Set([...slotToPiece.values()].slice(0, d).map(p => p.id));
      [...ids].forEach(id => {
        const t = this.tokens.find(x => x.id === id);
        if(t && t._el) t._el.remove();
      });
      this.tokens = this.tokens.filter(t => !ids.has(t.id));

      const disk = { id: this.nextId++, z: ++this.zTop, denom: d, kind:'disk', side: s.side, x: baseX, y: baseY, rot:0, slot:null, hideLabel:false };
      this.tokens.push(disk);
      this.mountToken(disk);
      this.selectToken(disk.id);
      playSound('pop');
    }

    // ---- Ciseaux : couper en 2 (uniquement si le double existe) ----
    canCut(t){
      if(!t) return false;
      if(t.denom <= 0) return false;
      const d2 = t.denom * 2;
      return this.DENOM_SET.has(d2);
    }

    cutSelected(){
      const s = this.selected;
      if(!s || !this.canCut(s)) return;

      const d = s.denom;
      const d2 = d * 2;
      const side = s.side;
      const x = s.x;
      const y = s.y;
      const hidden = !!s.hideLabel;

      this.saveState();

      if(s._el) s._el.remove();
      this.tokens = this.tokens.filter(t => t.id !== s.id);

      if(s.kind === 'disk'){
        const disk = { id: this.nextId++, z: ++this.zTop, denom: d2, kind:'disk', side, x, y, rot:0, slot:null, hideLabel: hidden };
        this.tokens.push(disk);
        this.mountToken(disk);
        this.selectToken(disk.id);
      } else {
        // pièce : devient 2 secteurs adjacents 1/(2d)
        const step2 = 360 / d2;
        const baseRot = (typeof s.rot === 'number') ? s.rot : ((typeof s.slot === 'number') ? s.slot * (360/d) : 0);
        const r1 = baseRot;
        const r2 = baseRot + step2;
        const slot1 = ((Math.round(r1/step2)%d2)+d2)%d2;
        const slot2 = ((Math.round(r2/step2)%d2)+d2)%d2;

        const p1 = { id: this.nextId++, z: ++this.zTop, denom: d2, kind:'piece', side, x, y, rot: r1, slot: slot1, hideLabel: hidden };
        const p2 = { id: this.nextId++, z: ++this.zTop, denom: d2, kind:'piece', side, x, y, rot: r2, slot: slot2, hideLabel: hidden };
        this.tokens.push(p1, p2);
        this.mountToken(p1);
        this.mountToken(p2);
        this.selectToken(p1.id);
      }

      playSound('pop');
    }

    // ---- Hit test wedge ----
    isPointInPiece(piece, wx, wy){
      if(!piece || piece.kind !== 'piece') return true;
      const D = this.diskD;
      const R = D/2;
      const cx = piece.x + R;
      const cy = piece.y + R;
      const dx = wx - cx;
      const dy = wy - cy;
      const r = Math.hypot(dx, dy);
      if(r > R) return false;
      const angle = Math.atan2(dy, dx);
      const step = Math.PI*2 / piece.denom;
      const rotRad = ((typeof piece.rot === 'number') ? piece.rot : 0) * Math.PI/180;
      const a0 = this._startAngleRad() + rotRad;
      const a1 = a0 + step;
      return this._angleInArc(angle, a0, a1);
    }


    isPointInDisk(disk, wx, wy){
      if(!disk || disk.kind !== 'disk') return true;
      const D = this.diskD;
      const R = D/2;
      const cx = disk.x + R;
      const cy = disk.y + R;
      return Math.hypot(wx - cx, wy - cy) <= R;
    }

    // Pick le token réellement sous le pointeur (forme peinte), du plus haut au plus bas.
    _pickTokenAt(wx, wy){
      // z-order: on se base sur token.z (zIndex = 10+z)
      const ordered = [...this.tokens].sort((a,b) => (( (typeof b.z==='number'? b.z : b.id) ) - ( (typeof a.z==='number'? a.z : a.id) )));
      for(const t of ordered){
        if(!t) continue;
        if(t.kind === 'piece'){
          const rh = this._hitRotateHandle(t, wx, wy);
          if(rh) return { token: t, rotateWhich: rh };
          if(this.isPointInPiece(t, wx, wy)) return { token: t, rotateWhich: null };
        } else {
          if(this.isPointInDisk(t, wx, wy)) return { token: t, rotateWhich: null };
        }
      }
      return null;
    }



    // ---- Rotation : poignées (extrémités des rayons) ----
    _shortestAngleDeltaRad(a, b){
      // delta dans [-pi, pi]
      return ((b - a + Math.PI*3) % (Math.PI*2)) - Math.PI;
    }

    _pieceAngles(piece){
      const rotDeg = (typeof piece.rot === 'number') ? piece.rot : 0;
      const rotRad = rotDeg * Math.PI/180;
      const step = Math.PI*2 / piece.denom;
      const a0 = this._startAngleRad() + rotRad;
      const a1 = a0 + step;
      return {a0, a1, step};
    }

    _pieceHandlePoints(piece){
      const D = this.diskD;
      const R = D/2;
      const cx = piece.x + R;
      const cy = piece.y + R;
      const {a0, a1} = this._pieceAngles(piece);
      const hr = R - 14;
      return [
        { which: 'a0', x: cx + hr*Math.cos(a0), y: cy + hr*Math.sin(a0) },
        { which: 'a1', x: cx + hr*Math.cos(a1), y: cy + hr*Math.sin(a1) },
      ];
    }

    _hitRotateHandle(piece, wx, wy){
      if(!piece || piece.kind !== 'piece') return null;
      const hitR = 26 / this.scale;
      let best = null;
      let bestD = Infinity;
      for(const p of this._pieceHandlePoints(piece)){
        const d = Math.hypot(wx - p.x, wy - p.y);
        if(d < bestD){ bestD = d; best = p; }
      }
      if(best && bestD <= hitR) return best.which;
      return null;
    }

    // Aimantation manuelle : centre ↔ centre uniquement ;
    // et (pour les pièces) clip d'angle uniquement si on est très proche et presque aligné
    // avec une arête déjà présente au même centre.
    snapToCenterAndMaybeClip(token, opts={}){
      const t = token;
      if(!t) return (opts && opts.returnTarget) ? {snapped:false} : false;
      const D = this.diskD;
      const thresh = (12 / this.scale);

      const ignore = (opts && opts.ignoreIds) ? (opts.ignoreIds instanceof Set ? opts.ignoreIds : new Set(opts.ignoreIds)) : null;

      const candidates = this.tokens.filter(o => o.id !== t.id && !(ignore && ignore.has(o.id)));
      if(!candidates.length) return (opts && opts.returnTarget) ? {snapped:false} : false;

      const tcx = t.x + D/2;
      const tcy = t.y + D/2;
      let best = null;
      let bestDist = Infinity;
      for(const o of candidates){
        const ocx = o.x + D/2;
        const ocy = o.y + D/2;
        const d = Math.hypot(tcx - ocx, tcy - ocy);
        if(d < bestDist){ bestDist = d; best = o; }
      }
      if(!best || bestDist > thresh) return (opts && opts.returnTarget) ? {snapped:false} : false;

      const target = { x: best.x, y: best.y };

      if(t.kind === 'piece'){
        const startBaseDeg = -90; // cohérent avec _startAngleRad()
        const stepDeg = 360 / t.denom;

        // Angles de référence présents au même centre (bords des disques + bords des pièces)
        const cx = best.x + D/2;
        const cy = best.y + D/2;
        const sameCenterTol = 2.6;
        const around = this.tokens.filter(o => {
          if(o.id === t.id) return false;
          const ocx = o.x + D/2;
          const ocy = o.y + D/2;
          return Math.hypot(ocx - cx, ocy - cy) < sameCenterTol;
        });

        const ref = [];
        for(const o of around){
          if(o.kind === 'disk'){
            const d = o.denom;
            if(d > 0){
              const step = 360 / d;
              for(let k=0;k<d;k++){
                ref.push(((startBaseDeg + k*step) % 360 + 360) % 360);
              }
            }
          } else if(o.kind === 'piece'){
            const d = o.denom;
            const step = 360 / d;
            const base = startBaseDeg + ((typeof o.rot === 'number') ? o.rot : 0);
            ref.push(((base) % 360 + 360) % 360);
            ref.push(((base + step) % 360 + 360) % 360);
          }
        }

        // S'il n'y a rien d'autre au centre, on s'aligne sur la grille naturelle de la pièce
        if(ref.length === 0){
          for(let k=0;k<t.denom;k++) ref.push(((startBaseDeg + k*stepDeg) % 360 + 360) % 360);
        }

        const tolDeg = 10;
        const cur = (typeof t.rot === 'number') ? t.rot : 0;
        const b0 = ((startBaseDeg + cur) % 360 + 360) % 360;
        const b1 = ((b0 + stepDeg) % 360 + 360) % 360;

        let bestDelta = 0;
        let bestAbs = Infinity;
        for(const ra of ref){
          const d0 = this._shortestAngleDelta(b0, ra);
          if(Math.abs(d0) < bestAbs){ bestAbs = Math.abs(d0); bestDelta = d0; }
          const d1 = this._shortestAngleDelta(b1, ra);
          if(Math.abs(d1) < bestAbs){ bestAbs = Math.abs(d1); bestDelta = d1; }
        }

        if(bestAbs <= tolDeg){
          let newRot = cur + bestDelta;
          newRot = ((newRot % 360) + 360) % 360;

          // Slot uniquement si on retombe sur une position "canon" de la pièce (utile pour Fusionner)
          const nearest = Math.round(newRot / stepDeg) * stepDeg;
          const deltaSlot = this._shortestAngleDelta(newRot, nearest);
          if(Math.abs(deltaSlot) <= 2.5){
            const slot = ((Math.round(nearest/stepDeg) % t.denom) + t.denom) % t.denom;
            target.rot = nearest;
            target.slot = slot;
          } else {
            target.rot = newRot;
          }
        }
      }

      const dx = (target.x - t.x);
      const dy = (target.y - t.y);
      this._animateTokenTo(t, target, {duration: 110, ...opts});
      if(opts && opts.returnTarget){
        return {snapped:true, target, dx, dy};
      }
      return true;
    }
    // ---- Aimantation (pièces ↔ centre, et disque ↔ centre si proche) ----

    _easeOutCubic(t){
      return 1 - Math.pow(1 - t, 3);
    }

    _shortestAngleDelta(a, b){
      // delta dans [-180, 180]
      return ((b - a + 540) % 360) - 180;
    }

    _animateTokenTo(t, target, opts={}){
      const duration = (typeof opts.duration === 'number') ? opts.duration : 170;
      if(t._anim && t._anim.raf){
        try{ cancelAnimationFrame(t._anim.raf); }catch(_){ /* ignore */ }
      }

      const sx = t.x, sy = t.y;
      const sr = (typeof t.rot === 'number') ? t.rot : 0;
      const ex = target.x, ey = target.y;
      const er = (typeof target.rot === 'number') ? target.rot : sr;

      const dRot = this._shortestAngleDelta(sr, er);
      const t0 = performance.now();

      const step = (now) => {
        const p = Math.min(1, (now - t0) / duration);
        const k = this._easeOutCubic(p);

        t.x = sx + (ex - sx) * k;
        t.y = sy + (ey - sy) * k;

        if(t.kind === 'piece'){
          t.rot = sr + dRot * k;
        }

        if(t._el){
          t._el.style.left = t.x + 'px';
          t._el.style.top  = t.y + 'px';
          if(t.kind === 'piece') this._renderToken(t);
        }

        if(p < 1){
          t._anim = {raf: requestAnimationFrame(step)};
        } else {
          t.x = ex; t.y = ey;
          if(t.kind === 'piece'){
            t.rot = er;
            if('slot' in target) t.slot = target.slot;
          }
          if(t._el){
            t._el.style.left = t.x + 'px';
            t._el.style.top  = t.y + 'px';
            if(t.kind === 'piece') this._renderToken(t);
          }
          t._anim = null;
          if(t._el){
            t._el.classList.remove('snap-pop');
            // relance l'animation
            void t._el.offsetWidth;
            t._el.classList.add('snap-pop');
            setTimeout(()=>{ try{ t._el && t._el.classList.remove('snap-pop'); }catch(_){} }, 220);
          }
          if(!opts.silent) playSound('pop');
        }
      };

      t._anim = {raf: requestAnimationFrame(step)};
    }

    // Aimantation "manuelle" : centre sur centre uniquement (pas de placement automatique en slots)
    snapToken(token, opts={}){
      const t = token;
      if(!t) return (opts && opts.returnTarget) ? {snapped:false} : undefined;

      const D = this.diskD;
      const thresh = (12 / this.scale);

      const ignore = (opts && opts.ignoreIds) ? (opts.ignoreIds instanceof Set ? opts.ignoreIds : new Set(opts.ignoreIds)) : null;

      const candidates = this.tokens.filter(o => o.id !== t.id && !(ignore && ignore.has(o.id)));
      if(!candidates.length){ return (opts && opts.returnTarget) ? {snapped:false} : undefined; }

      const tcx = t.x + D/2;
      const tcy = t.y + D/2;

      let best = null;
      let bestDist = Infinity;
      for(const o of candidates){
        const ocx = o.x + D/2;
        const ocy = o.y + D/2;
        const d = Math.hypot(tcx - ocx, tcy - ocy);
        if(d < bestDist){ bestDist = d; best = o; }
      }

      if(!best || bestDist > thresh){ return (opts && opts.returnTarget) ? {snapped:false} : undefined; }
      const target = {x: best.x, y: best.y};
      const dx = (target.x - t.x);
      const dy = (target.y - t.y);
      this._animateTokenTo(t, target, {duration: 80, ...opts});
      if(opts && opts.returnTarget){
        return {snapped:true, target, dx, dy};
      }
    }

    // Après une rotation, on "clipse" la pièce si elle est presque alignée (et centrée sur un autre disque/pièce)
    snapAngleToGridIfClose(token, opts={}){
      const t = token;
      if(!t || t.kind !== 'piece') return;

      const D = this.diskD;
      const centerThresh = (14 / this.scale);
      const tcx = t.x + D/2;
      const tcy = t.y + D/2;

      let target = null;
      for(const o of this.tokens){
        if(o.id === t.id) continue;
        
        const ocx = o.x + D/2;
        const ocy = o.y + D/2;
        if(Math.hypot(tcx - ocx, tcy - ocy) <= centerThresh){
          target = o;
          break;
        }
      }
      if(!target) return;

      const stepDeg = 360 / t.denom;
      const sr = t.rot || 0;
      const norm = ((sr % 360) + 360) % 360;
      const nearest = Math.round(norm / stepDeg) * stepDeg;
      const delta = this._shortestAngleDelta(sr, nearest);
      const tolDeg = 8;
      if(Math.abs(delta) > tolDeg) return;

      const slot = ((Math.round(nearest/stepDeg) % t.denom) + t.denom) % t.denom;
      this._animateTokenTo(t, {x: target.x, y: target.y, rot: nearest, slot}, {duration: 120, ...opts});
    }

    // ---- Drag tokens ----
    handleDragStart(e){
      const isRightMouse = (!e.touches && typeof e.button === 'number' && e.button === 2);
      // En mode stylo : on autorise la manipulation des pièces au bouton droit
      if(this.currentTool !== 'hand' && !(this.currentTool === 'pen' && isRightMouse)) return;
      if(isRightMouse) e.preventDefault();
      e.stopPropagation();

      // Position au down (monde)
      const pt0 = e.touches ? e.touches[0] : e;
      const wp0 = this.getWorldPos(pt0.clientX, pt0.clientY);

      // IMPORTANT : on choisit le token réellement sous le pointeur (forme),
      // pour éviter que les zones transparentes des carrés englobants bloquent la sélection
      // quand plusieurs pièces se touchent.
      const picked = this._pickTokenAt(wp0.x, wp0.y);
      if(!picked) return;
      const token = picked.token;
      const rotateWhich = picked.rotateWhich;

      this.saveState();

      // PATCH D3 : multi-sélection
      const wantToggle = !!(e.ctrlKey || e.metaKey || e.shiftKey);
      const hasSet = (this.selectedIds instanceof Set);
      const isSelected = hasSet ? this.selectedIds.has(token.id) : (this.selectedId === token.id);
      const alreadyInGroup = hasSet && this.selectedIds.has(token.id) && this.selectedIds.size > 1;

      if(wantToggle){
        // Important : si l'utilisateur garde Ctrl/Cmd (ou Shift) enfoncé pour déplacer un groupe déjà sélectionné,
        // on ne doit PAS "dé-toggl-er" la sélection au mousedown.
        if(isSelected){
          // on garde la sélection existante, et on met juste à jour le primaire
          this.selectedId = token.id;
          this.refreshTokenSelectedClass();
          this.updateSelectionUI();
        } else {
          this.toggleSelectToken(token.id);
        }
      }else if(!alreadyInGroup){
        // clic normal : sélection simple (si pas déjà dans un groupe)
        this.selectToken(token.id);
      }else{
        // on garde la sélection de groupe, mais on met à jour le primaire
        this.selectedId = token.id;
        this.refreshTokenSelectedClass();
        this.updateSelectionUI();
      }

      this.bringToFront(token);

      if(token._el) token._el.classList.add('dragging');
      // PATCH D3 : si groupe, on marque aussi les autres
      if(this.selectedIds instanceof Set && this.selectedIds.size > 1 && this.selectedIds.has(token.id)){
        for(const id of this.selectedIds){
          if(id === token.id) continue;
          const t2 = this.tokens.find(tt => tt.id === id);
          if(t2 && t2._el) t2._el.classList.add('dragging');
        }
      }

      // --- Mode rotation ---
      if(rotateWhich){
        const D = this.diskD;
        const R = D/2;
        const cx = token.x + R;
        const cy = token.y + R;

        let lastPointer = Math.atan2(wp0.y - cy, wp0.x - cx);
        let rotDeg = (typeof token.rot === 'number') ? token.rot : 0;
        document.body.style.cursor = 'grabbing';

        const move = (ev) => {
          ev.preventDefault();
          const pt = ev.touches ? ev.touches[0] : ev;
          const wp = this.getWorldPos(pt.clientX, pt.clientY);

          const pointer = Math.atan2(wp.y - cy, wp.x - cx);
          const delta = this._shortestAngleDeltaRad(lastPointer, pointer);
          rotDeg += delta * 180/Math.PI;
          rotDeg = ((rotDeg % 360) + 360) % 360;
          lastPointer = pointer;

          token.rot = rotDeg;
          this._renderToken(token);
          token._pointerWorld = wp;
        };

        const end = () => {
          document.removeEventListener('mousemove', move);
          document.removeEventListener('touchmove', move);
          document.removeEventListener('mouseup', end);
          document.removeEventListener('touchend', end);
          // Retire le style dragging (leader + éventuel groupe)
        if(token._el) token._el.classList.remove('dragging');
        if(this.selectedIds instanceof Set && this.selectedIds.size > 1 && this.selectedIds.has(token.id)){
          for(const id of this.selectedIds){
            if(id === token.id) continue;
            const t2 = this.tokens.find(tt => tt.id === id);
            if(t2 && t2._el) t2._el.classList.remove('dragging');
          }
        }
          // PATCH D3 (fix): supprime le clic "fantôme" après la rotation
        this._suppressClickUntil = Date.now() + 260;

        // aimantation centre↔centre + clip angle (si proche)
          const snapped = this.snapToCenterAndMaybeClip(token);
          document.body.style.cursor = "";
        };

        document.addEventListener('mousemove', move);
        document.addEventListener('touchmove', move, {passive:false});
        document.addEventListener('mouseup', end);
        document.addEventListener('touchend', end);
        return;
      }

      // --- Mode déplacement ---
      const clientX = pt0.clientX;
      const clientY = pt0.clientY;
            // PATCH D3 (fix): déplacement de groupe
      const isGroup = (this.selectedIds instanceof Set) && this.selectedIds.size > 1 && this.selectedIds.has(token.id);
      const groupIds = isGroup ? Array.from(this.selectedIds) : [token.id];
      const groupTokens = groupIds.map(id => this.tokens.find(tt => tt.id === id)).filter(Boolean);

      // Positions de départ (pour appliquer un même delta à tout le groupe)
      const startPos = new Map();
      for(const t0 of groupTokens){
        startPos.set(t0.id, {x: t0.x, y: t0.y});
      }
      const leaderStart = startPos.get(token.id) || {x: token.x, y: token.y};

      const rect = token._el.getBoundingClientRect();
      const offset = { x: clientX - rect.left, y: clientY - rect.top };
      const br = this.boardContainer.getBoundingClientRect();

      let moved = false;

      const move = (ev) => {
        ev.preventDefault();
        const pt = ev.touches ? ev.touches[0] : ev;
        const cx = pt.clientX;
        const cy = pt.clientY;

        const wx = (cx - br.left - this.pan.x - offset.x) / this.scale;
        const wy = (cy - br.top  - this.pan.y - offset.y) / this.scale;

        const dx = (wx - leaderStart.x);
        const dy = (wy - leaderStart.y);

        if(!moved && (Math.abs(dx) > (1/this.scale) || Math.abs(dy) > (1/this.scale))){
          moved = true;
        }

        // Applique le même delta à tout le groupe (ou au seul token si pas de groupe)
        for(const t0 of groupTokens){
          const sp = startPos.get(t0.id) || {x: t0.x, y: t0.y};
          const nx = sp.x + dx;
          const ny = sp.y + dy;
          t0.x = nx;
          t0.y = ny;
          if(t0._el){
            t0._el.style.left = nx + 'px';
            t0._el.style.top  = ny + 'px';
          }
        }

        token._pointerWorld = this.getWorldPos(cx, cy);
      };

      const end = () => {
        document.removeEventListener('mousemove', move);
        document.removeEventListener('touchmove', move);
        document.removeEventListener('mouseup', end);
        document.removeEventListener('touchend', end);

        // Retire le style dragging sur tout le groupe
        for(const t0 of groupTokens){
          if(t0 && t0._el) t0._el.classList.remove('dragging');
        }

        // PATCH D3 (fix): évite le clic "fantôme" après un pointerup/touchend (sinon la multi-sélection se casse)
        this._suppressClickUntil = Date.now() + 260;

        // PATCH D3 (fix): snap du groupe sans s'accrocher aux éléments du groupe
        if(groupTokens.length > 1){
          const ignore = new Set(groupTokens.map(t0 => t0.id));
          const res = this.snapToCenterAndMaybeClip(token, {ignoreIds: ignore, returnTarget: true});
          if(res && res.snapped){
            for(const t0 of groupTokens){
              if(t0.id === token.id) continue;
              this._animateTokenTo(t0, {x: t0.x + res.dx, y: t0.y + res.dy}, {duration: 110, silent: true});
            }
          }
        } else {
          // aimantation centre↔centre + clip angle (si proche)
          this.snapToCenterAndMaybeClip(token);
        }
      };

document.addEventListener('mousemove', move);
      document.addEventListener('touchmove', move, {passive:false});
      document.addEventListener('mouseup', end);
      document.addEventListener('touchend', end);
    }

    // ---- Outils dessin ----

    setTool(tool){
      this.currentTool = tool;
      const hand = document.getElementById('tool-hand');
      const pen  = document.getElementById('tool-pen');
      if(hand){ hand.classList.toggle('bg-white', tool==='hand'); hand.classList.toggle('shadow', tool==='hand'); }
      if(pen){  pen.classList.toggle('bg-white', tool==='pen');   pen.classList.toggle('shadow', tool==='pen'); }

      const penMode = (tool === 'pen');
      this.boardContainer.classList.toggle('hide-cursor', penMode);
            this.boardContainer.classList.toggle('pen-active', penMode);
document.getElementById('custom-cursor').style.display = penMode ? 'block' : 'none';
    }

    // Suit le pointeur pour afficher une "petite croix" en mode stylo
    moveCursor(e){
      const cur = document.getElementById('custom-cursor');
      if(!cur) return;
      if(this.currentTool !== 'pen') return;
      const pt = e.touches ? e.touches[0] : e;
      if(!pt) return;
      cur.style.left = pt.clientX + 'px';
      cur.style.top  = pt.clientY + 'px';
    }

    resizeCanvas(){
      // Canvas HiDPI (lissage) : on augmente la résolution interne sans changer la taille « monde »
      const base = 4000;
      const dprRaw = window.devicePixelRatio || 1;
      // Cap pour éviter un canvas énorme (mémoire) sur écrans très denses
      const dpr = Math.min(dprRaw, 1.5);

      this.canvas.width = Math.round(base * dpr);
      this.canvas.height = Math.round(base * dpr);
      this.canvas.style.width = `${base}px`;
      this.canvas.style.height = `${base}px`;

      // 1 unité de coordonnées = 1 px du « monde »
      this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      this.ctx.lineWidth = 3;
      this.ctx.lineCap = 'round';
      this.ctx.lineJoin = 'round';
      this.ctx.strokeStyle = '#111827';
      this.ctx.imageSmoothingEnabled = true;
      if(this.ctx.imageSmoothingQuality) this.ctx.imageSmoothingQuality = 'high';

      // PATCH D2 : garder les traits lors d'un resize (le resize efface le canvas)
      this.redrawAllStrokes();
    }
    // ---- PATCH D2 : Crayon "pro" (Pointer Events + rAF + undo) ----
    _penCacheFromEvent(e){
      const r = this.boardContainer.getBoundingClientRect();
      this._drawCache = { left: r.left, top: r.top, panX: this.pan.x, panY: this.pan.y, scale: this.scale };
    }

    _penClientToWorld(clientX, clientY){
      const c = this._drawCache;
      return {
        x: (clientX - c.left - c.panX) / c.scale,
        y: (clientY - c.top  - c.panY) / c.scale
      };
    }

    _penPointerDown(e){
      this.isDrawing = true;
      this._activeDrawPointerId = e.pointerId;

      // capture = on continue à recevoir les move/up même si on sort du board
      try{ this.boardContainer.setPointerCapture(e.pointerId); }catch(_){}

      // cache rect/pan/zoom pour ne pas recalculer à chaque move
      this._penCacheFromEvent(e);

      // nouveau trait
      this._activeStroke = { color: '#111827', width: 3, pts: [] };
      this._drawQueue = [];

      const events = (typeof e.getCoalescedEvents === 'function') ? e.getCoalescedEvents() : [e];
      for(const ev of events){
        const p = this._penClientToWorld(ev.clientX, ev.clientY);
        const pr = (typeof ev.pressure === 'number') ? ev.pressure : 0;
        this._activeStroke.pts.push([p.x, p.y, pr]);
        this._drawQueue.push(p);
      }

      const first = this._drawQueue[0] || this._penClientToWorld(e.clientX, e.clientY);
      this._lastStrokePt = {x: first.x, y: first.y};
      this._schedulePenFlush();
    }

    _penPointerMove(e){
      if(!this._activeStroke) return;

      const events = (typeof e.getCoalescedEvents === 'function') ? e.getCoalescedEvents() : [e];
      for(const ev of events){
        const p = this._penClientToWorld(ev.clientX, ev.clientY);
        const pr = (typeof ev.pressure === 'number') ? ev.pressure : 0;
        this._activeStroke.pts.push([p.x, p.y, pr]);
        this._drawQueue.push(p);
      }
      this._schedulePenFlush();
    }

    _penPointerUp(e, cancelled=false){
      // flush ce qu'il reste
      this._flushPenNow();

      if(this._activeStroke && Array.isArray(this._activeStroke.pts) && this._activeStroke.pts.length){
        this.strokes.push(this._activeStroke);
      }

      this._activeStroke = null;
      this._drawQueue = [];
      this._drawCache = null;

      this.isDrawing = false;
      this._activeDrawPointerId = null;
    }

    _schedulePenFlush(){
      if(this._drawRAF) return;
      this._drawRAF = requestAnimationFrame(() => this._flushPenNow());
    }

    _flushPenNow(){
      if(this._drawRAF){
        // (si on est déjà dans le frame, cancelAnimationFrame est sans effet)
        try{ cancelAnimationFrame(this._drawRAF); }catch(_){}
        this._drawRAF = 0;
      }
      if(!this._activeStroke || !this._drawQueue || this._drawQueue.length === 0) return;

      const ctx = this.ctx;
      ctx.save();
      ctx.lineWidth = this._activeStroke.width || 3;
      ctx.strokeStyle = this._activeStroke.color || '#111827';
      ctx.beginPath();
      ctx.moveTo(this._lastStrokePt.x, this._lastStrokePt.y);

      for(const p of this._drawQueue){
        ctx.lineTo(p.x, p.y);
        this._lastStrokePt = p;
      }

      ctx.stroke();
      ctx.restore();
      this._drawQueue.length = 0;
    }

    undoDrawing(){
      if(!Array.isArray(this.strokes) || this.strokes.length === 0) return;
      this.strokes.pop();
      this.redrawAllStrokes();
      playSound('whoosh');
    }

    redrawAllStrokes(){
      const ctx = this.ctx;
      ctx.clearRect(0, 0, 4000, 4000);

      if(!Array.isArray(this.strokes) || this.strokes.length === 0) return;

      ctx.save();
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      for(const s of this.strokes){
        if(!s || !Array.isArray(s.pts) || s.pts.length === 0) continue;
        ctx.lineWidth = s.width || 3;
        ctx.strokeStyle = s.color || '#111827';
        ctx.beginPath();
        ctx.moveTo(s.pts[0][0], s.pts[0][1]);
        for(let i=1;i<s.pts.length;i++){
          const pt = s.pts[i];
          ctx.lineTo(pt[0], pt[1]);
        }
        ctx.stroke();
      }
      ctx.restore();
    }

    clearDrawing(){
      this.strokes = [];
      this._activeStroke = null;
      this._drawQueue = [];
      this._drawCache = null;
      this.ctx.clearRect(0, 0, 4000, 4000);
    }
    clearAllTokens(withHistory=true){
      if(withHistory) this.saveState();
      this.tokens.forEach(t => t._el && t._el.remove());
      this.tokens = [];
      this.selectedId = null;

      // Ordre d'empilement (z-index dynamique : la dernière pièce manipulée reste au-dessus)
      this.zTop = 0;
      this.updateSelectionUI();
    }

    resetAll(){
      this.saveState();
      this.clearAllTokens(false);
      this.clearDrawing();
      this.resetView();
      playSound('whoosh');
    }
  }

  // --- Mini tests (sécurité) ---
  function runSelfTests(){
    const required = [
      'btn-undo','btn-clear','btn-zoom-in','btn-zoom-out','btn-reset-view',
      'btn-hide-label','btn-flip','btn-separate','btn-cut','btn-fuse','btn-duplicate','btn-delete',
      'tool-hand','tool-pen','btn-clear-drawing',
      'board-container','board-world','palette','drawing-canvas',
      'mode-frac','mode-word','mode-percent','mode-angle','mode-empty',
      'btn-session','btn-help','btn-sound','btn-fullscreen',
      'modal-help','modal-session','session-select','session-name'
    ];
    const missing = required.filter(id => !document.getElementById(id));
    if(missing.length){
      // console.error('[SelfTest] IDs manquants:', missing);
    } else {
      // console.log('[SelfTest] OK');
    }
  }

  window.addEventListener('DOMContentLoaded', () => {
    runSelfTests();
    window.app = new FractionDisksApp();
  });

</script>

</body>
</html>
