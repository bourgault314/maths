<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Plateau – Disques de fractions</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;800&display=swap" rel="stylesheet">

  <style>

    :root{
      --diskD: 240;          /* diamètre d'un disque */
      --boardBg: #ffffff;    /* plateau blanc */
    }

    body{
      font-family: 'Fredoka', sans-serif;
      background: #ffffff;
      overflow: hidden;
      touch-action: none;
      user-select: none;
      -webkit-user-select: none;
    }

    #board-container{
      position: absolute;
      inset: 0;
      overflow: hidden;
      cursor: grab;
      background: var(--boardBg);
    }
    #board-container.panning{ cursor: grabbing; }

    #board-world{
      position: absolute;
      top: 0; left: 0;
      transform-origin: 0 0;
      width: 0; height: 0;
    }

    #drawing-canvas{
      position: absolute;
      top: 0; left: 0;
      pointer-events: none;
    }

    .no-scrollbar::-webkit-scrollbar{ display:none; }
    .no-scrollbar{ -ms-overflow-style:none; scrollbar-width:none; }

    /* --- Disques / pièces --- */
    .strip{
      /* anneau de sélection */
      --selRing: 0 0 0 0 rgba(59,130,246,0);

      position: absolute;
      border-radius: 9999px;
      box-shadow: var(--selRing);

      cursor: grab;
      touch-action: none;
      transform-origin: 0 0;
      overflow: visible;
      box-sizing: border-box;
      border: none;
      perspective: 900px;
      background: transparent;
    }
    .strip.dragging{ cursor: grabbing; z-index: 2000 !important; }
    .strip.is-disk.selected{ --selRing: 0 0 0 3px rgba(59,130,246,0.85); }

    @keyframes snapPop{
      0%{ transform: scale(1); }
      55%{ transform: scale(1.05); }
      100%{ transform: scale(1); }
    }
    .strip.snap-pop{ animation: snapPop 160ms ease-out; transform-origin: 50% 50%; }

    /* --- Animation de retournement --- */
    .strip-inner{
      position: relative;
      width: 100%;
      height: 100%;
      flex: 1 1 auto;
      transform-style: preserve-3d;
      transition: transform 820ms cubic-bezier(0.22, 0.8, 0.2, 1);
    }
    .strip.is-back .strip-inner{ transform: rotateX(180deg); }

    .face{
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      backface-visibility: hidden;
      -webkit-backface-visibility: hidden;
    }
    .face-back{ transform: rotateX(180deg); }

    .token-svg{ width: 100%; height: 100%; display:block; overflow: visible; }
    .sel-outline{ opacity: 0; transition: opacity 120ms ease; }
    .strip.selected .sel-outline{ opacity: 1; }

    /* Ghost drag depuis menu */
    .strip.ghost{
      position: fixed;
      pointer-events: none;
      opacity: 0.96;
      z-index: 9998;
      box-shadow: 0 22px 38px rgba(0,0,0,0.30);
      transform: scale(0.98);
      transition: transform 120ms ease-out, opacity 120ms ease-out;
    }
    .strip.ghost.ready{ transform: scale(1); }

    .strip.spawn-pop{ animation: popIn 140ms ease-out; }
    @keyframes popIn{ from{ transform: scale(0.92); } to{ transform: scale(1); } }

    /* fraction verticale (utilisée dans le menu) */
    .frac{
      display: inline-flex;
      flex-direction: column;
      align-items: center;
      line-height: 1;
      transform: translateY(-1px);
      filter: drop-shadow(0 1px 0 rgba(255,255,255,0.35));
    }
    .frac .num, .frac .den{ font-weight: 700; }
    .frac .bar{
      width: 1.2em;
      height: 2px;
      background: rgba(0,0,0,0.65);
      border-radius: 2px;
      /* + d'espace sous la barre (le dénominateur ne doit pas être collé) */
      margin: 3px 0 6px 0;
    }
    .frac .den{ margin-top: 1px; }

    .back-one{
      font-weight: 800;
      font-size: 1.35rem;
      text-shadow: 0 2px 0 rgba(255,255,255,0.35);
    }

    /* --- Menu gauche (palette) --- */
    .palette-item{
      padding: 6px 8px;
      border-radius: 12px;
      transition: none;
    }
    .palette-item:hover{ background: transparent; }

    .spawn-tile{
      height: 44px;
      width: 44px;
      flex: 0 0 auto;
      flex-shrink: 0;
      position: relative;
      border-radius: 9999px;
      border: none;
      overflow: visible;
      display: flex;
      cursor: grab;
      box-shadow:
        0 4px 10px rgba(0,0,0,0.18);
      user-select: none;
      touch-action: none;
      background: transparent;
    }
    .spawn-tile:active{ cursor: grabbing; }

    .spawn-tile .mini-svg{ width: 44px; height: 44px; display:block; }

    .frac.menu{ transform: none; filter: none; font-size: inherit; }
    .frac.menu .bar{ width: 0.9em; height: 2px; margin: 2px 0 7px 0; background: rgba(0,0,0,0.70); }
    .frac.menu .den{ margin-top: 2px; }

    /* poignées de rotation (sur les secteurs) */
    .rotate-handle{ opacity: 0; transition: opacity 120ms ease; cursor: grab; }
    .strip.selected .rotate-handle{ opacity: 1; }

    /* outils */
    #custom-cursor{ position: fixed; pointer-events:none; z-index: 9999; display:none; }
    .hide-cursor, .hide-cursor * { cursor: none !important; }

    /* Boutons de mode actifs */
    .mode-btn.active {
      background-color: #ffffff;
      color: #1d4ed8;
      box-shadow: 0 1px 2px rgba(0,0,0,0.1);
      border-color: #bfdbfe;
    }
    .mode-btn {
      color: #64748b;
      border: 1px solid transparent;
    }
    .mode-btn:hover:not(.active) {
      background-color: #f1f5f9;
      color: #475569;
    }

    @media (max-width: 640px){
      :root{ --diskD: 220; }
    }

  </style>
</head>

<body class="h-screen w-screen flex flex-col">

  <div id="custom-cursor">
    <svg class="drop-shadow-lg" width="34" height="34" viewBox="0 0 34 34" fill="none">
      <path d="M27 7 L13 21" stroke="#1d4ed8" stroke-width="6" stroke-linecap="round"/>
      <path d="M13 21 L8 32" stroke="#0f172a" stroke-width="4" stroke-linecap="round"/>
      <path d="M8 32 L12 28 L16 32 Z" fill="#111827"/>
      <circle cx="8" cy="32" r="1" fill="white"/>
    </svg>
  </div>

  <header class="bg-blue-50 p-2 shadow-md z-30 flex flex-wrap items-center gap-3 shrink-0">
    <div class="flex items-center gap-2">
      <button id="btn-undo" class="bg-blue-100 text-blue-700 hover:bg-blue-200 p-2 rounded-lg font-bold border border-blue-200 shadow-sm active:scale-95 transition" title="Annuler">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6" />
        </svg>
      </button>

      <button id="btn-clear" class="bg-rose-100 text-rose-700 hover:bg-rose-200 p-2 rounded-lg font-bold border border-rose-200 shadow-sm active:scale-95 transition" title="Tout effacer">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
        </svg>
      </button>

      <div class="h-8 w-px bg-slate-200 mx-1"></div>

      <button id="btn-zoom-out" class="bg-slate-100 hover:bg-slate-200 text-slate-800 px-3 py-2 rounded-lg border border-slate-200 font-bold active:scale-95 transition" title="Zoom -">−</button>
      <button id="btn-zoom-in" class="bg-slate-100 hover:bg-slate-200 text-slate-800 px-3 py-2 rounded-lg border border-slate-200 font-bold active:scale-95 transition" title="Zoom +">+</button>
      <button id="btn-reset-view" class="bg-slate-100 hover:bg-slate-200 text-slate-800 px-3 py-2 rounded-lg border border-slate-200 font-bold active:scale-95 transition" title="Recentrer">⤾</button>
      
      <div class="h-8 w-px bg-slate-200 mx-1"></div>

      <div class="flex items-center bg-slate-100 p-1 rounded-lg border border-slate-200">
        <button id="mode-frac"    class="mode-btn px-2 py-1.5 rounded-md text-xs font-bold transition-all active:scale-95" title="Fraction (1/2)">1/2</button>
        <button id="mode-word"    class="mode-btn px-2 py-1.5 rounded-md text-xs font-bold transition-all active:scale-95" title="Lettres (un demi)">Abc</button>
        <button id="mode-percent" class="mode-btn px-2 py-1.5 rounded-md text-xs font-bold transition-all active:scale-95" title="Pourcentage (50%)">%</button>
        <button id="mode-angle"   class="mode-btn px-2 py-1.5 rounded-md text-xs font-bold transition-all active:scale-95" title="Angle (180°)">Angle</button>
        <button id="mode-empty"   class="mode-btn px-2 py-1.5 rounded-md text-xs font-bold transition-all active:scale-95" title="Vide (pas de texte)">Vide</button>
      </div>
    </div>

    <div id="selection-actions" class="flex items-center gap-2">
      
      <button id="btn-hide-label" disabled class="bg-indigo-500 hover:bg-indigo-600 disabled:bg-indigo-200 text-white px-2 py-1 rounded-lg shadow-sm border border-indigo-200 disabled:opacity-40 disabled:cursor-not-allowed active:scale-95 transition flex flex-col items-center gap-0.5" title="Masquer/Afficher l'écriture">
        <svg id="icon-eye-open" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display:block">
          <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
          <circle cx="12" cy="12" r="3"></circle>
        </svg>
        <svg id="icon-eye-closed" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display:none">
          <path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"></path>
          <line x1="1" y1="1" x2="23" y2="23"></line>
        </svg>
        <span class="text-[10px] font-extrabold leading-none">Masquer</span>
      </button>

      <button id="btn-flip" disabled class="bg-amber-500 hover:bg-amber-600 disabled:bg-amber-200 text-white px-2 py-1 rounded-lg shadow-sm border border-amber-200 disabled:opacity-40 disabled:cursor-not-allowed active:scale-95 transition flex flex-col items-center gap-0.5" title="Retourner (double-clic aussi)">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M3 12a9 9 0 0 1 9-9"/>
          <path d="M3 4v8h8"/>
          <path d="M21 12a9 9 0 0 1-9 9"/>
          <path d="M21 20v-8h-8"/>
        </svg>
        <span class="text-[10px] font-extrabold leading-none">Retourner</span>
      </button>

      <button id="btn-separate" disabled class="bg-blue-600 hover:bg-blue-700 disabled:bg-blue-200 text-white px-2 py-1 rounded-lg shadow-sm border border-blue-200 disabled:opacity-40 disabled:cursor-not-allowed active:scale-95 transition flex flex-col items-center gap-0.5" title="Séparer le disque en secteurs">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M4 4l16 16"/>
          <path d="M4 20L20 4"/>
        </svg>
        <span class="text-[10px] font-extrabold leading-none">Séparer</span>
      </button>

      <button id="btn-cut" disabled class="bg-slate-700 hover:bg-slate-800 disabled:bg-slate-200 text-white px-2 py-1 rounded-lg shadow-sm border border-slate-200 disabled:opacity-40 disabled:cursor-not-allowed active:scale-95 transition flex flex-col items-center gap-0.5" title="Couper en 2 (si le double existe)">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="6" cy="6" r="2"/>
          <circle cx="6" cy="18" r="2"/>
          <path d="M20 4L8.12 15.88"/>
          <path d="M14.47 14.48L20 20"/>
          <path d="M8.12 8.12L12 12"/>
        </svg>
        <span class="text-[10px] font-extrabold leading-none">Couper</span>
      </button>

      <button id="btn-fuse" disabled class="bg-violet-600 hover:bg-violet-700 disabled:bg-violet-200 text-white px-2 py-1 rounded-lg shadow-sm border border-violet-200 disabled:opacity-40 disabled:cursor-not-allowed active:scale-95 transition flex flex-col items-center gap-0.5" title="Fusionner des secteurs alignés en un disque">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M10 13a5 5 0 0 1 0-7l1-1a5 5 0 0 1 7 7l-1 1"/>
          <path d="M14 11a5 5 0 0 1 0 7l-1 1a5 5 0 0 1-7-7l1-1"/>
        </svg>
        <span class="text-[10px] font-extrabold leading-none">Fusionner</span>
      </button>

      <button id="btn-duplicate" disabled class="bg-emerald-600 hover:bg-emerald-700 disabled:bg-emerald-200 text-white px-2 py-1 rounded-lg shadow-sm border border-emerald-200 disabled:opacity-40 disabled:cursor-not-allowed active:scale-95 transition flex flex-col items-center gap-0.5" title="Dupliquer">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <rect x="9" y="9" width="13" height="13" rx="2"/>
          <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
        </svg>
        <span class="text-[10px] font-extrabold leading-none">Dupliquer</span>
      </button>

      <button id="btn-delete" disabled class="bg-rose-600 hover:bg-rose-700 disabled:bg-rose-200 text-white px-2 py-1 rounded-lg shadow-sm border border-rose-200 disabled:opacity-40 disabled:cursor-not-allowed active:scale-95 transition flex flex-col items-center gap-0.5" title="Supprimer">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
        </svg>
        <span class="text-[10px] font-extrabold leading-none">Supprimer</span>
      </button>
    </div>

    <div class="flex items-center gap-1 bg-gray-100 p-1 rounded-lg">
      <button id="tool-hand" class="p-2 rounded bg-white shadow text-gray-700" title="Main (déplacer / sélectionner)">
        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 11.5V14m0-2.5v-6a1.5 1.5 0 113 0m-3 6a1.5 1.5 0 00-3 0v2a7.5 7.5 0 0015 0v-5a1.5 1.5 0 00-3 0m-6-3V11m0-5.5v-1a1.5 1.5 0 013 0v1m0 0V11m0-5.5a1.5 1.5 0 013 0v3m0 0V11"/></svg>
      </button>
      <button id="tool-pen" class="p-2 rounded text-gray-500 hover:bg-gray-200" title="Stylo (annoter)">
        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"/></svg>
      </button>
      <button id="btn-clear-drawing" class="p-2 rounded text-rose-500 hover:bg-rose-50" title="Effacer les annotations">
        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/></svg>
      </button>
    </div>
  </header>

  <div class="flex flex-1 overflow-hidden relative">

    <aside class="w-[340px] bg-blue-50 border-r border-blue-200 flex flex-col py-4 gap-3 z-20 shadow-lg shrink-0 overflow-y-auto no-scrollbar">
      <div class="px-3"></div>
      <div id="palette" class="px-3 flex flex-col gap-3"></div>

      <div class="mt-2 px-3">
        <div class="text-[10px] font-bold text-slate-400 uppercase">Astuces</div>
        <ul class="text-[11px] text-slate-500 leading-snug list-disc ml-4 mt-1">
          <li>Double-clic sur un disque/secteur = retourner.</li>
          <li>Molette = zoom, glisser sur fond = déplacer le plateau.</li>
        </ul>
      </div>
    </aside>

    <main class="flex-1 relative overflow-hidden">
      <div id="board-container">
        <div id="board-world">
          <canvas id="drawing-canvas"></canvas>
        </div>
      </div>
    </main>

  </div>

<script>

  // --- Configuration couleurs ---
  const FRACTIONS = [
    { denom: 1,  name: 'Unité',     color: '#fff7e6', border: '#cbd5e1', text: '#111827' },
    { denom: 2,  name: 'Demi',      color: '#facc15', border: '#a16207', text: '#111827' },
    { denom: 3,  name: 'Tiers',     color: '#e9d5ff', border: '#7c3aed', text: '#111827' },
    { denom: 4,  name: 'Quart',     color: '#84cc16', border: '#3f6212', text: '#111827' },
    { denom: 5,  name: 'Cinquième', color: '#38bdf8', border: '#075985', text: '#0b1220' },
    { denom: 6,  name: 'Sixième',   color: '#f97316', border: '#9a3412', text: '#111827' },
    { denom: 8,  name: 'Huitième',  color: '#f472b6', border: '#be185d', text: '#111827' },
    { denom: 10, name: 'Dixième',   color: '#b91c1c', border: '#7f1d1d', text: '#111827' },
  ];

  // Audio (optionnel) – protège si indisponible
  let audioCtx = null;
  try{ audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }catch(_){ audioCtx = null; }

  function playSound(type){
    if (!audioCtx) return;
    if (audioCtx.state === 'suspended') audioCtx.resume().catch(()=>{});
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain); gain.connect(audioCtx.destination);
    const now = audioCtx.currentTime;
    const stop = (t)=>{ try{ osc.stop(t); }catch(_){} };
    if(type==='pop'){
      osc.type='sine';
      osc.frequency.setValueAtTime(320, now);
      osc.frequency.exponentialRampToValueAtTime(560, now+0.08);
      gain.gain.setValueAtTime(0.10, now);
      gain.gain.linearRampToValueAtTime(0, now+0.10);
      osc.start(now); stop(now+0.10);
    } else if(type==='flip'){
      osc.type='triangle';
      osc.frequency.setValueAtTime(210, now);
      osc.frequency.linearRampToValueAtTime(440, now+0.16);
      gain.gain.setValueAtTime(0.10, now);
      gain.gain.linearRampToValueAtTime(0, now+0.18);
      osc.start(now); stop(now+0.18);
    } else if(type==='whoosh'){
      osc.type='triangle';
      osc.frequency.setValueAtTime(360, now);
      osc.frequency.exponentialRampToValueAtTime(60, now+0.22);
      gain.gain.setValueAtTime(0.06, now);
      gain.gain.linearRampToValueAtTime(0, now+0.22);
      osc.start(now); stop(now+0.22);
    }
  }

  class FractionDisksApp {
    constructor(){
      this.history = [];
      // token: {id, denom, kind:'disk'|'piece', side:'front'|'back', x,y, rot?, slot?, hideLabel?, _el}
      this.tokens = [];
      this.nextId = 1;
      this.selectedId = null;

      this.scale = 1;
      this.pan = {x: 0, y: 0};
      this.isPanning = false;
      this.panStart = {x:0, y:0};

      this.currentTool = 'hand';
      this.isDrawing = false;
      this.lastDrawPos = {x:0,y:0};

      // Modes: 'frac' | 'word' | 'percent' | 'angle' | 'empty'
      this.labelMode = 'frac';

      // Drag depuis le menu (ghost)
      this.spawnDrag = null;
      this._lastSpawnClient = {x:0, y:0};

      this.boardContainer = document.getElementById('board-container');
      this.boardWorld = document.getElementById('board-world');
      this.palette = document.getElementById('palette');

      this.canvas = document.getElementById('drawing-canvas');
      this.ctx = this.canvas.getContext('2d');

      this.DENOM_SET = new Set(FRACTIONS.map(f => f.denom));

      this.buildPalette();
      this.initUI();
      this.initBoardListeners();
      this.resizeCanvas();
      this.updateTransform();
      this.updateSelectionUI();
      this.setLabelMode('frac'); // set initial UI state
    }

    // ---- Dimensions ----
    get diskD(){ return parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--diskD')) || 240; }
    tokenDims(_t){ return { w: this.diskD, h: this.diskD }; }

    // ---- Historique ----
    saveState(){
      const snapshot = {
        tokens: this.tokens.map(t => ({
          id:t.id, denom:t.denom, kind:t.kind, side:t.side, x:t.x, y:t.y,
          rot: (typeof t.rot === 'number') ? t.rot : 0,
          slot: (typeof t.slot === 'number') ? t.slot : null,
          hideLabel: !!t.hideLabel
        })),
        nextId: this.nextId,
        selectedId: this.selectedId,
        pan: {...this.pan},
        scale: this.scale,
      };
      this.history.push(snapshot);
      if(this.history.length > 30) this.history.shift();
    }

    undo(){
      const snap = this.history.pop();
      if(!snap) return;
      this.clearAllTokens(false);
      this.tokens = snap.tokens.map(t => ({...t}));
      this.nextId = snap.nextId;
      this.selectedId = snap.selectedId;
      this.pan = snap.pan;
      this.scale = snap.scale;
      this.tokens.forEach(t => this.mountToken(t));
      this.updateTransform();
      this.updateSelectionUI();
      playSound('whoosh');
    }

    // ---- Palette ----

    buildPalette(){
      this.palette.innerHTML = '';
      FRACTIONS.forEach(f => {
        const row = document.createElement('div');
        row.className = 'palette-item';

        const line = document.createElement('div');
        line.className = 'flex items-center gap-3';

        const picks = document.createElement('div');
        picks.className = 'flex items-center gap-3 flex-nowrap';

        picks.appendChild(this.makeSpawnTile(f.denom, 'disk'));
        if(f.denom !== 1) picks.appendChild(this.makeSpawnTile(f.denom, 'piece'));

        const label = document.createElement('div');
        label.className = 'text-sm font-extrabold text-slate-700 flex items-center gap-2 select-none';
        label.innerHTML = this._menuFractionHTML(f.denom);

        line.appendChild(picks);
        line.appendChild(label);
        row.appendChild(line);
        this.palette.appendChild(row);
      });
    }

    _menuFractionHTML(denom){
      // Empty: on cache totalement le texte du menu
      if(this.labelMode === 'empty'){
        return ``;
      }

      if(this.labelMode === 'percent'){
        const val = (100 / denom);
        // parseFloat retire les zéros inutiles (.00)
        const txt = parseFloat(val.toFixed(2)) + '%';
        return `<span class="font-extrabold">${txt}</span>`;
      }

      if(this.labelMode === 'angle'){
        const val = (360 / denom);
        // "arrondis au 10e" -> 1 chiffre après la virgule
        const txt = Number(val.toFixed(1)) + '°'; 
        return `<span class="font-extrabold">${txt}</span>`;
      }

      if(this.labelMode === 'word'){
        if(denom === 1) return `<span class="font-extrabold">1</span>`;
        return `<span class="font-extrabold">${this.wordInlineForDenom(denom)}</span>`;
      }
      
      // Frac mode
      if(denom === 1) return `<span class="font-extrabold">1</span>`;
      return `<span class="frac menu"><span class="num">1</span><span class="bar"></span><span class="den">${denom}</span></span>`;
    }

    wordInlineForDenom(denom){
      if(denom === 1) return '1';
      const map = {
        2: 'demi',
        3: 'tiers',
        4: 'quart',
        5: 'cinquième',
        6: 'sixième',
        8: 'huitième',
        10:'dixième'
      };
      const w = map[denom] || `${denom}e`;
      return `un ${w}`;
    }

    wordLinesForDenom(denom){
      if(denom === 1) return ['1'];
      const inline = this.wordInlineForDenom(denom);
      const parts = inline.split(' ');
      if(parts.length >= 2) return [parts[0], parts.slice(1).join(' ')];
      return [inline];
    }

    // Gestion du mode d'affichage
    setLabelMode(mode){
      this.labelMode = mode;
      this.updateModeButtonsUI();
      this.buildPalette(); // Rebuild menu labels
      // Update tokens on board
      for(const t of this.tokens){
        if(t._el) this._renderToken(t);
      }
    }

    updateModeButtonsUI(){
      const modes = ['frac','word','percent','angle','empty'];
      modes.forEach(m => {
        const btn = document.getElementById(`mode-${m}`);
        if(btn){
          if(m === this.labelMode) btn.classList.add('active');
          else btn.classList.remove('active');
        }
      });
    }

    getFractionConfig(denom){
      return FRACTIONS.find(f => f.denom === denom) || FRACTIONS[0];
    }

    fontSizeFor(denom, kind){
      if(kind === 'piece'){
        if(denom >= 10) return 14; 
        if(denom === 9)  return 15;
        if(denom === 8)  return 17;
        if(denom === 7)  return 17;
        if(denom === 6)  return 18;
        if(denom === 5)  return 19;
        if(denom === 4)  return 20;
        if(denom === 3)  return 21;
        if(denom === 2)  return 22;
        return 18;
      }
      if(denom >= 10) return 13;
      if(denom === 9)  return 14;
      if(denom === 8)  return 15;
      if(denom === 7)  return 16;
      if(denom === 6)  return 17;
      if(denom === 5)  return 17;
      if(denom === 4)  return 18;
      if(denom === 3)  return 19;
      if(denom === 2)  return 20;
      return 17;
    }

    // --- Géométrie ---
    _startAngleRad(){ return -Math.PI/2; }

    _normAngle0to2pi(a){
      const two = Math.PI*2;
      a = a % two;
      if(a < 0) a += two;
      return a;
    }

    _angleInArc(angle, start, end){
      // Compare en [0,2pi)
      const a = this._normAngle0to2pi(angle);
      const s = this._normAngle0to2pi(start);
      const e = this._normAngle0to2pi(end);
      if(s <= e) return a >= s && a <= e;
      return a >= s || a <= e;
    }

    _sectorPath(cx, cy, r, start, end){
      const p1x = cx + r*Math.cos(start);
      const p1y = cy + r*Math.sin(start);
      const p2x = cx + r*Math.cos(end);
      const p2y = cy + r*Math.sin(end);
      const delta = this._normAngle0to2pi(end - start);
      const largeArc = delta > Math.PI ? 1 : 0;
      return `M ${cx} ${cy} L ${p1x} ${p1y} A ${r} ${r} 0 ${largeArc} 1 ${p2x} ${p2y} Z`;
    }

    _fractionSVG(denom, x, y, fs, color){
      const barW = fs * 1.05;
      if(denom === 1){
        return `
          <g font-family="Fredoka, sans-serif" text-anchor="middle" font-weight="800">
            <text x="${x}" y="${y+1}" font-size="${fs*1.15}" fill="rgba(255,255,255,0.35)">1</text>
            <text x="${x}" y="${y}"   font-size="${fs*1.15}" fill="${color}">1</text>
          </g>
        `;
      }
      const numY = y - fs*0.62;
      const barY = y - fs*0.05;
      const denY = y + fs*1.30;
      return `
        <g font-family="Fredoka, sans-serif" text-anchor="middle" font-weight="800">
          <text x="${x}" y="${numY+1}" font-size="${fs}" fill="rgba(255,255,255,0.35)">1</text>
          <text x="${x}" y="${numY}"   font-size="${fs}" fill="${color}">1</text>

          <line x1="${x-barW/2}" y1="${barY+1}" x2="${x+barW/2}" y2="${barY+1}" stroke="rgba(255,255,255,0.35)" stroke-width="2" stroke-linecap="round" />
          <line x1="${x-barW/2}" y1="${barY}"   x2="${x+barW/2}" y2="${barY}"   stroke="rgba(0,0,0,0.70)" stroke-width="2" stroke-linecap="round" />

          <text x="${x}" y="${denY+1}" font-size="${fs}" fill="rgba(255,255,255,0.35)">${denom}</text>
          <text x="${x}" y="${denY}"   font-size="${fs}" fill="${color}">${denom}</text>
        </g>
      `;
    }

    _wordSVG(denom, x, y, fs, color){
      if(denom === 1){
        return this._fractionSVG(1, x, y, fs, color);
      }
      const lines = this.wordLinesForDenom(denom);
      const sf = (denom >= 10) ? 0.62 : (denom >= 8) ? 0.66 : (denom >= 6) ? 0.70 : (denom >= 5) ? 0.74 : 0.82;
      const f = fs * sf;

      if(lines.length === 1){
        const t = lines[0];
        return `
          <g font-family="Fredoka, sans-serif" text-anchor="middle" font-weight="900" style="pointer-events:none">
            <text x="${x}" y="${y+1}" font-size="${f}" fill="rgba(255,255,255,0.35)">${t}</text>
            <text x="${x}" y="${y}"   font-size="${f}" fill="${color}">${t}</text>
          </g>
        `;
      }
      const l1 = lines[0];
      const l2 = lines[1];
      const y1 = y - f*0.12;
      const y2 = y + f*0.98;
      return `
        <g font-family="Fredoka, sans-serif" text-anchor="middle" font-weight="900" style="pointer-events:none">
          <text x="${x}" y="${y1+1}" font-size="${f}" fill="rgba(255,255,255,0.35)">${l1}</text>
          <text x="${x}" y="${y1}"   font-size="${f}" fill="${color}">${l1}</text>
          <text x="${x}" y="${y2+1}" font-size="${f}" fill="rgba(255,255,255,0.35)">${l2}</text>
          <text x="${x}" y="${y2}"   font-size="${f}" fill="${color}">${l2}</text>
        </g>
      `;
    }

    _textSVG(txt, x, y, fs, color){
      // Helper pour afficher du texte simple (%, angle)
      // On réduit un peu la police si c'est long
      const str = String(txt);
      let f = fs;
      if(str.length >= 6) f = fs * 0.75;
      else if(str.length >= 4) f = fs * 0.85;

      return `
        <g font-family="Fredoka, sans-serif" text-anchor="middle" font-weight="900" style="pointer-events:none">
          <text x="${x}" y="${y+1}" font-size="${f}" fill="rgba(255,255,255,0.35)">${str}</text>
          <text x="${x}" y="${y}"   font-size="${f}" fill="${color}">${str}</text>
        </g>
      `;
    }

    _labelSVG(denom, x, y, fs, color){
      if(this.labelMode === 'empty') return '';

      if(this.labelMode === 'word'){
        return this._wordSVG(denom, x, y, fs, color);
      }
      if(this.labelMode === 'percent'){
        const val = (100 / denom);
        // parseFloat retire les .00
        const txt = parseFloat(val.toFixed(2)) + '%'; 
        return this._textSVG(txt, x, y, fs, color);
      }
      if(this.labelMode === 'angle'){
        const val = (360 / denom);
        // arrondi au 10e
        const txt = Number(val.toFixed(1)) + '°';
        return this._textSVG(txt, x, y, fs, color);
      }
      // default: frac
      return this._fractionSVG(denom, x, y, fs, color);
    }

    _tokenSVGMarkup(token, face){
      const D = this.diskD;
      const R = D/2;
      const cx = R, cy = R;
      const cfg = this.getFractionConfig(token.denom);
      const border = 'rgba(0,0,0,0.55)';
      const fs = this.fontSizeFor(token.denom, token.kind);
      const start = this._startAngleRad();
      const step = (token.denom > 0) ? (Math.PI*2/token.denom) : (Math.PI*2);

      const isBackFace = (face === 'back');
      // Pour l'affichage de la valeur
      const showDen = token.denom;

      // Logique spécifique pour le verso (le '1')
      const getBackLabel = () => {
        if(this.labelMode === 'empty') return '';
        if(this.labelMode === 'percent') return '100%';
        if(this.labelMode === 'angle') return '360°';
        return 1;
      };

      if(token.kind === 'disk'){
        let lines = '';
        let labels = '';

        const circle = `<circle cx="${cx}" cy="${cy}" r="${R-0.8}" fill="${cfg.color}" stroke="${border}" stroke-width="1.2" />`;

        if(!isBackFace && token.denom > 1){
          // traits
          for(let k=0;k<token.denom;k++){
            const a = start + k*step;
            const x2 = cx + (R-2)*Math.cos(a);
            const y2 = cy + (R-2)*Math.sin(a);
            lines += `<line x1="${cx}" y1="${cy}" x2="${x2}" y2="${y2}" stroke="rgba(0,0,0,0.28)" stroke-width="1" stroke-dasharray="6 4" stroke-linecap="round" />`;
          }
          // étiquettes (seulement si non masquées par le bouton Oeil)
          if(!token.hideLabel){
            const rr = R * 0.62;
            for(let i=0;i<token.denom;i++){
              const mid = start + (i+0.5)*step;
              const tx = cx + rr*Math.cos(mid);
              const ty = cy + rr*Math.sin(mid);
              labels += this._labelSVG(showDen, tx, ty, fs, cfg.text);
            }
          }
        } else {
          // verso (ou denom=1)
          if(!token.hideLabel){
            const bl = getBackLabel();
            if(bl !== ''){
               if(typeof bl === 'number') labels += this._labelSVG(bl, cx, cy, Math.max(16, fs*1.25), cfg.text);
               else labels += this._textSVG(bl, cx, cy, Math.max(16, fs*1.25), cfg.text);
            }
          }
        }

        return `
          <svg class="token-svg" viewBox="0 0 ${D} ${D}" xmlns="http://www.w3.org/2000/svg">
            ${circle}
            ${lines}
            ${labels}
          </svg>
        `;
      }

      // piece
      const rotDeg = (typeof token.rot === 'number') ? token.rot : 0;
      const rotRad = rotDeg * Math.PI/180;
      const a0 = start + rotRad;
      const a1 = a0 + step;
      const path = this._sectorPath(cx, cy, R-1.2, a0, a1);
      const mid = a0 + step/2;
      
      // MODIFICATION ICI : Rapprochement du centre pour les demis (denom=2)
      let rr = R * 0.62;
      if(token.denom === 2) rr = R * 0.45;

      const tx = cx + rr*Math.cos(mid);
      const ty = cy + rr*Math.sin(mid);

      const handleR = 5.2;
      const hrH = R - 14;
      const h1x = cx + hrH*Math.cos(a0);
      const h1y = cy + hrH*Math.sin(a0);
      const h2x = cx + hrH*Math.cos(a1);
      const h2y = cy + hrH*Math.sin(a1);
      const handles = `
        <circle class="rotate-handle" data-handle="a0" cx="${h1x}" cy="${h1y}" r="${handleR}" fill="rgba(255,255,255,0.95)" stroke="rgba(0,0,0,0.55)" stroke-width="1.2" />
        <circle class="rotate-handle" data-handle="a1" cx="${h2x}" cy="${h2y}" r="${handleR}" fill="rgba(255,255,255,0.95)" stroke="rgba(0,0,0,0.55)" stroke-width="1.2" />
      `;

      let pieceLabel = '';
      if(!token.hideLabel){
         pieceLabel = this._labelSVG(showDen, tx, ty, fs, cfg.text);
      }

      return `
        <svg class="token-svg" viewBox="0 0 ${D} ${D}" xmlns="http://www.w3.org/2000/svg">
          <path d="${path}" fill="${cfg.color}" stroke="${border}" stroke-width="1.2" />
          <path class="sel-outline" d="${path}" fill="none" stroke="rgba(59,130,246,0.85)" stroke-width="4" stroke-linejoin="round" />
          ${pieceLabel}
          ${handles}
        </svg>
      `;
    }

    makeSpawnTile(denom, kind){
      const cfg = this.getFractionConfig(denom);
      const tile = document.createElement('div');
      tile.className = `spawn-tile ${kind==='disk' ? 'spawn-disk' : 'spawn-piece'}`;
      tile.setAttribute('draggable', 'false');
      tile.title = (kind === 'disk') ? 'Ajouter un disque' : 'Ajouter une pièce';

      // mini preview
      const D = 44;
      const R = D/2;
      const cx = R, cy = R;
      const start = -Math.PI/2;
      const step = (denom > 0) ? (Math.PI*2/denom) : (Math.PI*2);

      let inner = '';
      if(kind === 'disk'){
        inner += `<circle cx="${cx}" cy="${cy}" r="${R-1.1}" fill="${cfg.color}" stroke="rgba(0,0,0,0.55)" stroke-width="1.2" />`;
        if(denom > 1){
          for(let k=0;k<denom;k++){
            const a = start + k*step;
            const x2 = cx + (R-2)*Math.cos(a);
            const y2 = cy + (R-2)*Math.sin(a);
            inner += `<line x1="${cx}" y1="${cy}" x2="${x2}" y2="${y2}" stroke="rgba(0,0,0,0.20)" stroke-width="1" stroke-dasharray="4 3" />`;
          }
        }
      } else {
        const a0 = start;
        const a1 = start + step;
        const path = this._sectorPath(cx, cy, R-1.5, a0, a1);
        inner += `<circle cx="${cx}" cy="${cy}" r="${R-1.1}" fill="rgba(255,255,255,0)" stroke="rgba(0,0,0,0.10)" stroke-width="1" />`;
        inner += `<path d="${path}" fill="${cfg.color}" stroke="rgba(0,0,0,0.55)" stroke-width="1.2" />`;
      }

      tile.innerHTML = `
        <svg class="mini-svg" viewBox="0 0 ${D} ${D}" xmlns="http://www.w3.org/2000/svg">
          ${inner}
        </svg>
      `;

      const startFn = (e) => this.startSpawnDrag(e, denom, kind);
      tile.addEventListener('mousedown', startFn);
      tile.addEventListener('touchstart', startFn, {passive:false});
      return tile;
    }

    buildGhostToken(denom, kind){
      const el = document.createElement('div');
      el.className = 'strip ghost';
      const t = {id:-1, denom, kind, side:'front', x:0, y:0, rot:0};
      el.innerHTML = `
        <div class="strip-inner">
          <div class="face face-front">${this._tokenSVGMarkup(t,'front')}</div>
          <div class="face face-back">${this._tokenSVGMarkup(t,'back')}</div>
        </div>
      `;
      return el;
    }

    startSpawnDrag(e, denom, kind){
      if(e.type === 'mousedown' && e.button !== 0) return;
      e.preventDefault();
      e.stopPropagation();

      const pt = e.touches ? e.touches[0] : e;
      const cx = pt.clientX;
      const cy = pt.clientY;
      this._lastSpawnClient = {x: cx, y: cy};

      const wWorld = this.diskD;
      const hWorld = this.diskD;
      const w = wWorld * this.scale;
      const h = hWorld * this.scale;

      const ghost = this.buildGhostToken(denom, kind);
      ghost.style.width = `${w}px`;
      ghost.style.height = `${h}px`;
      ghost.style.left = `${cx - w/2}px`;
      ghost.style.top  = `${cy - h/2}px`;
      document.body.appendChild(ghost);
      requestAnimationFrame(() => ghost.classList.add('ready'));

      this.spawnDrag = { denom, kind, start: {x: cx, y: cy}, moved: false, ghost, w, h };

      const move = (ev) => this.onSpawnMove(ev);
      const end  = (ev) => this.onSpawnEnd(ev, move, end);
      document.addEventListener('mousemove', move);
      document.addEventListener('mouseup', end);
      document.addEventListener('touchmove', move, {passive:false});
      document.addEventListener('touchend', end);
      document.addEventListener('touchcancel', end);
    }

    onSpawnMove(ev){
      const sd = this.spawnDrag;
      if(!sd) return;
      ev.preventDefault();

      const pt = ev.touches ? ev.touches[0] : ev;
      const cx = pt.clientX;
      const cy = pt.clientY;
      this._lastSpawnClient = {x: cx, y: cy};

      const dist = Math.hypot(cx - sd.start.x, cy - sd.start.y);
      if(dist > 6) sd.moved = true;

      sd.ghost.style.left = `${cx - sd.w/2}px`;
      sd.ghost.style.top  = `${cy - sd.h/2}px`;
    }

    onSpawnEnd(ev, moveFn, endFn){
      const sd = this.spawnDrag;
      if(!sd) return;

      document.removeEventListener('mousemove', moveFn);
      document.removeEventListener('mouseup', endFn);
      document.removeEventListener('touchmove', moveFn);
      document.removeEventListener('touchend', endFn);
      document.removeEventListener('touchcancel', endFn);

      const cx = (ev.changedTouches && ev.changedTouches[0]) ? ev.changedTouches[0].clientX : this._lastSpawnClient.x;
      const cy = (ev.changedTouches && ev.changedTouches[0]) ? ev.changedTouches[0].clientY : this._lastSpawnClient.y;

      const br = this.boardContainer.getBoundingClientRect();
      const insideBoard = (cx >= br.left && cx <= br.right && cy >= br.top && cy <= br.bottom);

      if(insideBoard){
        const p = this.getWorldPos(cx, cy);
        const created = this.addToken({denom: sd.denom, kind: sd.kind, x: p.x, y: p.y});
        created._pointerWorld = p;
        this.snapToken(created, {silent:true});
      } else if(!sd.moved){
        const center = this.getWorldPos(br.left + br.width*0.5, br.top + br.height*0.35);
        this.addToken({denom: sd.denom, kind: sd.kind, x: center.x, y: center.y});
      }

      if(sd.ghost) sd.ghost.remove();
      this.spawnDrag = null;
    }

    // ---- Plateau / transformation ----
    updateTransform(){
      this.boardWorld.style.transform = `translate(${this.pan.x}px, ${this.pan.y}px) scale(${this.scale})`;
    }

    setZoom(z){
      this.scale = Math.min(Math.max(0.45, z), 3);
      this.updateTransform();
    }

    resetView(){
      this.pan = {x:0, y:0};
      this.scale = 1;
      this.updateTransform();
    }

    getWorldPos(clientX, clientY){
      const r = this.boardContainer.getBoundingClientRect();
      return {
        x: (clientX - r.left - this.pan.x) / this.scale,
        y: (clientY - r.top - this.pan.y) / this.scale,
      };
    }

    // ---- UI ----
    _bind(id, evt, fn){
      const el = document.getElementById(id);
      if(!el){
        // console.warn(`[UI] Élément manquant: #${id} (listener ${evt} ignoré)`);
        return null;
      }
      el.addEventListener(evt, fn);
      return el;
    }

    initUI(){
      this._bind('btn-undo','click', () => this.undo());
      this._bind('btn-clear','click', () => this.resetAll());
      this._bind('btn-zoom-in','click', () => this.setZoom(this.scale + 0.15));
      this._bind('btn-zoom-out','click', () => this.setZoom(this.scale - 0.15));
      this._bind('btn-reset-view','click', () => this.resetView());
      
      // Modes
      this._bind('mode-frac', 'click', () => this.setLabelMode('frac'));
      this._bind('mode-word', 'click', () => this.setLabelMode('word'));
      this._bind('mode-percent', 'click', () => this.setLabelMode('percent'));
      this._bind('mode-angle', 'click', () => this.setLabelMode('angle'));
      this._bind('mode-empty', 'click', () => this.setLabelMode('empty'));

      // Actions selection
      this._bind('btn-hide-label', 'click', () => this.toggleTokenLabel());
      this._bind('btn-flip','click', () => this.flipSelected());
      this._bind('btn-separate','click', () => this.separateSelected());
      this._bind('btn-cut','click', () => this.cutSelected());
      this._bind('btn-fuse','click', () => this.fuseSelected());
      this._bind('btn-duplicate','click', () => this.duplicateSelected());
      this._bind('btn-delete','click', () => this.deleteSelected());

      this._bind('tool-hand','click', () => this.setTool('hand'));
      this._bind('tool-pen','click', () => this.setTool('pen'));
      this._bind('btn-clear-drawing','click', () => this.clearDrawing());

      window.addEventListener('keydown', (e) => {
        if(e.key === 'Escape') this.selectToken(null);
        if((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') { e.preventDefault(); this.undo(); }
        if(e.key === 'Delete' || e.key === 'Backspace') this.deleteSelected();
      });
    }

    updateSelectionUI(){
      const btnHide = document.getElementById('btn-hide-label');
      const iconOpen = document.getElementById('icon-eye-open');
      const iconClosed = document.getElementById('icon-eye-closed');

      const btnFlip = document.getElementById('btn-flip');
      const btnSep  = document.getElementById('btn-separate');
      const btnCut  = document.getElementById('btn-cut');
      const btnFuse = document.getElementById('btn-fuse');
      const btnDup  = document.getElementById('btn-duplicate');
      const btnDel  = document.getElementById('btn-delete');

      const s = this.selected;
      const has = !!s;

      if(btnHide){
        btnHide.disabled = !has;
        if(has && s.hideLabel){
           // Mode masqué : montrer l'oeil barré
           iconOpen.style.display = 'none';
           iconClosed.style.display = 'block';
           btnHide.classList.add('bg-rose-500', 'border-rose-300');
           btnHide.classList.remove('bg-indigo-500', 'border-indigo-200');
        } else {
           // Mode normal
           iconOpen.style.display = 'block';
           iconClosed.style.display = 'none';
           btnHide.classList.remove('bg-rose-500', 'border-rose-300');
           btnHide.classList.add('bg-indigo-500', 'border-indigo-200');
        }
      }

      if(btnFlip) btnFlip.disabled = !has;
      if(btnDup)  btnDup.disabled  = !has;
      if(btnDel)  btnDel.disabled  = !has;

      if(btnSep)  btnSep.disabled  = !(has && s.kind === 'disk'  && s.denom > 1);
      if(btnFuse) btnFuse.disabled = !(has && s.kind === 'piece' && s.denom > 1);
      if(btnCut)  btnCut.disabled  = !(has && this.canCut(s));
    }

    // ---- Plateau listeners ----
    initBoardListeners(){
      // zoom molette
      this.boardContainer.addEventListener('wheel', (e) => {
        e.preventDefault();
        const delta = -e.deltaY * 0.001;
        this.setZoom(this.scale + delta);
      }, {passive:false});

      // pan sur fond
      this.boardContainer.addEventListener('mousedown', (e) => {
        if(this.currentTool === 'pen') return;
        if(e.target.closest('.strip')) return;
        this.isPanning = true;
        this.panStart = {x: e.clientX - this.pan.x, y: e.clientY - this.pan.y};
        this.boardContainer.classList.add('panning');
        this.selectToken(null);
      });

      // dessin
      this.boardContainer.addEventListener('mousedown', (e) => {
        if(this.currentTool === 'pen') this.startDraw(e);
      });

      window.addEventListener('mousemove', (e) => {
        this.moveCursor(e);
        if(this.isPanning){
          this.pan.x = e.clientX - this.panStart.x;
          this.pan.y = e.clientY - this.panStart.y;
          this.updateTransform();
        } else if(this.isDrawing && this.currentTool === 'pen'){
          this.draw(e);
        }
      });

      window.addEventListener('mouseup', () => {
        this.isPanning = false;
        this.isDrawing = false;
        this.boardContainer.classList.remove('panning');
      });

      window.addEventListener('resize', () => this.resizeCanvas());
    }

    // ---- Création / rendu tokens ----
    _renderToken(token){
      if(!token._el) return;
      const {w,h} = this.tokenDims(token);
      token._el.style.width = `${w}px`;
      token._el.style.height = `${h}px`;
      token._el.style.left = `${token.x}px`;
      token._el.style.top  = `${token.y}px`;
      token._el.style.zIndex = String(10 + token.id);
      token._el.classList.toggle('is-back', token.side === 'back');

      const front = token._el.querySelector('.face-front');
      const back  = token._el.querySelector('.face-back');
      if(front) front.innerHTML = this._tokenSVGMarkup(token, 'front');
      if(back)  back.innerHTML  = this._tokenSVGMarkup(token, 'back');
    }

    mountToken(token){
      const el = document.createElement('div');
      el.className = 'strip';
      el.classList.add(token.kind === 'disk' ? 'is-disk' : 'is-piece');
      el.dataset.kind = token.kind;
      el.dataset.id = String(token.id);

      el.innerHTML = `
        <div class="strip-inner">
          <div class="face face-front"></div>
          <div class="face face-back"></div>
        </div>
      `;

      // interactions
      el.addEventListener('mousedown', (e) => this.handleDragStart(e));
      el.addEventListener('touchstart', (e) => this.handleDragStart(e), {passive:false});

      el.addEventListener('click', (e) => {
        e.stopPropagation();
        const t = this.tokens.find(tt => tt.id === token.id);
        if(!t) return;
        const pt = e.touches ? e.touches[0] : e;
        const wp = this.getWorldPos(pt.clientX, pt.clientY);
        if(t.kind === 'piece' && !this.isPointInPiece(t, wp.x, wp.y)) return;
        this.selectToken(token.id);
      });

      el.addEventListener('dblclick', (e) => {
        e.stopPropagation();
        const t = this.tokens.find(tt => tt.id === token.id);
        if(!t) return;
        const pt = e.touches ? e.touches[0] : e;
        const wp = this.getWorldPos(pt.clientX, pt.clientY);
        if(t.kind === 'piece' && !this.isPointInPiece(t, wp.x, wp.y)) return;
        this.selectToken(token.id);
        this.flipSelected();
      });

      // double-tap mobile
      let lastTap = 0;
      el.addEventListener('touchend', (e) => {
        const now = Date.now();
        if(now - lastTap < 300){
          e.preventDefault();
          const t = this.tokens.find(tt => tt.id === token.id);
          if(t){
            const pt = e.changedTouches ? e.changedTouches[0] : e;
            const wp = this.getWorldPos(pt.clientX, pt.clientY);
            if(t.kind !== 'piece' || this.isPointInPiece(t, wp.x, wp.y)){
              this.selectToken(token.id);
              this.flipSelected();
            }
          }
        }
        lastTap = now;
      });

      this.boardWorld.appendChild(el);
      token._el = el;
      this._renderToken(token);

      if(token._new){
        el.classList.add('spawn-pop');
        el.addEventListener('animationend', () => el.classList.remove('spawn-pop'), {once:true});
        delete token._new;
      }

      this.refreshTokenSelectedClass(token.id);
    }

    refreshTokenSelectedClass(id){
      this.tokens.forEach(t => {
        if(!t._el) return;
        t._el.classList.toggle('selected', t.id === id);
      });
    }

    addToken({denom, kind, x=null, y=null}){
      this.saveState();
      playSound('pop');
      const pos = (x===null || y===null) ? {x: 40 + Math.random()*40, y: 40 + Math.random()*30} : {x, y};

      const D = this.diskD;
      const token = {
        id: this.nextId++,
        denom,
        kind,
        side: 'front',
        x: pos.x - D/2,
        y: pos.y - D/2,
        rot: 0,
        slot: null,
        hideLabel: false,
        _new: true,
      };
      this.tokens.push(token);
      this.mountToken(token);
      this.selectToken(token.id);
      return token;
    }

    selectToken(id){
      this.selectedId = id;
      this.refreshTokenSelectedClass(id);
      this.updateSelectionUI();
    }

    get selected(){
      return this.tokens.find(t => t.id === this.selectedId) || null;
    }

    toggleTokenLabel(){
      const s = this.selected;
      if(!s) return;
      this.saveState();
      s.hideLabel = !s.hideLabel;
      this._renderToken(s);
      this.updateSelectionUI();
    }

    flipSelected(){
      const s = this.selected;
      if(!s) return;
      this.saveState();
      s.side = (s.side === 'front') ? 'back' : 'front';
      if(s._el){
        requestAnimationFrame(() => {
          s._el.classList.toggle('is-back', s.side === 'back');
        });
      }
      this.updateSelectionUI();
      playSound('flip');
    }

    duplicateSelected(){
      const s = this.selected;
      if(!s) return;
      this.saveState();
      const copy = {
        id: this.nextId++,
        denom: s.denom,
        kind: s.kind,
        side: s.side,
        x: s.x + 24,
        y: s.y + 24,
        rot: (typeof s.rot === 'number') ? s.rot : 0,
        slot: (typeof s.slot === 'number') ? s.slot : null,
        hideLabel: !!s.hideLabel
      };
      this.tokens.push(copy);
      this.mountToken(copy);
      this.selectToken(copy.id);
      playSound('pop');
    }

    deleteSelected(){
      const s = this.selected;
      if(!s) return;
      this.saveState();
      if(s._el) s._el.remove();
      this.tokens = this.tokens.filter(t => t.id !== s.id);
      this.selectToken(null);
      playSound('whoosh');
    }

    separateSelected(){
      const s = this.selected;
      if(!s || s.kind !== 'disk' || s.denom <= 1) return;
      this.saveState();

      const baseX = s.x;
      const baseY = s.y;
      const denom = s.denom;
      const side = s.side;
      const hidden = !!s.hideLabel;

      if(s._el) s._el.remove();
      this.tokens = this.tokens.filter(t => t.id !== s.id);

      const stepDeg = 360 / denom;
      for(let i=0;i<denom;i++){
        const piece = {
          id: this.nextId++,
          denom,
          kind:'piece',
          side,
          x: baseX,
          y: baseY,
          rot: i * stepDeg,
          slot: i,
          hideLabel: hidden
        };
        this.tokens.push(piece);
        this.mountToken(piece);
      }
      this.selectToken(this.tokens[this.tokens.length - denom].id);
      playSound('pop');
    }

    fuseSelected(){
      const s = this.selected;
      if(!s || s.kind !== 'piece' || s.denom <= 1) return;

      const d = s.denom;
      const tol = 2.4;
      const baseX = s.x;
      const baseY = s.y;

      const group = this.tokens
        .filter(t => t.kind === 'piece' && t.denom === d && t.side === s.side && Math.abs(t.x - baseX) < tol && Math.abs(t.y - baseY) < tol);

      if(group.length < d){ playSound('whoosh'); return; }

      // slot unique
      const stepDeg = 360 / d;
      const slotToPiece = new Map();
      for(const p of group){
        const slot = (typeof p.slot === 'number') ? p.slot : (typeof p.rot === 'number') ? (Math.round(p.rot / stepDeg) % d + d) % d : 0;
        // prioriser la pièce sélectionnée si collision
        if(!slotToPiece.has(slot) || p.id === s.id){
          slotToPiece.set(slot, p);
        }
      }

      if(slotToPiece.size < d){ playSound('whoosh'); return; }

      this.saveState();
      const ids = new Set([...slotToPiece.values()].slice(0, d).map(p => p.id));
      [...ids].forEach(id => {
        const t = this.tokens.find(x => x.id === id);
        if(t && t._el) t._el.remove();
      });
      this.tokens = this.tokens.filter(t => !ids.has(t.id));

      const disk = { id: this.nextId++, denom: d, kind:'disk', side: s.side, x: baseX, y: baseY, rot:0, slot:null, hideLabel:false };
      this.tokens.push(disk);
      this.mountToken(disk);
      this.selectToken(disk.id);
      playSound('pop');
    }

    // ---- Ciseaux : couper en 2 (uniquement si le double existe) ----
    canCut(t){
      if(!t) return false;
      if(t.denom <= 0) return false;
      const d2 = t.denom * 2;
      return this.DENOM_SET.has(d2);
    }

    cutSelected(){
      const s = this.selected;
      if(!s || !this.canCut(s)) return;

      const d = s.denom;
      const d2 = d * 2;
      const side = s.side;
      const x = s.x;
      const y = s.y;
      const hidden = !!s.hideLabel;

      this.saveState();

      if(s._el) s._el.remove();
      this.tokens = this.tokens.filter(t => t.id !== s.id);

      if(s.kind === 'disk'){
        const disk = { id: this.nextId++, denom: d2, kind:'disk', side, x, y, rot:0, slot:null, hideLabel: hidden };
        this.tokens.push(disk);
        this.mountToken(disk);
        this.selectToken(disk.id);
      } else {
        // pièce : devient 2 secteurs adjacents 1/(2d)
        const step2 = 360 / d2;
        const baseRot = (typeof s.rot === 'number') ? s.rot : ((typeof s.slot === 'number') ? s.slot * (360/d) : 0);
        const r1 = baseRot;
        const r2 = baseRot + step2;
        const slot1 = ((Math.round(r1/step2)%d2)+d2)%d2;
        const slot2 = ((Math.round(r2/step2)%d2)+d2)%d2;

        const p1 = { id: this.nextId++, denom: d2, kind:'piece', side, x, y, rot: r1, slot: slot1, hideLabel: hidden };
        const p2 = { id: this.nextId++, denom: d2, kind:'piece', side, x, y, rot: r2, slot: slot2, hideLabel: hidden };
        this.tokens.push(p1, p2);
        this.mountToken(p1);
        this.mountToken(p2);
        this.selectToken(p1.id);
      }

      playSound('pop');
    }

    // ---- Hit test wedge ----
    isPointInPiece(piece, wx, wy){
      if(!piece || piece.kind !== 'piece') return true;
      const D = this.diskD;
      const R = D/2;
      const cx = piece.x + R;
      const cy = piece.y + R;
      const dx = wx - cx;
      const dy = wy - cy;
      const r = Math.hypot(dx, dy);
      if(r > R) return false;
      const angle = Math.atan2(dy, dx);
      const step = Math.PI*2 / piece.denom;
      const rotRad = ((typeof piece.rot === 'number') ? piece.rot : 0) * Math.PI/180;
      const a0 = this._startAngleRad() + rotRad;
      const a1 = a0 + step;
      return this._angleInArc(angle, a0, a1);
    }


    isPointInDisk(disk, wx, wy){
      if(!disk || disk.kind !== 'disk') return true;
      const D = this.diskD;
      const R = D/2;
      const cx = disk.x + R;
      const cy = disk.y + R;
      return Math.hypot(wx - cx, wy - cy) <= R;
    }

    // Pick le token réellement sous le pointeur (forme peinte), du plus haut au plus bas.
    _pickTokenAt(wx, wy){
      // z-order: on se base sur l'id (comme le zIndex = 10+id)
      const ordered = [...this.tokens].sort((a,b) => (b.id - a.id));
      for(const t of ordered){
        if(!t) continue;
        if(t.kind === 'piece'){
          const rh = this._hitRotateHandle(t, wx, wy);
          if(rh) return { token: t, rotateWhich: rh };
          if(this.isPointInPiece(t, wx, wy)) return { token: t, rotateWhich: null };
        } else {
          if(this.isPointInDisk(t, wx, wy)) return { token: t, rotateWhich: null };
        }
      }
      return null;
    }



    // ---- Rotation : poignées (extrémités des rayons) ----
    _shortestAngleDeltaRad(a, b){
      // delta dans [-pi, pi]
      return ((b - a + Math.PI*3) % (Math.PI*2)) - Math.PI;
    }

    _pieceAngles(piece){
      const rotDeg = (typeof piece.rot === 'number') ? piece.rot : 0;
      const rotRad = rotDeg * Math.PI/180;
      const step = Math.PI*2 / piece.denom;
      const a0 = this._startAngleRad() + rotRad;
      const a1 = a0 + step;
      return {a0, a1, step};
    }

    _pieceHandlePoints(piece){
      const D = this.diskD;
      const R = D/2;
      const cx = piece.x + R;
      const cy = piece.y + R;
      const {a0, a1} = this._pieceAngles(piece);
      const hr = R - 14;
      return [
        { which: 'a0', x: cx + hr*Math.cos(a0), y: cy + hr*Math.sin(a0) },
        { which: 'a1', x: cx + hr*Math.cos(a1), y: cy + hr*Math.sin(a1) },
      ];
    }

    _hitRotateHandle(piece, wx, wy){
      if(!piece || piece.kind !== 'piece') return null;
      const hitR = 26 / this.scale;
      let best = null;
      let bestD = Infinity;
      for(const p of this._pieceHandlePoints(piece)){
        const d = Math.hypot(wx - p.x, wy - p.y);
        if(d < bestD){ bestD = d; best = p; }
      }
      if(best && bestD <= hitR) return best.which;
      return null;
    }

    // Aimantation manuelle : centre ↔ centre uniquement ;
    // et (pour les pièces) clip d'angle uniquement si on est très proche et presque aligné
    // avec une arête déjà présente au même centre.
    snapToCenterAndMaybeClip(token, opts={}){
      const t = token;
      if(!t) return false;
      const D = this.diskD;
      const thresh = (12 / this.scale);

      const candidates = this.tokens.filter(o => o.id !== t.id && o.side === t.side);
      if(!candidates.length) return false;

      const tcx = t.x + D/2;
      const tcy = t.y + D/2;
      let best = null;
      let bestDist = Infinity;
      for(const o of candidates){
        const ocx = o.x + D/2;
        const ocy = o.y + D/2;
        const d = Math.hypot(tcx - ocx, tcy - ocy);
        if(d < bestDist){ bestDist = d; best = o; }
      }
      if(!best || bestDist > thresh) return false;

      const target = { x: best.x, y: best.y };

      if(t.kind === 'piece'){
        const startBaseDeg = -90; // cohérent avec _startAngleRad()
        const stepDeg = 360 / t.denom;

        // Angles de référence présents au même centre (bords des disques + bords des pièces)
        const cx = best.x + D/2;
        const cy = best.y + D/2;
        const sameCenterTol = 2.6;
        const around = this.tokens.filter(o => {
          if(o.id === t.id || o.side !== t.side) return false;
          const ocx = o.x + D/2;
          const ocy = o.y + D/2;
          return Math.hypot(ocx - cx, ocy - cy) < sameCenterTol;
        });

        const ref = [];
        for(const o of around){
          if(o.kind === 'disk'){
            const d = o.denom;
            if(d > 0){
              const step = 360 / d;
              for(let k=0;k<d;k++){
                ref.push(((startBaseDeg + k*step) % 360 + 360) % 360);
              }
            }
          } else if(o.kind === 'piece'){
            const d = o.denom;
            const step = 360 / d;
            const base = startBaseDeg + ((typeof o.rot === 'number') ? o.rot : 0);
            ref.push(((base) % 360 + 360) % 360);
            ref.push(((base + step) % 360 + 360) % 360);
          }
        }

        // S'il n'y a rien d'autre au centre, on s'aligne sur la grille naturelle de la pièce
        if(ref.length === 0){
          for(let k=0;k<t.denom;k++) ref.push(((startBaseDeg + k*stepDeg) % 360 + 360) % 360);
        }

        const tolDeg = 10;
        const cur = (typeof t.rot === 'number') ? t.rot : 0;
        const b0 = ((startBaseDeg + cur) % 360 + 360) % 360;
        const b1 = ((b0 + stepDeg) % 360 + 360) % 360;

        let bestDelta = 0;
        let bestAbs = Infinity;
        for(const ra of ref){
          const d0 = this._shortestAngleDelta(b0, ra);
          if(Math.abs(d0) < bestAbs){ bestAbs = Math.abs(d0); bestDelta = d0; }
          const d1 = this._shortestAngleDelta(b1, ra);
          if(Math.abs(d1) < bestAbs){ bestAbs = Math.abs(d1); bestDelta = d1; }
        }

        if(bestAbs <= tolDeg){
          let newRot = cur + bestDelta;
          newRot = ((newRot % 360) + 360) % 360;

          // Slot uniquement si on retombe sur une position "canon" de la pièce (utile pour Fusionner)
          const nearest = Math.round(newRot / stepDeg) * stepDeg;
          const deltaSlot = this._shortestAngleDelta(newRot, nearest);
          if(Math.abs(deltaSlot) <= 2.5){
            const slot = ((Math.round(nearest/stepDeg) % t.denom) + t.denom) % t.denom;
            target.rot = nearest;
            target.slot = slot;
          } else {
            target.rot = newRot;
          }
        }
      }

      this._animateTokenTo(t, target, {duration: 110, ...opts});
      return true;
    }
    // ---- Aimantation (pièces ↔ centre, et disque ↔ centre si proche) ----

    _easeOutCubic(t){
      return 1 - Math.pow(1 - t, 3);
    }

    _shortestAngleDelta(a, b){
      // delta dans [-180, 180]
      return ((b - a + 540) % 360) - 180;
    }

    _animateTokenTo(t, target, opts={}){
      const duration = (typeof opts.duration === 'number') ? opts.duration : 170;
      if(t._anim && t._anim.raf){
        try{ cancelAnimationFrame(t._anim.raf); }catch(_){ /* ignore */ }
      }

      const sx = t.x, sy = t.y;
      const sr = (typeof t.rot === 'number') ? t.rot : 0;
      const ex = target.x, ey = target.y;
      const er = (typeof target.rot === 'number') ? target.rot : sr;

      const dRot = this._shortestAngleDelta(sr, er);
      const t0 = performance.now();

      const step = (now) => {
        const p = Math.min(1, (now - t0) / duration);
        const k = this._easeOutCubic(p);

        t.x = sx + (ex - sx) * k;
        t.y = sy + (ey - sy) * k;

        if(t.kind === 'piece'){
          t.rot = sr + dRot * k;
        }

        if(t._el){
          t._el.style.left = t.x + 'px';
          t._el.style.top  = t.y + 'px';
          if(t.kind === 'piece') this._renderToken(t);
        }

        if(p < 1){
          t._anim = {raf: requestAnimationFrame(step)};
        } else {
          t.x = ex; t.y = ey;
          if(t.kind === 'piece'){
            t.rot = er;
            if('slot' in target) t.slot = target.slot;
          }
          if(t._el){
            t._el.style.left = t.x + 'px';
            t._el.style.top  = t.y + 'px';
            if(t.kind === 'piece') this._renderToken(t);
          }
          t._anim = null;
          if(t._el){
            t._el.classList.remove('snap-pop');
            // relance l'animation
            void t._el.offsetWidth;
            t._el.classList.add('snap-pop');
            setTimeout(()=>{ try{ t._el && t._el.classList.remove('snap-pop'); }catch(_){} }, 220);
          }
          if(!opts.silent) playSound('pop');
        }
      };

      t._anim = {raf: requestAnimationFrame(step)};
    }

    // Aimantation "manuelle" : centre sur centre uniquement (pas de placement automatique en slots)
    snapToken(token, opts={}){
      const t = token;
      if(!t) return;

      const D = this.diskD;
      const thresh = (12 / this.scale);

      const candidates = this.tokens.filter(o => o.id !== t.id && o.side === t.side);
      if(!candidates.length){ return; }

      const tcx = t.x + D/2;
      const tcy = t.y + D/2;

      let best = null;
      let bestDist = Infinity;
      for(const o of candidates){
        const ocx = o.x + D/2;
        const ocy = o.y + D/2;
        const d = Math.hypot(tcx - ocx, tcy - ocy);
        if(d < bestDist){ bestDist = d; best = o; }
      }

      if(!best || bestDist > thresh){ return; }
      this._animateTokenTo(t, {x: best.x, y: best.y}, {duration: 80, ...opts});
    }

    // Après une rotation, on "clipse" la pièce si elle est presque alignée (et centrée sur un autre disque/pièce)
    snapAngleToGridIfClose(token, opts={}){
      const t = token;
      if(!t || t.kind !== 'piece') return;

      const D = this.diskD;
      const centerThresh = (14 / this.scale);
      const tcx = t.x + D/2;
      const tcy = t.y + D/2;

      let target = null;
      for(const o of this.tokens){
        if(o.id === t.id) continue;
        if(o.side !== t.side) continue;
        const ocx = o.x + D/2;
        const ocy = o.y + D/2;
        if(Math.hypot(tcx - ocx, tcy - ocy) <= centerThresh){
          target = o;
          break;
        }
      }
      if(!target) return;

      const stepDeg = 360 / t.denom;
      const sr = t.rot || 0;
      const norm = ((sr % 360) + 360) % 360;
      const nearest = Math.round(norm / stepDeg) * stepDeg;
      const delta = this._shortestAngleDelta(sr, nearest);
      const tolDeg = 8;
      if(Math.abs(delta) > tolDeg) return;

      const slot = ((Math.round(nearest/stepDeg) % t.denom) + t.denom) % t.denom;
      this._animateTokenTo(t, {x: target.x, y: target.y, rot: nearest, slot}, {duration: 120, ...opts});
    }

    // ---- Drag tokens ----
    handleDragStart(e){
      if(this.currentTool !== 'hand') return;
      e.stopPropagation();

      // Position au down (monde)
      const pt0 = e.touches ? e.touches[0] : e;
      const wp0 = this.getWorldPos(pt0.clientX, pt0.clientY);

      // IMPORTANT : on choisit le token réellement sous le pointeur (forme),
      // pour éviter que les zones transparentes des carrés englobants bloquent la sélection
      // quand plusieurs pièces se touchent.
      const picked = this._pickTokenAt(wp0.x, wp0.y);
      if(!picked) return;
      const token = picked.token;
      const rotateWhich = picked.rotateWhich;

      this.saveState();
      this.selectToken(token.id);

      if(token._el) token._el.classList.add('dragging');

      // --- Mode rotation ---
      if(rotateWhich){
        const D = this.diskD;
        const R = D/2;
        const cx = token.x + R;
        const cy = token.y + R;

        let lastPointer = Math.atan2(wp0.y - cy, wp0.x - cx);
        let rotDeg = (typeof token.rot === 'number') ? token.rot : 0;
        document.body.style.cursor = 'grabbing';

        const move = (ev) => {
          ev.preventDefault();
          const pt = ev.touches ? ev.touches[0] : ev;
          const wp = this.getWorldPos(pt.clientX, pt.clientY);

          const pointer = Math.atan2(wp.y - cy, wp.x - cx);
          const delta = this._shortestAngleDeltaRad(lastPointer, pointer);
          rotDeg += delta * 180/Math.PI;
          rotDeg = ((rotDeg % 360) + 360) % 360;
          lastPointer = pointer;

          token.rot = rotDeg;
          this._renderToken(token);
          token._pointerWorld = wp;
        };

        const end = () => {
          document.removeEventListener('mousemove', move);
          document.removeEventListener('touchmove', move);
          document.removeEventListener('mouseup', end);
          document.removeEventListener('touchend', end);
          if(token._el) token._el.classList.remove('dragging');
          // aimantation centre↔centre + clip angle (si proche)
          const snapped = this.snapToCenterAndMaybeClip(token);
          if(snapped) this.selectToken(null);
          document.body.style.cursor = "";
        };

        document.addEventListener('mousemove', move);
        document.addEventListener('touchmove', move, {passive:false});
        document.addEventListener('mouseup', end);
        document.addEventListener('touchend', end);
        return;
      }

      // --- Mode déplacement ---
      const clientX = pt0.clientX;
      const clientY = pt0.clientY;
      const rect = token._el.getBoundingClientRect();
      const offset = { x: clientX - rect.left, y: clientY - rect.top };

      const move = (ev) => {
        ev.preventDefault();
        const pt = ev.touches ? ev.touches[0] : ev;
        const cx = pt.clientX;
        const cy = pt.clientY;
        const br = this.boardContainer.getBoundingClientRect();
        const wx = (cx - br.left - this.pan.x - offset.x) / this.scale;
        const wy = (cy - br.top - this.pan.y - offset.y) / this.scale;
        token.x = wx;
        token.y = wy;
        token._el.style.left = wx + 'px';
        token._el.style.top = wy + 'px';
        token._pointerWorld = this.getWorldPos(cx, cy);
      };

      const end = () => {
        document.removeEventListener('mousemove', move);
        document.removeEventListener('touchmove', move);
        document.removeEventListener('mouseup', end);
        document.removeEventListener('touchend', end);
        if(token._el) token._el.classList.remove('dragging');
        // aimantation centre↔centre + clip angle (si proche)
        const snapped = this.snapToCenterAndMaybeClip(token);
        if(snapped) this.selectToken(null);
      };

      document.addEventListener('mousemove', move);
      document.addEventListener('touchmove', move, {passive:false});
      document.addEventListener('mouseup', end);
      document.addEventListener('touchend', end);
    }

    // ---- Outils dessin ----

    setTool(tool){
      this.currentTool = tool;
      const hand = document.getElementById('tool-hand');
      const pen  = document.getElementById('tool-pen');
      if(hand){ hand.classList.toggle('bg-white', tool==='hand'); hand.classList.toggle('shadow', tool==='hand'); }
      if(pen){  pen.classList.toggle('bg-white', tool==='pen');   pen.classList.toggle('shadow', tool==='pen'); }

      const penMode = (tool === 'pen');
      this.boardContainer.classList.toggle('hide-cursor', penMode);
      document.getElementById('custom-cursor').style.display = penMode ? 'block' : 'none';
    }

    resizeCanvas(){
      this.canvas.width = 4000;
      this.canvas.height = 4000;
      this.canvas.style.width = '4000px';
      this.canvas.style.height = '4000px';
      this.ctx.lineWidth = 3;
      this.ctx.lineCap = 'round';
      this.ctx.strokeStyle = '#111827';
    }

    startDraw(e){
      this.isDrawing = true;
      const cx = e.touches ? e.touches[0].clientX : e.clientX;
      const cy = e.touches ? e.touches[0].clientY : e.clientY;
      const p = this.getWorldPos(cx, cy);
      this.lastDrawPos = p;
      this.ctx.beginPath();
      this.ctx.moveTo(p.x, p.y);
    }

    draw(e){
      e.preventDefault();
      const cx = e.touches ? e.touches[0].clientX : e.clientX;
      const cy = e.touches ? e.touches[0].clientY : e.clientY;
      const p = this.getWorldPos(cx, cy);
      this.ctx.lineTo(p.x, p.y);
      this.ctx.stroke();
      this.lastDrawPos = p;
    }

    clearDrawing(){
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }

    clearAllTokens(withHistory=true){
      if(withHistory) this.saveState();
      this.tokens.forEach(t => t._el && t._el.remove());
      this.tokens = [];
      this.selectedId = null;
      this.updateSelectionUI();
    }

    resetAll(){
      this.saveState();
      this.clearAllTokens(false);
      this.clearDrawing();
      this.resetView();
      playSound('whoosh');
    }
  }

  // --- Mini tests (sécurité) ---
  function runSelfTests(){
    const required = [
      'btn-undo','btn-clear','btn-zoom-in','btn-zoom-out','btn-reset-view',
      'btn-hide-label','btn-flip','btn-separate','btn-cut','btn-fuse','btn-duplicate','btn-delete',
      'tool-hand','tool-pen','btn-clear-drawing',
      'board-container','board-world','palette','drawing-canvas',
      'mode-frac','mode-word','mode-percent','mode-angle','mode-empty'
    ];
    const missing = required.filter(id => !document.getElementById(id));
    if(missing.length){
      // console.error('[SelfTest] IDs manquants:', missing);
    } else {
      // console.log('[SelfTest] OK');
    }
  }

  window.addEventListener('DOMContentLoaded', () => {
    runSelfTests();
    window.app = new FractionDisksApp();
  });

</script>

</body>
</html>
