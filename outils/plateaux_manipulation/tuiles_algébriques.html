<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Calcul Littéral - Tuiles Algébriques</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css">
    <style>
        body {
            font-family: 'Fredoka', sans-serif;
            background-color: #f0f9ff;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            cursor: default;
        }

        /* --- STYLES DES TUILES --- */
        .token {
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            color: white;
            box-shadow: 0 4px 6px rgba(0,0,0,0.25);
            cursor: grab;
            transition: transform 0.1s, background-color 0.5s;
            z-index: 10;
            touch-action: none;
            box-sizing: border-box;
            font-family: 'Times New Roman', serif;
            font-style: italic;
            font-size: 1.2rem;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        .token.animating {
            transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1), left 0.5s ease-in-out, top 0.5s ease-in-out, background-color 0.5s !important;
        }

        @keyframes flipToken {
            0% { transform: rotateY(0deg) scale(1); }
            50% { transform: rotateY(90deg) scale(1.1); }
            100% { transform: rotateY(0deg) scale(1); }
        }
        .flipping { animation: flipToken 0.6s ease-in-out; }

        @keyframes flyAway {
            0% { transform: scale(1) translateY(0); opacity: 1; }
            100% { transform: scale(0.1) translateY(-150px); opacity: 0; }
        }
        .flying { animation: flyAway 0.6s ease-in forwards; pointer-events: none; }

        @keyframes vanish {
            0% { transform: scale(1); opacity: 1; }
            100% { transform: scale(0.1); opacity: 0; }
        }
        .vanish { animation: vanish 0.45s ease-in forwards; pointer-events: none; }


        .token:active {
            cursor: grabbing;
            transform: scale(1.05);
            z-index: 100 !important;
            box-shadow: 0 10px 15px rgba(0,0,0,0.3);
            transition: none !important;
        }

        .token.green {
            background: radial-gradient(circle at 30% 30%, #4ade80, #16a34a);
            border: 2px solid #14532d;
        }
        .token.red {
            background: radial-gradient(circle at 30% 30%, #f87171, #dc2626);
            border: 2px solid #7f1d1d;
        }
        
        .token.in-bracket { opacity: 0.95; box-shadow: none !important; }
        .token.pending-mult { box-shadow: 0 0 0 3px #3b82f6 !important; }
.token.is-zero {
            background: #9ca3af !important;
            opacity: 0.6;
            border: 2px solid #6b7280;
            box-shadow: none;
            z-index: 5;
            transform: scale(0.95);
            color: rgba(255,255,255,0.5);
        }

        
        .token.fading-gray {
            background: #9ca3af !important;
            border-color: #6b7280 !important;
            box-shadow: none !important;
            filter: grayscale(1);
        }
/* FORMES */
        .token.type-unit { width: 40px; height: 40px; border-radius: 4px; font-style: normal; }
        .token.type-x { width: 90px; height: 40px; border-radius: 4px; }
        .token.type-x2 { width: 90px; height: 90px; border-radius: 4px; }

        .zero-badge {
            position: absolute;
            font-size: 2rem;
            font-weight: 800;
            color: #374151;
            pointer-events: none;
            z-index: 20;
            text-shadow: 0 0 10px rgba(255,255,255,1);
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        /* Les "0" doivent disparaître un peu plus vite que les tuiles pour éviter l'effet "ça traîne" */
        .zero-badge.vanish { animation: vanish 0.25s ease-in forwards; }
        @keyframes popIn { from { transform: scale(0); opacity: 0; } to { transform: scale(1); opacity: 1; } }

        #drawing-canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 50; pointer-events: none; touch-action: none;
        }
        .hide-cursor, .hide-cursor * { cursor: none !important; }
        #custom-cursor { position: fixed; pointer-events: none; z-index: 9999; display: none; }

        /* SIDEBAR BOUTONS */
        .tile-btn {
            position: relative;
            background: white;
            border: 1px solid #cbd5e1;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.1s, background 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }
        .tile-btn:active { transform: translateY(1px); box-shadow: none; }
        .tile-btn:hover { background: #f1f5f9; }
        
        .preview-shape { 
            display: flex; align-items: center; justify-content: center; 
            border-radius: 2px; color: white; font-weight: bold; 
            font-family: 'Times New Roman', serif; font-style: italic;
            text-shadow: 0 1px 1px rgba(0,0,0,0.3);
        }
        .ps-green { background: #4ade80; border: 1px solid #15803d; }
        .ps-red { background: #f87171; border: 1px solid #b91c1c; }

        .mode-active-minus { border: 2px solid #f97316; background-color: #fff7ed; }
@keyframes pulse-orange {
            0%, 100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(249, 115, 22, 0.7); }
            50% { transform: scale(1.05); box-shadow: 0 0 0 10px rgba(249, 115, 22, 0); }
        }
        .btn-opposite { animation: pulse-orange 2s infinite; }
        
        @keyframes pulse-blue {
            0%, 100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.7); }
            50% { transform: scale(1.05); box-shadow: 0 0 0 10px rgba(59, 130, 246, 0); }
        }
        .btn-distribute { animation: pulse-blue 2s infinite; }
    </style>
</head>
<body class="h-screen w-screen flex flex-col">

    <!-- CURSEUR -->
    <div id="custom-cursor">
        <svg class="drop-shadow-lg" width="34" height="34" viewBox="0 0 34 34" fill="none">
            <path d="M27 7 L13 21" stroke="#1d4ed8" stroke-width="6" stroke-linecap="round"/>
            <path d="M13 21 L8 32" stroke="#0f172a" stroke-width="4" stroke-linecap="round"/>
            <path d="M8 32 L12 28 L16 32 Z" fill="#111827"/>
            <circle cx="8" cy="32" r="1" fill="white"/>
        </svg>
    </div>

    <!-- HEADER -->
    <header class="bg-white p-2 shadow-md z-30 flex flex-wrap items-center gap-4 shrink-0">
        <div class="flex items-center gap-2">
            <button onclick="resetBoard()" class="bg-rose-100 text-rose-600 hover:bg-rose-200 p-2 rounded-lg font-bold border border-rose-200 shadow-sm flex items-center gap-1 active:scale-95 transition" title="Tout effacer">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                </svg>
            </button>
            
            <!-- BOUTON DISTRIBUER -->
            <button id="btn-distribute" onclick="applyDistribution()" class="hidden btn-distribute bg-blue-500 hover:bg-blue-600 text-white font-bold py-1 px-4 rounded-lg shadow-md border-b-4 border-blue-700 active:border-b-0 active:translate-y-1 transition text-sm">
                Développer
            </button>
            
            <div class="h-8 w-px bg-slate-200 mx-1"></div>
            
            <!-- OPÉRATEURS -->
            <div class="flex gap-1 items-center">
                <div class="flex gap-1 items-center bg-blue-50 rounded-full p-1 border border-blue-100">
                    <button id="btn-op-plus" onclick="separatePack()" class="w-10 h-10 bg-blue-100 text-blue-700 rounded-full border-2 border-blue-400 font-bold text-xl active:scale-95 transition hover:bg-blue-200" title="Séparer les groupes">+</button>
                    <!-- FERMER PARENTHÈSE (cas : +(- ... ) ) -->
                </div>
                
                <div class="flex gap-1 items-center bg-orange-50 rounded-full p-1 border border-orange-100">
                    <button id="btn-op-minus" onclick="setOperator('subtract')" class="w-10 h-10 bg-orange-100 text-orange-700 rounded-full border-2 border-orange-400 font-bold text-xl active:scale-95 transition hover:bg-orange-200" title="Soustraire (Ouvrir parenthèse)">-</button>
                    <!-- BOUTON FERMER PARENTHÈSE -->
                    <button id="btn-close-parenthesis" onclick="closeParenthesis()" class="hidden w-10 h-10 bg-orange-500 text-white rounded-full border-2 border-orange-700 font-bold text-xl active:scale-95 transition shadow-lg animate-pulse" title="Fermer parenthèse"> ) </button>
                </div>

                <!-- BOUTON OPPOSÉ -->
                <button id="btn-opposite" onclick="applyOpposite()" class="hidden btn-opposite ml-2 bg-orange-600 text-white px-3 py-1 rounded-full font-bold shadow-lg border-b-4 border-orange-800 active:border-b-0 active:translate-y-1 text-xs sm:text-sm uppercase tracking-wide flex flex-col items-center leading-none py-2">
                    <span class="text-xs sm:text-sm leading-none">Ajouter l'opposé</span>
                </button>
            </div>
        </div>

        <!-- ZONE EQUATION -->
        <div class="flex-1 flex flex-col items-center justify-center min-w-[200px] px-2">
            <div class="flex items-center gap-2 bg-slate-50 px-4 py-2 rounded-xl border border-slate-200 shadow-inner mb-1 w-full justify-start overflow-x-auto no-scrollbar min-h-[60px]">
                <div id="equation-display" class="text-xl sm:text-3xl font-bold text-slate-600 tracking-tight flex items-center gap-1 font-mono whitespace-nowrap">
                    (...)
                </div>
            </div>
        </div>

        <!-- OUTILS STYLO -->
        <div class="flex items-center gap-1 bg-gray-100 p-1 rounded-lg">
            <button onclick="setTool('hand')" id="tool-hand" class="p-2 rounded bg-white shadow text-gray-700"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 11.5V14m0-2.5v-6a1.5 1.5 0 113 0m-3 6a1.5 1.5 0 00-3 0v2a7.5 7.5 0 0015 0v-5a1.5 1.5 0 00-3 0m-6-3V11m0-5.5v-1a1.5 1.5 0 013 0v1m0 0V11m0-5.5a1.5 1.5 0 013 0v3m0 0V11"/></svg></button>
            <button onclick="setTool('pen')" id="tool-pen" class="p-2 rounded text-gray-500 hover:bg-gray-200"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"/></svg></button>
            <button onclick="clearCanvas()" class="p-2 rounded text-red-400 hover:bg-red-50"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/></svg></button>
        </div>
    </header>

    <div class="flex flex-1 overflow-hidden relative">

        <!-- SIDEBAR -->
        <aside class="w-24 bg-slate-100 border-r border-slate-300 flex flex-col items-center py-4 gap-2 z-20 shadow-lg shrink-0 overflow-y-auto">
            <span class="text-[10px] font-bold text-slate-400 uppercase mb-1">Tuiles</span>

            <!-- X² -->
            <div class="flex flex-col gap-1 w-full px-2 items-center">
                <button onclick="addTile('x2', 1)" class="tile-btn w-12 h-12" title="+x²">
                    <div class="preview-shape ps-green w-8 h-8 text-sm">x²</div>
                </button>
                <button onclick="addTile('x2', -1)" class="tile-btn w-12 h-12" title="-x²">
                    <div class="preview-shape ps-red w-8 h-8 text-sm">-x²</div>
                </button>
            </div>

            <!-- X -->
            <div class="flex flex-col gap-1 w-full px-2 items-center mt-2">
                <button onclick="addTile('x', 1)" class="tile-btn w-16 h-10" title="+x">
                    <div class="preview-shape ps-green w-10 h-5 text-sm">x</div>
                </button>
                <button onclick="addTile('x', -1)" class="tile-btn w-16 h-10" title="-x">
                    <div class="preview-shape ps-red w-10 h-5 text-sm">-x</div>
                </button>
            </div>

            <!-- Unit -->
            <div class="flex flex-col gap-1 w-full px-2 items-center mt-2">
                <button onclick="addTile('unit', 1)" class="tile-btn w-10 h-10" title="+1">
                    <div class="preview-shape ps-green w-5 h-5 text-xs font-normal">1</div>
                </button>
                <button onclick="addTile('unit', -1)" class="tile-btn w-10 h-10" title="-1">
                    <div class="preview-shape ps-red w-5 h-5 text-xs font-normal">-1</div>
                </button>
            </div>

            <!-- MULTIPLICATION -->
            <div class="flex flex-col gap-1 w-full px-2 items-center mt-2">
                <span class="text-[9px] font-bold text-slate-400 uppercase text-center leading-tight">Multiplier</span>
                <div class="flex flex-col gap-1 w-full">
                    <button onclick="startMultiplication(2)" class="text-[11px] font-bold text-indigo-700 py-2 border border-indigo-200 rounded bg-indigo-50 hover:bg-indigo-100 flex flex-col items-center leading-none" title="2 fois ( … )">
                        <span>2 fois</span>
                        <span class="text-[10px] text-indigo-500">( ? )</span>
                    </button>
                    <button onclick="startMultiplication(3)" class="text-[11px] font-bold text-indigo-700 py-2 border border-indigo-200 rounded bg-indigo-50 hover:bg-indigo-100 flex flex-col items-center leading-none" title="3 fois ( … )">
                        <span>3 fois</span>
                        <span class="text-[10px] text-indigo-500">( ? )</span>
                    </button>
                    <button onclick="startMultiplication(4)" class="text-[11px] font-bold text-indigo-700 py-2 border border-indigo-200 rounded bg-indigo-50 hover:bg-indigo-100 flex flex-col items-center leading-none" title="4 fois ( … )">
                        <span>4 fois</span>
                        <span class="text-[10px] text-indigo-500">( ? )</span>
                    </button>
                </div>
            </div>

            <!-- ORDONNER --><!-- ORDONNER -->
            <button id="btn-order" onclick="orderAll()" class="w-20 py-2 mt-4 bg-white border border-slate-300 rounded text-xs font-bold text-slate-600 shadow-sm active:bg-slate-100 hover:bg-slate-50 transition" title="Ordonner les tuiles">ordonner</button>
            <!-- RÉDUIRE -->
            <button id="btn-reduce" onclick="reduceExpression()" class="w-20 py-2 mt-2 bg-white border border-yellow-300 rounded text-xs font-bold text-yellow-700 shadow-sm active:bg-yellow-50 hover:bg-yellow-50 transition" title="Réduire (regrouper les termes)">réduire</button>

            <!-- FLASH / SIMPLIFIER -->
            <button id="btn-simplify" onclick="autoSimplify()" class="w-20 py-2 mt-2 bg-white border border-amber-300 rounded text-xs font-bold text-amber-700 shadow-sm active:bg-amber-50 hover:bg-amber-50 transition" title="Simplifier (annuler + et -)">simplifier</button>

        </aside>

        <!-- PLATEAU -->
        <main id="board" class="flex-1 relative bg-white overflow-hidden touch-none">
            <div class="absolute inset-0 opacity-10 pointer-events-none" 
                 style="background-image: linear-gradient(#94a3b8 1px, transparent 1px), linear-gradient(90deg, #94a3b8 1px, transparent 1px); background-size: 40px 40px;">
            </div>
            <div class="absolute top-2 left-2 pointer-events-none opacity-40">
                <p class="text-xs text-slate-400">Zone de manipulation</p>
            </div>
            <canvas id="drawing-canvas"></canvas>
        </main>
    </div>

    <script>
        const SNAP_THRESHOLD = 60;
        
        const SIZES = {
            'unit': { w: 40, h: 40 },
            'x': { w: 90, h: 40 }, 
            'x2': { w: 90, h: 90 }
        };

        // Couleurs de l'écriture (comme les tuiles)
        const COLORS = {
            pos: 'green',   // vert
            neg: 'red',     // rouge
            orange: 'orange' // orange (soustraction avant opposé)
        };


        const state = {
            tokens: [],
            nextId: 1,
            // "Pack" = un paquet de tuiles issues d'une même action (utile pour ORDONNER sans réduire)
            nextPackId: 1,
            nextPackOrder: 1,
            packMeta: {}, // packId -> { order: number }
            lastPack: null, // {packId,type,sign,stepIndex,ts}
            steps: [{ id: 0, operator: '', type: 'simple', tokenIds: [], factor: 1, oppositeApplied: false, distributed: false, isClosed: false }],
            currentStepIndex: 0,
            isSubtractingInput: false,
            isMultiplyingInput: false,
            _internalAdd: false, // utilisé pour dupliquer des tuiles sans créer de nouveau step
            isAnimating: false,
            displayMode: 'normal',
            isReduced: false,
            currentTool: 'hand',
            lastPos: { x: 40, y: 60, maxYInRow: 0 },
            // Pour garder des espaces entre paquets dès la saisie (avant ORDONNER)
            lastSequentialPackId: null,
            pendingPackGap: 0
        };

        // Espace entre paquets (même logique que l'affichage ORDONNER non réduit)
        const PACK_GAP = 18;

        const board = document.getElementById('board');
        const eqDisplay = document.getElementById('equation-display');
        const btnOpposite = document.getElementById('btn-opposite');
        const btnMinus = document.getElementById('btn-op-minus');
        const btnCloseP = document.getElementById('btn-close-parenthesis');
        const btnDistribute = document.getElementById('btn-distribute');

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            const now = audioCtx.currentTime;
            
            if (type === 'pop') {
                osc.type = 'sine'; osc.frequency.setValueAtTime(300, now); osc.frequency.exponentialRampToValueAtTime(500, now+0.1);
                gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now+0.1);
                osc.start(now); osc.stop(now+0.1);
            } else if (type === 'snap') {
                osc.type = 'square'; osc.frequency.setValueAtTime(100, now);
                gain.gain.setValueAtTime(0.05, now); gain.gain.exponentialRampToValueAtTime(0.01, now+0.05);
                osc.start(now); osc.stop(now+0.05);
            } else if (type === 'flip') {
                osc.type = 'triangle'; osc.frequency.setValueAtTime(200, now); osc.frequency.linearRampToValueAtTime(400, now+0.2);
                gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now+0.2);
                osc.start(now); osc.stop(now+0.2);
            } else if (type === 'magic') {
                osc.type = 'sine'; osc.frequency.setValueAtTime(400, now); osc.frequency.linearRampToValueAtTime(800, now+0.3);
                gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now+0.3);
                osc.start(now); osc.stop(now+0.3);
            } else if (type === 'whoosh') {
                osc.type = 'triangle'; osc.frequency.setValueAtTime(300, now); osc.frequency.exponentialRampToValueAtTime(50, now+0.3);
                gain.gain.setValueAtTime(0.05, now); gain.gain.linearRampToValueAtTime(0, now+0.3);
                osc.start(now); osc.stop(now+0.3);
            }
        }

        // --- GESTION DES TUILES ---

        function newPackId() {
            const pid = state.nextPackId++;
            state.packMeta[pid] = { order: state.nextPackOrder++ };
            return pid;
        }

        function getOrCreatePackId({ type, sign, stepIndex }) {
            const now = Date.now();
            const lp = state.lastPack;
            // Si l'utilisateur clique plusieurs fois d'affilée sur la même tuile,
            // on "colle" dans le même pack (ex: 3 fois x² -> 3x² collés).
            // Fenêtre courte pour éviter de fusionner des actions pédagogiquement distinctes.
            const MERGE_WINDOW_MS = 1000000000000;// no time-based split (pause-friendly)
            if (
                lp &&
                lp.type === type &&
                lp.sign === sign &&
                lp.stepIndex === stepIndex &&
                (now - lp.ts) < MERGE_WINDOW_MS
            ) {
                lp.ts = now;
                return lp.packId;
            }
            const pid = newPackId();
            state.lastPack = { packId: pid, type, sign, stepIndex, ts: now };
            return pid;
        }

        function addTile(type, sign, x = null, y = null, packId = null) {
            // Si on était en mode ordonné/réduit, on revient en mode normal dès qu'on ajoute une tuile
            if (state.displayMode !== 'normal') {
                state.displayMode = 'normal';
                state.isReduced = false;
            }

            // Si on repart de zéro (plus aucune tuile), on recrée en haut
            if (state.tokens.length === 0) {
                state.lastPos = { x: 40, y: 60, maxYInRow: 0 };
            }
            playSound('pop');

            // Si le step courant est une parenthèse déjà fermée (soustraction ou multiplication),
            // et qu'on ajoute une nouvelle tuile (action utilisateur), on ouvre automatiquement un nouveau step.
            let currentStep = state.steps[state.currentStepIndex];
            if (!state._internalAdd && currentStep && currentStep.isClosed && !state.isSubtractingInput && !state.isMultiplyingInput) {
                const newStep = { id: state.steps.length, operator: '+', type: 'simple', tokenIds: [], factor: 1, oppositeApplied: false, distributed: false, isClosed: false };
                state.steps.push(newStep);
                state.currentStepIndex = state.steps.length - 1;
                currentStep = newStep;
                // Nouveau pack logique
                state.lastPack = null;
            }

            const id = state.nextId++;
            const el = document.createElement('div');

            const isSubInput = (state.isSubtractingInput && currentStep.type === 'subtraction' && !currentStep.oppositeApplied);
            const isMultInput = (state.isMultiplyingInput && currentStep.type === 'multiplication' && !currentStep.distributed);
            const isNegMultInput = (isMultInput && currentStep.operator === '-');

            // Sur le tapis :
            // - soustraction en cours => on pose directement l'opposé.
            // - multiplication négative en cours (-2(…)) => on pose aussi l'opposé (représentation matérielle).
            // Dans le calcul : on garde l'écriture saisie (displaySign), jusqu'aux boutons OPPOSÉ / DÉVELOPPER.
            const displaySign = sign;
            const tileSign = (isSubInput || isNegMultInput) ? -sign : sign;

            // Pack (pour ORDONNER sans réduire) : un pack = une action (ou une rafale de clics identiques)
            const stepIndex = state.currentStepIndex;
            let pid;
            if (packId !== null && packId !== undefined) {
                pid = packId;
                if (!state.packMeta[pid]) {
                    state.packMeta[pid] = { order: state.nextPackOrder++ };
                }
                state.lastPack = { packId: pid, type, sign: tileSign, stepIndex, ts: Date.now() };
            } else {
                pid = getOrCreatePackId({ type, sign: tileSign, stepIndex });
            }

            let colorClass = tileSign === 1 ? 'green' : 'red';
            el.classList.add('token', colorClass, `type-${type}`);

            const isSubStep = (currentStep.type === 'subtraction' && !currentStep.oppositeApplied);
            if (isSubStep) el.classList.add('in-bracket');

            let label = "";
            if (type === 'x2') label = tileSign === 1 ? "x²" : "-x²";
            else if (type === 'x') label = tileSign === 1 ? "x" : "-x";
            else label = tileSign === 1 ? "1" : "-1";

            el.innerHTML = `<span style="pointer-events:none;">${label}</span>`;
            el.id = `t-${id}`;

            let pos;
            if (x !== null && y !== null) {
                pos = {x, y};
            } else {
                // Avant ORDONNER : on garde un petit espace entre les paquets (packs) visibles
                // (ex : 3x² puis -3x² => deux groupes séparés).
                if (!state._internalAdd) {
                    let gap = 0;
                    if (state.pendingPackGap && state.pendingPackGap > 0) {
                        gap = state.pendingPackGap;
                        state.pendingPackGap = 0;
                    } else if (state.lastSequentialPackId !== null && pid !== state.lastSequentialPackId) {
                        gap = PACK_GAP;
                    }
                    if (gap > 0) state.lastPos.x += gap;
                }
                pos = getSequentialPosition(SIZES[type].w, SIZES[type].h);
            }
            el.style.left = pos.x + 'px';
            el.style.top = pos.y + 'px';

            el.addEventListener('mousedown', handleDragStart);
            el.addEventListener('touchstart', handleDragStart, {passive: false});

            board.appendChild(el);
            const tokenObj = {
                id, type, sign: tileSign, displaySign: displaySign, element: el, x: pos.x, y: pos.y,
                pairId: null,
                packId: pid
            };

            state.tokens.push(tokenObj);
            state.steps[state.currentStepIndex].tokenIds.push(id);

            if (x === null && y === null && !state._internalAdd) {
                state.lastSequentialPackId = pid;
            }

            updateEquation();
        }

        function getSequentialPosition(w, h) {
            const padding = 10;
            const boardW = board.clientWidth;
            if (state.lastPos.x + w + padding > boardW) {
                state.lastPos.x = 40;
                state.lastPos.y += state.lastPos.maxYInRow + padding;
                state.lastPos.maxYInRow = 0;
            }
            const x = state.lastPos.x;
            const y = state.lastPos.y; 
            state.lastPos.x += w + padding;
            if (h > state.lastPos.maxYInRow) state.lastPos.maxYInRow = h;
            return {x, y};
        }

        // --- MULTIPLICATION (entrée + développer) ---

        function startMultiplication(factor) {
            // Interprétation : si l'utilisateur vient juste de faire "-" (parenthèse ouverte) et n'a posé aucune tuile,
            // alors "-" puis "2 fois/3 fois/4 fois" devient : "- {}" k( … ) (multiplication négative).
            const cur = state.steps[state.currentStepIndex];
            const canConvertMinusToMult = state.isSubtractingInput && cur && cur.type === 'subtraction' && (cur.tokenIds?.length || 0) === 0;

            if (canConvertMinusToMult) {
                cur.type = 'multiplication';
                cur.factor = factor;
                cur.distributed = false;
                cur.isClosed = false;
                cur._multVisualized = false;
                cur._multLayout = null;
                state.isSubtractingInput = false;
                state.isMultiplyingInput = true;
                btnCloseP.classList.remove('hidden');
                btnDistribute.classList.add('hidden');
                btnOpposite.classList.add('hidden');
                updateEquation();
                return;
            }

            // Si une parenthèse (soustraction ou multiplication) est en cours, on ne démarre pas une nouvelle multiplication.
            if (state.isSubtractingInput || state.isMultiplyingInput) return;

            const step = {
                id: state.steps.length,
                operator: '+',
                type: 'multiplication',
                tokenIds: [],
                factor: factor,
                oppositeApplied: false,
                distributed: false,
                isClosed: false,
                _multVisualized: false,
                _multLayout: null
            };
            state.steps.push(step);
            state.currentStepIndex = state.steps.length - 1;
            state.lastPack = null;
            // Nouvelle "famille" (multiplication) : espace entre le paquet précédent et ce bloc
            state.pendingPackGap = Math.max(state.pendingPackGap, PACK_GAP);

            state.isMultiplyingInput = true;
            btnCloseP.classList.remove('hidden');
            btnDistribute.classList.add('hidden');
            updateEquation();
        }

        function closeParenthesis() {
            const step = state.steps[state.currentStepIndex];
            if (!step) return;
            if (state.isSubtractingInput && step.type === 'subtraction') {
                closeSubtraction();
                return;
            }
            if (state.isMultiplyingInput && step.type === 'multiplication') {
                closeMultiplication();
                return;
            }
        }

        function closeMultiplication() {
            const step = state.steps[state.currentStepIndex];
            if (!step || step.type !== 'multiplication') return;
            step.isClosed = true;
            state.isMultiplyingInput = false;
            btnCloseP.classList.add('hidden');

            // Visualisation matérielle : empiler k copies en bleu
            if (step.factor > 1 && step.tokenIds.length > 0 && !step.distributed) {
                visualizeMultiplication(step);
            }
            updateEquation();
        }

        function visualizeMultiplication(step) {
            if (!step || step.type !== 'multiplication') return;
            if (step._multVisualized) return;
            if (!step.factor || step.factor < 2) return;

            // On conserve les tuiles "source" (1 seule fois) pour l'affichage du calcul : 2( x^2 - 1 )
            // Les duplications bleues sur le tapis ne doivent pas contaminer l'écriture dans le calcul.
            if (!step._multBaseTokenIds) step._multBaseTokenIds = step.tokenIds.slice();
            const baseIds = step._multBaseTokenIds.slice();
            const baseTokens = baseIds.map(id => state.tokens.find(t => t.id === id)).filter(Boolean);
            if (baseTokens.length === 0) return;

            // Bounding box du groupe de base
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            for (const t of baseTokens) {
                const w = SIZES[t.type].w, h = SIZES[t.type].h;
                minX = Math.min(minX, t.x);
                minY = Math.min(minY, t.y);
                maxX = Math.max(maxX, t.x + w);
                maxY = Math.max(maxY, t.y + h);
            }
            const groupWidth = Math.max(60, maxX - minX);
            const groupHeight = Math.max(40, maxY - minY);
            const vGap = 18;
            const blockH = groupHeight + vGap;

            step._multLayout = { minX, minY, groupWidth, groupHeight, vGap, blockH };
            step._multVisualized = true;

            // Marque la copie de base
            baseTokens.forEach(t => t.element.classList.add('pending-mult'));

            // Duplication verticale
            const prevInternal = state._internalAdd;
            const prevMult = state.isMultiplyingInput;
            const prevClosed = step.isClosed;

            state._internalAdd = true;
            state.isMultiplyingInput = true; // pour conserver l'inversion de signe si operator === '-'
            step.isClosed = false;

            const prevIdx = state.currentStepIndex;
            // Assure qu'on duplique bien dans ce step
            const stepIdx = state.steps.indexOf(step);
            if (stepIdx >= 0) state.currentStepIndex = stepIdx;

            for (let i = 1; i < step.factor; i++) {
                for (const bt of baseTokens) {
                    addTile(bt.type, bt.displaySign, bt.x, bt.y + i * blockH, bt.packId);
                    const newTok = state.tokens[state.tokens.length - 1];
                    if (newTok && newTok.element) newTok.element.classList.add('pending-mult');
                }
            }

            state.currentStepIndex = prevIdx;
            step.isClosed = prevClosed;
            state.isMultiplyingInput = prevMult;
            state._internalAdd = prevInternal;

            btnDistribute.classList.remove('hidden');
        }

        function applyDistribution() {
            const step = state.steps[state.currentStepIndex];
            if (!step || step.type !== 'multiplication') return;
            if (step.distributed) return;
            if (!step._multLayout) return;

            const layout = step._multLayout;
            const blockH = layout.blockH;
            const copyGapX = 28;

            const stepTokens = step.tokenIds.map(id => state.tokens.find(t => t.id === id)).filter(Boolean);
            if (stepTokens.length === 0) return;

            // Détermine le nombre de copies à partir des positions empilées
            let maxCopy = 0;
            for (const t of stepTokens) {
                const ci = Math.round((t.y - layout.minY) / blockH);
                t._copyIndex = ci;
                if (ci > maxCopy) maxCopy = ci;
            }
            const copies = maxCopy + 1;
            if (copies <= 1) return;

            // PackIds de la copie 0 (pour recréer des packs distincts pour les copies 1..)
            const basePackIds = [];
            const seen = new Set();
            const baseTokens = stepTokens.filter(t => t._copyIndex === 0);
            // On trie par ordre de pack (stable)
            baseTokens.sort((a,b) => (state.packMeta[a.packId]?.order ?? 0) - (state.packMeta[b.packId]?.order ?? 0));
            for (const t of baseTokens) {
                if (!seen.has(t.packId)) {
                    seen.add(t.packId);
                    basePackIds.push(t.packId);
                }
            }

            // Remap packId pour chaque copie
            for (let ci = 1; ci < copies; ci++) {
                const map = new Map();
                for (const pid of basePackIds) {
                    const np = newPackId();
                    map.set(pid, np);
                }
                for (const t of stepTokens) {
                    if (t._copyIndex !== ci) continue;
                    const np = map.get(t.packId);
                    if (np !== undefined) t.packId = np;
                }
            }

            // Dé-empile : on met les copies côte à côte
            for (const t of stepTokens) {
                const ci = t._copyIndex || 0;
                if (ci === 0) continue;
                moveToken(t, t.x + ci * (layout.groupWidth + copyGapX), t.y - ci * blockH);
            }

            // Nettoyage visuel
            stepTokens.forEach(t => {
                t.element.classList.remove('pending-mult');
                delete t._copyIndex;
            });

            step.distributed = true;
            btnDistribute.classList.add('hidden');
            updateEquation();
        }

        // --- GESTION OPÉRATEURS ---

        function separatePack() {
            // Bouton + : ne crée pas d'opération.
            // Sert uniquement à séparer les groupes (packs) : 2x² + x² reste visible en deux blocs avant Réduire.
            playSound('pop');
            // Force un nouveau pack au prochain clic de tuile, même si c'est la même tuile/sign.
            state.lastPack = null;
            // Demande un espace visible entre paquets dès la saisie.
            state.pendingPackGap = Math.max(state.pendingPackGap, PACK_GAP);
        }

        function setOperator(op) {
            // Gestion des opérateurs réels : soustraction et multiplication.
            // Le bouton '+' est géré par separatePack() (séparation de packs), donc ici pas de op==='add'.

            // On empêche d'ouvrir un nouvel opérateur si une parenthèse de soustraction est en cours.
            if (state.isSubtractingInput) return;

            if (op === 'subtract') {
                // Nouvelle "famille" (soustraction) -> on veut un espace visible avant le prochain paquet
                state.pendingPackGap = Math.max(state.pendingPackGap, PACK_GAP);
                state.steps.push({
                    id: state.steps.length,
                    operator: '-',
                    type: 'subtraction',
                    tokenIds: [],
                    factor: 1,
                    oppositeApplied: false, distributed: false, isClosed: false
                });
                state.currentStepIndex++;
                state.isSubtractingInput = true;
                state.lastPack = null;
                btnCloseP.classList.remove('hidden');
            }
            updateEquation();
        }

        function closeSubtraction() {
            state.isSubtractingInput = false;
            state.steps[state.currentStepIndex].isClosed = true;
            btnCloseP.classList.add('hidden');
            checkOppositeAvailable();
            updateEquation();
        }

        function checkOppositeAvailable() {
            const hasPending = state.steps.some(s => s.type === 'subtraction' && !s.oppositeApplied);
            if (hasPending) btnOpposite.classList.remove('hidden');
            else btnOpposite.classList.add('hidden');
        }

        function applyOpposite() {
            const pendingSteps = state.steps.filter(s => s.type === 'subtraction' && !s.oppositeApplied);
            if (pendingSteps.length === 0) return;

            playSound('flip');

            pendingSteps.forEach(step => {
                const tokensToFlip = step.tokenIds
                    .map(id => state.tokens.find(t => t.id === id))
                    .filter(Boolean);

                tokensToFlip.forEach(t => {
                    if (typeof t.displaySign === 'number') {
                        t.displaySign *= -1;
                    } else {
                        // sécurité
                        t.displaySign = -(t.sign || 0);
                    }
                    // visuel : on enlève le contour "en-bracket" une fois l'opposé validé
                    t.element.classList.remove('in-bracket');
                });

                step.oppositeApplied = true;
            });

            checkOppositeAvailable();
            updateEquation();
        }

// --- ORDONNER ---

        function orderAll() {
            // ORDONNER :
            // - ordonne l'affichage du calcul (x² puis x puis 1, puis + avant -) SANS réduire
            // - sur le tapis : regroupe par types en gardant des séparations entre paquets
            playSound('pop');
            state.displayMode = 'ordered';
            state.isReduced = false;
            organizeBoard(false);
            updateEquation();
        }

        function reduceExpression() {
            playSound('magic');
            state.displayMode = 'reduced';
            state.isReduced = true;
            organizeBoard(true);
            updateEquation();
        }

        // --- ORDONNER / RÉDUIRE (mise en page des tuiles) ---
        function organizeBoard(reduced = false) {
            playSound('pop');

            // Packs :
            // - AVANT réduction : on respecte les "paquets" (packId) pour laisser des séparations entre 3x² et +x², etc.
            // - APRÈS réduction : on colle tout (un seul pack par type/signe).
            const getPacks = (type, sign) => {
                const eligible = state.tokens
                    .filter(t => t.pairId === null && t.type === type && t.sign === sign);

                if (eligible.length === 0) return [];
                if (reduced) {
                    return [eligible];
                }

                const map = new Map(); // packId -> tokens[]
                eligible.forEach(t => {
                    const pid = (typeof t.packId === 'number') ? t.packId : 0;
                    if (!map.has(pid)) map.set(pid, []);
                    map.get(pid).push(t);
                });

                const packIds = Array.from(map.keys()).sort((a, b) => {
                    const oa = state.packMeta[a]?.order ?? a;
                    const ob = state.packMeta[b]?.order ?? b;
                    return oa - ob;
                });

                return packIds.map(pid => map.get(pid));
            };

            const boardW = board.clientWidth;
            const startX = 20;
            let y = 60;

            const innerGap = 2;                  // serré à l'intérieur d'un paquet (ex : 3x²)
            const packGap = reduced ? 2 : 18;    // espace ENTRE paquets (ex : 2x² + x²)
            const lineGap = reduced ? 10 : packGap; // même gap en hauteur/largeur lors des retours à la ligne
            const rowGap = reduced ? 18 : 18;    // espace entre familles (x², -x², x, -x, 1, -1)

            const placeRow = (packs, y0) => {
                let x = startX;
                let yy = y0;
                let rowH = 0;
                const maxX = boardW - 20;

                for (const pack of packs) {
                    for (const t of pack) {
                        const size = SIZES[t.type] || { w: 50, h: 50 };

                        // Retour à la ligne si nécessaire (dans la même famille)
                        if (x + size.w > maxX) {
                            x = startX;
                            yy += rowH + lineGap;
                            rowH = 0;
                        }

                        t.element.classList.add('animating');
                        moveToken(t, x, yy);
                        setTimeout(() => t.element.classList.remove('animating'), 500);

                        x += size.w + innerGap;
                        rowH = Math.max(rowH, size.h);
                    }
                    x += packGap;
                }

                return yy + rowH;
            };

            const rows = [
                { type: 'x2', sign: 1 },
                { type: 'x2', sign: -1 },
                { type: 'x', sign: 1 },
                { type: 'x', sign: -1 },
                { type: 'unit', sign: 1 },
                { type: 'unit', sign: -1 }
            ];

            rows.forEach(r => {
                const packs = getPacks(r.type, r.sign);
                if (!packs.length) return;
                y = placeRow(packs, y) + rowGap;
            });

            // Après un ordonnancement / réduction, on garde l'affichage en haut tel quel
            state.lastPos = { x: 20, y: board.clientHeight - 100, maxYInRow: 0 };
        }

function moveToken(t, x, y) {
            t.x = x; t.y = y;
            t.element.style.left = x + 'px';
            t.element.style.top = y + 'px';
        }

        // --- GÉNÉRATION ÉQUATION ---

        function tokensToSeparatedLatex(tokens, scaleFactor = 1) {
            // Regroupe uniquement les termes CONSÉCUTIFS identiques,
            // en utilisant displaySign pour l'écriture.
            // Couleurs dans le calcul : vert (positif) / rouge (négatif).
            if (!tokens || tokens.length === 0) return "";

            const colorFor = (sgn) => (sgn === -1 ? COLORS.neg : COLORS.pos);
            // IMPORTANT : on met \color dans la chaîne JS pour obtenir \color dans le LaTeX.
            const colorWrap = (color, str) => `{\\color{${color}}{${str}}}`;
            const plus = colorWrap(COLORS.pos, '+');

            const groups = [];
            let current = null;

            tokens.forEach(t => {
                const writtenSignRaw = (typeof t.displaySign === 'number') ? t.displaySign : t.sign;
                const writtenSign = (writtenSignRaw === -1) ? -1 : 1;
                if (current && current.type === t.type && current.writtenSign === writtenSign && current.packId === t.packId) {
                    current.count++;
                } else {
                    if (current) groups.push(current);
                    current = { type: t.type, writtenSign, packId: t.packId, count: 1 };
                }
            });
            if (current) groups.push(current);

            let latex = "";
            let isFirst = true;

            groups.forEach(g => {
                let count = g.count / scaleFactor;
                count = Math.round(count * 100) / 100;
                if (count <= 0) return;

                // Terme sans signe (le signe est géré séparément)
                let termCore = "";
                if (g.type === 'unit') {
                    termCore = String(count);
                } else {
                    termCore = (count === 1 ? "" : count) + (g.type === 'x2' ? "x^2" : "x");
                }

                const termColor = colorFor(g.writtenSign);
                const coloredTerm = colorWrap(termColor, termCore);
                const coloredMinus = colorWrap(termColor, '-');

                if (isFirst) {
                    latex += (g.writtenSign === -1 ? coloredMinus : "") + coloredTerm;
                } else {
                    if (g.writtenSign === -1) {
                        latex += `\\;${coloredMinus}\\;` + coloredTerm;
                    } else {
                        // Plus en vert
                        latex += `\\;${plus}\\;` + coloredTerm;
                    }
                }

                isFirst = false;
            });

            return latex || "0";
        }

        function tokensToReducedSumLatex(tokens) {
            // Reduced display: group by type+sign (local to this step), without touching other groups.
            // Uses the real tile sign (t.sign). This matches the expected writing after DEVELOPPER.
            if (!tokens || tokens.length === 0) return "0";

            const counts = {
                x2: { pos: 0, neg: 0 },
                x: { pos: 0, neg: 0 },
                unit: { pos: 0, neg: 0 }
            };

            for (const t of tokens) {
                if (!t || t._canceling) continue;
                if (!counts[t.type]) continue;
                if (t.sign === -1) counts[t.type].neg += 1;
                else counts[t.type].pos += 1;
            }

            const ordered = [
                ['x2', 1], ['x2', -1],
                ['x', 1], ['x', -1],
                ['unit', 1], ['unit', -1]
            ];

            let latex = '';
            let hasPrev = false;

            const coreOf = (type, count) => {
                if (type === 'unit') return String(count);
                const core = latexForTokenCore(type);
                return (count === 1) ? core : String(count) + core;
            };

            const addTerm = (type, sign, count) => {
                if (!count) return;
                const core = coreOf(type, count);
                const coloredCore = coloredSpan(core, sign);
                if (!hasPrev) {
                    if (sign === -1) latex += ` ${minusRed()} ${coloredCore}`;
                    else latex += coloredCore;
                } else {
                    latex += (sign === 1) ? ` ${plusGreen()} ${coloredCore}` : ` ${minusRed()} ${coloredCore}`;
                }
                hasPrev = true;
            };

            for (const [type, sign] of ordered) {
                const count = sign === 1 ? counts[type].pos : counts[type].neg;
                addTerm(type, sign, count);
            }

            return latex || "0";
        }

        function tokensToExpandedLatex(tokens, scaleFactor = 1, hasPrevInEquation = false) {
            // Après "Ajouter l'opposé" : on enlève les parenthèses et on distribue le signe.
            // On évite les écritures du type +(-3x). On écrit directement ... - 3x ...
            // Règle :
            //  - si hasPrevInEquation : chaque terme (y compris le premier) est précédé par + ou -
            //  - sinon : le premier terme n'a pas de +, mais peut commencer par -
            //  - "+" en vert, "-" en rouge, termes pos en vert / neg en rouge

            if (!tokens || tokens.length === 0) return "";

            const colorWrap = (color, str) => `{\\color{${color}}{${str}}}`;
            const plus = colorWrap(COLORS.pos, '+');
            const minus = colorWrap(COLORS.neg, '-');

            // Regrouper uniquement des tuiles consécutives de même type/signe (pour garder l'esprit "pictural")
            const groups = [];
            let cur = null;
            tokens.forEach(t => {
                const raw = (typeof t.displaySign === 'number') ? t.displaySign : t.sign;
                const sgn = (raw === -1) ? -1 : 1;
                if (cur && cur.type === t.type && cur.sign === sgn) {
                    cur.count += 1;
                } else {
                    if (cur) groups.push(cur);
                    cur = { type: t.type, sign: sgn, count: 1 };
                }
            });
            if (cur) groups.push(cur);

            const termCoreOf = (type, count) => {
                let c = count / scaleFactor;
                c = Math.round(c * 100) / 100;
                if (c <= 0) return "";
                if (type === 'unit') return String(c);
                return (c === 1 ? "" : String(c)) + (type === 'x2' ? 'x^2' : 'x');
            };

            let latex = "";
            groups.forEach((g, idx) => {
                const core = termCoreOf(g.type, g.count);
                if (!core) return;

                const col = (g.sign === -1) ? COLORS.neg : COLORS.pos;
                const coloredCore = colorWrap(col, core);

                const op = (g.sign === -1) ? minus : plus;

                if (hasPrevInEquation) {
                    // Toujours un opérateur devant
                    latex += `\\;${op}\\;` + coloredCore;
                } else {
                    if (idx === 0) {
                        latex += (g.sign === -1 ? minus : "") + coloredCore;
                    } else {
                        latex += `\\;${op}\\;` + coloredCore;
                    }
                }
            });

            return latex;
        }

function latexStartsWithMinus(str) {
            const s = (str || '').trim();
            if (!s) return false;
            if (s.startsWith('-')) return true;
            // Cas : la chaîne commence par un "-" coloré : {\\color{...}{-}}
            return /^\{\\color\{[^}]+\}\{-\}\}/.test(s);
        }


        function generateEquationString(mode) {
            if (mode === 'ordered') {
                return generateOrderedLatex();
            }
            if (mode === 'reduced') {
                return generateGroupedLatex();
            }

            const hasNonEmptyBefore = (idx) => {
                for (let i = 0; i < idx; i++) {
                    if (state.steps[i] && state.steps[i].tokenIds && state.steps[i].tokenIds.length > 0) return true;
                }
                return false;
            };

            let latex = "";
            let isEmpty = true;

            state.steps.forEach((step, index) => {
                // Pour une multiplication non développée : l'écriture dans le calcul doit rester
                // k( ... ) avec le contenu saisi UNE seule fois, même si le plateau affiche k copies en bleu.
                let stepIds = step.tokenIds;
                if (step.type === 'multiplication' && !step.distributed && Array.isArray(step._multBaseTokenIds) && step._multBaseTokenIds.length) {
                    stepIds = step._multBaseTokenIds;
                }
                const stepTokens = stepIds.map(id => state.tokens.find(t => t.id === id)).filter(t => t);
                const isCurrent = (index === state.currentStepIndex);
                if (stepTokens.length === 0 && !isCurrent) return;

                if (index > 0 && hasNonEmptyBefore(index)) {
                    const plus = `{\\color{${COLORS.pos}}{+}}`;
                    const minusOrange = `{\\color{${COLORS.orange}}{-}}`;

                    // Cas particulier : une soustraction "opposée" devient une succession de termes signés
                    // (on gère le signe d'entrée en fonction du 1er terme après inversion).
                    if (step.type === 'subtraction' && step.oppositeApplied) {
                        // prefix géré plus bas
                    } else if (step.operator === '+' && step.type !== 'addition') {
                        latex += `\\;${plus}\\;`;
                    } else if (step.operator === '-') {
                        // Soustraction non encore "opposée" : le "-" devant la parenthèse est ORANGE.
                        if (step.type === 'subtraction' && !step.oppositeApplied) latex += `\\;${minusOrange}\\;`;
                        else latex += ' - ';
                    }
                }

                // Facteur
                // IMPORTANT : on n'applique JAMAIS de division (pas de 0.5x^2).
                // Le facteur s'affiche uniquement devant la parenthèse (2(...), 3(...)).
                let currentFactor = 1;

                // CONTENU GÉNÉRÉ SANS SIMPLIFICATION
                let content = tokensToSeparatedLatex(stepTokens, 1);
                if (stepTokens.length === 0) content = "\\dots";

                let pStr = "";

                if (step.type === 'multiplication') {
                    if (step.distributed) {
                        // After develop, show reduced expanded form (no parentheses)
                        pStr = tokensToReducedSumLatex(stepTokens);
                    } else {
                        pStr = step.factor + "(" + content + ")";
                    }
                }
                else if (step.type === 'subtraction') {
                    if (step.distributed && !step.oppositeApplied) {
                        pStr = "(" + content + ")";
                    } 
                    else if (step.factor > 1 && !step.distributed) {
                        pStr = step.factor + "(" + content + ")";
                    }
                    else if (!step.oppositeApplied) {
                        pStr = "(" + content + ")";
                    } else {
                        // Opposé appliqué : on enlève les parenthèses et on distribue le signe.
                        // On veut une écriture naturelle :
                        //   A - (2x-3) -> A -2x + 3
                        //   A - (-3x+2) -> A +3x - 2
                        // (pas de "+(-...)", pas de "+ - ...", pas de double "+").
                        const hasPrev = hasNonEmptyBefore(index);

                        const colorWrap = (color, str) => `{\\color{${color}}{${str}}}`;
                        const plus = colorWrap(COLORS.pos, '+');
                        const minus = colorWrap(COLORS.neg, '-');

                        // Regrouper uniquement des tuiles consécutives de même type/signe (pictural)
                        const groups = [];
                        let cur = null;
                        stepTokens.forEach(t => {
                            const raw = (typeof t.displaySign === 'number') ? t.displaySign : t.sign;
                            const sgn = (raw === -1) ? -1 : 1;
                            if (cur && cur.type === t.type && cur.sign === sgn) {
                                cur.count += 1;
                            } else {
                                if (cur) groups.push(cur);
                                cur = { type: t.type, sign: sgn, count: 1 };
                            }
                        });
                        if (cur) groups.push(cur);

                        const termCoreOf = (type, count) => {
                            let c = count / currentFactor;
                            c = Math.round(c * 100) / 100;
                            if (c <= 0) return '';
                            if (type === 'unit') return String(c);
                            return (c === 1 ? '' : String(c)) + (type === 'x2' ? 'x^2' : 'x');
                        };

                        // Construire une chaîne SANS signe en tête (le signe d'entrée est traité à part)
                        let body = '';
                        let leadingSign = 1;

                        // Trouver le premier groupe non vide
                        let firstIdx = -1;
                        for (let i = 0; i < groups.length; i++) {
                            const core = termCoreOf(groups[i].type, groups[i].count);
                            if (core) { firstIdx = i; break; }
                        }

                        if (firstIdx === -1) {
                            pStr = '0';
                        } else {
                            const first = groups[firstIdx];
                            leadingSign = first.sign;
                            const firstCol = (first.sign === -1) ? COLORS.neg : COLORS.pos;
                            const firstCore = termCoreOf(first.type, first.count);
                            body = colorWrap(firstCol, firstCore);

                            for (let i = firstIdx + 1; i < groups.length; i++) {
                                const g = groups[i];
                                const core = termCoreOf(g.type, g.count);
                                if (!core) continue;
                                const col = (g.sign === -1) ? COLORS.neg : COLORS.pos;
                                const coloredCore = colorWrap(col, core);
                                const op = (g.sign === -1) ? minus : plus;
                                body += `\\;${op}\\;` + coloredCore;
                            }

                            if (hasPrev) {
                                // On injecte le signe d'entrée entre les étapes : + si 1er terme pos, - si 1er terme neg
                                const prefix = (leadingSign === -1) ? minus : plus;
                                pStr = `\\;${prefix}\\;` + body;
                            } else {
                                // Début du calcul : pas de "+" au début
                                pStr = (leadingSign === -1 ? minus : '') + body;
                            }
                        }
                    }
                }
                else {
                    pStr = content;
                    if (index > 0 && latexStartsWithMinus(pStr)) pStr = "(" + pStr + ")";
                }
                
                latex += pStr;
                isEmpty = false;
            });
            return isEmpty ? "\\dots" : latex;
        }

        function renderTermsToLatex(terms) {
            // terms: [{type:'x2'|'x'|'unit', sign:1|-1, count:int}]
            // Écriture colorée : vert (positif) / rouge (négatif)
            // Le signe "+" est aussi en vert.
            if (!terms || terms.length === 0) return '0';

            const colorFor = (sgn) => (sgn === -1 ? COLORS.neg : COLORS.pos);
            const colorWrap = (color, str) => `{\\color{${color}}{${str}}}`;
            const plus = colorWrap(COLORS.pos, '+');

            const termStr = (type, count) => {
                if (type === 'unit') return String(count);
                const coef = (count === 1) ? '' : String(count);
                return coef + (type === 'x2' ? 'x^2' : 'x');
            };

            let latex = '';
            terms.forEach((t, i) => {
                const core = termStr(t.type, t.count);
                if (!core) return;

                const col = colorFor(t.sign);
                const coloredCore = colorWrap(col, core);
                const coloredMinus = colorWrap(col, '-');

                if (i === 0) {
                    latex += (t.sign === -1 ? coloredMinus : '') + coloredCore;
                } else {
                    if (t.sign === -1) latex += `\\;${coloredMinus}\\;` + coloredCore;
                    else latex += `\\;${plus}\\;` + coloredCore;
                }
            });

            return latex || '0';
        }

        function generateOrderedLatex() {
            // ORDONNER (en haut) :
            // - Trie sans reduire (pas de fusion des packs)
            // - Affichage EN LIGNE uniquement (pas de colonnes / aligned)
            // - Ordre : +x^2, -x^2, +x, -x, +1, -1
            // - Conserve les packs (separateur "+") : 2x^2 puis +x^2 restent deux blocs tant qu\'on n\'a pas reduit.

            // Securite : si une soustraction n\'a pas encore applique l\'oppose,
            // ou si une multiplication n\'est pas distribuee, on conserve l\'affichage normal.
            const hasLocked = state.steps.some(s =>
                (s.type === 'subtraction' && !s.oppositeApplied) ||
                (s.type === 'multiplication' && s.factor > 1 && !s.distributed)
            );
            if (hasLocked) {
                return generateEquationString('normal');
            }

            // Regroupement par packs (packId) pour ne PAS reduire.
            const byPack = new Map();
            state.tokens.forEach(t => {
                if (t.pairId !== null) return;
                const pid = (typeof t.packId === 'number') ? t.packId : 0;
                if (!byPack.has(pid)) byPack.set(pid, []);
                byPack.get(pid).push(t);
            });

            const packs = Array.from(byPack.keys()).map(pid => ({
                pid,
                order: state.packMeta[pid]?.order ?? pid,
                tokens: byPack.get(pid)
            })).sort((a, b) => a.order - b.order);

            const colorWrap = (color, str) => `{\\color{${color}}{${str}}}`;
            const plus = colorWrap(COLORS.pos, '+');
            const minus = colorWrap(COLORS.neg, '-');

            const termCore = (type, count) => {
                if (type === 'unit') return String(count);
                const coef = (count === 1) ? '' : String(count);
                return coef + (type === 'x2' ? 'x^2' : 'x');
            };

            // Construit une liste ordonnee de termes AU NIVEAU DES PACKS
            // (on garde les groupes, on ne fusionne pas).
            const orderedTerms = [];
            const pushPackTerms = (tp, sgn) => {
                packs.forEach(p => {
                    let c = 0;
                    p.tokens.forEach(t => {
                        if (t.type === tp && t.sign === sgn) c += 1;
                    });
                    if (!c) return;
                    orderedTerms.push({ type: tp, sign: sgn, count: c });
                });
            };

            pushPackTerms('x2',  1);
            pushPackTerms('x2', -1);
            pushPackTerms('x',   1);
            pushPackTerms('x',  -1);
            pushPackTerms('unit', 1);
            pushPackTerms('unit',-1);

            if (orderedTerms.length === 0) return '0';

            let latex = '';
            orderedTerms.forEach((t, i) => {
                const col = (t.sign === -1) ? COLORS.neg : COLORS.pos;
                const core = termCore(t.type, t.count);
                const coloredCore = colorWrap(col, core);

                if (i === 0) {
                    if (t.sign === -1) latex += `${minus}`;
                    latex += coloredCore;
                } else {
                    const op = (t.sign === -1) ? minus : plus;
                    latex += `\\;${op}\\;` + coloredCore;
                }
            });

            return latex || '0';
        }

function generateGroupedLatex() {
            // RÉDUIRE (en haut) :
            // - regroupe : tout ce qui est +x² ensemble, puis -x² ensemble, etc.
            // - IMPORTANT : on NE FAIT PAS de simplification (+ et - ne s'annulent pas ici).
            const order = ['x2', 'x', 'unit'];
            const pos = { x2: 0, x: 0, unit: 0 };
            const neg = { x2: 0, x: 0, unit: 0 };

            state.tokens.forEach(t => {
                if (t.pairId !== null) return;
                if (!(t.type in pos)) return;
                if (t.sign === 1) pos[t.type] += 1;
                else if (t.sign === -1) neg[t.type] += 1;
            });

            const terms = [];
            order.forEach(tp => {
                if (pos[tp]) terms.push({ type: tp, sign: 1, count: pos[tp] });
                if (neg[tp]) terms.push({ type: tp, sign: -1, count: neg[tp] });
            });

            return renderTermsToLatex(terms);
        }

        // Ancienne réduction nette (x² et -x² se combinent), gardée au cas où.
        function generateReducedLatex() {
            const coeff = { x2: 0, x: 0, unit: 0 };
            state.tokens.forEach(t => {
                if (t.pairId !== null) return;
                if (t.type in coeff) coeff[t.type] += (t.sign || 0);
            });

            const order = ['x2', 'x', 'unit'];
            let latex = '';
            let first = true;
            function addTerm(type) {
                const c = coeff[type];
                if (!c) return;
                const abs = Math.abs(c);
                let base = '';
                if (type === 'unit') base = String(abs);
                else if (type === 'x') base = (abs === 1 ? '' : String(abs)) + 'x';
                else base = (abs === 1 ? '' : String(abs)) + 'x^2';
                if (first) {
                    latex += (c < 0 ? '-' : '') + base;
                    first = false;
                } else {
                    latex += (c < 0 ? ' - ' : ' + ') + base;
                }
            }
            order.forEach(addTerm);
            return first ? '0' : latex;
        }

function tightenLatex(latex){
    return (latex || "")
        .replace(/(\\;|\\,|\\quad|\\qquad)/g, "")
        .replace(/\s+/g, "");
}

function updateEquation() {
            if (state.isAnimating) return;
            let displayString = tightenLatex(generateEquationString(state.displayMode));
            const isMultiLine = (displayString || '').includes('\\begin{aligned}');
            katex.render(displayString, eqDisplay, { throwOnError: false, displayMode: isMultiLine });
        }

        // --- OUTILS & HELPERS ---

        function animateCancelPair(t1, t2, badgeEl=null) {
            // On veut visualiser : le vert "saute" dans le rouge, puis tout devient gris et disparaît.
            // Si le zéro a déjà été formé (badgeEl), on ne fait pas "sauter" : on grise et on efface.

            // Ensure t1 is the positive one for the "jump" animation
            if (t1.sign === -1 && t2.sign === 1) {
                [t1, t2] = [t2, t1];
            }

            // Break pair link
            if (t1.pairedWith === t2.id) t1.pairedWith = null;
            if (t2.pairedWith === t1.id) t2.pairedWith = null;

            // --- Cas : zéro déjà combiné (effacement direct, sans vert visible) ---
            if (badgeEl) {
                const badge = badgeEl;
                t1._canceling = true;
                t2._canceling = true;
                if (t1.pairId === t2.id) t1.pairId = null;
                if (t2.pairId === t1.id) t2.pairId = null;
                t1.element.classList.add('animating', 'fading-gray');
                t2.element.classList.add('animating', 'fading-gray');

                // keep the 0 visible a bit, then fade everything (plus rapide : le 0 ne doit pas "traîner")
                setTimeout(() => {
                    t1.element.classList.add('vanish');
                    t2.element.classList.add('vanish');
                    badge.classList.add('vanish');
                }, 250);

                // on enlève le badge un peu plus tôt que les tuiles pour éviter l'effet "0 qui reste"...
                setTimeout(() => {
                    try { badge.remove(); } catch(e) {}
                }, 650);

                setTimeout(() => {
                    removeTokenById(t1.id);
                    removeTokenById(t2.id);
                }, 820);
                return;
            }

            // --- Cas : annulation automatique (saut + grisé + disparition) ---
            const startX = t1.x, startY = t1.y;
            const endX = t2.x, endY = t2.y;

            // Remove any pre-existing "zero" styling
            t1.element.classList.remove('is-zero');
            t2.element.classList.remove('is-zero');

            t1._canceling = true;
            t2._canceling = true;
            if (t1.pairId === t2.id) t1.pairId = null;
            if (t2.pairId === t1.id) t2.pairId = null;
            t1.element.classList.add('animating', 'fading-gray');
            t2.element.classList.add('animating', 'fading-gray');

            // Move positive tile to negative tile
            moveToken(t1, endX, endY);

            // Create a gray 0 in the middle
            const badge = document.createElement('div');
            badge.className = 'zero-badge';
            badge.textContent = '0';
            badge.style.left = (endX + 18) + 'px';
            badge.style.top = (endY - 8) + 'px';
            badge.style.pointerEvents = 'none';
            board.appendChild(badge);

            // Once the jump completes, gray-out both tiles, then fade out
            setTimeout(() => {
                t1.element.classList.add('fading-gray');
                t2.element.classList.add('fading-gray');
            }, 420);

            setTimeout(() => {
                t1.element.classList.add('vanish');
                t2.element.classList.add('vanish');
                badge.classList.add('vanish');
            }, 520);

            // badge : il disparaît vite
            setTimeout(() => {
                try { badge.remove(); } catch(e) {}
            }, 820);

            // tuiles : on attend la fin de l'animation vanish (0.45s)
            setTimeout(() => {
                removeTokenById(t1.id);
                removeTokenById(t2.id);
            }, 1100);
        }

        function autoSimplify() {
            // Bouton SIMPLIFIER :
            // 1) si des zéros ont déjà été formés manuellement (superposition), ils disparaissent d'abord.
            // 2) sinon, annulations automatiques par type (x², x, 1).
            // IMPORTANT : pas de boucles qui ré-annulent les mêmes tuiles (flag _canceling + timer unique).
            if (state._autoSimplifyActive) return;
            state._autoSimplifyActive = true;
            if (state._autoSimplifyTimer) {
                clearTimeout(state._autoSimplifyTimer);
                state._autoSimplifyTimer = null;
            }
            playSound('whoosh');
            runAutoSimplifyPass();
        }

        function runAutoSimplifyPass() {
            // 1) PAIRES MANUELLES (0 déjà visibles)
            const manualPairs = [];
            const processedIds = new Set();
            for (const t of state.tokens) {
                if (t._canceling) continue;
                if (t.element.classList.contains('in-bracket') || t.element.classList.contains('pending-mult')) continue;
                if (t.pairId !== null && !processedIds.has(t.id)) {
                    const partner = state.tokens.find(p => p.id === t.pairId);
                    if (partner && !partner._canceling && !partner.element.classList.contains('in-bracket') && !partner.element.classList.contains('pending-mult')) {
                        const badge = document.getElementById(`badge-${t.id}-${partner.id}`) ||
                                      document.getElementById(`badge-${partner.id}-${t.id}`);
                        manualPairs.push([t, partner, badge]);
                        processedIds.add(t.id);
                        processedIds.add(partner.id);
                    }
                }
            }

            if (manualPairs.length > 0) {
                manualPairs.forEach((pair, idx) => {
                    setTimeout(() => {
                        let [a, b, badge] = pair;
                        if (a.sign === -1 && b.sign === 1) [a, b] = [b, a];
                        animateCancelPair(a, b, badge);
                    }, idx * 160);
                });

                const totalDelay = manualPairs.length * 160 + 1500;
                state._autoSimplifyTimer = setTimeout(() => runAutoSimplifyPass(), totalDelay);
                return;
            }

            // 2) AUTO PAIRING
            const available = state.tokens.filter(t =>
                !t._canceling &&
                t.pairId === null &&
                !t.element.classList.contains('in-bracket') &&
                !t.element.classList.contains('pending-mult') &&
                !t.element.classList.contains('animating')
            );

            const pairs = [];
            const types = ['x2', 'x', 'unit'];

            const centerOf = (t) => {
                const s = SIZES[t.type] || { w: 50, h: 50 };
                return { cx: t.x + s.w / 2, cy: t.y + s.h / 2 };
            };

            for (const ty of types) {
                const greens = available.filter(t => t.type === ty && t.sign === 1);
                let reds = available.filter(t => t.type === ty && t.sign === -1);

                greens.sort((a, b) => (a.y - b.y) || (a.x - b.x));
                reds.sort((a, b) => (a.y - b.y) || (a.x - b.x));

                for (const g of greens) {
                    if (!reds.length) break;
                    const gc = centerOf(g);
                    let bestIdx = -1;
                    let bestD = Infinity;
                    for (let i = 0; i < reds.length; i++) {
                        const r = reds[i];
                        const rc = centerOf(r);
                        const dx = gc.cx - rc.cx;
                        const dy = gc.cy - rc.cy;
                        const d2 = dx * dx + dy * dy;
                        if (d2 < bestD) {
                            bestD = d2;
                            bestIdx = i;
                        }
                    }
                    if (bestIdx !== -1) {
                        const r = reds.splice(bestIdx, 1)[0];
                        pairs.push([g, r]);
                    }
                }
            }

            if (pairs.length === 0) {
                state._autoSimplifyActive = false;
                state._autoSimplifyTimer = null;
                updateEquation();
                return;
            }

            pairs.forEach((pair, idx) => {
                setTimeout(() => {
                    const [t1, t2] = pair;
                    animateCancelPair(t1, t2);
                }, idx * 220);
            });

            const nextDelay = pairs.length * 220 + 1500;
            state._autoSimplifyTimer = setTimeout(() => runAutoSimplifyPass(), nextDelay);
        }

        function removeTokenById(id) {
            const t = state.tokens.find(x => x.id === id);
            if (!t) return;
            removeTokens([t]);
        }

        function removeTokens(list) {
            list.forEach(t => t.element.remove());
            const idsToRemove = list.map(t => t.id);
            state.tokens = state.tokens.filter(t => !idsToRemove.includes(t.id));
            state.steps.forEach(s => s.tokenIds = s.tokenIds.filter(id => !idsToRemove.includes(id)));

            // Si tout a disparu, on remet la zone de création en haut (pratique pour "recommencer")
            if (state.tokens.length === 0) {
                state.lastPos = { x: 40, y: 60, maxYInRow: 0 };
                state.lastSequentialPackId = null;
                state.pendingPackGap = 0;
                state.lastPack = null;
            }

            updateEquation();
        }

        // --- DRAG & DROP ---
        let draggedToken = null; let dragOffset = {x:0, y:0};
        function handleDragStart(e) {
            if (state.currentTool !== 'hand') return;
            e.preventDefault();
            const el = e.target.closest('.token');
            if(!el) return;
            const id = parseInt(el.id.split('-')[1]);
            draggedToken = state.tokens.find(t => t.id === id);
            unpair(draggedToken);
            el.style.zIndex = 1000;
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            const rect = el.getBoundingClientRect();
            dragOffset.x = clientX - rect.left; dragOffset.y = clientY - rect.top;
            document.addEventListener('mousemove', handleDragMove); document.addEventListener('touchmove', handleDragMove, {passive: false});
            document.addEventListener('mouseup', handleDragEnd); document.addEventListener('touchend', handleDragEnd);
        }
        function handleDragMove(e) {
            if (!draggedToken) return;
            e.preventDefault();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            const bRect = board.getBoundingClientRect();
            let nx = clientX - bRect.left - dragOffset.x; let ny = clientY - bRect.top - dragOffset.y;
            draggedToken.element.style.left = nx + 'px'; draggedToken.element.style.top = ny + 'px';
            draggedToken.x = nx; draggedToken.y = ny;
        }
        function handleDragEnd(e) {
            if (!draggedToken) return;
            const partner = findOverlap(draggedToken);
            if (partner) createZeroPair(draggedToken, partner);
            draggedToken.element.style.zIndex = ''; draggedToken = null;
            document.removeEventListener('mousemove', handleDragMove); document.removeEventListener('touchmove', handleDragMove);
            document.removeEventListener('mouseup', handleDragEnd); document.removeEventListener('touchend', handleDragEnd);
            updateEquation();
        }
        function findOverlap(token) {
            const center = { x: token.x + SIZES[token.type].w/2, y: token.y + SIZES[token.type].h/2 };
            for (let t of state.tokens) {
                if (t === token) continue;
                if (t.pairId !== null) continue; 
                if (t.type !== token.type) continue;
                if (t.sign === token.sign) continue;
                const tCenter = { x: t.x + SIZES[t.type].w/2, y: t.y + SIZES[t.type].h/2 };
                const dist = Math.hypot(center.x - tCenter.x, center.y - tCenter.y);
                if (dist < SNAP_THRESHOLD) return t;
            }
            return null;
        }
        function createZeroPair(t1, t2) {
            playSound('snap');
            const mx = (t1.x + t2.x) / 2; const my = (t1.y + t2.y) / 2;
            moveToken(t1, mx, my); moveToken(t2, mx, my);
            t1.pairId = t2.id; t2.pairId = t1.id;
            t1.element.classList.add('is-zero'); t2.element.classList.add('is-zero');
            const badge = document.createElement('div');
            badge.className = 'zero-badge'; badge.innerText = '0'; badge.id = `badge-${t1.id}-${t2.id}`;
            badge.style.left = (mx + SIZES[t1.type].w/2 - 10) + 'px'; badge.style.top = (my + SIZES[t1.type].h/2 - 20) + 'px';
            board.appendChild(badge);
        }
        function unpair(t) {
            if (t.pairId === null) return;
            const p = state.tokens.find(tok => tok.id === t.pairId);
            if (p) { p.pairId = null; p.element.classList.remove('is-zero'); }
            t.pairId = null; t.element.classList.remove('is-zero');
            let b = document.getElementById(`badge-${t.id}-${p?.id}`) || document.getElementById(`badge-${p?.id}-${t.id}`);
            if(b) b.remove();
        }
        
        function resetBoard() {
            playSound('pop');
            state.tokens.forEach(t => t.element.remove());
            document.querySelectorAll('.zero-badge').forEach(b => b.remove());
            state.tokens = []; 
            state.steps = [{ id: 0, operator: '', type: 'simple', tokenIds: [], factor: 1, oppositeApplied: false, distributed: false, isClosed: false }];
            state.currentStepIndex = 0;
            state.displayMode = 'normal';
            state.isSubtractingInput = false;
            state.isMultiplyingInput = false;
            state.lastPos = { x: 40, y: 60, maxYInRow: 0 };
            state.lastSequentialPackId = null;
            state.pendingPackGap = 0;
            state.lastPack = null;
            
            btnOpposite.classList.add('hidden');
            btnCloseP.classList.add('hidden');
            btnDistribute.classList.add('hidden'); 
            clearCanvas(); updateEquation();
        }
        function setTool(t) {
            state.currentTool = t; const penMode = t === 'pen';
            board.classList.toggle('hide-cursor', penMode);
            document.getElementById('custom-cursor').style.display = penMode ? 'block' : 'none';
            document.getElementById('drawing-canvas').style.pointerEvents = penMode ? 'auto' : 'none';
        }
        const dCanvas = document.getElementById('drawing-canvas'); const ctx = dCanvas.getContext('2d');
        let isDrawing = false, lastX = 0, lastY = 0;
        function resizeCanvas() {
            const rect = board.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            dCanvas.style.width = rect.width + 'px';
            dCanvas.style.height = rect.height + 'px';
            dCanvas.width = Math.round(rect.width * dpr);
            dCanvas.height = Math.round(rect.height * dpr);
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            ctx.strokeStyle = '#2563eb';
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
        }
        window.addEventListener('resize', resizeCanvas); setTimeout(resizeCanvas, 100);
        function getMousePos(e) { const r = dCanvas.getBoundingClientRect(); const cx = e.touches ? e.touches[0].clientX : e.clientX; const cy = e.touches ? e.touches[0].clientY : e.clientY; return { x: cx - r.left, y: cy - r.top }; }
        dCanvas.addEventListener('mousedown', startDraw); dCanvas.addEventListener('touchstart', startDraw, {passive:false});
        dCanvas.addEventListener('mousemove', draw); dCanvas.addEventListener('touchmove', draw, {passive:false});
        dCanvas.addEventListener('mouseup', endDraw); dCanvas.addEventListener('touchend', endDraw);
        window.addEventListener('mousemove', moveCursor);
        function startDraw(e) { if(state.currentTool!=='pen')return; isDrawing=true; const p=getMousePos(e); lastX=p.x; lastY=p.y; }
        function draw(e) { if(!isDrawing||state.currentTool!=='pen')return; e.preventDefault(); const p=getMousePos(e); ctx.beginPath(); ctx.moveTo(lastX,lastY); ctx.lineTo(p.x,p.y); ctx.stroke(); lastX=p.x; lastY=p.y; }
        function endDraw() { isDrawing=false; }
        function clearCanvas() { ctx.clearRect(0,0,dCanvas.width,dCanvas.height); }
        function moveCursor(e) { if(state.currentTool!=='pen')return; const c=document.getElementById('custom-cursor'); c.style.left=e.clientX+'px'; c.style.top=e.clientY+'px'; c.style.transform='translate(-6px,-28px)'; }
        updateEquation();
    </script>
</body>
</html>
