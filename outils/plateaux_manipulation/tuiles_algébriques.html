<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Calcul Littéral - Tuiles Algébriques</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css">
    <style>
        body {
            font-family: 'Fredoka', sans-serif;
            background-color: #f0f9ff;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            cursor: default;
        }

        /* --- STYLES DES TUILES --- */
        .token {
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            color: white;
            box-shadow: 0 4px 6px rgba(0,0,0,0.25);
            cursor: grab;
            transition: transform 0.1s, background-color 0.5s;
            z-index: 10;
            touch-action: none;
            box-sizing: border-box;
            font-family: 'Times New Roman', serif;
            font-style: italic;
            font-size: 1.2rem;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        .token.animating {
            transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1), left 0.5s ease-in-out, top 0.5s ease-in-out, background-color 0.5s !important;
        }

        @keyframes flipToken {
            0% { transform: rotateY(0deg) scale(1); }
            50% { transform: rotateY(90deg) scale(1.1); }
            100% { transform: rotateY(0deg) scale(1); }
        }
        .flipping { animation: flipToken 0.6s ease-in-out; }

        @keyframes flyAway {
            0% { transform: scale(1) translateY(0); opacity: 1; }
            100% { transform: scale(0.1) translateY(-150px); opacity: 0; }
        }
        .flying { animation: flyAway 0.6s ease-in forwards; pointer-events: none; }

        .token:active {
            cursor: grabbing;
            transform: scale(1.05);
            z-index: 100 !important;
            box-shadow: 0 10px 15px rgba(0,0,0,0.3);
            transition: none !important;
        }

        .token.green {
            background: radial-gradient(circle at 30% 30%, #4ade80, #16a34a);
            border: 2px solid #14532d;
        }
        .token.red {
            background: radial-gradient(circle at 30% 30%, #f87171, #dc2626);
            border: 2px solid #7f1d1d;
        }
        
        .token.in-bracket { opacity: 0.95; box-shadow: none !important; }
        .token.pending-mult { box-shadow: 0 0 0 3px #3b82f6 !important; }
        .token.in-group { box-shadow: 0 0 0 3px rgba(147, 197, 253, 0.6); }

        .token.is-zero {
            background: #9ca3af !important;
            opacity: 0.6;
            border: 2px solid #6b7280;
            box-shadow: none;
            z-index: 5;
            transform: scale(0.95);
            color: rgba(255,255,255,0.5);
        }

        /* FORMES */
        .token.type-unit { width: 40px; height: 40px; border-radius: 4px; font-style: normal; }
        .token.type-x { width: 90px; height: 40px; border-radius: 4px; }
        .token.type-x2 { width: 90px; height: 90px; border-radius: 4px; }

        .zero-badge {
            position: absolute;
            font-size: 2rem;
            font-weight: 800;
            color: #374151;
            pointer-events: none;
            z-index: 20;
            text-shadow: 0 0 10px rgba(255,255,255,1);
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes popIn { from { transform: scale(0); opacity: 0; } to { transform: scale(1); opacity: 1; } }

        #drawing-canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 50; pointer-events: none; touch-action: none;
        }
        .hide-cursor, .hide-cursor * { cursor: none !important; }
        #custom-cursor { position: fixed; pointer-events: none; z-index: 9999; display: none; }

        /* SIDEBAR BOUTONS */
        .tile-btn {
            position: relative;
            background: white;
            border: 1px solid #cbd5e1;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.1s, background 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }
        .tile-btn:active { transform: translateY(1px); box-shadow: none; }
        .tile-btn:hover { background: #f1f5f9; }
        
        .preview-shape { 
            display: flex; align-items: center; justify-content: center; 
            border-radius: 2px; color: white; font-weight: bold; 
            font-family: 'Times New Roman', serif; font-style: italic;
            text-shadow: 0 1px 1px rgba(0,0,0,0.3);
        }
        .ps-green { background: #4ade80; border: 1px solid #15803d; }
        .ps-red { background: #f87171; border: 1px solid #b91c1c; }

        .mode-active-minus { border: 2px solid #f97316; background-color: #fff7ed; }
        .mode-active-group { border: 2px solid #3b82f6; background-color: #eff6ff; }

        @keyframes pulse-orange {
            0%, 100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(249, 115, 22, 0.7); }
            50% { transform: scale(1.05); box-shadow: 0 0 0 10px rgba(249, 115, 22, 0); }
        }
        .btn-opposite { animation: pulse-orange 2s infinite; }
        
        @keyframes pulse-blue {
            0%, 100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.7); }
            50% { transform: scale(1.05); box-shadow: 0 0 0 10px rgba(59, 130, 246, 0); }
        }
        .btn-distribute { animation: pulse-blue 2s infinite; }
    </style>
</head>
<body class="h-screen w-screen flex flex-col">

    <!-- CURSEUR -->
    <div id="custom-cursor">
        <svg class="drop-shadow-lg" width="34" height="34" viewBox="0 0 34 34" fill="none">
            <path d="M27 7 L13 21" stroke="#1d4ed8" stroke-width="6" stroke-linecap="round"/>
            <path d="M13 21 L8 32" stroke="#0f172a" stroke-width="4" stroke-linecap="round"/>
            <path d="M8 32 L12 28 L16 32 Z" fill="#111827"/>
            <circle cx="8" cy="32" r="1" fill="white"/>
        </svg>
    </div>

    <!-- HEADER -->
    <header class="bg-white p-2 shadow-md z-30 flex flex-wrap items-center gap-4 shrink-0">
        <div class="flex items-center gap-2">
            <button onclick="resetBoard()" class="bg-rose-100 text-rose-600 hover:bg-rose-200 p-2 rounded-lg font-bold border border-rose-200 shadow-sm flex items-center gap-1 active:scale-95 transition" title="Tout effacer">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                </svg>
            </button>
            
            <!-- BOUTON DISTRIBUER -->
            <button id="btn-distribute" onclick="applyDistribution()" class="hidden btn-distribute bg-blue-500 hover:bg-blue-600 text-white font-bold py-1 px-4 rounded-lg shadow-md border-b-4 border-blue-700 active:border-b-0 active:translate-y-1 transition text-sm">
                Distribuer
            </button>
            
            <div class="h-8 w-px bg-slate-200 mx-1"></div>
            
            <!-- OPÉRATEURS -->
            <div class="flex gap-1 items-center">
                <button onclick="setOperator('add')" class="w-10 h-10 bg-blue-100 text-blue-700 rounded-full border-2 border-blue-400 font-bold text-xl active:scale-95 transition hover:bg-blue-200" title="Ajouter">+</button>
                
                <div class="flex gap-1 items-center bg-orange-50 rounded-full p-1 border border-orange-100">
                    <button id="btn-op-minus" onclick="setOperator('subtract')" class="w-10 h-10 bg-orange-100 text-orange-700 rounded-full border-2 border-orange-400 font-bold text-xl active:scale-95 transition hover:bg-orange-200" title="Soustraire (Ouvrir parenthèse)">-</button>
                    <!-- BOUTON FERMER PARENTHÈSE -->
                    <button id="btn-close-parenthesis" onclick="closeSubtraction()" class="hidden w-10 h-10 bg-orange-500 text-white rounded-full border-2 border-orange-700 font-bold text-xl active:scale-95 transition shadow-lg animate-pulse" title="Fermer parenthèse"> ) </button>
                </div>

                <!-- BOUTON OPPOSÉ -->
                <button id="btn-opposite" onclick="applyOpposite()" class="hidden btn-opposite ml-2 bg-orange-600 text-white px-3 py-1 rounded-full font-bold shadow-lg border-b-4 border-orange-800 active:border-b-0 active:translate-y-1 text-xs sm:text-sm uppercase tracking-wide flex flex-col items-center leading-none py-2">
                    <span>OPPOSÉ</span>
                    <span class="text-[10px] opacity-80">(Changer signes)</span>
                </button>
            </div>
        </div>

        <!-- ZONE EQUATION -->
        <div class="flex-1 flex flex-col items-center justify-center min-w-[200px] px-2">
            <div class="flex items-center gap-2 bg-slate-50 px-4 py-2 rounded-xl border border-slate-200 shadow-inner mb-1 w-full justify-start overflow-x-auto no-scrollbar min-h-[60px]">
                <div id="equation-display" class="text-xl sm:text-3xl font-bold text-slate-600 tracking-tight flex items-center gap-1 font-mono whitespace-nowrap">
                    (...)
                </div>
            </div>
        </div>

        <!-- OUTILS STYLO -->
        <div class="flex items-center gap-1 bg-gray-100 p-1 rounded-lg">
            <button onclick="setTool('hand')" id="tool-hand" class="p-2 rounded bg-white shadow text-gray-700"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 11.5V14m0-2.5v-6a1.5 1.5 0 113 0m-3 6a1.5 1.5 0 00-3 0v2a7.5 7.5 0 0015 0v-5a1.5 1.5 0 00-3 0m-6-3V11m0-5.5v-1a1.5 1.5 0 013 0v1m0 0V11m0-5.5a1.5 1.5 0 013 0v3m0 0V11"/></svg></button>
            <button onclick="setTool('pen')" id="tool-pen" class="p-2 rounded text-gray-500 hover:bg-gray-200"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"/></svg></button>
            <button onclick="clearCanvas()" class="p-2 rounded text-red-400 hover:bg-red-50"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/></svg></button>
        </div>
    </header>

    <div class="flex flex-1 overflow-hidden relative">

        <!-- SIDEBAR -->
        <aside class="w-24 bg-slate-100 border-r border-slate-300 flex flex-col items-center py-4 gap-2 z-20 shadow-lg shrink-0 overflow-y-auto">
            <span class="text-[10px] font-bold text-slate-400 uppercase mb-1">Tuiles</span>

            <!-- X² -->
            <div class="flex flex-col gap-1 w-full px-2 items-center">
                <button onclick="addTile('x2', 1)" class="tile-btn w-12 h-12" title="+x²">
                    <div class="preview-shape ps-green w-8 h-8 text-sm">x²</div>
                </button>
                <button onclick="addTile('x2', -1)" class="tile-btn w-12 h-12" title="-x²">
                    <div class="preview-shape ps-red w-8 h-8 text-sm">-x²</div>
                </button>
            </div>

            <!-- X -->
            <div class="flex flex-col gap-1 w-full px-2 items-center mt-2">
                <button onclick="addTile('x', 1)" class="tile-btn w-16 h-10" title="+x">
                    <div class="preview-shape ps-green w-10 h-5 text-sm">x</div>
                </button>
                <button onclick="addTile('x', -1)" class="tile-btn w-16 h-10" title="-x">
                    <div class="preview-shape ps-red w-10 h-5 text-sm">-x</div>
                </button>
            </div>

            <!-- Unit -->
            <div class="flex flex-col gap-1 w-full px-2 items-center mt-2">
                <button onclick="addTile('unit', 1)" class="tile-btn w-10 h-10" title="+1">
                    <div class="preview-shape ps-green w-5 h-5 text-xs font-normal">1</div>
                </button>
                <button onclick="addTile('unit', -1)" class="tile-btn w-10 h-10" title="-1">
                    <div class="preview-shape ps-red w-5 h-5 text-xs font-normal">-1</div>
                </button>
            </div>

            <!-- BOUTON GROUPE -->
            <div class="flex flex-col gap-1 w-full px-2 items-center mt-2">
                <button id="btn-group" onclick="toggleGroupMode()" class="w-full py-1 text-[10px] font-bold bg-blue-50 text-blue-700 border border-blue-200 rounded hover:bg-blue-100 transition shadow-sm">
                    GROUPE ( )
                </button>
            </div>

            <!-- MULTIPLICATEUR -->
            <div class="flex flex-col gap-1 w-full px-2 items-center mt-1">
                <span class="text-[9px] font-bold text-slate-400 uppercase text-center leading-tight">Multiplier</span>
                <div class="grid grid-cols-2 gap-1 w-full">
                    <button onclick="multiplyGroup(2)" class="text-xs font-bold text-indigo-600 py-1 border border-indigo-200 rounded bg-indigo-50 hover:bg-indigo-100">x2</button>
                    <button onclick="multiplyGroup(3)" class="text-xs font-bold text-indigo-600 py-1 border border-indigo-200 rounded bg-indigo-50 hover:bg-indigo-100">x3</button>
                    <button onclick="multiplyGroup(4)" class="text-xs font-bold text-indigo-600 py-1 border border-indigo-200 rounded bg-indigo-50 hover:bg-indigo-100 col-span-2">x4</button>
                </div>
            </div>

            <!-- ORDONNER -->
            <button onclick="orderAll()" class="w-20 py-2 mt-4 bg-white border border-slate-300 rounded text-xs font-bold text-slate-600 shadow-sm active:bg-slate-100 flex flex-col items-center gap-1 hover:bg-slate-50 transition" title="Ordonner les tuiles">
                <svg class="w-4 h-4 text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"/></svg>
                ORDONNER
            </button>
            <!-- RÉDUIRE -->
            <button id="btn-reduce" onclick="reduceExpression()" class="w-20 py-2 mt-2 bg-white border border-yellow-300 rounded text-xs font-bold text-yellow-700 shadow-sm active:bg-yellow-50 flex flex-col items-center gap-1 hover:bg-yellow-50 transition" title="Réduire (regrouper les termes)">
                <svg class="w-4 h-4 text-yellow-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h6M4 12h10M4 18h6M14 6h6M18 6v12M14 18h6"/></svg>
                RÉDUIRE
            </button>

            <!-- FLASH / SIMPLIFIER -->
            <button id="btn-simplify" onclick="autoSimplify()" class="w-14 h-14 mt-2 rounded-full bg-yellow-100 border-4 border-yellow-300 text-yellow-600 shadow-md flex items-center justify-center hover:bg-yellow-200 active:scale-95 transition" title="Simplifier (annuler + et -)">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z" />
                </svg>
            </button>

        </aside>

        <!-- PLATEAU -->
        <main id="board" class="flex-1 relative bg-white overflow-hidden touch-none">
            <div class="absolute inset-0 opacity-10 pointer-events-none" 
                 style="background-image: linear-gradient(#94a3b8 1px, transparent 1px), linear-gradient(90deg, #94a3b8 1px, transparent 1px); background-size: 40px 40px;">
            </div>
            <div class="absolute top-2 left-2 pointer-events-none opacity-40">
                <p class="text-xs text-slate-400">Zone de manipulation</p>
            </div>
            <canvas id="drawing-canvas"></canvas>
        </main>
    </div>

    <script>
        const SNAP_THRESHOLD = 60;
        
        const SIZES = {
            'unit': { w: 40, h: 40 },
            'x': { w: 90, h: 40 }, 
            'x2': { w: 90, h: 90 }
        };

        // Couleurs de l'écriture (comme les tuiles)
        const COLORS = {
            pos: '#16a34a',   // vert
            neg: '#dc2626',   // rouge
            orange: '#f97316' // orange (soustraction avant opposé)
        };


        const state = {
            tokens: [],
            nextId: 1,
            // "Pack" = un paquet de tuiles issues d'une même action (utile pour ORDONNER sans réduire)
            nextPackId: 1,
            nextPackOrder: 1,
            packMeta: {}, // packId -> { order: number }
            lastPack: null, // {packId,type,sign,stepIndex,ts}
            steps: [{ id: 0, operator: '', type: 'simple', tokenIds: [], factor: 1, oppositeApplied: false, distributed: false, isClosed: false }],
            currentStepIndex: 0,
            isGrouping: false,
            currentGroupId: null,
            isSubtractingInput: false,
            isAnimating: false,
            displayMode: 'normal',
            isReduced: false, 
            currentTool: 'hand',
            lastPos: { x: 40, y: 60, maxYInRow: 0 }
        };

        const board = document.getElementById('board');
        const eqDisplay = document.getElementById('equation-display');
        const btnOpposite = document.getElementById('btn-opposite');
        const btnMinus = document.getElementById('btn-op-minus');
        const btnCloseP = document.getElementById('btn-close-parenthesis');
        const btnGroup = document.getElementById('btn-group');
        const btnDistribute = document.getElementById('btn-distribute');

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            const now = audioCtx.currentTime;
            
            if (type === 'pop') {
                osc.type = 'sine'; osc.frequency.setValueAtTime(300, now); osc.frequency.exponentialRampToValueAtTime(500, now+0.1);
                gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now+0.1);
                osc.start(now); osc.stop(now+0.1);
            } else if (type === 'snap') {
                osc.type = 'square'; osc.frequency.setValueAtTime(100, now);
                gain.gain.setValueAtTime(0.05, now); gain.gain.exponentialRampToValueAtTime(0.01, now+0.05);
                osc.start(now); osc.stop(now+0.05);
            } else if (type === 'flip') {
                osc.type = 'triangle'; osc.frequency.setValueAtTime(200, now); osc.frequency.linearRampToValueAtTime(400, now+0.2);
                gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now+0.2);
                osc.start(now); osc.stop(now+0.2);
            } else if (type === 'magic') {
                osc.type = 'sine'; osc.frequency.setValueAtTime(400, now); osc.frequency.linearRampToValueAtTime(800, now+0.3);
                gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now+0.3);
                osc.start(now); osc.stop(now+0.3);
            } else if (type === 'whoosh') {
                osc.type = 'triangle'; osc.frequency.setValueAtTime(300, now); osc.frequency.exponentialRampToValueAtTime(50, now+0.3);
                gain.gain.setValueAtTime(0.05, now); gain.gain.linearRampToValueAtTime(0, now+0.3);
                osc.start(now); osc.stop(now+0.3);
            }
        }

        // --- GESTION DES TUILES ---

        function newPackId() {
            const pid = state.nextPackId++;
            state.packMeta[pid] = { order: state.nextPackOrder++ };
            return pid;
        }

        function getOrCreatePackId({ type, sign, stepIndex }) {
            const now = Date.now();
            const lp = state.lastPack;
            // Si l'utilisateur clique plusieurs fois d'affilée sur la même tuile,
            // on "colle" dans le même pack (ex: 3 fois x² -> 3x² collés).
            // Fenêtre courte pour éviter de fusionner des actions pédagogiquement distinctes.
            const MERGE_WINDOW_MS = 650;
            if (
                lp &&
                lp.type === type &&
                lp.sign === sign &&
                lp.stepIndex === stepIndex &&
                (now - lp.ts) < MERGE_WINDOW_MS
            ) {
                lp.ts = now;
                return lp.packId;
            }
            const pid = newPackId();
            state.lastPack = { packId: pid, type, sign, stepIndex, ts: now };
            return pid;
        }

        function addTile(type, sign, x = null, y = null, packId = null) {
            // Si on était en mode ordonné/réduit, on revient en mode normal dès qu'on ajoute une tuile
            if (state.displayMode !== 'normal') {
                state.displayMode = 'normal';
                state.isReduced = false;
            }

            // Si on repart de zéro (plus aucune tuile), on recrée en haut
            if (state.tokens.length === 0) {
                state.lastPos = { x: 40, y: 60, maxYInRow: 0 };
            }
            playSound('pop');
            const id = state.nextId++;
            const el = document.createElement('div');
            const currentStep = state.steps[state.currentStepIndex];
            const isSubInput = (state.isSubtractingInput && currentStep.type === 'subtraction' && !currentStep.oppositeApplied);

            // Sur le tapis : dans une soustraction en cours, on pose directement l'opposé.
            // Dans le calcul : on garde l'écriture telle que saisie (displaySign), jusqu'au bouton OPPOSÉ.
            const displaySign = sign;
            const tileSign = isSubInput ? -sign : sign;

            // Pack (pour ORDONNER sans réduire) : un pack = une action (ou une rafale de clics identiques)
            const stepIndex = state.currentStepIndex;
            let pid;
            if (packId !== null && packId !== undefined) {
                pid = packId;
                if (!state.packMeta[pid]) {
                    state.packMeta[pid] = { order: state.nextPackOrder++ };
                }
                // on met à jour le dernier pack pour ne pas créer de "micro-packs" ensuite
                state.lastPack = { packId: pid, type, sign: tileSign, stepIndex, ts: Date.now() };
            } else {
                pid = getOrCreatePackId({ type, sign: tileSign, stepIndex });
            }

            let colorClass = tileSign === 1 ? 'green' : 'red';
            el.classList.add('token', colorClass, `type-${type}`);

            const isSubStep = (currentStep.type === 'subtraction' && !currentStep.oppositeApplied);
            if (isSubStep) el.classList.add('in-bracket');
            if (state.isGrouping) el.classList.add('in-group');

            let label = "";
            if (type === 'x2') label = tileSign === 1 ? "x²" : "-x²";
            else if (type === 'x') label = tileSign === 1 ? "x" : "-x";
            else label = tileSign === 1 ? "1" : "-1";

            
            el.innerHTML = `<span style="pointer-events:none;">${label}</span>`;
            el.id = `t-${id}`;
            
            let pos = (x !== null && y !== null) ? {x, y} : getSequentialPosition(SIZES[type].w, SIZES[type].h);
            el.style.left = pos.x + 'px';
            el.style.top = pos.y + 'px';
            
            el.addEventListener('mousedown', handleDragStart);
            el.addEventListener('touchstart', handleDragStart, {passive: false});

            board.appendChild(el);
            const tokenObj = {
                id, type, sign: tileSign, displaySign: displaySign, element: el, x: pos.x, y: pos.y, 
                pairId: null,
                inGroup: state.isGrouping ? state.currentGroupId : null,
                packId: pid
            };
            
            state.tokens.push(tokenObj);
            state.steps[state.currentStepIndex].tokenIds.push(id);

            updateEquation();
        }

        function getSequentialPosition(w, h) {
            const padding = 10;
            const boardW = board.clientWidth;
            if (state.lastPos.x + w + padding > boardW) {
                state.lastPos.x = 40;
                state.lastPos.y += state.lastPos.maxYInRow + padding;
                state.lastPos.maxYInRow = 0;
            }
            const x = state.lastPos.x;
            const y = state.lastPos.y; 
            state.lastPos.x += w + padding;
            if (h > state.lastPos.maxYInRow) state.lastPos.maxYInRow = h;
            return {x, y};
        }

        // --- MODE GROUPE ---

        function toggleGroupMode() {
            if (state.isSubtractingInput) return;
            state.isGrouping = !state.isGrouping;
            if (state.isGrouping) {
                state.currentGroupId = Date.now();
                btnGroup.classList.add('mode-active-group');
                btnGroup.innerText = 'FIN GROUPE';
                state.lastPos.x += 20; 
                state.lastPos.maxYInRow = Math.max(state.lastPos.maxYInRow, 40);
            } else {
                btnGroup.classList.remove('mode-active-group');
                btnGroup.innerText = 'GROUPE ( )';
                state.currentGroupId = null;
            }
        }

        function multiplyGroup(factor) {
            if (state.isGrouping) toggleGroupMode();

            const currentStep = state.steps[state.currentStepIndex];
            if (currentStep.tokenIds.length === 0) return;

            playSound('magic');

            currentStep.type = (currentStep.type === 'subtraction') ? 'subtraction' : 'multiplication';
            currentStep.factor = factor;
            currentStep.distributed = false; 

            const stepTokens = currentStep.tokenIds.map(id => state.tokens.find(t => t.id === id)).filter(t => t);
            stepTokens.forEach(t => t.element.classList.add('pending-mult'));

            state.isAnimating = true;
            
            const baseTokens = [...stepTokens];
            let minY = Infinity, maxY = -Infinity;
            baseTokens.forEach(t => {
                if(t.y < minY) minY = t.y;
                if(t.y + SIZES[t.type].h > maxY) maxY = t.y + SIZES[t.type].h;
            });
            const groupHeight = maxY - minY;
            const verticalGap = 15;

            for (let i = 1; i < factor; i++) {
                const shiftY = i * (groupHeight + verticalGap);
                baseTokens.forEach(original => {
                    addTile(original.type, original.sign, original.x, original.y + shiftY);
                    
                    const newId = state.tokens[state.tokens.length - 1].id;
                    const newEl = document.getElementById(`t-${newId}`);
                    newEl.classList.add('pending-mult'); 
                    if (currentStep.type === 'subtraction' && !currentStep.oppositeApplied) {
                        newEl.classList.add('in-bracket');
                    }
                });
            }
            
            state.isAnimating = false;
            
            btnDistribute.classList.remove('hidden');
            updateEquation();
        }

        function applyDistribution() {
            const currentStep = state.steps[state.currentStepIndex];
            if (!currentStep || currentStep.factor <= 1) return;

            playSound('whoosh');

            const allTokens = currentStep.tokenIds.map(id => state.tokens.find(t => t.id === id)).filter(t => t);
            allTokens.forEach(t => t.element.classList.remove('pending-mult'));

            currentStep.distributed = true;
            btnDistribute.classList.add('hidden');
            updateEquation();
        }

        // --- GESTION OPÉRATEURS ---

        function setOperator(op) {
            if (state.isSubtractingInput) return;
            if (state.isGrouping) {
                state.lastPos.x += 20; 
                state.lastPos.maxYInRow = Math.max(state.lastPos.maxYInRow, 40);
                return;
            }

            if (op === 'add') {
                state.lastPos.x += 30; 
                state.lastPos.maxYInRow = Math.max(state.lastPos.maxYInRow, 40);
                state.steps.push({
                    id: state.steps.length,
                    operator: '+',
                    type: 'simple',
                    tokenIds: [],
                    factor: 1,
                    oppositeApplied: false, distributed: false, isClosed: false
                });
                state.currentStepIndex++;

            } else if (op === 'subtract') {
                state.lastPos.x += 30;
                state.lastPos.maxYInRow = Math.max(state.lastPos.maxYInRow, 40);
                state.steps.push({
                    id: state.steps.length,
                    operator: '-',
                    type: 'subtraction',
                    tokenIds: [],
                    factor: 1,
                    oppositeApplied: false, distributed: false, isClosed: false
                });
                state.currentStepIndex++;
                state.isSubtractingInput = true;
                btnCloseP.classList.remove('hidden');
            }
            updateEquation();
        }

        function closeSubtraction() {
            state.isSubtractingInput = false;
            state.steps[state.currentStepIndex].isClosed = true;
            btnCloseP.classList.add('hidden');
            checkOppositeAvailable();
            updateEquation();
        }

        function checkOppositeAvailable() {
            const hasPending = state.steps.some(s => s.type === 'subtraction' && !s.oppositeApplied);
            if (hasPending) btnOpposite.classList.remove('hidden');
            else btnOpposite.classList.add('hidden');
        }

        function applyOpposite() {
            const pendingSteps = state.steps.filter(s => s.type === 'subtraction' && !s.oppositeApplied);
            if (pendingSteps.length === 0) return;

            playSound('flip');

            pendingSteps.forEach(step => {
                const tokensToFlip = step.tokenIds
                    .map(id => state.tokens.find(t => t.id === id))
                    .filter(Boolean);

                tokensToFlip.forEach(t => {
                    if (typeof t.displaySign === 'number') {
                        t.displaySign *= -1;
                    } else {
                        // sécurité
                        t.displaySign = -(t.sign || 0);
                    }
                    // visuel : on enlève le contour "en-bracket" une fois l'opposé validé
                    t.element.classList.remove('in-bracket');
                });

                step.oppositeApplied = true;
            });

            checkOppositeAvailable();
            updateEquation();
        }

// --- ORDONNER ---

        function orderAll() {
            // ORDONNER :
            // - ordonne l'affichage du calcul (x² puis x puis 1, puis + avant -) SANS réduire
            // - sur le tapis : regroupe par types en gardant des séparations entre paquets
            playSound('pop');
            state.displayMode = 'ordered';
            state.isReduced = false;
            organizeBoard(false);
            updateEquation();
        }

        function reduceExpression() {
            playSound('magic');
            state.displayMode = 'reduced';
            state.isReduced = true;
            organizeBoard(true);
            updateEquation();
        }

        // --- ORDONNER / RÉDUIRE (mise en page des tuiles) ---
        function organizeBoard(reduced = false) {
            playSound('pop');

            // Packs :
            // - AVANT réduction : on respecte les "paquets" (packId) pour laisser des séparations entre 3x² et +x², etc.
            // - APRÈS réduction : on colle tout (un seul pack par type/signe).
            const getPacks = (type, sign) => {
                const eligible = state.tokens
                    .filter(t => t.pairId === null && t.type === type && t.sign === sign);

                if (eligible.length === 0) return [];
                if (reduced) {
                    return [eligible];
                }

                const map = new Map(); // packId -> tokens[]
                eligible.forEach(t => {
                    const pid = (typeof t.packId === 'number') ? t.packId : 0;
                    if (!map.has(pid)) map.set(pid, []);
                    map.get(pid).push(t);
                });

                const packIds = Array.from(map.keys()).sort((a, b) => {
                    const oa = state.packMeta[a]?.order ?? a;
                    const ob = state.packMeta[b]?.order ?? b;
                    return oa - ob;
                });

                return packIds.map(pid => map.get(pid));
            };

            const boardW = board.clientWidth;
            const startY = 60;

            const placePacks = (packs, colStartX, widthLimit, y0, innerGap, packGap, lineGap) => {
                let x = colStartX;
                let y = y0;
                let rowH = 0;

                for (const pack of packs) {
                    for (const t of pack) {
                        const size = SIZES[t.type] || { w: 50, h: 50 };
                        if (x + size.w > colStartX + widthLimit) {
                            x = colStartX;
                            y += rowH + lineGap;
                            rowH = 0;
                        }
                        t.element.classList.add('animating');
                        moveToken(t, x, y);
                        setTimeout(() => t.element.classList.remove('animating'), 500);
                        x += size.w + innerGap;
                        rowH = Math.max(rowH, size.h);
                    }
                    x += packGap;
                }
                return y + rowH;
            };

            const colW = (boardW - 40) / 3;
            const cols = {
                x2: { x: 20, w: colW },
                x: { x: 20 + colW, w: colW },
                unit: { x: 20 + colW * 2, w: colW }
            };

            const innerGap = 2;
            const packGap = reduced ? 2 : 20;          // espace entre paquets AVANT réduction (ex: 3x² puis +x²)
            const lineGap = reduced ? 10 : packGap;    // même espace en hauteur qu'en largeur (avant réduction)
            const groupGap = reduced ? 20 : 30;        // espace entre + et -

            ['x2', 'x', 'unit'].forEach(type => {
                const col = cols[type];

                const posPacks = getPacks(type, 1);
                const negPacks = getPacks(type, -1);

                const bottomPos = placePacks(posPacks, col.x, col.w, startY, innerGap, packGap, lineGap);
                let negStartY = Math.max(bottomPos + groupGap, startY + 180);
                placePacks(negPacks, col.x, col.w, negStartY, innerGap, packGap, lineGap);
            });

            // Après un ordonnancement, on garde l'affichage en haut tel quel
            state.lastPos = { x: 20, y: board.clientHeight - 100, maxYInRow: 0 };
        }

function moveToken(t, x, y) {
            t.x = x; t.y = y;
            t.element.style.left = x + 'px';
            t.element.style.top = y + 'px';
        }

        // --- GÉNÉRATION ÉQUATION ---

        function tokensToSeparatedLatex(tokens, scaleFactor = 1) {
            // Regroupe uniquement les termes CONSÉCUTIFS identiques,
            // en utilisant displaySign pour l'écriture.
            // Couleurs dans le calcul : vert (positif) / rouge (négatif).
            if (!tokens || tokens.length === 0) return "";

            const colorFor = (sgn) => (sgn === -1 ? COLORS.neg : COLORS.pos);
            // IMPORTANT : on met \color dans la chaîne JS pour obtenir \color dans le LaTeX.
            const colorWrap = (color, str) => `{\\color{${color}}{${str}}}`;
            const plus = colorWrap(COLORS.pos, '+');

            const groups = [];
            let current = null;

            tokens.forEach(t => {
                const writtenSignRaw = (typeof t.displaySign === 'number') ? t.displaySign : t.sign;
                const writtenSign = (writtenSignRaw === -1) ? -1 : 1;
                if (current && current.type === t.type && current.writtenSign === writtenSign) {
                    current.count++;
                } else {
                    if (current) groups.push(current);
                    current = { type: t.type, writtenSign, count: 1 };
                }
            });
            if (current) groups.push(current);

            let latex = "";
            let isFirst = true;

            groups.forEach(g => {
                let count = g.count / scaleFactor;
                count = Math.round(count * 100) / 100;
                if (count <= 0) return;

                // Terme sans signe (le signe est géré séparément)
                let termCore = "";
                if (g.type === 'unit') {
                    termCore = String(count);
                } else {
                    termCore = (count === 1 ? "" : count) + (g.type === 'x2' ? "x^2" : "x");
                }

                const termColor = colorFor(g.writtenSign);
                const coloredTerm = colorWrap(termColor, termCore);
                const coloredMinus = colorWrap(termColor, '-');

                if (isFirst) {
                    latex += (g.writtenSign === -1 ? coloredMinus : "") + coloredTerm;
                } else {
                    if (g.writtenSign === -1) {
                        latex += `\\;${coloredMinus}\\;` + coloredTerm;
                    } else {
                        // Plus en vert
                        latex += `\\;${plus}\\;` + coloredTerm;
                    }
                }

                isFirst = false;
            });

            return latex || "0";
        }



        function latexStartsWithMinus(str) {
            const s = (str || '').trim();
            if (!s) return false;
            if (s.startsWith('-')) return true;
            // Cas : la chaîne commence par un "-" coloré : {\\color{...}{-}}
            return /^\{\\color\{[^}]+\}\{-\}\}/.test(s);
        }


        function generateEquationString(mode) {
            if (mode === 'ordered') {
                return generateOrderedLatex();
            }
            if (mode === 'reduced') {
                return generateGroupedLatex();
            }

            let latex = "";
            let isEmpty = true;

            state.steps.forEach((step, index) => {
                const stepTokens = step.tokenIds.map(id => state.tokens.find(t => t.id === id)).filter(t => t);
                const isCurrent = (index === state.currentStepIndex);
                if (stepTokens.length === 0 && !isCurrent) return;

                if (index > 0) {
                    const plus = `{\\color{${COLORS.pos}}{+}}`;
                    const minusOrange = `{\\color{${COLORS.orange}}{-}}`;

                    if (step.type === 'subtraction' && step.oppositeApplied) {
                        latex += `\\;${plus}\\;`;
                    } else if (step.operator === '+') {
                        latex += `\\;${plus}\\;`;
                    } else if (step.operator === '-') {
                        // Soustraction non encore "opposée" : le "-" devant la parenthèse est ORANGE.
                        if (step.type === 'subtraction' && !step.oppositeApplied) latex += `\\;${minusOrange}\\;`;
                        else latex += ' - ';
                    }
                }

                // Facteur
                let currentFactor = 1;
                if (!step.distributed && step.factor > 1) {
                    currentFactor = step.factor;
                }

                // CONTENU GÉNÉRÉ SANS SIMPLIFICATION
                let content = tokensToSeparatedLatex(stepTokens, currentFactor);
                if (stepTokens.length === 0) content = "\\dots";

                let pStr = "";

                if (step.type === 'multiplication') {
                    if (step.distributed) {
                        pStr = content;
                        if (index > 0 && (stepTokens.length > 1 || latexStartsWithMinus(pStr))) pStr = "(" + pStr + ")";
                    } else {
                        pStr = step.factor + "(" + content + ")";
                    }
                }
                else if (step.type === 'subtraction') {
                    if (step.distributed && !step.oppositeApplied) {
                        pStr = "(" + content + ")";
                    } 
                    else if (step.factor > 1 && !step.distributed) {
                        pStr = step.factor + "(" + content + ")";
                    }
                    else if (!step.oppositeApplied) {
                        pStr = "(" + content + ")";
                    } else {
                        // Opposé appliqué : on peut enlever les parenthèses si un seul terme
                        pStr = (stepTokens.length <= 1) ? content : "(" + content + ")";
                    }
                }
                else {
                    pStr = content;
                    if (index > 0 && latexStartsWithMinus(pStr)) pStr = "(" + pStr + ")";
                }
                
                latex += pStr;
                isEmpty = false;
            });
            return isEmpty ? "\\dots" : latex;
        }

        function renderTermsToLatex(terms) {
            // terms: [{type:'x2'|'x'|'unit', sign:1|-1, count:int}]
            // Écriture colorée : vert (positif) / rouge (négatif)
            // Le signe "+" est aussi en vert.
            if (!terms || terms.length === 0) return '0';

            const colorFor = (sgn) => (sgn === -1 ? COLORS.neg : COLORS.pos);
            const colorWrap = (color, str) => `{\\color{${color}}{${str}}}`;
            const plus = colorWrap(COLORS.pos, '+');

            const termStr = (type, count) => {
                if (type === 'unit') return String(count);
                const coef = (count === 1) ? '' : String(count);
                return coef + (type === 'x2' ? 'x^2' : 'x');
            };

            let latex = '';
            terms.forEach((t, i) => {
                const core = termStr(t.type, t.count);
                if (!core) return;

                const col = colorFor(t.sign);
                const coloredCore = colorWrap(col, core);
                const coloredMinus = colorWrap(col, '-');

                if (i === 0) {
                    latex += (t.sign === -1 ? coloredMinus : '') + coloredCore;
                } else {
                    if (t.sign === -1) latex += `\\;${coloredMinus}\\;` + coloredCore;
                    else latex += `\\;${plus}\\;` + coloredCore;
                }
            });

            return latex || '0';
        }



        function generateOrderedLatex() {
            // ORDONNER (en haut) :
            // - met d'abord tous les x², puis x, puis unités
            // - à l'intérieur : + puis -
            // - IMPORTANT : ne réduit PAS (pas de 3x² + 2x² -> 5x²)
            //   On conserve les "paquets" (packs) : ex. 3x² + 2x²
            // Sécurité : si une soustraction n'a pas encore appliqué l'opposé,
            // ou si une multiplication n'est pas distribuée, on conserve l'affichage normal.
            const hasLocked = state.steps.some(s =>
                (s.type === 'subtraction' && !s.oppositeApplied) ||
                (s.type === 'multiplication' && s.factor > 1 && !s.distributed)
            );
            if (hasLocked) {
                return generateEquationString('normal');
            }

            const typeOrder = { x2: 0, x: 1, unit: 2 };
            const signOrder = (s) => (s === 1 ? 0 : 1); // + avant -
            const terms = [];

            // On travaille au niveau des packs (packId), pas au niveau des steps,
            // pour obtenir : 3x^2 + 2x^2 (et pas 5x^2).
            const byPack = new Map();
            state.tokens.forEach(t => {
                if (t.pairId !== null) return;
                const pid = (typeof t.packId === 'number') ? t.packId : 0;
                if (!byPack.has(pid)) byPack.set(pid, []);
                byPack.get(pid).push(t);
            });

            const packs = Array.from(byPack.keys()).map(pid => ({
                pid,
                order: state.packMeta[pid]?.order ?? pid,
                tokens: byPack.get(pid)
            })).sort((a, b) => a.order - b.order);

            packs.forEach(pack => {
                const counts = {
                    x2: { pos: 0, neg: 0 },
                    x: { pos: 0, neg: 0 },
                    unit: { pos: 0, neg: 0 }
                };
                pack.tokens.forEach(t => {
                    const s = t.sign;
                    if (!s) return;
                    const bucket = (s === 1) ? 'pos' : 'neg';
                    if (counts[t.type]) counts[t.type][bucket] += 1;
                });

                ['x2', 'x', 'unit'].forEach(tp => {
                    if (counts[tp].pos) terms.push({ type: tp, sign: 1, count: counts[tp].pos, order: pack.order });
                    if (counts[tp].neg) terms.push({ type: tp, sign: -1, count: counts[tp].neg, order: pack.order });
                });
            });

            terms.sort((a, b) => {
                const t = typeOrder[a.type] - typeOrder[b.type];
                if (t !== 0) return t;
                const s = signOrder(a.sign) - signOrder(b.sign);
                if (s !== 0) return s;
                return a.order - b.order;
            });

            return renderTermsToLatex(terms);
        }

        function generateGroupedLatex() {
            // RÉDUIRE (en haut) :
            // - regroupe : tout ce qui est +x² ensemble, puis -x² ensemble, etc.
            // - IMPORTANT : on NE FAIT PAS de simplification (+ et - ne s'annulent pas ici).
            const order = ['x2', 'x', 'unit'];
            const pos = { x2: 0, x: 0, unit: 0 };
            const neg = { x2: 0, x: 0, unit: 0 };

            state.tokens.forEach(t => {
                if (t.pairId !== null) return;
                if (!(t.type in pos)) return;
                if (t.sign === 1) pos[t.type] += 1;
                else if (t.sign === -1) neg[t.type] += 1;
            });

            const terms = [];
            order.forEach(tp => {
                if (pos[tp]) terms.push({ type: tp, sign: 1, count: pos[tp] });
                if (neg[tp]) terms.push({ type: tp, sign: -1, count: neg[tp] });
            });

            return renderTermsToLatex(terms);
        }

        // Ancienne réduction nette (x² et -x² se combinent), gardée au cas où.
        function generateReducedLatex() {
            const coeff = { x2: 0, x: 0, unit: 0 };
            state.tokens.forEach(t => {
                if (t.pairId !== null) return;
                if (t.type in coeff) coeff[t.type] += (t.sign || 0);
            });

            const order = ['x2', 'x', 'unit'];
            let latex = '';
            let first = true;
            function addTerm(type) {
                const c = coeff[type];
                if (!c) return;
                const abs = Math.abs(c);
                let base = '';
                if (type === 'unit') base = String(abs);
                else if (type === 'x') base = (abs === 1 ? '' : String(abs)) + 'x';
                else base = (abs === 1 ? '' : String(abs)) + 'x^2';
                if (first) {
                    latex += (c < 0 ? '-' : '') + base;
                    first = false;
                } else {
                    latex += (c < 0 ? ' - ' : ' + ') + base;
                }
            }
            order.forEach(addTerm);
            return first ? '0' : latex;
        }

function updateEquation() {
            if (state.isAnimating) return;
            let displayString = generateEquationString(state.displayMode);
            katex.render(displayString, eqDisplay, { throwOnError: false });
        }

        // --- OUTILS & HELPERS ---

        function animateCancelPair(t1, t2, badgeEl = null) {
            // Animation : un vert "saute" dans un rouge, puis disparition.
            // On part du principe que t1 et t2 sont de même type, signes opposés.
            // Sécurité : on force toujours vert -> rouge.
            if (t1.sign === -1 && t2.sign === 1) { const tmp = t1; t1 = t2; t2 = tmp; }

            const targetX = t2.x;
            const targetY = t2.y;

            // Si on vient d'un 0 manuel, on casse le lien SANS supprimer le badge déjà présent.
            if (badgeEl) {
                const p1 = state.tokens.find(tok => tok.id === t1.pairId);
                const p2 = state.tokens.find(tok => tok.id === t2.pairId);
                if (p1) p1.pairId = null;
                if (p2) p2.pairId = null;
                t1.pairId = null;
                t2.pairId = null;
                t1.element.classList.remove('is-zero');
                t2.element.classList.remove('is-zero');
            } else {
                // Auto : on casse proprement (et on supprime un éventuel badge)
                unpair(t1);
                unpair(t2);
            }

            t1.element.classList.add('animating');
            t2.element.classList.add('animating');

            // Saut : le vert va rejoindre le rouge
            t1.element.style.zIndex = 2000;
            moveToken(t1, targetX, targetY);

            // Badge "0" (si déjà présent, on le réutilise)
            let badge = badgeEl;
            if (!badge) {
                badge = document.createElement('div');
                badge.className = 'zero-badge';
                badge.innerText = '0';
                badge.style.left = (targetX + SIZES[t1.type].w / 2 - 10) + 'px';
                badge.style.top = (targetY + SIZES[t1.type].h / 2 - 20) + 'px';
                board.appendChild(badge);
            }

            setTimeout(() => {
                t1.element.classList.add('flying');
                t2.element.classList.add('flying');
                badge.classList.add('flying');
            }, 260);

            setTimeout(() => {
                removeTokens([t1, t2]);
                badge.remove();
            }, 860);
        }

        function autoSimplify() {
            // Bouton SIMPLIFIER :
            // 1) s'il y a des paires déjà superposées (0 manuel), elles s'annulent d'abord.
            // 2) sinon, appairage automatique par type (x², x, 1).

            // 1. PAIRES MANUELLES
            const manualPairs = [];
            const processedIds = new Set();
            state.tokens.forEach(t => {
                if (t.pairId !== null && !processedIds.has(t.id)) {
                    const partner = state.tokens.find(p => p.id === t.pairId);
                    if (partner) {
                        const badge = document.getElementById(`badge-${t.id}-${partner.id}`) || document.getElementById(`badge-${partner.id}-${t.id}`);
                        manualPairs.push([t, partner, badge]);
                        processedIds.add(t.id);
                        processedIds.add(partner.id);
                    }
                }
            });
            if (manualPairs.length > 0) {
                playSound('whoosh');
                manualPairs.forEach((pair, idx) => {
                    setTimeout(() => {
                        let [a, b, badge] = pair;
                        // On force vert -> rouge pour une animation lisible
                        if (a.sign === -1 && b.sign === 1) { const tmp = a; a = b; b = tmp; }
                        animateCancelPair(a, b, badge);
                    }, idx * 150);
                });

                // Puis, automatiquement, on continue avec les annulations restantes (auto), sans 2e clic.
                const totalDelay = manualPairs.length * 150 + 980;
                setTimeout(() => {
                    autoSimplify();
                }, totalDelay);
                return;
            }

            // 2. AUTO PAIRING
            playSound('whoosh');
            const available = state.tokens.filter(t =>
                t.pairId === null &&
                !t.element.classList.contains('in-bracket') &&
                !t.element.classList.contains('pending-mult')
            );

            const pairs = [];
            const types = ['x2', 'x', 'unit'];

            // Objectif : quand c'est ordonné, annuler avec la tuile "en face" (la plus proche),
            // pour une animation lisible (pas de sauts bizarres).
            const centerOf = (t) => {
                const s = SIZES[t.type] || { w: 50, h: 50 };
                return { cx: t.x + s.w / 2, cy: t.y + s.h / 2 };
            };

            for (const ty of types) {
                const greens = available.filter(t => t.type === ty && t.sign === 1);
                let reds = available.filter(t => t.type === ty && t.sign === -1);

                // On parcourt dans l'ordre de lecture (haut->bas, gauche->droite)
                greens.sort((a, b) => (a.y - b.y) || (a.x - b.x));
                reds.sort((a, b) => (a.y - b.y) || (a.x - b.x));

                for (const g of greens) {
                    if (reds.length === 0) break;
                    const gc = centerOf(g);

                    // Choisir le rouge le plus proche (souvent "en face" en mode ordonné)
                    let bestIdx = -1;
                    let bestD = Infinity;
                    for (let i = 0; i < reds.length; i++) {
                        const r = reds[i];
                        const rc = centerOf(r);
                        const dx = gc.cx - rc.cx;
                        const dy = gc.cy - rc.cy;
                        const d2 = dx*dx + dy*dy;
                        if (d2 < bestD) { bestD = d2; bestIdx = i; }
                    }

                    if (bestIdx !== -1) {
                        const r = reds.splice(bestIdx, 1)[0];
                        pairs.push([g, r]);
                    }
                }
            }

            if (pairs.length === 0) return;

            pairs.forEach((pair, idx) => {
                setTimeout(() => {
                    const [t1, t2] = pair;
                    animateCancelPair(t1, t2);
                }, idx * 200);
            });
        }

        function removeTokens(list) {
            list.forEach(t => t.element.remove());
            const idsToRemove = list.map(t => t.id);
            state.tokens = state.tokens.filter(t => !idsToRemove.includes(t.id));
            state.steps.forEach(s => s.tokenIds = s.tokenIds.filter(id => !idsToRemove.includes(id)));

            // Si tout a disparu, on remet la zone de création en haut (pratique pour "recommencer")
            if (state.tokens.length === 0) {
                state.lastPos = { x: 40, y: 60, maxYInRow: 0 };
            }

            updateEquation();
        }

        // --- DRAG & DROP ---
        let draggedToken = null; let dragOffset = {x:0, y:0};
        function handleDragStart(e) {
            if (state.currentTool !== 'hand') return;
            e.preventDefault();
            const el = e.target.closest('.token');
            if(!el) return;
            const id = parseInt(el.id.split('-')[1]);
            draggedToken = state.tokens.find(t => t.id === id);
            unpair(draggedToken);
            el.style.zIndex = 1000;
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            const rect = el.getBoundingClientRect();
            dragOffset.x = clientX - rect.left; dragOffset.y = clientY - rect.top;
            document.addEventListener('mousemove', handleDragMove); document.addEventListener('touchmove', handleDragMove, {passive: false});
            document.addEventListener('mouseup', handleDragEnd); document.addEventListener('touchend', handleDragEnd);
        }
        function handleDragMove(e) {
            if (!draggedToken) return;
            e.preventDefault();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            const bRect = board.getBoundingClientRect();
            let nx = clientX - bRect.left - dragOffset.x; let ny = clientY - bRect.top - dragOffset.y;
            draggedToken.element.style.left = nx + 'px'; draggedToken.element.style.top = ny + 'px';
            draggedToken.x = nx; draggedToken.y = ny;
        }
        function handleDragEnd(e) {
            if (!draggedToken) return;
            const partner = findOverlap(draggedToken);
            if (partner) createZeroPair(draggedToken, partner);
            draggedToken.element.style.zIndex = ''; draggedToken = null;
            document.removeEventListener('mousemove', handleDragMove); document.removeEventListener('touchmove', handleDragMove);
            document.removeEventListener('mouseup', handleDragEnd); document.removeEventListener('touchend', handleDragEnd);
            updateEquation();
        }
        function findOverlap(token) {
            const center = { x: token.x + SIZES[token.type].w/2, y: token.y + SIZES[token.type].h/2 };
            for (let t of state.tokens) {
                if (t === token) continue;
                if (t.pairId !== null) continue; 
                if (t.type !== token.type) continue;
                if (t.sign === token.sign) continue;
                const tCenter = { x: t.x + SIZES[t.type].w/2, y: t.y + SIZES[t.type].h/2 };
                const dist = Math.hypot(center.x - tCenter.x, center.y - tCenter.y);
                if (dist < SNAP_THRESHOLD) return t;
            }
            return null;
        }
        function createZeroPair(t1, t2) {
            playSound('snap');
            const mx = (t1.x + t2.x) / 2; const my = (t1.y + t2.y) / 2;
            moveToken(t1, mx, my); moveToken(t2, mx, my);
            t1.pairId = t2.id; t2.pairId = t1.id;
            t1.element.classList.add('is-zero'); t2.element.classList.add('is-zero');
            const badge = document.createElement('div');
            badge.className = 'zero-badge'; badge.innerText = '0'; badge.id = `badge-${t1.id}-${t2.id}`;
            badge.style.left = (mx + SIZES[t1.type].w/2 - 10) + 'px'; badge.style.top = (my + SIZES[t1.type].h/2 - 20) + 'px';
            board.appendChild(badge);
        }
        function unpair(t) {
            if (t.pairId === null) return;
            const p = state.tokens.find(tok => tok.id === t.pairId);
            if (p) { p.pairId = null; p.element.classList.remove('is-zero'); }
            t.pairId = null; t.element.classList.remove('is-zero');
            let b = document.getElementById(`badge-${t.id}-${p?.id}`) || document.getElementById(`badge-${p?.id}-${t.id}`);
            if(b) b.remove();
        }
        
        function resetBoard() {
            playSound('pop');
            state.tokens.forEach(t => t.element.remove());
            document.querySelectorAll('.zero-badge').forEach(b => b.remove());
            state.tokens = []; 
            state.steps = [{ id: 0, operator: '', type: 'simple', tokenIds: [], factor: 1, oppositeApplied: false, distributed: false, isClosed: false }];
            state.currentStepIndex = 0;
            state.displayMode = 'normal';
            state.isGrouping = false; state.currentGroupId = null;
            state.isSubtractingInput = false;
            state.lastPos = { x: 40, y: 60, maxYInRow: 0 };
            
            btnOpposite.classList.add('hidden'); btnCloseP.classList.add('hidden');
            btnGroup.classList.remove('mode-active-group'); btnGroup.innerText = 'GROUPE ( )';
            btnDistribute.classList.add('hidden'); 
            clearCanvas(); updateEquation();
        }
        function setTool(t) {
            state.currentTool = t; const penMode = t === 'pen';
            board.classList.toggle('hide-cursor', penMode);
            document.getElementById('custom-cursor').style.display = penMode ? 'block' : 'none';
            document.getElementById('drawing-canvas').style.pointerEvents = penMode ? 'auto' : 'none';
        }
        const dCanvas = document.getElementById('drawing-canvas'); const ctx = dCanvas.getContext('2d');
        let isDrawing = false, lastX = 0, lastY = 0;
        function resizeCanvas() {
            const rect = board.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            dCanvas.style.width = rect.width + 'px';
            dCanvas.style.height = rect.height + 'px';
            dCanvas.width = Math.round(rect.width * dpr);
            dCanvas.height = Math.round(rect.height * dpr);
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            ctx.strokeStyle = '#2563eb';
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
        }
        window.addEventListener('resize', resizeCanvas); setTimeout(resizeCanvas, 100);
        function getMousePos(e) { const r = dCanvas.getBoundingClientRect(); const cx = e.touches ? e.touches[0].clientX : e.clientX; const cy = e.touches ? e.touches[0].clientY : e.clientY; return { x: cx - r.left, y: cy - r.top }; }
        dCanvas.addEventListener('mousedown', startDraw); dCanvas.addEventListener('touchstart', startDraw, {passive:false});
        dCanvas.addEventListener('mousemove', draw); dCanvas.addEventListener('touchmove', draw, {passive:false});
        dCanvas.addEventListener('mouseup', endDraw); dCanvas.addEventListener('touchend', endDraw);
        window.addEventListener('mousemove', moveCursor);
        function startDraw(e) { if(state.currentTool!=='pen')return; isDrawing=true; const p=getMousePos(e); lastX=p.x; lastY=p.y; }
        function draw(e) { if(!isDrawing||state.currentTool!=='pen')return; e.preventDefault(); const p=getMousePos(e); ctx.beginPath(); ctx.moveTo(lastX,lastY); ctx.lineTo(p.x,p.y); ctx.stroke(); lastX=p.x; lastY=p.y; }
        function endDraw() { isDrawing=false; }
        function clearCanvas() { ctx.clearRect(0,0,dCanvas.width,dCanvas.height); }
        function moveCursor(e) { if(state.currentTool!=='pen')return; const c=document.getElementById('custom-cursor'); c.style.left=e.clientX+'px'; c.style.top=e.clientY+'px'; c.style.transform='translate(-6px,-28px)'; }
        updateEquation();
    </script>
</body>
</html>
