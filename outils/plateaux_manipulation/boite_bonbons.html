<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Boîte à bonbons — 3D + Cavalière + Patron</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#111a33;
      --text:#e9eefc;
      --muted:#a9b6e6;
      --line:rgba(255,255,255,.18);
      --btn:#1a2550;
      --btn2:#22306a;
      --accent:#7ee787;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:system-ui,Segoe UI,Roboto,Arial}
    .app{display:grid;grid-template-rows:auto 1fr; height:100%;}
    .topbar{
      display:flex; flex-wrap:wrap; gap:10px; align-items:center;
      padding:10px 12px; border-bottom:1px solid var(--line);
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
    }
    .title{font-weight:700}
    .pill{padding:6px 10px;border:1px solid var(--line);border-radius:999px;color:var(--muted)}
    .btn{
      background:var(--btn); border:1px solid var(--line); color:var(--text);
      padding:8px 10px; border-radius:10px; cursor:pointer;
    }
    .btn:hover{background:var(--btn2)}
    .toggle{display:flex; gap:6px; align-items:center; padding:6px 10px; border:1px solid var(--line); border-radius:10px; background:rgba(255,255,255,.03);}
    input[type="checkbox"]{transform:scale(1.1)}
    .spacer{flex:1}
    .grid{
      display:grid;
      grid-template-columns: 1.2fr 1fr;
      grid-template-rows: 1fr 1fr;
      gap:12px;
      padding:12px;
      height:100%;
      min-height:0;
    }
    .card{
      background:var(--panel);
      border:1px solid var(--line);
      border-radius:14px;
      overflow:hidden;
      display:flex;
      flex-direction:column;
      min-height:0;
    }
    .card header{
      padding:10px 12px;
      display:flex; align-items:center; gap:10px; flex-wrap:wrap;
      border-bottom:1px solid var(--line);
      background:rgba(255,255,255,.03);
    }
    .card header .h{font-weight:700}
    .card header .sub{color:var(--muted); font-size:.92rem}
    .card .body{position:relative; flex:1; min-height:0;}
    #view3d{width:100%; height:100%; display:block;}
    #cav{width:100%; height:100%; display:block; background:#0f1733;}
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
    label{color:var(--muted); font-size:.92rem}
    input[type="range"]{width:160px}
    .legend{
      position:absolute; left:10px; bottom:10px;
      background:rgba(0,0,0,.35);
      border:1px solid var(--line);
      padding:8px 10px;
      border-radius:12px;
      max-width:min(520px, calc(100% - 20px));
      font-size:.92rem;
      color:var(--muted);
      backdrop-filter: blur(6px);
    }
    .legend b{color:var(--text)}
    .svgWrap{width:100%; height:100%; overflow:auto; background:#0f1733;}
    .note{color:var(--muted); font-size:.92rem}
    .kpi{color:var(--text)}
    .kpi span{color:var(--muted)}
    .warn{
      margin-left:auto;
      color:#ffd28a;
      font-size:.92rem;
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="topbar">
      <div class="title">Boîte à bonbons — 3D + Cavalière + Patron</div>
      <div class="pill" id="dimsPill"></div>

      <div class="spacer"></div>

      <button class="btn" id="resetCam">Réinitialiser la vue 3D</button>
      <button class="btn" id="focusBox">Centrer sur la boîte</button>
      <button class="btn" id="printNet">Imprimer le patron</button>
    </div>

    <div class="grid">
      <!-- 3D -->
      <section class="card">
        <header>
          <div class="h">Vue 3D (correction)</div>
          <div class="sub">Pile de bonbons + boîte filaire</div>
          <div class="row">
            <div class="toggle"><input id="showCandies" type="checkbox" checked><label for="showCandies">Bonbons</label></div>
            <div class="toggle"><input id="showBox" type="checkbox" checked><label for="showBox">Boîte</label></div>
            <div class="toggle"><input id="showGrid" type="checkbox" checked><label for="showGrid">Grille sol</label></div>
          </div>
        </header>
        <div class="body">
          <canvas id="view3d"></canvas>
          <div class="legend" id="legend3d"></div>
        </div>
      </section>

      <!-- Cavalière -->
      <section class="card">
        <header>
          <div class="h">Perspective cavalière</div>
          <div class="sub">pas à pas sur “feuille quadrillée”</div>
          <div class="row">
            <label>Coef profondeur</label>
            <input id="coef" type="range" min="0.3" max="0.8" step="0.05" value="0.5">
            <span class="note" id="coefVal"></span>
          </div>
          <div class="row">
            <label>Étape</label>
            <input id="step" type="range" min="1" max="3" step="1" value="3">
            <span class="note" id="stepVal"></span>
          </div>
        </header>
        <div class="body">
          <canvas id="cav"></canvas>
          <div class="legend" id="legendCav"></div>
        </div>
      </section>

      <!-- Patron -->
      <section class="card" style="grid-column: 1 / -1;">
        <header>
          <div class="h">Patron (SVG imprimable)</div>
          <div class="sub">dimensions en mm + option languettes</div>

          <div class="row">
            <div class="toggle"><input id="tabs" type="checkbox" checked><label for="tabs">Languettes</label></div>
            <div class="toggle"><input id="mmGrid" type="checkbox"><label for="mmGrid">Grille 5 mm</label></div>

            <span class="warn" id="printHint">Astuce : imprime à 100% (sans “ajuster”).</span>
          </div>
        </header>
        <div class="body">
          <div class="svgWrap" id="svgWrap"></div>
        </div>
      </section>
    </div>
  </div>

  <!-- THREE (version globale, pas de modules -> plus simple en local) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js"></script>

  <script>
    // ======= Données (en mm pour éviter les décimales) =======
    const D = {
      a: 30,   // côté angle droit 3 cm
      b: 40,   // côté angle droit 4 cm
      c: 50,   // hypoténuse 5 cm
      t: 6,    // épaisseur d'un bonbon
      n: 10,   // nombre de bonbons
      clearanceXY: 1, // petit jeu (mm) pour visualiser la "boîte" autour
      clearanceZ: 1
    };

    const H = () => D.n * D.t; // hauteur de la pile (mm)

    const dimsPill = document.getElementById('dimsPill');
    function refreshDimsPill(){
      dimsPill.textContent =
        `Base: 3–4–5 cm | Épaisseur: ${D.t} mm | Pile: ${D.n} ⇒ ${H()} mm (= ${(H()/10).toFixed(1)} cm)`;
    }
    refreshDimsPill();

    // ======= UI =======
    const ui = {
      showCandies: document.getElementById('showCandies'),
      showBox: document.getElementById('showBox'),
      showGrid: document.getElementById('showGrid'),
      coef: document.getElementById('coef'),
      coefVal: document.getElementById('coefVal'),
      step: document.getElementById('step'),
      stepVal: document.getElementById('stepVal'),
      tabs: document.getElementById('tabs'),
      mmGrid: document.getElementById('mmGrid'),
      resetCam: document.getElementById('resetCam'),
      focusBox: document.getElementById('focusBox'),
      printNet: document.getElementById('printNet'),
      legend3d: document.getElementById('legend3d'),
      legendCav: document.getElementById('legendCav'),
      svgWrap: document.getElementById('svgWrap'),
    };

    // ======= 3D =======
    const canvas3d = document.getElementById('view3d');
    const renderer = new THREE.WebGLRenderer({ canvas: canvas3d, antialias:true });
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio));

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b1020);

    const camera = new THREE.PerspectiveCamera(50, 1, 1, 5000);
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // Lumières
    scene.add(new THREE.AmbientLight(0xffffff, 0.65));
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(200, 260, 180);
    scene.add(dir);

    // Grille sol
    const grid = new THREE.GridHelper(400, 40, 0x6b78b8, 0x2a355f);
    grid.position.y = -80;
    scene.add(grid);

    // Groupes
    const Gcandies = new THREE.Group();
    const Gbox = new THREE.Group();
    scene.add(Gcandies, Gbox);

    // Fabrique un prisme triangulaire (base rectangle a,b ; profondeur = depth)
    function makeTriPrism(a, b, depth){
      const shape = new THREE.Shape();
      shape.moveTo(0,0);
      shape.lineTo(a,0);
      shape.lineTo(0,b);
      shape.lineTo(0,0);

      const geo = new THREE.ExtrudeGeometry(shape, { depth: depth, bevelEnabled:false });
      geo.computeBoundingBox();
      const bb = geo.boundingBox;
      const cx = (bb.min.x + bb.max.x)/2;
      const cy = (bb.min.y + bb.max.y)/2;
      const cz = (bb.min.z + bb.max.z)/2;
      geo.translate(-cx, -cy, -cz); // centre
      geo.computeVertexNormals();
      return geo;
    }

    let candyMeshProto = null;
    function rebuild3D(){
      // Cleanup
      while(Gcandies.children.length) Gcandies.remove(Gcandies.children[0]);
      while(Gbox.children.length) Gbox.remove(Gbox.children[0]);

      // Bonbons (10 prismes de profondeur t)
      const candyGeo = makeTriPrism(D.a, D.b, D.t);
      candyMeshProto = candyGeo;

      const candyMat = new THREE.MeshStandardMaterial({
        color: 0x7ee787,
        roughness: 0.45,
        metalness: 0.05
      });

      const totalH = H();
      for(let i=0;i<D.n;i++){
        const m = new THREE.Mesh(candyGeo, candyMat);
        // empilement sur Z
        m.position.z = (i - (D.n-1)/2) * D.t;
        // un tout petit décalage pour que ça "se lise" en 3D
        m.position.y = 2*Math.sin(i*0.6);
        Gcandies.add(m);
      }

      // Boîte filaire (un prisme un poil plus grand)
      const bx = D.clearanceXY;
      const bz = D.clearanceZ;
      const boxGeo = makeTriPrism(D.a + 2*bx, D.b + 2*bx, totalH + 2*bz);

      const edges = new THREE.EdgesGeometry(boxGeo, 15);
      const lineMat = new THREE.LineBasicMaterial({ color: 0xa9b6e6, transparent:true, opacity:0.9 });
      const wire = new THREE.LineSegments(edges, lineMat);
      Gbox.add(wire);

      // Positionne boîte et bonbons ensemble (centrés)
      Gcandies.position.set(0, 0, 0);
      Gbox.position.set(0, 0, 0);

      // Légende pédagogique
      ui.legend3d.innerHTML = `
        <b>Objectif correction :</b><br/>
        • Base = triangle rectangle <span class="kpi">3–4–5 cm</span><br/>
        • Épaisseur bonbon = <span class="kpi">${D.t} mm</span> ⇒ pile = <span class="kpi">${totalH} mm</span> (= ${(totalH/10).toFixed(1)} cm)<br/>
        • La boîte est le <b>prisme droit</b> qui “enveloppe” la pile.
      `;

      // Cam par défaut
      resetCamera();
      drawCavaliere();
      buildNetSVG();
    }

    function resetCamera(){
      const size = Math.max(D.a, D.b, H());
      camera.position.set(size*2.2, size*1.6, size*2.0);
      camera.lookAt(0,0,0);
      controls.target.set(0,0,0);
      controls.update();
    }

    function focusBox(){
      controls.target.set(0,0,0);
      camera.position.set(140, 120, 220);
      controls.update();
    }

    ui.resetCam.addEventListener('click', resetCamera);
    ui.focusBox.addEventListener('click', focusBox);

    ui.showCandies.addEventListener('change', ()=>{ Gcandies.visible = ui.showCandies.checked; });
    ui.showBox.addEventListener('change', ()=>{ Gbox.visible = ui.showBox.checked; });
    ui.showGrid.addEventListener('change', ()=>{ grid.visible = ui.showGrid.checked; });

    function resize3D(){
      const r = canvas3d.getBoundingClientRect();
      renderer.setSize(r.width, r.height, false);
      camera.aspect = r.width / r.height;
      camera.updateProjectionMatrix();
    }

    // ======= Cavalière (canvas 2D) =======
    const cav = document.getElementById('cav');
    const ctx = cav.getContext('2d');

    function resizeCav(){
      const r = cav.getBoundingClientRect();
      cav.width = Math.floor(r.width * devicePixelRatio);
      cav.height = Math.floor(r.height * devicePixelRatio);
      ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
      drawCavaliere();
    }

    function drawGrid(ctx, w, h, step=20){
      ctx.save();
      ctx.clearRect(0,0,w,h);
      ctx.fillStyle = '#0f1733';
      ctx.fillRect(0,0,w,h);

      ctx.strokeStyle = 'rgba(255,255,255,.06)';
      ctx.lineWidth = 1;
      for(let x=0;x<=w;x+=step){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke(); }
      for(let y=0;y<=h;y+=step){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke(); }
      ctx.restore();
    }

    function projectCav(p, k=0.5, theta=Math.PI/4){
      // p = {x,y,z} en mm -> on convertit en px plus bas via scale
      const dx = k * p.z * Math.cos(theta);
      const dy = k * p.z * Math.sin(theta);
      return { x: p.x + dx, y: p.y - dy };
    }

    function drawCavaliere(){
      ui.coefVal.textContent = `k = ${Number(ui.coef.value).toFixed(2)} (souvent 0,5)`;
      const step = Number(ui.step.value);
      ui.stepVal.textContent = step===1 ? '1: base' : step===2 ? '2: profondeur' : '3: boîte complète';

      const w = cav.getBoundingClientRect().width;
      const h = cav.getBoundingClientRect().height;
      drawGrid(ctx, w, h, 20);

      const k = Number(ui.coef.value);
      const theta = Math.PI/4;

      // points du prisme (en mm) - on prend le triangle dans le plan (x,y) et la profondeur sur z
      const A = {x:0, y:0, z:0};
      const B = {x:D.a, y:0, z:0};
      const C = {x:0, y:D.b, z:0};

      const Z = H(); // profondeur / hauteur du prisme
      const A2 = {x:0, y:0, z:Z};
      const B2 = {x:D.a, y:0, z:Z};
      const C2 = {x:0, y:D.b, z:Z};

      // échelle mm -> px
      const margin = 60;
      const maxX = D.a + k*Z*Math.cos(theta);
      const maxY = D.b + k*Z*Math.sin(theta);
      const scale = Math.min((w-2*margin)/maxX, (h-2*margin)/maxY);

      function P(p){
        const q = projectCav(p, k, theta);
        return {
          x: margin + q.x*scale,
          y: margin + q.y*scale
        };
      }

      const pA = P(A), pB = P(B), pC = P(C);
      const pA2 = P(A2), pB2 = P(B2), pC2 = P(C2);

      // Style
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(233,238,252,.9)';

      function seg(p,q){
        ctx.beginPath();
        ctx.moveTo(p.x,p.y);
        ctx.lineTo(q.x,q.y);
        ctx.stroke();
      }

      // Étape 1 : base triangle (vraie grandeur)
      seg(pA,pB);
      seg(pA,pC);
      seg(pB,pC);

      // Étape 2 : arêtes de profondeur
      if(step >= 2){
        ctx.strokeStyle = 'rgba(126,231,135,.9)';
        seg(pA,pA2);
        seg(pB,pB2);
        seg(pC,pC2);
      }

      // Étape 3 : face arrière + arêtes restantes
      if(step >= 3){
        ctx.strokeStyle = 'rgba(233,238,252,.75)';
        seg(pA2,pB2);
        seg(pA2,pC2);
        seg(pB2,pC2);
        ctx.strokeStyle = 'rgba(233,238,252,.6)';
        seg(pA,pA2); seg(pB,pB2); seg(pC,pC2);
      }

      // Labels utiles (sans surcharger)
      ctx.fillStyle = 'rgba(233,238,252,.9)';
      ctx.font = '14px system-ui';
      ctx.fillText('3 cm', (pA.x+pB.x)/2 - 10, (pA.y+pB.y)/2 - 10);
      ctx.fillText('4 cm', (pA.x+pC.x)/2 - 10, (pA.y+pC.y)/2 + 18);
      ctx.fillText('5 cm', (pB.x+pC.x)/2 + 8, (pB.y+pC.y)/2 + 4);
      ctx.fillStyle = 'rgba(126,231,135,.95)';
      ctx.fillText(`6 cm (10×6 mm)`, (pA2.x+pB2.x)/2 - 30, (pA2.y+pB2.y)/2 - 12);

      ui.legendCav.innerHTML = `
        <b>Lecture cavalière :</b><br/>
        1) Dessine le triangle <b>3–4–5</b> en vraie grandeur.<br/>
        2) Trace la profondeur à <b>45°</b> avec le coefficient <b>k</b> (souvent 1/2).<br/>
        3) Ferme la boîte en reliant les points “du fond”.
      `;
    }

    ui.coef.addEventListener('input', drawCavaliere);
    ui.step.addEventListener('input', drawCavaliere);

    // ======= Patron SVG =======
    function buildNetSVG(){
      const tabsOn = ui.tabs.checked;
      const gridOn = ui.mmGrid.checked;

      // Layout en mm : bande des 3 rectangles (hauteur = Z, largeurs = a, c, b)
      const Z = H();
      const w1 = D.a, w2 = D.c, w3 = D.b;
      const stripW = w1 + w2 + w3;

      // Page A4 en mm
      const pageW = 210, pageH = 297;
      const pad = 12;

      // Positionne le patron
      const x0 = pad;
      const y0 = 60;

      // Triangle attaché au rectangle central (w2)
      // Triangle rectangle 3-4-5 : on le met “debout” : points (0,0) (a,0) (0,b)
      // On le place centré sur le rectangle central (au-dessus et en-dessous)
      const triW = D.a;
      const triH = D.b;

      // Languettes (simple bande)
      const tab = 10;

      function line(x1,y1,x2,y2, dashed=false){
        return `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="rgba(233,238,252,.9)" stroke-width="0.6" ${dashed?`stroke-dasharray="3 3"`:''}/>`;
      }
      function rect(x,y,w,h, dashed=false){
        return `<rect x="${x}" y="${y}" width="${w}" height="${h}" fill="none" stroke="rgba(233,238,252,.9)" stroke-width="0.8" ${dashed?`stroke-dasharray="3 3"`:''}/>`;
      }
      function poly(points, fill="none", stroke="rgba(233,238,252,.9)", sw=0.8, dashed=false){
        const pts = points.map(p=>`${p[0]},${p[1]}`).join(' ');
        return `<polygon points="${pts}" fill="${fill}" stroke="${stroke}" stroke-width="${sw}" ${dashed?`stroke-dasharray="3 3"`:''}/>`;
      }
      function text(x,y,s, size=4){
        return `<text x="${x}" y="${y}" font-size="${size}" fill="rgba(233,238,252,.85)" font-family="system-ui,Segoe UI,Roboto">${s}</text>`;
      }

      // Grille 5mm optionnelle
      let grid = '';
      if(gridOn){
        for(let x=0; x<=pageW; x+=5){
          grid += `<line x1="${x}" y1="0" x2="${x}" y2="${pageH}" stroke="rgba(255,255,255,.05)" stroke-width="0.2"/>`;
        }
        for(let y=0; y<=pageH; y+=5){
          grid += `<line x1="0" y1="${y}" x2="${pageW}" y2="${y}" stroke="rgba(255,255,255,.05)" stroke-width="0.2"/>`;
        }
      }

      // Rectangles du bandeau
      const R1 = [x0, y0, w1, Z];
      const R2 = [x0+w1, y0, w2, Z];
      const R3 = [x0+w1+w2, y0, w3, Z];

      // Triangles (haut / bas) attachés au rectangle central
      // On colle le côté "a" sur le haut du rectangle central : de (xR2, y0) à (xR2 + a, y0)
      const xT = R2[0] + (w2 - D.a)/2;
      const yTop = y0;
      const triTop = [
        [xT, yTop],
        [xT + D.a, yTop],
        [xT, yTop - D.b]
      ];
      const triBot = [
        [xT, y0+Z],
        [xT + D.a, y0+Z],
        [xT, y0+Z + D.b]
      ];

      // Languettes : on en met une sur un bord externe + autour triangles (simple)
      let tabs = '';
      if(tabsOn){
        // languette sur le bord externe gauche du bandeau (collage final)
        tabs += `<rect x="${x0 - tab}" y="${y0}" width="${tab}" height="${Z}" fill="rgba(126,231,135,.08)" stroke="rgba(233,238,252,.7)" stroke-width="0.6" stroke-dasharray="3 3"/>`;
        tabs += text(x0 - tab + 1, y0 + 6, 'languette', 3.6);

        // languettes triangles : petite bande le long du côté libre du triangle (hypothénuse), très simplifiée
        // (pédagogiquement ça suffit : tu peux leur dire "ajoutez les languettes où vous voulez coller")
      }

      // Traits de pliage (entre rectangles)
      const fold1 = line(R1[0]+R1[2], y0, R1[0]+R1[2], y0+Z, true);
      const fold2 = line(R2[0]+R2[2], y0, R2[0]+R2[2], y0+Z, true);

      // SVG final
      const svg = `
        <svg xmlns="http://www.w3.org/2000/svg" width="210mm" height="297mm" viewBox="0 0 210 297">
          <rect x="0" y="0" width="210" height="297" fill="#0f1733"/>
          ${grid}
          ${text(12, 18, 'Patron de la boîte (échelle 1:1) — Bonbons prismes 3–4–5 cm, pile 10×6 mm = 6 cm', 4.2)}
          ${text(12, 28, 'Rectangles: 6×3 cm, 6×5 cm, 6×4 cm — 2 triangles 3–4–5 cm', 4.2)}

          ${rect(...R1)}
          ${rect(...R2)}
          ${rect(...R3)}

          ${fold1}
          ${fold2}

          ${poly(triTop)}
          ${poly(triBot)}

          ${tabs}

          ${text(R1[0]+2, y0-2, '6×3 cm', 4)}
          ${text(R2[0]+2, y0-2, '6×5 cm', 4)}
          ${text(R3[0]+2, y0-2, '6×4 cm', 4)}

          ${text(xT, yTop - D.b - 3, 'triangle 3–4–5', 4)}
          ${text(xT, y0+Z + D.b + 6, 'triangle 3–4–5', 4)}

          ${text(12, 285, 'Conseil : imprime à 100% (sans ajuster). Découpe le contour plein, plie sur les pointillés.', 4)}
        </svg>
      `;

      ui.svgWrap.innerHTML = svg;
    }

    ui.tabs.addEventListener('change', buildNetSVG);
    ui.mmGrid.addEventListener('change', buildNetSVG);

    ui.printNet.addEventListener('click', ()=>{
      const svg = ui.svgWrap.querySelector('svg');
      if(!svg) return;

      const w = window.open('', '_blank');
      const html = `
        <!doctype html><html><head><meta charset="utf-8">
        <title>Patron — impression</title>
        <style>
          body{margin:0; background:#fff;}
          svg{width:210mm;height:297mm; display:block;}
        </style></head><body>
          ${svg.outerHTML}
          <script>window.onload=()=>{ setTimeout(()=>window.print(), 200); }<\/script>
        </body></html>
      `;
      w.document.open();
      w.document.write(html);
      w.document.close();
    });

    // ======= Anim loop + resize =======
    function animate(){
      controls.update();
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    // Resize observer
    const ro = new ResizeObserver(()=>{
      resize3D();
      resizeCav();
    });
    ro.observe(document.body);

    // Init
    rebuild3D();
    resize3D();
    resizeCav();
    animate();
  </script>
</body>
</html>
