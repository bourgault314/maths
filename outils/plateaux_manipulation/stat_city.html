<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>City Stats - La ville des statistiques</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;800&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Fredoka', sans-serif;
            background-color: #0f172a;
            color: white;
            overflow: hidden;
            user-select: none;
            touch-action: none;
        }

        /* --- UI ELEMENTS --- */
        .mode-btn {
            padding: 6px 16px;
            border-radius: 8px;
            font-weight: bold;
            font-size: 0.9rem;
            transition: all 0.2s;
            border: 1px solid rgba(255,255,255,0.1);
            background: rgba(30, 41, 59, 0.8);
            color: #94a3b8;
        }
        .mode-btn:hover { background: rgba(51, 65, 85, 0.9); color: white; }
        .mode-btn.active {
            background: #e11d48; /* Rose vif */
            color: white;
            border-color: #fb7185;
            box-shadow: 0 0 15px rgba(225, 29, 72, 0.4);
        }

        /* SC√àNE */
        #city-container {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            perspective: 1000px;
            z-index: 10;
        }
        
        #drawing-canvas {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 60; pointer-events: none;
        }

        #custom-cursor {
            position: fixed; pointer-events: none; z-index: 9999; display: none;
        }
        .hide-cursor, .hide-cursor * { cursor: none !important; }

        /* IMMEUBLES */
        .building-wrapper {
            position: absolute;
            bottom: 24px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            z-index: 20;
            touch-action: none;
            transition: left 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        }
        
        .mode-mean .building-wrapper {
            transition: none;
        }

        /* Dragging Style (Cyan) */
        .building-wrapper.is-dragging .building {
            transform: scale(1.05) translateY(-10px);
            box-shadow: 0 0 30px rgba(34, 211, 238, 0.6);
            border-color: #67e8f9 !important;
            z-index: 100;
            filter: brightness(1.1);
        }

        .building {
            width: 60px;
            background: linear-gradient(180deg, #38bdf8 0%, #0284c7 100%);
            border: 3px solid #7dd3fc;
            border-bottom: none;
            border-radius: 8px 8px 0 0;
            box-shadow: 0 5px 15px rgba(0,0,0,0.4);
            cursor: grab;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column-reverse;
            /* Motif Fen√™tres (Points) */
            background-image: radial-gradient(rgba(255,255,255,0.4) 20%, transparent 20%);
            background-size: 12px 20px;
            background-position: center 6px;
            transition: height 0.3s cubic-bezier(0.25, 0.8, 0.25, 1), transform 0.2s, box-shadow 0.2s, opacity 0.5s, filter 0.5s;
        }

        /* Highlight M√©diane Impaire (L'√âLU - Gold Glow Intense) */
        .building.highlight-odd {
            background: linear-gradient(180deg, #facc15 0%, #ca8a04 100%) !important;
            border-color: #fef08a !important; 
            box-shadow: 0 0 60px rgba(250, 204, 21, 0.9), inset 0 0 20px rgba(255,255,255,0.5) !important;
            z-index: 30;
            transform: scale(1.05);
        }
        
        /* Highlight Range (Violet) */
        .building.highlight-range {
            border-color: #a855f7 !important;
            box-shadow: 0 0 30px rgba(168, 85, 247, 0.8) !important;
            transform: scale(1.05);
            z-index: 30;
        }
        
        .building.dimmed { opacity: 0.3; filter: grayscale(0.8); }

        /* MODE MOYENNE : BRIQUES */
        .building.mean-mode {
            background: transparent !important;
            border: none !important;
            box-shadow: none !important;
            background-image: none !important;
            overflow: visible !important;
        }

        .brick {
            width: 60px;
            box-sizing: border-box;
            background: linear-gradient(180deg, #38bdf8 0%, #0284c7 100%);
            border-left: 3px solid #7dd3fc;
            border-right: 3px solid #0284c7;
            border-bottom: 1px solid rgba(255,255,255,0.3);
            /* Motif Fen√™tres SUR LES BRIQUES */
            background-image: radial-gradient(rgba(255,255,255,0.4) 20%, transparent 20%);
            background-size: 12px 20px;
            background-position: center 4px;
            position: relative;
        }
        /* Top brick */
        .building.mean-mode .brick:last-child {
            border-top: 3px solid #7dd3fc;
            border-radius: 8px 8px 0 0;
            cursor: grab;
        }
        .building.mean-mode .brick:last-child:hover {
            filter: brightness(1.15);
            border-color: #bae6fd;
        }
        
        .brick.half-brick {
            background: #a855f7; 
            border-color: #d8b4fe;
            background-image: none;
        }
        .brick.half-brick::after {
            content: '¬Ω'; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 10px; color: white; opacity: 0.9; font-weight: bold;
        }

        /* Badge Valeur */
        .value-badge {
            background: white; color: #0f172a; font-weight: 800;
            padding: 4px 12px; border-radius: 20px; font-size: 1.5rem;
            margin-bottom: 8px; box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            z-index: 30; cursor: pointer;
            transition: all 0.3s;
            border: 2px solid transparent;
        }
        .value-badge:hover { transform: scale(1.15); background-color: #f0f9ff; color: #0284c7; }
        .value-badge.highlight-neighbor {
            background-color: #fff7ed !important; color: #ea580c !important;
            border: 2px solid #fb923c !important; transform: scale(1.05);
            box-shadow: 0 0 10px rgba(251, 146, 60, 0.3);
        }
        
        /* PANNEAU MEDIANE */
        #median-tool {
            position: absolute; bottom: 24px; width: 6px; 
            background: #ec4899; z-index: 50; display: none;
            align-items: flex-start; justify-content: center;
            cursor: grab; touch-action: none;
            transition: opacity 0.3s, height 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
            transform: translateX(-50%);
            pointer-events: auto;
            border-radius: 4px 4px 0 0;
            box-shadow: 0 0 15px rgba(236, 72, 153, 0.6);
        }
        #median-tool:active { cursor: grabbing; }
        
        #tool-handle {
            position: absolute; bottom: 50%; width: 60px; height: 32px;
            background: white; border: 3px solid #ec4899; border-radius: 20px;
            display: flex; align-items: center; justify-content: space-between;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            color: #ec4899; padding: 0 8px;
        }
        /* Petit b√¢ton blanc horizontal dans la poign√©e */
        #tool-handle::after {
             content: '';
             position: absolute;
             left: 50%; top: 50%; transform: translate(-50%, -50%);
             width: 20px; height: 4px;
             background: #ec4899;
             border-radius: 2px;
             opacity: 0.3;
        }
        
        #tool-label {
            position: absolute; top: 0px; background: #ec4899; color: white;
            padding: 8px 16px; border-radius: 12px; font-weight: bold; font-size: 1.4rem;
            white-space: nowrap; box-shadow: 0 5px 20px rgba(236, 72, 153, 0.6);
            pointer-events: none; z-index: 60; text-align: center; transition: all 0.3s;
            min-width: 60px;
        }
        #tool-label::after {
            content: ''; position: absolute; bottom: -8px; left: 50%; transform: translateX(-50%);
            border-left: 8px solid transparent; border-right: 8px solid transparent; border-top: 8px solid #ec4899;
        }

        /* FLECHE D'ETENDUE (Animation) */
        #range-arrow {
            position: absolute; top: 20%; left: 0; height: 40px; pointer-events: none;
            display: none; z-index: 45;
            align-items: center;
        }
        .range-line {
            height: 4px; background: #a855f7; border-radius: 2px;
            box-shadow: 0 0 10px #a855f7;
            width: 0; /* Pour animation */
            transition: width 0.8s ease-out;
        }
        .range-tip {
            width: 0; height: 0; 
            border-top: 8px solid transparent; border-bottom: 8px solid transparent;
            opacity: 0; transition: opacity 0.3s 0.8s;
        }
        .range-tip-left { border-right: 12px solid #a855f7; margin-right: -2px; }
        .range-tip-right { border-left: 12px solid #a855f7; margin-left: -2px; }

        /* Indicateurs */
        .group-indicator {
            position: absolute; bottom: 40px; height: 2px; background: rgba(255, 255, 255, 0.3);
            display: flex; align-items: flex-end; justify-content: center;
            opacity: 0; transition: opacity 0.5s; z-index: 5;
        }
        .group-indicator::before, .group-indicator::after {
            content: ''; position: absolute; width: 2px; height: 10px;
            background: rgba(255, 255, 255, 0.3); bottom: 0;
        }
        .group-indicator::before { left: 0; } .group-indicator::after { right: 0; }
        .group-label {
            margin-bottom: 5px; font-size: 0.9rem; color: #94a3b8; font-weight: bold;
            background: rgba(15, 23, 42, 0.8); padding: 2px 8px; border-radius: 4px;
        }

        /* Sol */
        .ground {
            position: absolute; bottom: 0; width: 100%; height: 24px;
            background: #1e293b; border-top: 4px solid #334155; z-index: 10;
            box-shadow: inset 0 10px 20px rgba(0,0,0,0.5);
        }

        /* Resultat Flottant (Au dessus de tout) */
        #floating-result {
            position: absolute; top: 15%; left: 50%; transform: translateX(-50%);
            text-align: center; pointer-events: none; z-index: 60;
            opacity: 0; transition: opacity 0.5s;
            width: 80%;
        }
        #floating-result h2 {
            font-size: 2.5rem; font-weight: 800; 
            text-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }
        #floating-result p {
            color: #cbd5e1; font-size: 1.1rem; margin-top: 5px;
            text-shadow: 0 2px 5px rgba(0,0,0,0.8);
            background: rgba(15, 23, 42, 0.8); padding: 5px 12px; border-radius: 8px;
            display: inline-block;
        }

        /* Brique Volante (Drag Moyenne) */
        .flying-brick {
            position: fixed; width: 60px; height: 20px;
            background: linear-gradient(180deg, #38bdf8 0%, #0284c7 100%);
            border: 2px solid #bae6fd;
            border-top: 3px solid #bae6fd;
            z-index: 9999; pointer-events: none; opacity: 0.95;
            box-shadow: 0 15px 30px rgba(0,0,0,0.4);
            border-radius: 4px;
            background-image: radial-gradient(rgba(255,255,255,0.3) 20%, transparent 20%);
            background-size: 12px 20px;
        }
        .flying-brick.half { height: 10px; background: #a855f7; border-color: #e9d5ff; background-image: none; }
    </style>
</head>
<body class="h-screen flex flex-col">

    <div id="custom-cursor">
        <svg id="cursor-pen-svg" class="drop-shadow-lg" width="34" height="34" viewBox="0 0 34 34" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M27 7 L13 21" stroke="#38bdf8" stroke-width="6" stroke-linecap="round"/>
            <path d="M13 21 L8 32" stroke="#0f172a" stroke-width="4" stroke-linecap="round"/>
            <path d="M8 32 L12 28 L16 32 Z" fill="#111827"/>
            <circle cx="8" cy="32" r="1" fill="white"/>
        </svg>
    </div>

    <!-- HEADER FLOTTANT -->
    <div class="bg-slate-950/90 backdrop-blur border-b border-slate-800 p-2 flex flex-col sm:flex-row justify-between items-center z-50 shrink-0 gap-2">
        <div class="flex items-center gap-3 pl-2">
            <span class="text-3xl">üèôÔ∏è</span>
            <div>
                <h1 class="text-xl font-bold text-slate-100">City Stats</h1>
                <p class="text-slate-500 text-xs font-semibold tracking-wide">La ville des statistiques</p>
            </div>
        </div>

        <!-- MESSAGE INFO DANS LE HEADER (RESULTATS ICI) -->
        <div id="info-message" class="flex-1 text-center transition-all duration-500">
            <h2 id="msg-title" class="text-lg sm:text-2xl font-bold text-slate-300 drop-shadow-md">La ville est pr√™te</h2>
            <p id="msg-subtitle" class="text-xs sm:text-sm text-sky-400 font-medium hidden mt-1">...</p>
        </div>

        <div class="flex gap-2 pr-2">
            <button onclick="setMode('MEDIAN')" id="btn-mode-median" class="mode-btn active">M√âDIANE</button>
            <button onclick="setMode('MEAN')" id="btn-mode-mean" class="mode-btn">MOYENNE</button>
            <button onclick="setMode('RANGE')" id="btn-mode-range" class="mode-btn">√âTENDUE</button>
            <button onclick="setMode('BUILD')" id="btn-mode-build" class="mode-btn">CONSTRUCTEUR</button>
        </div>
    </div>

    <!-- TOOLBAR -->
    <div class="bg-slate-900 border-b border-slate-700 p-2 flex justify-between items-center z-40 shrink-0 relative">
        <div class="flex gap-2 items-center">
            <!-- DESSIN -->
            <div class="flex items-center gap-1 bg-slate-800 p-1 rounded-lg border border-slate-600">
                <button onclick="setTool('hand')" id="tool-hand" class="p-2 rounded bg-slate-600 text-white shadow"><svg class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 11.5V14m0-2.5v-6a1.5 1.5 0 113 0m-3 6a1.5 1.5 0 00-3 0v2a7.5 7.5 0 0015 0v-5a1.5 1.5 0 00-3 0m-6-3V11m0-5.5v-1a1.5 1.5 0 013 0v1m0 0V11m0-5.5a1.5 1.5 0 013 0v3m0 0V11" /></svg></button>
                <button onclick="setTool('pen')" id="tool-pen" class="p-2 rounded text-slate-400 hover:text-white"><svg class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z" /></svg></button>
                <button onclick="clearCanvas()" class="p-2 rounded text-red-400 hover:text-red-200"><svg class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg></button>
            </div>

            <!-- INSTRUCTION DISCR√àTE -->
            <div id="mini-instruction" class="text-[10px] text-slate-400 border border-slate-700 rounded px-2 py-1 hidden sm:block">
                Cliquez sur une bulle pour changer la valeur ‚Ä¢ Glissez pour ranger
            </div>

            <!-- CISEAUX (Mode Moyenne) -->
            <div id="scissors-container" class="hidden items-center gap-1 bg-purple-900/30 p-1 rounded-lg border border-purple-600/50">
                <button onclick="setTool('scissors')" id="tool-scissors" class="p-2 rounded text-purple-300 hover:bg-purple-800 hover:text-white" title="Couper en deux (0.5)">
                    <svg class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.121 14.121L19 19m-7-7l7-7m-7 7l-2.879 2.879M12 12L9.121 9.121m0 5.758a3 3 0 10-4.243 4.243 3 3 0 004.243-4.243zm0-5.758a3 3 0 10-4.243-4.243 3 3 0 004.243 4.243z" /></svg>
                </button>
            </div>
        </div>

        <!-- GENERATEUR -->
        <div class="flex items-center gap-3 bg-slate-800 p-1 pr-2 rounded-xl border border-slate-600">
            <div class="flex items-center gap-1 px-2 border-r border-slate-600">
                <button onclick="updateCount(-1)" class="w-6 h-6 rounded bg-slate-700 text-white font-bold hover:bg-slate-600">-</button>
                <span id="count-display" class="w-6 text-center font-bold text-sky-400">5</span>
                <button onclick="updateCount(1)" class="w-6 h-6 rounded bg-slate-700 text-white font-bold hover:bg-slate-600">+</button>
            </div>
            <button onclick="generateCity(true)" class="bg-indigo-600 hover:bg-indigo-500 text-white px-3 py-1 rounded font-bold text-sm shadow flex items-center gap-2">
                <svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" /></svg>
                Nouveau
            </button>
        </div>
    </div>

    <!-- MAIN -->
    <main id="main-area" class="flex-1 relative bg-slate-800 overflow-hidden w-full cursor-crosshair">
        <canvas id="drawing-canvas"></canvas>

        <div id="city-container">
            <!-- Buildings generated here -->
            <div id="group-left" class="group-indicator"><span class="group-label"></span></div>
            <div id="group-right" class="group-indicator"><span class="group-label"></span></div>
            
            <div id="median-tool">
                <div id="tool-label">?</div>
                <div id="tool-handle">
                    <!-- Fl√®ches gauche/droite -->
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M15 19l-7-7 7-7" /></svg>
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M9 5l7 7-7 7" /></svg>
                </div>
            </div>
            
            <!-- Fl√®che √âtendue -->
            <div id="range-arrow">
                <div class="range-tip range-tip-left"></div>
                <div class="range-line"></div>
                <div class="range-tip range-tip-right"></div>
            </div>
            
            <!-- Resultat Flottant (Au dessus de tout) -->
            <div id="floating-result">
                <h2 id="res-title"></h2>
                <p id="res-sub"></p>
            </div>

            <div class="ground"></div>
        </div>
    </main>

    <!-- FOOTER MEDIANE -->
    <footer id="footer-median" class="bg-slate-900 border-t border-slate-700 p-4 flex justify-center items-center gap-8 min-h-[80px]">
        <button id="btn-sort" onclick="autoSort()" class="px-6 py-2 bg-blue-600 hover:bg-blue-500 text-white rounded-full font-bold shadow-lg flex items-center gap-2 transition-all active:scale-95">
            <span>üìä</span> 1. RANGER
        </button>
        <div class="w-px h-8 bg-slate-700"></div>
        <button id="btn-median" onclick="solveMedian()" disabled class="px-6 py-2 bg-slate-700 text-slate-500 rounded-full font-bold border border-slate-600 flex items-center gap-2 cursor-not-allowed opacity-50 transition-all">
            <span id="median-icon">üîí</span> 2. SOLUTION
        </button>
    </footer>
    
    <!-- FOOTER RANGE (ETENDUE) -->
    <footer id="footer-range" class="hidden bg-slate-900 border-t border-slate-700 p-4 justify-center items-center gap-8 min-h-[80px]">
        <button onclick="autoSort()" class="px-6 py-2 bg-blue-600 hover:bg-blue-500 text-white rounded-full font-bold shadow-lg flex items-center gap-2 transition-all active:scale-95">
            <span>üìä</span> RANGER
        </button>
        <div class="text-slate-400 text-sm font-medium flex items-center gap-2">
            <span class="text-2xl">üìè</span>
            <span>S√©lectionnez le plus petit et le plus grand</span>
        </div>
    </footer>
    
    <!-- FOOTER MOYENNE -->
    <footer id="footer-mean" class="hidden bg-slate-900 border-t border-slate-700 p-4 justify-center items-center min-h-[80px]">
        <div class="text-slate-400 text-sm font-medium flex items-center gap-2">
            <span class="text-2xl">üèóÔ∏è</span>
            <span>D√©placez les briques pour √©galiser les hauteurs</span>
        </div>
    </footer>
    
    <!-- FOOTER BUILD (VIDE POUR L'INSTANT) -->
    <footer id="footer-build" class="hidden bg-slate-900 border-t border-slate-700 p-4 justify-center items-center min-h-[80px]">
        <div class="text-slate-400 text-sm font-medium">Mode Constructeur activ√©</div>
    </footer>

    <script>
        const CONFIG = {
            buildingWidth: 60,
            gap: 20,
            floorHeight: 20,
            maxFloors: 20,
            minFloors: 1
        };

        let state = {
            mode: 'MEDIAN', // 'MEDIAN', 'MEAN', 'RANGE', 'BUILD'
            count: 5,
            buildings: [], 
            isSorted: false,
            isMedianFound: false,
            isMeanFound: false,
            isRangeFound: false,
            rangeSelection: [],
            currentTool: 'hand'
        };

        // UI Refs
        const container = document.getElementById('city-container');
        const mainArea = document.getElementById('main-area');
        const medianTool = document.getElementById('median-tool');
        const toolLabel = document.getElementById('tool-label');
        const groupLeft = document.getElementById('group-left');
        const groupRight = document.getElementById('group-right');
        const ground = document.querySelector('.ground');
        const rangeArrow = document.getElementById('range-arrow');
        
        const floatRes = document.getElementById('floating-result');
        const resTitle = document.getElementById('res-title');
        const resSub = document.getElementById('res-sub');
        
        const headerInfoTitle = document.querySelector('#info-message h2');
        const headerInfoSub = document.querySelector('#info-message p');

        const footerMedian = document.getElementById('footer-median');
        const footerMean = document.getElementById('footer-mean');
        const footerRange = document.getElementById('footer-range');
        const footerBuild = document.getElementById('footer-build');
        const scissorsContainer = document.getElementById('scissors-container');
        const btnMedian = document.getElementById('btn-median');

        // --- CORE FUNCTIONS ---

        function init() {
            window.addEventListener('resize', () => { 
                resizeCanvas(); 
                repositionBuildings(); 
            });
            setTimeout(resizeCanvas, 100);
            generateCity(true); 
        }

        function setMode(mode) {
            if(state.mode === mode) return;
            state.mode = mode;
            
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            if(mode === 'MEDIAN') document.getElementById('btn-mode-median').classList.add('active');
            if(mode === 'MEAN') document.getElementById('btn-mode-mean').classList.add('active');
            if(mode === 'RANGE') document.getElementById('btn-mode-range').classList.add('active');
            if(mode === 'BUILD') document.getElementById('btn-mode-build').classList.add('active');

            footerMedian.classList.add('hidden'); footerMedian.classList.remove('flex');
            footerMean.classList.add('hidden'); footerMean.classList.remove('flex');
            footerRange.classList.add('hidden'); footerRange.classList.remove('flex');
            footerBuild.classList.add('hidden'); footerBuild.classList.remove('flex');
            scissorsContainer.classList.add('hidden'); scissorsContainer.classList.remove('flex');
            
            if (mode === 'MEDIAN') {
                footerMedian.classList.remove('hidden'); footerMedian.classList.add('flex');
                showMessage("La ville est pr√™te");
                document.getElementById('mini-instruction').innerText = "Cliquez sur une bulle pour changer la valeur ‚Ä¢ Glissez pour ranger";
            } else if (mode === 'MEAN') {
                footerMean.classList.remove('hidden'); footerMean.classList.add('flex');
                scissorsContainer.classList.remove('hidden'); scissorsContainer.classList.add('flex');
                showMessage("√âgalisez les hauteurs");
                document.getElementById('mini-instruction').innerText = "D√©placez les briques pour √©galiser";
            } else if (mode === 'RANGE') {
                footerRange.classList.remove('hidden'); footerRange.classList.add('flex');
                showMessage("Calculez l'√©tendue");
                document.getElementById('mini-instruction').innerText = "Cliquez sur Min et Max";
                state.rangeSelection = [];
            } else if (mode === 'BUILD') {
                footerBuild.classList.remove('hidden'); footerBuild.classList.add('flex');
                showMessage("Mode Constructeur");
            }
            
            setTool('hand');
            refreshCityFromState();
        }

        function updateCount(delta) {
            let n = state.count + delta;
            if (n < 2) n = 2;
            if (n > 12) n = 12;
            state.count = n;
            document.getElementById('count-display').innerText = n;
            generateCity(true);
        }

        function generateCity(randomize = false) {
            clearCanvas();
            state.isSorted = false;
            state.isMedianFound = false;
            state.isMeanFound = false;
            state.isRangeFound = false;
            state.rangeSelection = [];
            
            if (randomize) {
                state.buildings = [];
                for(let i=0; i<state.count; i++) {
                    let val = Math.floor(Math.random() * 19) + 2; 
                    state.buildings.push({ id: i, value: val, originalId: i });
                }
                
                // Adjust for Mean Mode (Result should be Integer)
                let sum = state.buildings.reduce((a,b)=>a+b.value, 0);
                while (sum % state.count !== 0) {
                    state.buildings[state.count-1].value += 1;
                    sum++;
                }
            }

            refreshCityFromState();
            if(randomize) playSound('pop');
        }

        function refreshCityFromState() {
            container.innerHTML = '';
            container.appendChild(medianTool);
            container.appendChild(groupLeft);
            container.appendChild(groupRight);
            container.appendChild(rangeArrow);
            container.appendChild(floatRes);
            container.appendChild(ground);

            medianTool.style.display = 'none';
            medianTool.style.height = '380px';
            toolLabel.style.opacity = '1';
            toolLabel.innerText = "?";
            toolLabel.style.minWidth = "60px";
            groupLeft.style.opacity = '0';
            groupRight.style.opacity = '0';
            floatRes.style.opacity = '0';
            rangeArrow.style.display = 'none';
            
            if(state.mode === 'MEAN') container.classList.add('mode-mean');
            else container.classList.remove('mode-mean');
            
            if(state.mode === 'BUILD') {
                // Clear buildings for build mode (just slots in future)
                container.innerHTML += '<div class="absolute top-1/2 left-1/2 -translate-x-1/2 text-slate-500">Zone de construction (A venir)</div>';
                return;
            }

            if(state.mode === 'MEAN') {
                state.buildings.sort((a,b) => a.originalId - b.originalId);
            }

            state.buildings.forEach((bData) => {
                createBuildingDOM(bData);
            });
            
            repositionBuildings();
            if(state.mode === 'MEDIAN') checkSorted();
        }

        function createBuildingDOM(bObj) {
            const wrapper = document.createElement('div');
            wrapper.className = 'building-wrapper';
            
            const badge = document.createElement('div');
            badge.className = 'value-badge';
            badge.innerText = bObj.value;
            
            const building = document.createElement('div');
            
            if (state.mode === 'MEDIAN') {
                building.className = 'building'; 
                building.style.height = (bObj.value * CONFIG.floorHeight) + 'px';
                
                wrapper.addEventListener('mousedown', (e) => startDragBuilding(e, wrapper, bObj.id));
                wrapper.addEventListener('touchstart', (e) => startDragBuilding(e, wrapper, bObj.id), {passive: false});
                badge.addEventListener('mousedown', (e) => { e.stopPropagation(); editBuilding(bObj.id); });
                badge.addEventListener('touchstart', (e) => { e.stopPropagation(); editBuilding(bObj.id); });
                building.addEventListener('click', () => trySelectMedian(bObj.id));
            } 
            else if (state.mode === 'MEAN') {
                building.className = 'building mean-mode'; 
                renderBricks(building, bObj.value);
                building.style.height = 'auto';
                
                building.addEventListener('mousedown', (e) => handleBrickInteraction(e, bObj.id));
                building.addEventListener('touchstart', (e) => handleBrickInteraction(e, bObj.id), {passive: false});
                badge.addEventListener('mousedown', (e) => { e.stopPropagation(); editBuilding(bObj.id); });
            }
            else if (state.mode === 'RANGE') {
                building.className = 'building'; 
                building.style.height = (bObj.value * CONFIG.floorHeight) + 'px';
                badge.addEventListener('mousedown', (e) => { e.stopPropagation(); editBuilding(bObj.id); });
                building.addEventListener('click', () => selectRangeBuilding(bObj.id));
            }

            wrapper.appendChild(badge);
            wrapper.appendChild(building);
            container.insertBefore(wrapper, medianTool);

            bObj.element = wrapper;
            bObj.buildingEl = building;
            bObj.badgeEl = badge;
        }

        function renderBricks(container, value) {
            container.innerHTML = '';
            let count = Math.floor(value);
            let hasHalf = (value % 1 !== 0);
            
            for(let i=0; i<count; i++) {
                let b = document.createElement('div');
                b.className = 'brick';
                b.style.height = CONFIG.floorHeight + 'px';
                container.appendChild(b);
            }
            if(hasHalf) {
                let b = document.createElement('div');
                b.className = 'brick half-brick';
                b.style.height = (CONFIG.floorHeight / 2) + 'px';
                container.appendChild(b);
            }
        }

        function repositionBuildings(skipItem = null) {
            const totalW = (state.count * CONFIG.buildingWidth) + ((state.count - 1) * CONFIG.gap);
            const startX = (container.offsetWidth - totalW) / 2;

            let list = state.buildings;
            if (state.mode === 'MEDIAN' && state.isSorted) {
                list.sort((a,b) => a.value - b.value);
            }
            if (state.mode === 'MEAN' || state.mode === 'RANGE') {
                if(state.isSorted && state.mode === 'RANGE') list.sort((a,b) => a.value - b.value);
                else if(state.mode === 'MEAN') list.sort((a,b) => a.originalId - b.originalId);
            }

            list.forEach((b, i) => {
                if (b === skipItem) return;
                const x = startX + i * (CONFIG.buildingWidth + CONFIG.gap);
                if(b.element) {
                    b.element.style.left = x + 'px';
                    b.element.style.transform = '';
                }
            });
        }

        function showMessage(title, sub = "", color = "text-slate-300") {
            headerInfoTitle.innerHTML = title;
            headerInfoTitle.className = "text-lg sm:text-2xl font-bold drop-shadow-md " + color;
            if(sub) {
                headerInfoSub.innerHTML = sub;
                headerInfoSub.classList.remove('hidden');
            } else {
                headerInfoSub.classList.add('hidden');
            }
        }
        
        function showFloatingResult(title, sub, colorClass = "text-yellow-400") {
            resTitle.innerText = title;
            resTitle.className = "font-extrabold text-4xl " + colorClass; // Class for color
            resSub.innerText = sub;
            floatRes.style.opacity = '1';
        }

        // --- MEDIAN LOGIC ---

        function checkSorted() {
            if(state.mode !== 'MEDIAN') return;
            
            let asc = true, desc = true;
            for(let i=0; i<state.buildings.length-1; i++) {
                if (state.buildings[i].value > state.buildings[i+1].value) asc = false;
                if (state.buildings[i].value < state.buildings[i+1].value) desc = false;
            }
            state.isSorted = (asc || desc);

            const icon = document.getElementById('median-icon');
            
            if (state.isSorted) {
                btnMedian.disabled = false;
                btnMedian.classList.remove('bg-slate-700', 'text-slate-500', 'cursor-not-allowed', 'opacity-50');
                btnMedian.classList.add('bg-pink-600', 'text-white', 'cursor-pointer', 'shadow-lg');
                icon.innerText = "üéØ";
                if(!state.isMedianFound) {
                    showMessage("La ville est rang√©e !");
                    medianTool.style.display = 'flex';
                    // Calculate height taller than tallest building
                    const maxVal = Math.max(...state.buildings.map(b => b.value));
                    const toolH = (maxVal * CONFIG.floorHeight) + 60;
                    medianTool.style.height = toolH + 'px';
                    
                    medianTool.style.left = '50px'; 
                }
            } else {
                btnMedian.disabled = true;
                btnMedian.classList.add('bg-slate-700', 'text-slate-500', 'cursor-not-allowed', 'opacity-50');
                btnMedian.classList.remove('bg-pink-600', 'text-white', 'cursor-pointer', 'shadow-lg');
                icon.innerText = "üîí";
                // Pas de message sur le plateau
                medianTool.style.display = 'none';
            }
        }

        function solveMedian() {
            if (state.isMedianFound) return;
            state.isMedianFound = true;
            playSound('ding');
            
            const n = state.buildings.length;
            const mid = Math.floor(n/2);
            const isOdd = (n % 2 !== 0);
            
            const totalW = (state.count * CONFIG.buildingWidth) + ((state.count - 1) * CONFIG.gap);
            const startX = (container.offsetWidth - totalW) / 2;

            if (isOdd) {
                const target = state.buildings[mid];
                medianTool.style.display = 'none'; 
                
                target.buildingEl.classList.add('highlight-odd');
                target.badgeEl.style.backgroundColor = '#facc15';
                target.badgeEl.style.transform = 'scale(1.3)';
                target.badgeEl.style.border = '3px solid white';
                
                state.buildings.forEach((b,i) => { if(i!==mid) b.buildingEl.classList.add('dimmed'); });
                
                showFloatingResult(`M√©diane = ${target.value}`, `Il y a autant de valeurs (${mid}) avant et apr√®s.`, "text-yellow-400");
            } else {
                const b1 = state.buildings[mid-1];
                const b2 = state.buildings[mid];
                const med = (b1.value + b2.value) / 2;
                
                medianTool.style.display = 'flex';
                medianTool.style.backgroundColor = '#ec4899';
                medianTool.style.pointerEvents = 'none';
                document.getElementById('tool-label').innerText = med;
                
                const centerX = startX + (mid-1)*(CONFIG.buildingWidth+CONFIG.gap) + CONFIG.buildingWidth + CONFIG.gap/2;
                medianTool.style.left = centerX + 'px';
                
                // Adjust height for pair case (also taller)
                const maxVal = Math.max(...state.buildings.map(b => b.value));
                medianTool.style.height = ((maxVal * CONFIG.floorHeight) + 80) + 'px';
                document.getElementById('tool-label').style.minWidth = "120px";
                
                b1.badgeEl.classList.add('highlight-neighbor');
                b2.badgeEl.classList.add('highlight-neighbor');
                state.buildings.forEach(b => b.buildingEl.classList.add('dimmed'));
                
                showFloatingResult(`M√©diane = ${med}`, `(${b1.value} + ${b2.value}) √∑ 2 = ${med}`, "text-pink-400");
            }
            
            btnMedian.disabled = true;
            btnMedian.classList.add('opacity-50', 'cursor-not-allowed');
        }

        // --- MEAN MODE LOGIC ---

        function handleBrickInteraction(e, colId) {
            if (state.mode !== 'MEAN' || state.isMeanFound) return;
            
            // Logic Ciseaux : Coupe la brique du haut en deux si elle est enti√®re
            if (state.currentTool === 'scissors') {
                const bObj = state.buildings.find(b => b.id === colId);
                // On peut couper seulement si > 0 et si c'est un entier
                if (bObj.value > 0 && bObj.value % 1 === 0) {
                    playSound('pop'); 
                    // Visual feedback: on peut "marquer" l'immeuble comme coup√© temporairement ?
                    // Simplification: le mode drag d√©tectera si on prend un demi.
                    // Pour l'instant, on va juste dire que le ciseau "pr√©pare" le drag.
                    // Mais pour faire simple : si on clique ciseau, on ne fait rien visuellement 
                    // sauf si on veut afficher "brique coup√©e". 
                    // L'utilisateur comprendra en draggant qu'il prend une moiti√©.
                    // Pour feedback: on fait clignoter la brique du haut en violet
                    if(bObj.buildingEl.lastChild) {
                        bObj.buildingEl.lastChild.classList.add('brick-cut-effect');
                        setTimeout(()=>bObj.buildingEl.lastChild.classList.remove('brick-cut-effect'), 500);
                    }
                }
            } else if (state.currentTool === 'hand') {
                startDragBrick(e, colId);
            }
        }

        let draggedBrick = null;
        
        function startDragBrick(e, colId) {
            e.preventDefault();
            const bObj = state.buildings.find(b => b.id === colId);
            if (bObj.value <= 0) return;

            let amount = 1;
            // Rule: Take half if it is a half-brick OR if using Scissors on a full brick
            if (bObj.value % 1 !== 0 || state.currentTool === 'scissors') {
                amount = 0.5;
            }
            
            const ghost = document.createElement('div');
            ghost.className = amount === 0.5 ? 'flying-brick half' : 'flying-brick';
            document.body.appendChild(ghost);
            
            // Masquer la brique du haut
            if(bObj.buildingEl.lastChild) bObj.buildingEl.lastChild.style.opacity = '0';

            draggedBrick = {
                sourceId: colId,
                amount: amount,
                element: ghost,
                startX: e.touches ? e.touches[0].clientX : e.clientX,
                startY: e.touches ? e.touches[0].clientY : e.clientY
            };
            
            updateGhostPos(e.touches ? e.touches[0] : e);
            document.addEventListener('mousemove', onBrickDrag);
            document.addEventListener('touchmove', onBrickDrag, {passive: false});
            document.addEventListener('mouseup', endBrickDrag);
            document.addEventListener('touchend', endBrickDrag);
        }

        function onBrickDrag(e) {
            if(!draggedBrick) return;
            e.preventDefault();
            updateGhostPos(e.touches ? e.touches[0] : e);
        }

        function updateGhostPos(e) {
            draggedBrick.element.style.left = (e.clientX - 30) + 'px';
            draggedBrick.element.style.top = (e.clientY - 10) + 'px';
        }

        function endBrickDrag(e) {
            if(!draggedBrick) return;
            
            const clientX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
            const containerRect = container.getBoundingClientRect();
            
            const totalW = (state.count * CONFIG.buildingWidth) + ((state.count - 1) * CONFIG.gap);
            const startX = (containerRect.width - totalW) / 2;
            const relativeX = clientX - containerRect.left - startX;
            
            let targetIdx = Math.floor((relativeX + CONFIG.gap/2) / (CONFIG.buildingWidth + CONFIG.gap));
            
            let success = false;
            if (targetIdx >= 0 && targetIdx < state.count) {
                // In Mean mode, visual index matches array index because we sorted by original ID
                const targetObj = state.buildings[targetIdx];
                const sourceObj = state.buildings.find(b => b.id === draggedBrick.sourceId);
                
                if (targetObj && targetObj.id !== draggedBrick.sourceId) {
                    if (targetObj.value + draggedBrick.amount <= CONFIG.maxFloors) {
                        sourceObj.value -= draggedBrick.amount;
                        targetObj.value += draggedBrick.amount;
                        
                        updateBuildingVisuals(sourceObj);
                        updateBuildingVisuals(targetObj);
                        playSound('pop');
                        checkMeanWin();
                        success = true;
                    }
                }
            }

            if (!success) {
                const sourceObj = state.buildings.find(b => b.id === draggedBrick.sourceId);
                updateBuildingVisuals(sourceObj); // Restore visibility via re-render
            }

            draggedBrick.element.remove();
            draggedBrick = null;
            document.removeEventListener('mousemove', onBrickDrag);
            document.removeEventListener('touchmove', onBrickDrag);
            document.removeEventListener('mouseup', endBrickDrag);
            document.removeEventListener('touchend', endBrickDrag);
        }

        function updateBuildingVisuals(bObj) {
            bObj.badgeEl.innerText = bObj.value;
            renderBricks(bObj.buildingEl, bObj.value);
        }

        function checkMeanWin() {
            const first = state.buildings[0].value;
            const allEqual = state.buildings.every(b => Math.abs(b.value - first) < 0.001);
            
            if (allEqual) {
                state.isMeanFound = true;
                playSound('ding');
                showFloatingResult(`Moyenne = ${first}`, "Toutes les barres sont √©galis√©es !", "text-green-400");
                state.buildings.forEach(b => {
                    b.badgeEl.style.backgroundColor = '#22c55e';
                    b.badgeEl.style.color = 'white';
                });
            }
        }

        // --- RANGE MODE LOGIC ---
        function selectRangeBuilding(id) {
            if(state.mode !== 'RANGE' || state.isRangeFound) return;
            
            const b = state.buildings.find(x => x.id === id);
            
            if(state.rangeSelection.includes(id)) {
                state.rangeSelection = state.rangeSelection.filter(sid => sid !== id);
                b.buildingEl.classList.remove('selected-range');
            } else {
                if(state.rangeSelection.length < 2) {
                    state.rangeSelection.push(id);
                    b.buildingEl.classList.add('selected-range');
                    playSound('pop');
                    
                    if(state.rangeSelection.length === 2) {
                        checkRange();
                    }
                }
            }
        }
        
        function checkRange() {
            const b1 = state.buildings.find(x => x.id === state.rangeSelection[0]);
            const b2 = state.buildings.find(x => x.id === state.rangeSelection[1]);
            
            const values = state.buildings.map(b => b.value);
            const min = Math.min(...values);
            const max = Math.max(...values);
            
            const v1 = b1.value;
            const v2 = b2.value;
            
            if ( (v1 === min && v2 === max) || (v1 === max && v2 === min) ) {
                // WIN
                state.isRangeFound = true;
                playSound('ding');
                const range = max - min;
                showFloatingResult(`√âtendue = ${range}`, `Max (${max}) - Min (${min}) = ${range}`, "text-violet-400");
                
                [b1, b2].forEach(b => {
                    b.buildingEl.classList.remove('selected-range');
                    b.buildingEl.classList.add('highlight-range');
                });
                
                // Draw Arrow (Animated Width)
                const rect1 = b1.element.getBoundingClientRect();
                const rect2 = b2.element.getBoundingClientRect();
                const containerRect = container.getBoundingClientRect();
                
                const x1 = rect1.left + rect1.width/2 - containerRect.left;
                const x2 = rect2.left + rect2.width/2 - containerRect.left;
                
                const left = Math.min(x1, x2);
                const width = Math.abs(x1 - x2);
                
                rangeArrow.style.left = left + 'px';
                rangeArrow.style.display = 'flex';
                // Animation width
                rangeArrow.querySelector('.range-line').style.width = '0px';
                rangeArrow.querySelector('.range-tip-right').style.opacity = '0';
                
                requestAnimationFrame(() => {
                   rangeArrow.querySelector('.range-line').style.width = width + 'px';
                   rangeArrow.querySelector('.range-tip-right').style.opacity = '1';
                });

                state.buildings.forEach(b => {
                    if(b.id !== b1.id && b.id !== b2.id) b.buildingEl.classList.add('dimmed');
                });
            } else {
                setTimeout(() => {
                    state.rangeSelection = [];
                    [b1, b2].forEach(b => b.buildingEl.classList.remove('selected-range'));
                    showMessage("Rat√© ! Cherchez le plus petit et le plus grand.");
                }, 500);
            }
        }

        // --- EVENTS ---
        
        function editBuilding(id) {
            const b = state.buildings.find(x => x.id === id);
            let v = prompt("Hauteur :", b.value);
            if(v) { 
                v = parseFloat(v); 
                if(!isNaN(v) && v>0 && v<=CONFIG.maxFloors) { 
                    v = Math.round(v * 2) / 2;
                    b.value=v; 
                    if(state.mode === 'MEDIAN') {
                        b.badgeEl.innerText = v;
                        b.buildingEl.style.height = (v * CONFIG.floorHeight) + 'px';
                        state.isMedianFound=false; 
                        medianTool.style.display='none';
                        floatRes.style.opacity='0';
                        checkSorted();
                    } else if(state.mode === 'MEAN') {
                        updateBuildingVisuals(b);
                        checkMeanWin();
                    } else {
                         b.badgeEl.innerText = v;
                         b.buildingEl.style.height = (v * CONFIG.floorHeight) + 'px';
                         if(state.mode === 'RANGE') {
                             state.rangeSelection = [];
                             state.buildings.forEach(b=>b.buildingEl.classList.remove('selected-range', 'dimmed', 'highlight-range'));
                             rangeArrow.style.display = 'none';
                             state.isRangeFound = false;
                         }
                    }
                }
            }
        }

        function startDragBuilding(e, wrapper, id) {
            if (state.currentTool !== 'hand' || state.isMedianFound || (state.mode !== 'MEDIAN' && state.mode !== 'RANGE')) return;
            e.preventDefault();
            
            const bObj = state.buildings.find(b => b.id === id);
            wrapper.classList.add('is-dragging');
            
            const onDrag = (e) => {
                e.preventDefault();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const containerRect = container.getBoundingClientRect();
                const mouseRelativeX = clientX - containerRect.left;
                const totalW = (state.count * CONFIG.buildingWidth) + ((state.count - 1) * CONFIG.gap);
                const startX = (containerRect.width - totalW) / 2;
                
                wrapper.style.left = (mouseRelativeX - CONFIG.buildingWidth/2) + 'px';
                
                let newIndex = Math.floor((mouseRelativeX - startX + CONFIG.gap/2) / (CONFIG.buildingWidth + CONFIG.gap));
                if (newIndex < 0) newIndex = 0; if (newIndex >= state.count) newIndex = state.count - 1;

                const oldIndex = state.buildings.indexOf(bObj);
                if (newIndex !== oldIndex) {
                    state.buildings.splice(oldIndex, 1);
                    state.buildings.splice(newIndex, 0, bObj);
                    repositionBuildings(bObj);
                    playSound('pop');
                }
            };
            
            const stopDrag = () => {
                wrapper.classList.remove('is-dragging');
                repositionBuildings();
                if(state.mode === 'MEDIAN') checkSorted();
                document.removeEventListener('mousemove', onDrag);
                document.removeEventListener('touchmove', onDrag);
                document.removeEventListener('mouseup', stopDrag);
                document.removeEventListener('touchend', stopDrag);
            };
            
            document.addEventListener('mousemove', onDrag);
            document.addEventListener('touchmove', onDrag, {passive: false});
            document.addEventListener('mouseup', stopDrag);
            document.addEventListener('touchend', stopDrag);
        }

        function autoSort() {
            state.isSorted = true; // Force sorted state
            state.buildings.sort((a,b)=>a.value-b.value);
            repositionBuildings();
            playSound('slide');
            if(state.mode === 'MEDIAN') checkSorted();
        }
        
        function trySelectMedian(id) {
            if(state.mode !== 'MEDIAN') return;
            const n = state.buildings.length;
            if(n%2===0 || !state.isSorted) return;
            const mid = Math.floor(n/2);
            if(state.buildings[mid].id === id) solveMedian();
            else playSound('lock');
        }

        // --- MEDIAN TOOL DRAG ---
        let isToolDragging = false;
        const mt = document.getElementById('median-tool');
        mt.addEventListener('mousedown', startToolDrag);
        mt.addEventListener('touchstart', startToolDrag, {passive: false});

        function startToolDrag(e) {
            if(state.isMedianFound || state.mode !== 'MEDIAN') return;
            e.preventDefault(); e.stopPropagation();
            isToolDragging = true;
            document.addEventListener('mousemove', onToolDrag);
            document.addEventListener('touchmove', onToolDrag, {passive: false});
            document.addEventListener('mouseup', stopToolDrag);
            document.addEventListener('touchend', stopToolDrag);
        }
        function onToolDrag(e) {
            if(!isToolDragging) return;
            const cx = e.touches ? e.touches[0].clientX : e.clientX;
            const r = container.getBoundingClientRect();
            let x = cx - r.left;
            if(x < 0) x = 0; if(x > r.width) x = r.width;
            mt.style.left = x + 'px';
            
            const snap = getClosestSnap(x);
            const tl = document.getElementById('tool-label');
            if(snap) tl.innerText = snap.val;
        }
        function stopToolDrag(e) {
            isToolDragging = false;
            const r = mt.getBoundingClientRect();
            const tx = r.left + r.width/2 - container.getBoundingClientRect().left;
            const snap = getClosestSnap(tx);
            if(snap && snap.isMedian) {
                mt.style.left = snap.x + 'px';
                solveMedian();
            } else {
                document.getElementById('tool-label').innerText = "?";
            }
            document.removeEventListener('mousemove', onToolDrag);
            document.removeEventListener('touchmove', onToolDrag);
            document.removeEventListener('mouseup', stopToolDrag);
            document.removeEventListener('touchend', stopToolDrag);
        }

        function getClosestSnap(x) {
            const totalW = (state.count * CONFIG.buildingWidth) + ((state.count - 1) * CONFIG.gap);
            const startX = (container.offsetWidth - totalW) / 2;
            let best = null, minD = 9999;
            const n = state.buildings.length;
            const isOdd = n%2!==0;
            const mid = Math.floor(n/2);

            state.buildings.forEach((b, i) => {
                const bx = startX + i * (CONFIG.buildingWidth + CONFIG.gap) + CONFIG.buildingWidth/2;
                const d = Math.abs(x - bx);
                if(d < 30 && d < minD) {
                    minD = d;
                    best = { x:bx, type:'building', val:b.value, isMedian:(isOdd && i===mid) };
                }
            });
            for(let i=0; i<n-1; i++) {
                const gx = startX + i * (CONFIG.buildingWidth + CONFIG.gap) + CONFIG.buildingWidth + CONFIG.gap/2;
                const d = Math.abs(x - gx);
                if(d < 30 && d < minD) {
                    minD = d;
                    const avg = (state.buildings[i].value + state.buildings[i+1].value)/2;
                    best = { x:gx, type:'gap', val:avg, isMedian:(!isOdd && i===mid-1) };
                }
            }
            return best;
        }

        // --- DRAWING & TOOLS ---
        const canvas = document.getElementById('drawing-canvas');
        const ctx = canvas.getContext('2d');
        const cursorDiv = document.getElementById('custom-cursor');
        let isDrawing = false, lastX=0, lastY=0;

        function resizeCanvas() {
            const rect = document.getElementById('city-container').getBoundingClientRect();
            canvas.width = rect.width; canvas.height = rect.height;
            if(state.currentTool === 'pen') {
                ctx.globalCompositeOperation = 'source-over'; ctx.strokeStyle = '#38bdf8';
                ctx.lineWidth = 4; ctx.lineCap = 'round';
            }
        }

        function setTool(tool) {
            state.currentTool = tool;
            const h = document.getElementById('tool-hand'), p = document.getElementById('tool-pen'), s = document.getElementById('tool-scissors');
            [h,p,s].forEach(el => { if(el) el.className = "p-2 rounded text-slate-400 hover:text-white"; });
            canvas.style.pointerEvents = 'none'; document.body.classList.remove('hide-cursor'); cursorDiv.style.display = 'none';
            mt.style.pointerEvents = 'auto';

            if(tool === 'hand') h.className = "p-2 rounded bg-slate-600 text-white shadow";
            else if(tool === 'pen') {
                p.className = "p-2 rounded bg-slate-600 text-white shadow";
                canvas.style.pointerEvents = 'auto'; document.body.classList.add('hide-cursor'); cursorDiv.style.display = 'block';
                mt.style.pointerEvents = 'none';
            } else if(tool === 'scissors') s.className = "p-2 rounded bg-purple-600 text-white shadow";
        }

        function clearCanvas() { ctx.clearRect(0,0,canvas.width,canvas.height); }
        function getPos(e) { const r = canvas.getBoundingClientRect(); return { x: (e.touches?e.touches[0].clientX:e.clientX)-r.left, y: (e.touches?e.touches[0].clientY:e.clientY)-r.top }; }
        function startDraw(e) { if(state.currentTool!=='pen')return; isDrawing=true; const p=getPos(e); lastX=p.x; lastY=p.y; }
        function draw(e) { if(!isDrawing)return; e.preventDefault(); const p=getPos(e); ctx.beginPath(); ctx.moveTo(lastX,lastY); ctx.lineTo(p.x,p.y); ctx.stroke(); lastX=p.x; lastY=p.y; cursorDiv.style.left = (e.touches?e.touches[0].clientX:e.clientX) + 'px'; cursorDiv.style.top = (e.touches?e.touches[0].clientY:e.clientY) + 'px'; }
        function endDraw() { isDrawing=false; }
        
        canvas.addEventListener('mousedown', startDraw); canvas.addEventListener('mousemove', draw); canvas.addEventListener('mouseup', endDraw);
        canvas.addEventListener('touchstart', startDraw, {passive:false}); canvas.addEventListener('touchmove', draw, {passive:false}); canvas.addEventListener('touchend', endDraw);

        // --- AUDIO ---
        const audioCtx = new (window.AudioContext||window.webkitAudioContext)();
        function playSound(type) {
            if(audioCtx.state==='suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator(); const g = audioCtx.createGain();
            osc.connect(g); g.connect(audioCtx.destination);
            if(type==='pop'){ osc.frequency.setValueAtTime(400,audioCtx.currentTime); g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime+0.1); }
            else if(type==='ding'){ osc.type='triangle'; osc.frequency.setValueAtTime(600,audioCtx.currentTime); g.gain.linearRampToValueAtTime(0, audioCtx.currentTime+0.5); }
            else if(type==='slide'){ osc.frequency.linearRampToValueAtTime(200, audioCtx.currentTime+0.3); }
            osc.start(); osc.stop(audioCtx.currentTime+(type==='ding'?0.5:0.1));
        }

        init();
    </script>
</body>
</html>