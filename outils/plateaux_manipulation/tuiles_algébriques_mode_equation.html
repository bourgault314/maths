<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Calcul Littéral - Équations (Balance)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css">
    <style>
        body { font-family: 'Fredoka', sans-serif; background-color: #f0f9ff; overflow: hidden; user-select: none; }
        
        /* --- TUILES --- */
        .token {
            position: absolute; display: flex; align-items: center; justify-content: center;
            font-weight: 600; color: white; box-shadow: 0 4px 6px rgba(0,0,0,0.25);
            cursor: grab; transition: transform 0.1s, background-color 0.5s; z-index: 10;
            font-family: 'Times New Roman', serif; font-style: italic; font-size: 1.2rem;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3); transform-origin: 0 0;
        }
        .token.dragging { transition: none !important; z-index: 1000 !important; cursor: grabbing; box-shadow: 0 10px 20px rgba(0,0,0,0.4); }
        .token.animating { transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1), left 0.5s ease-in-out, top 0.5s ease-in-out, background-color 0.5s !important; }
        .vanish { animation: vanish 0.45s ease-in forwards; pointer-events: none; }
        @keyframes vanish { 0% { transform: scale(1); opacity: 1; } 100% { transform: scale(0.1); opacity: 0; } }

        .token.green { background: radial-gradient(circle at 30% 30%, #4ade80, #16a34a); border: 2px solid #14532d; }
        .token.red { background: radial-gradient(circle at 30% 30%, #f87171, #dc2626); border: 2px solid #7f1d1d; }
        .token.is-zero { background: #9ca3af !important; opacity: 0.6; border: 2px solid #6b7280; box-shadow: none; z-index: 5; color: rgba(255,255,255,0.5); }
        .token.fading-gray { background: #9ca3af !important; border-color: #6b7280 !important; box-shadow: none !important; filter: grayscale(1); }

        .token.type-unit { width: 40px; height: 40px; border-radius: 4px; font-style: normal; }
        .token.type-x { width: 90px; height: 40px; border-radius: 4px; }
        .token.type-x2 { width: 90px; height: 90px; border-radius: 4px; }

        .zero-badge { position: absolute; font-size: 2rem; font-weight: 800; color: #374151; pointer-events: none; z-index: 20; text-shadow: 0 0 10px rgba(255,255,255,1); animation: popIn 0.3s; }
        @keyframes popIn { from { transform: scale(0); opacity: 0; } to { transform: scale(1); opacity: 1; } }

        #board-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; cursor: grab; padding-bottom: 100px; /* Space for bottom bar */ }
        #board-container.panning { cursor: grabbing; }
        #board-world { position: absolute; top: 0; left: 0; transform-origin: 0 0; width: 0; height: 0; }
        
        /* AXE CENTRAL */
        #equation-divider {
            position: absolute; top: -5000px; bottom: -5000px; left: 0; width: 6px;
            background-color: #e2e8f0; border-left: 2px dashed #94a3b8; border-right: 2px dashed #94a3b8;
            transform: translateX(-3px); pointer-events: none; z-index: 0;
        }

        /* BOTTOM BAR */
        #bottom-bar {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 90px;
            background: white; border-top: 1px solid #cbd5e1;
            display: flex; justify-content: space-between; align-items: center;
            padding: 0 20px; z-index: 50; box-shadow: 0 -4px 6px -1px rgba(0, 0, 0, 0.1);
        }
        .deck-section { display: flex; align-items: center; gap: 10px; padding: 5px 15px; border-radius: 12px; background: #f8fafc; border: 1px solid #e2e8f0; }
        .deck-label { font-size: 0.75rem; font-weight: bold; color: #64748b; text-transform: uppercase; margin-bottom: 4px; text-align: center; }

        .tile-btn { position: relative; background: transparent; border: none; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: transform 0.1s; }
        .tile-btn:active { transform: scale(0.9); } .tile-btn:hover { transform: translateY(-2px); }
        .preview-shape { display: flex; align-items: center; justify-content: center; border-radius: 2px; color: white; font-weight: bold; font-family: 'Times New Roman', serif; font-style: italic; text-shadow: 0 1px 1px rgba(0,0,0,0.3); box-shadow: 0 2px 4px rgba(0,0,0,0.2); pointer-events: none; }
        .ps-green { background: #4ade80; border: 1px solid #15803d; } .ps-red { background: #f87171; border: 1px solid #b91c1c; }
        
        .toggle-mode { background-color: #fef08a; color: #854d0e; border: 1px solid #eab308; }
        .toggle-mode.solve { background-color: #dcfce7; color: #166534; border-color: #22c55e; }

        /* EQUATION VISIBILITY */
        .equation-hidden { opacity: 0; pointer-events: none; }
        .equation-blur { filter: blur(5px); opacity: 0.5; }
    </style>
</head>
<body class="h-screen w-screen flex flex-col overflow-hidden">

    <!-- HEADER -->
    <header class="bg-white p-2 shadow-md z-30 flex flex-wrap items-center gap-4 shrink-0 justify-between">
        
        <!-- GAUCHE : ACTIONS -->
        <div class="flex items-center gap-2">
            <button onclick="app.undo()" class="bg-blue-100 text-blue-600 hover:bg-blue-200 p-2 rounded-lg font-bold border border-blue-200 shadow-sm" title="Annuler">
                <svg class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6" /></svg>
            </button>
            <button onclick="app.resetBoard()" class="bg-rose-100 text-rose-600 hover:bg-rose-200 p-2 rounded-lg font-bold border border-rose-200 shadow-sm" title="Tout effacer">
                <svg class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>
            </button>
            <div class="h-8 w-px bg-slate-200 mx-1"></div>
            <button id="btn-mode" onclick="app.toggleMode()" class="toggle-mode px-4 py-2 rounded-lg font-bold text-sm transition flex items-center gap-2 shadow-sm">
                <span id="mode-text">Phase 1 : Poser l'équation</span>
            </button>
        </div>

        <!-- CENTRE : EQUATION -->
        <div class="flex-1 flex flex-col items-center justify-center px-4">
            <div class="flex items-center gap-2 bg-slate-50 px-6 py-2 rounded-full border border-slate-200 shadow-inner">
                <div id="equation-display" class="text-3xl font-bold text-slate-700 tracking-tight font-mono transition-all duration-300">0 = 0</div>
                <button onclick="app.toggleEquationVisibility()" class="ml-2 text-slate-400 hover:text-slate-600 focus:outline-none">
                    <svg id="eye-icon" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
                    </svg>
                </button>
            </div>
        </div>

        <!-- DROITE : OUTILS -->
        <div class="flex items-center gap-2">
            <button onclick="app.organizeBoard()" class="px-3 py-1 bg-white border border-slate-300 rounded text-xs font-bold text-slate-600 shadow-sm hover:bg-slate-50">Ranger</button>
            <button onclick="app.autoSimplify()" class="px-3 py-1 bg-white border border-amber-300 rounded text-xs font-bold text-amber-700 shadow-sm hover:bg-amber-50">Simplifier</button>
        </div>
    </header>

    <!-- PLATEAU -->
    <main id="board" class="flex-1 relative bg-white overflow-hidden cursor-move">
        <div class="absolute inset-0 opacity-10 pointer-events-none" style="background-image: linear-gradient(#94a3b8 1px, transparent 1px), linear-gradient(90deg, #94a3b8 1px, transparent 1px); background-size: 40px 40px;"></div>
        <div id="board-container">
            <div id="board-world">
                <!-- LE TRAIT EST AU CENTRE (x=0) -->
                <div id="equation-divider"></div>
            </div>
        </div>
        
        <!-- Badges Joueurs -->
        <div class="absolute top-4 left-10 opacity-30 text-2xl font-bold font-serif italic text-slate-500 pointer-events-none">Membre de Gauche</div>
        <div class="absolute top-4 right-10 opacity-30 text-2xl font-bold font-serif italic text-slate-500 pointer-events-none">Membre de Droite</div>
    </main>

    <!-- BARRE D'OUTILS BAS (PIÈCES) -->
    <div id="bottom-bar">
        <!-- DECKS GAUCHE -->
        <div class="deck-section" id="deck-left">
            <div class="flex flex-col items-center mr-4">
                <span class="deck-label">Gauche</span>
                <div class="flex gap-2">
                    <button draggable="true" ondragstart="app.handleDragFromMenu(event, 'x2', 1, 'left')" onclick="app.menuClick('x2', 1, 'left')" class="tile-btn w-12 h-12"><div class="preview-shape ps-green w-8 h-8 text-sm">x²</div></button>
                    <button draggable="true" ondragstart="app.handleDragFromMenu(event, 'x2', -1, 'left')" onclick="app.menuClick('x2', -1, 'left')" class="tile-btn w-12 h-12"><div class="preview-shape ps-red w-8 h-8 text-sm">-x²</div></button>
                    <button draggable="true" ondragstart="app.handleDragFromMenu(event, 'x', 1, 'left')" onclick="app.menuClick('x', 1, 'left')" class="tile-btn w-16 h-10"><div class="preview-shape ps-green w-10 h-5 text-sm">x</div></button>
                    <button draggable="true" ondragstart="app.handleDragFromMenu(event, 'x', -1, 'left')" onclick="app.menuClick('x', -1, 'left')" class="tile-btn w-16 h-10"><div class="preview-shape ps-red w-10 h-5 text-sm">-x</div></button>
                    <button draggable="true" ondragstart="app.handleDragFromMenu(event, 'unit', 1, 'left')" onclick="app.menuClick('unit', 1, 'left')" class="tile-btn w-10 h-10"><div class="preview-shape ps-green w-5 h-5 text-xs">1</div></button>
                    <button draggable="true" ondragstart="app.handleDragFromMenu(event, 'unit', -1, 'left')" onclick="app.menuClick('unit', -1, 'left')" class="tile-btn w-10 h-10"><div class="preview-shape ps-red w-5 h-5 text-xs">-1</div></button>
                </div>
            </div>
        </div>

        <!-- DECKS DROITE -->
        <div class="deck-section" id="deck-right">
            <div class="flex flex-col items-center ml-4">
                <span class="deck-label">Droite</span>
                <div class="flex gap-2">
                    <button draggable="true" ondragstart="app.handleDragFromMenu(event, 'x2', 1, 'right')" onclick="app.menuClick('x2', 1, 'right')" class="tile-btn w-12 h-12"><div class="preview-shape ps-green w-8 h-8 text-sm">x²</div></button>
                    <button draggable="true" ondragstart="app.handleDragFromMenu(event, 'x2', -1, 'right')" onclick="app.menuClick('x2', -1, 'right')" class="tile-btn w-12 h-12"><div class="preview-shape ps-red w-8 h-8 text-sm">-x²</div></button>
                    <button draggable="true" ondragstart="app.handleDragFromMenu(event, 'x', 1, 'right')" onclick="app.menuClick('x', 1, 'right')" class="tile-btn w-16 h-10"><div class="preview-shape ps-green w-10 h-5 text-sm">x</div></button>
                    <button draggable="true" ondragstart="app.handleDragFromMenu(event, 'x', -1, 'right')" onclick="app.menuClick('x', -1, 'right')" class="tile-btn w-16 h-10"><div class="preview-shape ps-red w-10 h-5 text-sm">-x</div></button>
                    <button draggable="true" ondragstart="app.handleDragFromMenu(event, 'unit', 1, 'right')" onclick="app.menuClick('unit', 1, 'right')" class="tile-btn w-10 h-10"><div class="preview-shape ps-green w-5 h-5 text-xs">1</div></button>
                    <button draggable="true" ondragstart="app.handleDragFromMenu(event, 'unit', -1, 'right')" onclick="app.menuClick('unit', -1, 'right')" class="tile-btn w-10 h-10"><div class="preview-shape ps-red w-5 h-5 text-xs">-1</div></button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const SNAP = 60;
        const SIZES = { 'unit': { w: 40, h: 40 }, 'x': { w: 90, h: 40 }, 'x2': { w: 90, h: 90 } };
        const COLORS = { pos: 'green', neg: 'red' };
        
        class AlgebraEqApp {
            constructor() {
                this.tokens = []; this.history = []; this.nextId = 1;
                this.scale = 1; this.pan = {x:0, y:0}; this.isPanning = false; this.panStart = {x:0,y:0};
                this.mode = 'setup'; // 'setup' | 'solve'
                this.equationVisible = true;

                // Cursors for auto-placement (relative to x=0 center)
                this.leftCursor = { x: -300, y: -100, maxY: 0 };
                this.rightCursor = { x: 50, y: -100, maxY: 0 };

                this.container = document.getElementById('board-container');
                this.world = document.getElementById('board-world');
                this.eqDisplay = document.getElementById('equation-display');
                
                this.initListeners();
                this.centerView();
                this.saveState();
            }

            initListeners() {
                // Zoom
                this.container.addEventListener('wheel', e => {
                    e.preventDefault();
                    this.scale = Math.min(Math.max(0.5, this.scale - e.deltaY * 0.001), 2.5);
                    this.updateTransform();
                }, {passive:false});
                
                // Pan
                this.container.addEventListener('mousedown', e => {
                    if(e.target.closest('.token')) return;
                    this.isPanning = true; this.panStart = { x: e.clientX - this.pan.x, y: e.clientY - this.pan.y };
                    this.container.classList.add('panning');
                });
                
                window.addEventListener('mousemove', e => {
                    if(this.isPanning) {
                        this.pan.x = e.clientX - this.panStart.x;
                        this.pan.y = e.clientY - this.panStart.y;
                        this.updateTransform();
                    }
                });
                window.addEventListener('mouseup', () => { this.isPanning = false; this.container.classList.remove('panning'); });

                // Drag & Drop from Menu
                this.container.addEventListener('dragover', e => e.preventDefault());
                this.container.addEventListener('drop', e => this.handleDrop(e));
                
                window.addEventListener('resize', () => this.centerView());
            }

            centerView() {
                // Center (0,0) of world on screen center
                const cx = this.container.clientWidth / 2;
                const cy = this.container.clientHeight / 2;
                this.pan.x = cx;
                this.pan.y = cy;
                this.updateTransform();
            }

            updateTransform() { this.world.style.transform = `translate(${this.pan.x}px, ${this.pan.y}px) scale(${this.scale})`; }
            getWorldPos(cx, cy) {
                const r = this.container.getBoundingClientRect();
                return { x: (cx - r.left - this.pan.x) / this.scale, y: (cy - r.top - this.pan.y) / this.scale };
            }

            // --- INTERACTION ---

            toggleMode() {
                this.saveState();
                const btn = document.getElementById('btn-mode');
                const txt = document.getElementById('mode-text');
                if (this.mode === 'setup') {
                    this.mode = 'solve';
                    btn.classList.add('solve');
                    txt.innerText = "Phase 2 : Résoudre (Balance)";
                    // Initialize solving cursors below existing setup (lowest Y + margin)
                    let maxY = -100;
                    this.tokens.forEach(t => maxY = Math.max(maxY, t.y + SIZES[t.type].h));
                    maxY += 40;
                    this.leftCursor = { x: -300, y: maxY, maxY: 0 };
                    this.rightCursor = { x: 50, y: maxY, maxY: 0 };
                } else {
                    this.mode = 'setup';
                    btn.classList.remove('solve');
                    txt.innerText = "Phase 1 : Poser l'équation";
                }
            }

            toggleEquationVisibility() {
                this.equationVisible = !this.equationVisible;
                if(this.equationVisible) {
                    this.eqDisplay.classList.remove('equation-blur');
                    document.getElementById('eye-icon').innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />';
                } else {
                    this.eqDisplay.classList.add('equation-blur');
                    document.getElementById('eye-icon').innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.59 3.59m0 0A9.953 9.953 0 0112 5c4.478 0 8.268 2.943 9.543 7a10.025 10.025 0 01-4.132 5.411m0 0L21 21" />';
                }
            }

            // --- TILE ADDITION ---

            handleDragFromMenu(e, type, sign, side) {
                e.dataTransfer.setData('type', type);
                e.dataTransfer.setData('sign', sign);
                e.dataTransfer.setData('source', side); // 'left' or 'right' menu
            }

            handleDrop(e) {
                e.preventDefault();
                const type = e.dataTransfer.getData('type');
                const sign = parseInt(e.dataTransfer.getData('sign'));
                const source = e.dataTransfer.getData('source');
                if (!type) return;

                this.saveState();
                const pos = this.getWorldPos(e.clientX, e.clientY);
                const centeredX = pos.x - SIZES[type].w/2;
                const centeredY = pos.y - SIZES[type].h/2;

                if (this.mode === 'solve') {
                    // MIRROR LOGIC: If dropped on left, add mirror on right (and vice versa) based on position
                    // Actually simple rule: Add +1 tile at drop pos, and +1 tile at "mirror" pos
                    // But usually solve mode is auto-stacked. Let's make it auto-stack for clarity
                    // If user insists on drag-drop in solve mode:
                    // Drop on Left -> Creates tile on Left + Mirror on Right
                    const dropSide = (pos.x < 0) ? 'left' : 'right';
                    this.createToken(type, sign, centeredX, centeredY); // The one dropped
                    this.createToken(type, sign, dropSide==='left'?'right':'left', 'auto'); // The mirror
                } else {
                    // Setup Mode: Just place it
                    this.createToken(type, sign, centeredX, centeredY);
                }
                this.updateEquation();
            }

            menuClick(type, sign, side) {
                this.saveState();
                if (this.mode === 'solve') {
                    // MIRROR ADDITION
                    this.createToken(type, sign, 'left', 'auto');
                    this.createToken(type, sign, 'right', 'auto');
                } else {
                    // SETUP ADDITION: Add to the side of the clicked menu
                    this.createToken(type, sign, side, 'auto');
                }
                this.updateEquation();
            }

            createToken(type, sign, xOrSide, yOrMode) {
                const id = this.nextId++;
                const el = document.createElement('div');
                el.className = `token ${type==='unit'?'type-unit':(type==='x'?'type-x':'type-x2')} ${sign===1?'green':'red'}`;
                el.innerHTML = `<span style="pointer-events:none;">${this.getLabel(type, sign)}</span>`;
                el.id = `t-${id}`;
                
                let x, y;
                
                // Determine Position
                if (typeof xOrSide === 'number') {
                    x = xOrSide; y = yOrMode;
                } else {
                    // Auto placement based on side ('left' or 'right')
                    const side = xOrSide;
                    let cursor = (side === 'left') ? this.leftCursor : this.rightCursor;
                    // Wrap logic
                    const limitX = (side === 'left') ? -20 : 480; 
                    const startX = (side === 'left') ? -300 : 50;
                    
                    if (cursor.x + SIZES[type].w > limitX) {
                        cursor.x = startX; cursor.y += cursor.maxY + 10; cursor.maxY = 0;
                    }
                    x = cursor.x; y = cursor.y;
                    
                    cursor.x += SIZES[type].w + 5;
                    cursor.maxY = Math.max(cursor.maxY, SIZES[type].h);
                }

                el.style.left = x + 'px'; el.style.top = y + 'px';
                
                // Drag Logic
                el.addEventListener('mousedown', e => this.handleDragStart(e, id));
                el.addEventListener('touchstart', e => this.handleDragStart(e, id), {passive:false});

                this.world.appendChild(el);
                this.tokens.push({ id, type, sign, x, y, element: el, pairId: null });
            }

            getLabel(t, s) { if(t==='unit') return s===1?'1':'-1'; if(t==='x') return s===1?'x':'-x'; return s===1?'x²':'-x²'; }

            // --- DRAG ---
            handleDragStart(e, id) {
                e.stopPropagation();
                const t = this.tokens.find(x => x.id === id);
                if(!t) return;
                t.element.classList.add('dragging');
                const r = t.element.getBoundingClientRect();
                const offset = { x: (e.touches?e.touches[0].clientX:e.clientX) - r.left, y: (e.touches?e.touches[0].clientY:e.clientY) - r.top };
                
                const move = ev => {
                    ev.preventDefault();
                    const cx = ev.touches?ev.touches[0].clientX:ev.clientX; const cy = ev.touches?ev.touches[0].clientY:ev.clientY;
                    const br = this.container.getBoundingClientRect();
                    t.x = (cx - br.left - this.pan.x - offset.x)/this.scale;
                    t.y = (cy - br.top - this.pan.y - offset.y)/this.scale;
                    t.element.style.left = t.x+'px'; t.element.style.top = t.y+'px';
                };
                const end = () => {
                    document.removeEventListener('mousemove', move); document.removeEventListener('touchmove', move);
                    document.removeEventListener('mouseup', end); document.removeEventListener('touchend', end);
                    t.element.classList.remove('dragging');
                    // Zero Pair Logic
                    this.checkOverlap(t);
                    this.updateEquation();
                };
                document.addEventListener('mousemove', move); document.addEventListener('touchmove', move, {passive:false});
                document.addEventListener('mouseup', end); document.addEventListener('touchend', end);
            }

            checkOverlap(t1) {
                const s1=SIZES[t1.type]; const c1={x:t1.x+s1.w/2,y:t1.y+s1.h/2};
                for(let t2 of this.tokens) {
                    if(t2===t1||t2.pairId||t2.type!==t1.type||t2.sign===t1.sign)continue;
                    // Strict side check in solving mode: can only cancel if on same side
                    if (this.mode === 'solve') {
                        if ((t1.x < 0 && t2.x > 0) || (t1.x > 0 && t2.x < 0)) continue; 
                    }
                    const s2=SIZES[t2.type]; const c2={x:t2.x+s2.w/2,y:t2.y+s2.h/2};
                    if(Math.hypot(c1.x-c2.x, c1.y-c2.y)<SNAP) {
                        this.createZeroPair(t1, t2);
                        break;
                    }
                }
            }

            createZeroPair(t1, t2) {
                const audio = new AudioContext(); // Simple beep or reuse playSound logic
                const mx=(t1.x+t2.x)/2; const my=(t1.y+t2.y)/2;
                t1.x=mx; t1.y=my; t2.x=mx; t2.y=my;
                t1.element.style.left=mx+'px'; t1.element.style.top=my+'px';
                t2.element.style.left=mx+'px'; t2.element.style.top=my+'px';
                t1.pairId=t2.id; t2.pairId=t1.id;
                t1.element.classList.add('is-zero'); t2.element.classList.add('is-zero');
                const b=document.createElement('div'); b.className='zero-badge'; b.textContent='0'; b.id=`badge-${t1.id}-${t2.id}`;
                b.style.left=(mx+SIZES[t1.type].w/2-10)+'px'; b.style.top=(my+SIZES[t1.type].h/2-20)+'px';
                this.world.appendChild(b);
            }

            // --- ACTIONS ---
            organizeBoard() {
                this.saveState();
                const organize = (subset, startX, limitX) => {
                    let y = -100;
                    ['x2','x','unit'].forEach(type=>{
                        [1,-1].forEach(s=>{
                            const ts = subset.filter(t=>t.type===type && t.sign===s && !t.pairId);
                            if(!ts.length)return;
                            let x=startX; let rh=0;
                            ts.forEach(t=>{
                                if(x+SIZES[type].w > limitX){ x=startX; y+=rh+10; rh=0; }
                                t.x=x; t.y=y; t.element.classList.add('animating');
                                t.element.style.left=x+'px'; t.element.style.top=y+'px';
                                setTimeout(()=>t.element.classList.remove('animating'),500);
                                x+=SIZES[type].w+2; rh=Math.max(rh,SIZES[type].h);
                            });
                            y+=rh+10;
                        });
                    });
                    return y;
                };
                const ly = organize(this.tokens.filter(t=>t.x<0), -300, -20);
                const ry = organize(this.tokens.filter(t=>t.x>=0), 50, 480);
                // Update cursors
                const my = Math.max(ly, ry)+20;
                this.leftCursor = {x:-300, y:my, maxY:0}; this.rightCursor = {x:50, y:my, maxY:0};
            }

            autoSimplify() {
                this.saveState();
                const process = (subset) => {
                    const toDel = [];
                    ['x2','x','unit'].forEach(type => {
                        const p = subset.filter(t=>t.type===type && t.sign===1 && !t.pairId);
                        const n = subset.filter(t=>t.type===type && t.sign===-1 && !t.pairId);
                        while(p.length && n.length) {
                            const t1=p.pop(); const t2=n.pop();
                            t1.element.classList.add('vanish'); t2.element.classList.add('vanish');
                            toDel.push(t1.id, t2.id);
                        }
                    });
                    return toDel;
                };
                const delL = process(this.tokens.filter(t=>t.x<0));
                const delR = process(this.tokens.filter(t=>t.x>=0));
                const all = [...delL, ...delR];
                if(all.length) {
                    setTimeout(() => {
                        this.tokens = this.tokens.filter(t => !all.includes(t.id));
                        this.tokens.forEach(t=>t.element.classList.contains('vanish') && t.element.remove()); // Cleanup DOM
                        this.updateEquation();
                    }, 500);
                }
            }

            // --- STATE & EQUATION ---
            updateEquation() {
                const sum = (subset) => {
                    const c = {x2:0,x:0,unit:0}; subset.forEach(t=>{c[t.type]+=t.sign});
                    let s="";
                    ['x2','x','unit'].forEach(k=>{
                        if(c[k]!==0) {
                            const v=c[k]; const lbl=k==='unit'?'':(k==='x'?'x':'x^2');
                            const p=(v>0&&s.length)?"+":"";
                            const n=(Math.abs(v)===1&&k!=='unit')?(v===-1?"-":""):v;
                            s+=`${p}${n}${lbl}`;
                        }
                    });
                    return s||"0";
                };
                const l = sum(this.tokens.filter(t=>t.x<0 && !t.pairId));
                const r = sum(this.tokens.filter(t=>t.x>=0 && !t.pairId));
                katex.render(`${l} = ${r}`, this.eqDisplay);
            }

            undo() {
                if(!this.history.length) return;
                const s = this.history.pop();
                this.tokens.forEach(t=>t.element.remove());
                this.tokens = [];
                s.tokens.forEach(d => {
                    const el=document.createElement('div');
                    el.className=`token ${d.type==='unit'?'type-unit':(d.type==='x'?'type-x':'type-x2')} ${d.sign===1?'green':'red'}`;
                    el.innerHTML=`<span style="pointer-events:none;">${this.getLabel(d.type,d.sign)}</span>`;
                    el.id=`t-${this.nextId++}`; el.style.left=d.x+'px'; el.style.top=d.y+'px';
                    el.addEventListener('mousedown', e=>this.handleDragStart(e, parseInt(el.id.split('-')[1])));
                    this.world.appendChild(el);
                    this.tokens.push({id:parseInt(el.id.split('-')[1]), type:d.type, sign:d.sign, x:d.x, y:d.y, element:el, pairId:null});
                });
                this.mode = s.mode;
                const btn = document.getElementById('btn-mode');
                if(this.mode==='solve') { btn.classList.add('solve'); document.getElementById('mode-text').innerText="Phase 2 : Résoudre (Balance)"; }
                else { btn.classList.remove('solve'); document.getElementById('mode-text').innerText="Phase 1 : Poser l'équation"; }
                this.updateEquation();
            }

            saveState() {
                if(this.history.length>20) this.history.shift();
                this.history.push({ tokens: this.tokens.map(t=>({type:t.type, sign:t.sign, x:t.x, y:t.y})), mode:this.mode });
            }

            resetBoard() {
                this.saveState();
                this.tokens.forEach(t=>t.element.remove()); this.tokens=[];
                this.mode='setup'; 
                document.getElementById('btn-mode').classList.remove('solve');
                document.getElementById('mode-text').innerText="Phase 1 : Poser l'équation";
                this.updateEquation();
            }
        }

        const app = new AlgebraEqApp();
    </script>
</body>
</html>