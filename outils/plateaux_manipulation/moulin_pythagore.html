<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Moulin de Pythagore — double puzzle</title>
<style>
  :root{
    --bg:#ffffff;
    --ink:#0f172a;
    --muted:#64748b;
    --border:#cbd5e1;
    --shadow:0 2px 10px rgba(0,0,0,.08);
    --btn:#ffffff;
    --btnHover:#f1f5f9;
    --accent:#2563eb;
    --danger:#dc2626;
  }
  html,body{height:100%; margin:0; background:var(--bg); font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji";}
  #app{height:100%; display:flex; flex-direction:column;}
  #toolbar{
    display:flex; flex-wrap:wrap; gap:8px;
    padding:10px 12px;
    border-bottom:1px solid var(--border);
    background:#fff;
    align-items:center;
    box-shadow:var(--shadow);
    z-index:2;
  }
  .group{display:flex; gap:8px; align-items:center;}
  .spacer{flex:1;}
  button, .toggle{
    border:1px solid var(--border);
    background:var(--btn);
    padding:8px 10px;
    border-radius:10px;
    font-size:14px;
    color:var(--ink);
    cursor:pointer;
    user-select:none;
  }
  button:hover, .toggle:hover{background:var(--btnHover);}
  button:active{transform:translateY(1px);}
  button.primary{border-color:rgba(37,99,235,.45);}
  button.primary.on{background:rgba(37,99,235,.12); border-color:rgba(37,99,235,.7);}
  button.danger{border-color:rgba(220,38,38,.45);}
  button.danger:hover{background:rgba(220,38,38,.08);}
  .toggle{display:flex; gap:10px; align-items:center;}
  .pill{
    width:36px; height:22px; border-radius:999px;
    background:#e2e8f0;
    position:relative;
    border:1px solid var(--border);
    flex:0 0 auto;
  }
  .pill::after{
    content:"";
    width:18px; height:18px; border-radius:50%;
    position:absolute; top:1px; left:1px;
    background:#fff;
    box-shadow:0 1px 2px rgba(0,0,0,.15);
    transition:all .15s ease;
  }
  .toggle.on .pill{background:rgba(37,99,235,.18); border-color:rgba(37,99,235,.5);}
  .toggle.on .pill::after{left:17px;}
  .hint{color:var(--muted); font-size:13px; padding-left:6px; white-space:nowrap;}
  #stageWrap{flex:1; position:relative; overflow:hidden; background:#fff;}
  svg{width:100%; height:100%; display:block; touch-action:none;}
  .boardLine{stroke:#111827; stroke-width:3; fill:none; stroke-linecap:round; stroke-linejoin:round;}
  .thinLine{stroke:#111827; stroke-width:2.2; fill:none; stroke-linecap:round; stroke-linejoin:round;}
  .rightAngle{stroke:#111827; stroke-width:3; fill:none; stroke-linecap:round; stroke-linejoin:round; opacity:.35;}
  .label{font-size:22px; font-weight:700; fill:#111827; paint-order:stroke; stroke:#fff; stroke-width:5px;}
  .subLabel{font-size:18px; font-weight:700; fill:#111827; paint-order:stroke; stroke:#fff; stroke-width:4px;}

  .label, .subLabel{display:none;}
  .showLetters .label{display:block;}
  .piecePoly{stroke:#111827; stroke-width:3.2; stroke-linejoin:round; cursor:grab;}
  .piecePoly:active{cursor:grabbing;}
  .pieceSelected .piecePoly{stroke:#111827; stroke-width:5.2;}
  .handle{pointer-events:auto; cursor:crosshair;}
  .handleLine{stroke:#111827; stroke-width:3; opacity:.8;}
  .handleDot{fill:#fff; stroke:#111827; stroke-width:3;}
  .handleIcon{fill:none; stroke:#111827; stroke-width:3.2; stroke-linecap:round; stroke-linejoin:round; opacity:.9;}
  .snapDot{fill:rgba(37,99,235,.15); stroke:rgba(37,99,235,.35); stroke-width:2; display:none;}

  /* Mode "Vide" : un seul squelette centré, sans pièces */
  .modeVide #pieces{display:none;}
  .modeVide #boardsR, .modeVide #labelsR{display:none;}
  .modeVide .rightAngle{display:none;}

</style>
</head>
<body>
<div id="app">
  <div id="toolbar">
    <div class="group">
      <button id="modeEleves" class="primary on" title="Vue élèves : sans lettres">Élèves</button>
<button id="modeVide" class="primary" title="Affiche un seul moulin vide (squelette) pour écrire">Vide</button>
    </div>

    <div class="group" style="margin-left:10px;"><div id="toggleLetters" class="toggle" title="Affiche les lettres A, B, C">
        <span>Lettres ABC</span><span class="pill"></span>
      </div>
    </div>

    <div class="group" style="margin-left:10px;">
      <button id="reset" class="danger" title="Remet toutes les pièces à leur place de départ">Réinitialiser</button>
    </div>

    <div class="spacer"></div>

    <div class="group">
      <button id="enonce" title="Générer les pages à imprimer">Énoncé</button>
      <button id="fullscreen" title="Plein écran">Plein écran</button>
    </div>
  </div>

  <div id="stageWrap">
    <svg id="stage" xmlns="http://www.w3.org/2000/svg">
      <g id="world"></g>
    </svg>
  </div>
</div>

<script>
(() => {
  "use strict";

  // ===== Config générale (proportions de ta photo) =====
  // On garde un ratio a/b ≈ 0.5 (d'après les mesures sur l'image fournie)
  const BASE = {
    b: 420,           // côté du carré du haut (moyen)
    ratio: 0.5,       // a = ratio*b (petit carré vert)
    gap: 170,         // espace entre les deux moulins
    margin: 60,       // marge intérieure dans le monde
  };

  const COLORS = {
    green: "#009900",
    magenta: "#cc0066",
    yellow: "#ffcc66",
    blue: "#0099ff",
    gray: "#808080",
  };

  const SNAP = {
    pos: 22,           // distance de snap (position) en unités du monde
    posStrong: 28,     // un peu plus fort sur les points du grand carré
    rot: 7,            // distance de snap (rotation) en degrés
  };

  // ===== DOM =====
  const stage = document.getElementById("stage");
  const world = document.getElementById("world");

  const btnModeEleves = document.getElementById("modeEleves");
  const btnModeVide = document.getElementById("modeVide");

      const toggleLetters = document.getElementById("toggleLetters");

  const btnReset = document.getElementById("reset");
  const btnFullscreen = document.getElementById("fullscreen");
const btnEnonce = document.getElementById("enonce");

  // ===== État global =====
  const state = {
    mode: "eleves",          // eleves | vide
    snapEnabled: true,
    angleSnapEnabled: true,
    lettersEnabled: false,
    selectedId: null,
    dragging: null,          // {type:'move'|'rotate', pieceId, ...}
    pieces: new Map(),       // id -> Piece
    snapPoints: [],          // {x,y, kind, moulinId}
    molds: [],
    moulins: {L:null, R:null},               // grand carré (2) : {id, corners, uvec, vvec, c, a, bbox}
    worldTransform: {s: 1, tx: 0, ty: 0},
  };

  // ===== Utilitaires =====
  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
  function deg(rad){ return rad * 180 / Math.PI; }
  function rad(deg){ return deg * Math.PI / 180; }
  function normAngleDeg(a){
    let x = a % 360;
    if (x < -180) x += 360;
    if (x > 180) x -= 360;
    return x;
  }

  function polygonCentroid(points){
    // centroid d'un polygone non auto-intersectant
    let a = 0, cx = 0, cy = 0;
    for (let i=0;i<points.length;i++){
      const p = points[i];
      const q = points[(i+1)%points.length];
      const cross = p.x*q.y - q.x*p.y;
      a += cross;
      cx += (p.x + q.x) * cross;
      cy += (p.y + q.y) * cross;
    }
    a *= 0.5;
    if (Math.abs(a) < 1e-9) {
      const n = points.length;
      return {
        x: points.reduce((s,p)=>s+p.x,0)/n,
        y: points.reduce((s,p)=>s+p.y,0)/n
      };
    }
    cx /= (6*a);
    cy /= (6*a);
    return {x:cx, y:cy};
  }

  function bboxOfPoints(points){
    let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
    for (const p of points){
      minX = Math.min(minX, p.x);
      minY = Math.min(minY, p.y);
      maxX = Math.max(maxX, p.x);
      maxY = Math.max(maxY, p.y);
    }
    return {minX, minY, maxX, maxY, w: maxX-minX, h: maxY-minY};
  }

  function clientToWorld(evt){
    const pt = stage.createSVGPoint();
    pt.x = evt.clientX;
    pt.y = evt.clientY;
    const m = world.getScreenCTM();
    if (!m) return {x:0,y:0};
    const inv = m.inverse();
    const q = pt.matrixTransform(inv);
    return {x:q.x, y:q.y};
  }

  function svgEl(name, attrs = {}){
    const el = document.createElementNS("http://www.w3.org/2000/svg", name);
    for (const [k,v] of Object.entries(attrs)) el.setAttribute(k, String(v));
    return el;
  }

  
  function setMode(mode){
    state.mode = mode;
    btnModeEleves.classList.toggle("on", mode==="eleves");
    btnModeVide.classList.toggle("on", mode==="vide");
    stage.classList.toggle("modeVide", mode==="vide");
    stage.classList.toggle("modeEleves", mode==="eleves");
    if (mode==="vide") setSelected(null);
    fitWorldToViewport(mode);
  }

  function setToggle(el, on){ el.classList.toggle("on", on); }

  // ===== Géométrie du moulin =====
  function lineIntersection(p1,p2, p3,p4){
    const x1=p1.x,y1=p1.y,x2=p2.x,y2=p2.y;
    const x3=p3.x,y3=p3.y,x4=p4.x,y4=p4.y;
    const den = (x1-x2)*(y3-y4) - (y1-y2)*(x3-x4);
    if (Math.abs(den) < 1e-9) return null;
    const px = ((x1*y2 - y1*x2)*(x3-x4) - (x1-x2)*(x3*y4 - y3*x4)) / den;
    const py = ((x1*y2 - y1*x2)*(y3-y4) - (y1-y2)*(x3*y4 - y3*x4)) / den;
    return {x:px, y:py};
  }

  function buildMoulin(moulinId, Ax, Ay, b, ratio){
    const a = b * ratio;
    const c = Math.hypot(b, a);

    const A = {x:Ax, y:Ay};
    const B = {x:Ax + b, y:Ay};
    const C = {x:Ax, y:Ay + a};

    const TL = {x:A.x, y:A.y - b};
    const TR = {x:B.x, y:B.y - b};

    const L = {x:A.x, y:A.y - (b - a)};
    const T = {x:A.x + (b - a), y:A.y - b};

    const P = lineIntersection(L, TR, B, T);
    if (!P) throw new Error("Intersection impossible (paramètres incohérents).");

    const pieces = [
      { key:"yellow", fill:COLORS.yellow, points:[ TL, T, P, L ] },
      { key:"blue", fill:COLORS.blue, points:[ T, TR, P ] },
      { key:"gray", fill:COLORS.gray, points:[ B, TR, P ] },
      { key:"magenta", fill:COLORS.magenta, points:[ A, B, P, L ] },
      { key:"green", fill:COLORS.green, points:[ {x:A.x - a, y:A.y}, {x:A.x, y:A.y}, {x:C.x, y:C.y}, {x:C.x - a, y:C.y} ] },
    ];

    // Grand carré sur BC
    const w = {x:a, y:b};
    const Bw = {x:B.x + w.x, y:B.y + w.y};
    const Cw = {x:C.x + w.x, y:C.y + w.y};

    const mold = {
      id: moulinId,
      a, b, c,
      corners: [B, C, Cw, Bw],
      uvec: {x:(B.x - C.x)/c, y:(B.y - C.y)/c},
      vvec: {x:(Cw.x - C.x)/c, y:(Cw.y - C.y)/c},
    };
    mold.bbox = bboxOfPoints(mold.corners);

    // points d'aimantation du moule
    const snapsUV = [
      {u:0, v:0}, {u:c, v:0}, {u:0, v:c}, {u:c, v:c},
      {u:a, v:0}, {u:0, v:a}, {u:a, v:a},
      {u:a, v:c}, {u:c, v:a},
    ];
    const snapPoints = snapsUV.map(s => ({
      x: C.x + s.u*mold.uvec.x + s.v*mold.vvec.x,
      y: C.y + s.u*mold.uvec.y + s.v*mold.vvec.y,
      kind: "mold",
      moulinId
    }));

    const labels = {
      A:{x:A.x - 28, y:A.y - 14, text:"A"},
      B:{x:B.x + 10, y:B.y + 6, text:"B"},
      C:{x:C.x - 14, y:C.y + 26, text:"C"},
    };

    return {moulinId, A,B,C, TL,TR, Bw,Cw, L,T,P, pieces, mold, snapPoints, labels};
  }

  // ===== Construction de la scène =====
  function clearWorld(){
    while (world.firstChild) world.removeChild(world.firstChild);
    state.pieces.clear();
    state.snapPoints = [];
    state.molds = [];
    state.selectedId = null;
  }

  
  function buildScene(){
    clearWorld();

    const b = BASE.b;
    const ratio = BASE.ratio;
    const a = b*ratio;
    const margin = BASE.margin;
    const gap = BASE.gap;

    const Aleft = {x: margin + a, y: margin + b};
    const Aright = {x: Aleft.x + (b + 2*a) + gap, y: Aleft.y};

    const left = buildMoulin("L", Aleft.x, Aleft.y, b, ratio);
    const right = buildMoulin("R", Aright.x, Aright.y, b, ratio);

    state.moulins = {L:left, R:right};

    state.molds.push(left.mold, right.mold);
    state.snapPoints.push(...left.snapPoints, ...right.snapPoints);

    const gBoards = svgEl("g", {id:"boards"});
    const gPieces = svgEl("g", {id:"pieces"});
    const gLabels = svgEl("g", {id:"labels"});

    const gBoardsL = svgEl("g", {id:"boardsL"});
    const gBoardsR = svgEl("g", {id:"boardsR"});
    const gPiecesL = svgEl("g", {id:"piecesL"});
    const gPiecesR = svgEl("g", {id:"piecesR"});
    const gLabelsL = svgEl("g", {id:"labelsL"});
    const gLabelsR = svgEl("g", {id:"labelsR"});

    gBoards.appendChild(gBoardsL);
    gBoards.appendChild(gBoardsR);
    gPieces.appendChild(gPiecesL);
    gPieces.appendChild(gPiecesR);
    gLabels.appendChild(gLabelsL);
    gLabels.appendChild(gLabelsR);

    world.appendChild(gBoards);
    world.appendChild(gPieces);
    world.appendChild(gLabels);

    drawMoulin(gBoardsL, gPiecesL, gLabelsL, left);
    drawMoulin(gBoardsR, gPiecesR, gLabelsR, right);

    setMode("eleves");
  }

  function drawMoulin(gBoards, gPieces, gLabels, moulin){
    const {A,B,C,TL,TR,Bw,Cw, pieces, mold, labels, moulinId} = moulin;
    const a = mold.a;
    const b = mold.b;

    // Carré du haut
    gBoards.appendChild(svgEl("rect", {x:A.x, y:A.y - b, width:b, height:b, class:"boardLine"}));

    // Petit carré vert
    gBoards.appendChild(svgEl("rect", {x:A.x - a, y:A.y, width:a, height:a, class:"boardLine"}));

    // Triangle
    gBoards.appendChild(svgEl("line", {x1:A.x, y1:A.y, x2:B.x, y2:B.y, class:"thinLine"}));
    gBoards.appendChild(svgEl("line", {x1:A.x, y1:A.y, x2:C.x, y2:C.y, class:"thinLine"}));
    gBoards.appendChild(svgEl("line", {x1:B.x, y1:B.y, x2:C.x, y2:C.y, class:"thinLine"}));

    // Grand carré sur BC (moule)
    const pts = [B,C,Cw,Bw].map(p=>`${p.x},${p.y}`).join(" ");
    gBoards.appendChild(svgEl("polygon", {points: pts, class:"boardLine"}));

    // Angle droit en A
    const ra = Math.max(18, Math.min(34, b*0.08));
    const raPts = [
      {x:A.x, y:A.y},
      {x:A.x+ra, y:A.y},
      {x:A.x+ra, y:A.y+ra},
      {x:A.x, y:A.y+ra},
    ];
    gBoards.appendChild(svgEl("polyline", {points: raPts.map(p=>`${p.x},${p.y}`).join(" "), class:"rightAngle"}));

    // Points d'aimantation (affichables)
    for (const sp of state.snapPoints.filter(s=>s.moulinId===moulinId)){
      gBoards.appendChild(svgEl("circle", {cx:sp.x, cy:sp.y, r:7, class:"snapDot"}));
    }

    // Labels
    const addLabel = (info, cls) => {
      const extra = (moulinId==="R") ? " labelR" : "";
      const t = svgEl("text", {x:info.x, y:info.y, class:cls + extra});
      t.textContent = info.text;
      gLabels.appendChild(t);
    };
    addLabel(labels.A, "label");
    addLabel(labels.B, "label");
    addLabel(labels.C, "label");

    // Pièces
    for (const pdef of pieces){
      const id = `${moulinId}-${pdef.key}`;
      const centroid = polygonCentroid(pdef.points);
      const localPts = pdef.points.map(q => ({x:q.x - centroid.x, y:q.y - centroid.y}));

      const g = svgEl("g", {class:"piece", "data-id": id});
      const poly = svgEl("polygon", {
        class:"piecePoly",
        fill:pdef.fill,
        points: localPts.map(q=>`${q.x},${q.y}`).join(" "),
      });

      // poignée rotation (plus visible)
      const handleDist = 64;
      const gh = svgEl("g", {class:"handle", "data-id":id, style:"display:none;"});
      gh.appendChild(svgEl("line", {x1:0, y1:0, x2:0, y2:-handleDist, class:"handleLine"}));
      gh.appendChild(svgEl("circle", {cx:0, cy:-handleDist, r:18, class:"handleDot"}));

      // Icône "rotation" nette (lisible au tableau)
      const iconT = svgEl("text", {
        x: 0,
        y: -handleDist,
        "text-anchor": "middle",
        "dominant-baseline": "central",
        style: "font-size:22px; font-weight:900; fill:#111827;"
      });
      iconT.textContent = "↻";
      gh.appendChild(iconT);

      g.appendChild(poly);
      g.appendChild(gh);

      poly.addEventListener("pointerdown", onPiecePointerDown);
      gh.addEventListener("pointerdown", onHandlePointerDown);

      gPieces.appendChild(g);

      const piece = {
        id,
        key: pdef.key,
        moulinId,
        fill: pdef.fill,
        localPts,
        verticesLocal: localPts.map(q=>({x:q.x, y:q.y})),
        pos: {x: centroid.x, y: centroid.y},
        rot: 0,
        home: {x: centroid.x, y: centroid.y, rot: 0},
        el: g,
        polyEl: poly,
        handleEl: gh,
      };

      state.pieces.set(id, piece);
      applyPieceTransform(piece);
    }
  }

  function applyPieceTransform(piece){
    piece.el.setAttribute("transform", `translate(${piece.pos.x},${piece.pos.y}) rotate(${piece.rot})`);
  }

  function setSelected(pieceId){
    if (state.selectedId && state.pieces.has(state.selectedId)){
      const prev = state.pieces.get(state.selectedId);
      prev.el.classList.remove("pieceSelected");
      prev.handleEl.style.display = "none";
    }
    state.selectedId = pieceId;
    if (pieceId && state.pieces.has(pieceId)){
      const p = state.pieces.get(pieceId);
      p.el.classList.add("pieceSelected");
      p.handleEl.style.display = "block";
      p.el.parentNode.appendChild(p.el);
    }
  }

  // ===== Mise en page =====
  function getPieceVerticesGlobal(piece, px=piece.pos.x, py=piece.pos.y, rotDeg=piece.rot){
    const t = rad(rotDeg);
    const c = Math.cos(t), s = Math.sin(t);
    return piece.verticesLocal.map(v => ({
      x: px + (v.x*c - v.y*s),
      y: py + (v.x*s + v.y*c),
    }));
  }

  function fitWorldToViewport(mode = state.mode){
    const wrap = document.getElementById("stageWrap");
    const w = wrap.clientWidth;
    const h = wrap.clientHeight;
    stage.setAttribute("viewBox", `0 0 ${w} ${h}`);

    
    const allPts = [];

    if (mode === "vide"){
      const m = state.moulins && state.moulins.L;
      if (m){
        const aL = m.mold.a;
        allPts.push(
          m.A, m.B, m.C, m.TL, m.TR, m.Bw, m.Cw,
          {x:m.A.x - aL, y:m.A.y},
          {x:m.C.x - aL, y:m.C.y}
        );
      }
    } else {
      for (const p of state.pieces.values()){
        allPts.push(...getPieceVerticesGlobal(p, p.home.x, p.home.y, p.home.rot));
      }
      for (const sp of state.snapPoints) allPts.push({x:sp.x,y:sp.y});
      for (const m of state.molds) allPts.push(...m.corners);
    }

    if (allPts.length === 0){
      world.removeAttribute("transform");
      return;
    }

    const bb = bboxOfPoints(allPts);

    const pad = 70;
    const s = Math.min((w - 2*pad) / bb.w, (h - 2*pad) / bb.h);
    const sClamped = clamp(s, 0.55, 1.8);

    const cx = bb.minX + bb.w/2;
    const cy = bb.minY + bb.h/2;

    const tx = w/2 - sClamped*cx;
    const ty = h/2 - sClamped*cy;

    state.worldTransform = {s:sClamped, tx, ty};
    world.setAttribute("transform", `translate(${tx},${ty}) scale(${sClamped})`);
  }

  // ===== Snapping =====
  function pieceNearAnyMold(piece){
    for (const mold of state.molds){
      const bb = mold.bbox;
      const inflate = 80;
      const bb2 = {minX:bb.minX-inflate, minY:bb.minY-inflate, maxX:bb.maxX+inflate, maxY:bb.maxY+inflate};
      if (piece.pos.x>=bb2.minX && piece.pos.x<=bb2.maxX && piece.pos.y>=bb2.minY && piece.pos.y<=bb2.maxY){
        return mold;
      }
    }
    return null;
  }

  function snapRotationIfNeeded(piece, evt){
    if (!state.angleSnapEnabled || !state.snapEnabled) return;
    if (evt && evt.shiftKey) return;

    const candidates = [];
    for (const k of [0,90,180,270]) candidates.push(k);

    const mold = pieceNearAnyMold(piece);
    if (mold){
      const base = deg(Math.atan2(mold.uvec.y, mold.uvec.x));
      for (const k of [0,90,180,270]) candidates.push(base + k);
    }

    let best = null;
    let bestD = Infinity;
    for (const a of candidates){
      const d = Math.abs(normAngleDeg(piece.rot - a));
      if (d < bestD){ bestD = d; best = a; }
    }
    if (best !== null && bestD <= SNAP.rot){
      piece.rot = best;
    }
  }

  function snapPositionIfNeeded(piece, evt){
    if (!state.snapEnabled) return;
    if (evt && evt.shiftKey) return;

    const verts = getPieceVerticesGlobal(piece);
    const targets = [];

    const nearMold = pieceNearAnyMold(piece);
    if (nearMold){
      const pts = state.snapPoints.filter(s=>s.moulinId===nearMold.id);
      targets.push(...pts.map(p=>({x:p.x,y:p.y,w:1.0})));
    }

    targets.push(...state.snapPoints.map(p=>({x:p.x,y:p.y,w:0.8})));

    for (const other of state.pieces.values()){
      if (other.id === piece.id) continue;
      const oVerts = getPieceVerticesGlobal(other);
      for (const v of oVerts) targets.push({x:v.x,y:v.y,w:0.6});
    }

    let best = {d:Infinity, delta:null};

    for (const v of verts){
      for (const t of targets){
        const d = Math.hypot(v.x - t.x, v.y - t.y);
        const thresh = (nearMold && t.w>=0.8) ? SNAP.posStrong : SNAP.pos;
        if (d < best.d && d <= thresh){
          best = {d, delta:{x:t.x - v.x, y:t.y - v.y}};
        }
      }
    }

    if (best.delta){
      piece.pos.x += best.delta.x;
      piece.pos.y += best.delta.y;
    }
  }

  function trySnap(piece, evt){
    snapRotationIfNeeded(piece, evt);
    snapPositionIfNeeded(piece, evt);
    applyPieceTransform(piece);
  }

  // ===== Interaction =====
  function onPiecePointerDown(evt){
    evt.preventDefault();
    evt.stopPropagation();

    const g = evt.currentTarget.closest("g.piece");
    if (!g) return;
    const id = g.getAttribute("data-id");
    if (!id || !state.pieces.has(id)) return;

    const piece = state.pieces.get(id);
    setSelected(id);

    const p0 = clientToWorld(evt);
    state.dragging = {
      type:"move",
      pieceId:id,
      startPointer: p0,
      startPos: {x: piece.pos.x, y: piece.pos.y},
      startRot: piece.rot
    };

    piece.el.parentNode.appendChild(piece.el);
    evt.currentTarget.setPointerCapture(evt.pointerId);
  }

  function onHandlePointerDown(evt){
    evt.preventDefault();
    evt.stopPropagation();

    const id = evt.currentTarget.getAttribute("data-id");
    if (!id || !state.pieces.has(id)) return;
    const piece = state.pieces.get(id);
    setSelected(id);

    const p0 = clientToWorld(evt);
    const a0 = Math.atan2(p0.y - piece.pos.y, p0.x - piece.pos.x);

    state.dragging = {
      type:"rotate",
      pieceId:id,
      startPointer: p0,
      startAngleRad: a0,
      startRot: piece.rot
    };

    evt.currentTarget.setPointerCapture(evt.pointerId);
  }

  function onPointerMove(evt){
    if (!state.dragging) return;
    const piece = state.pieces.get(state.dragging.pieceId);
    if (!piece) return;

    const p = clientToWorld(evt);

    if (state.dragging.type === "move"){
      const dx = p.x - state.dragging.startPointer.x;
      const dy = p.y - state.dragging.startPointer.y;
      piece.pos.x = state.dragging.startPos.x + dx;
      piece.pos.y = state.dragging.startPos.y + dy;
      applyPieceTransform(piece);
    } else if (state.dragging.type === "rotate"){
      const a = Math.atan2(p.y - piece.pos.y, p.x - piece.pos.x);
      const delta = a - state.dragging.startAngleRad;
      piece.rot = state.dragging.startRot + deg(delta);
      snapRotationIfNeeded(piece, evt);
      applyPieceTransform(piece);
    }
  }

  function onPointerUp(evt){
    if (!state.dragging) return;
    const piece = state.pieces.get(state.dragging.pieceId);
    state.dragging = null;
    if (!piece) return;
    trySnap(piece, evt);
  }

  function onBackgroundPointerDown(){
    setSelected(null);
  }

  stage.addEventListener("pointermove", onPointerMove);
  stage.addEventListener("pointerup", onPointerUp);
  stage.addEventListener("pointercancel", onPointerUp);
  stage.addEventListener("pointerdown", onBackgroundPointerDown);

  
  // ===== ÉNONCÉ / IMPRESSION =====
  function openEnonce(){
    const html = buildEnonceHTML();
    const w = window.open("", "_blank");
    if (!w){
      alert("Impossible d'ouvrir la fenêtre d'impression (popup bloquée). Autorise les popups pour ce site, puis réessaie.");
      return;
    }
    w.document.open();
    w.document.write(html);
    w.document.close();
    w.focus();
  }
  function buildEnonceHTML(){
    const svgPage1 = buildPage1SVG();
    const svgTriangle = buildTriangleSVG(5, 12);
    const svgEmptyDouble = buildEmptyDoubleSVG();
    const miniSheet = buildMiniSkeletonSheetHTML(8);
    const dateStr = new Date().toLocaleDateString("fr-FR");

    return `<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Moulin de Pythagore — Énoncé</title>
<style>
  @page { size: A4 landscape; margin: 6mm; }

  html,body{margin:0; padding:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; color:#0f172a;}
  *{box-sizing:border-box;}

  .noprint{position:sticky; top:0; background:#ffffff; border-bottom:1px solid #cbd5e1; padding:10px 12px; display:flex; gap:8px; align-items:center; z-index:5;}
  .noprint button{border:1px solid #cbd5e1; background:#fff; padding:8px 10px; border-radius:10px; cursor:pointer;}
  .noprint button:hover{background:#f1f5f9;}
  .noprint .sp{flex:1;}

  .page{page-break-after:always; break-after:page;}
  .page.last{page-break-after:auto; break-after:auto;}

  .hdr{display:flex; align-items:flex-end; justify-content:space-between; gap:12px; margin:0 0 3mm;}
  .title{font-size:14px; font-weight:900; margin:0;}
  .sub{font-size:10px; color:#334155; margin:0;}

  .consigne{font-size:10px; margin:0 0 3mm; line-height:1.2;}
  .q{font-size:12px; font-weight:800; margin:0 0 3mm; line-height:1.25;}

  .figureWrap{display:flex; justify-content:center; align-items:center; margin:0;}
  .figureWrap svg{width:100%; height:auto; max-height:175mm; display:block;}
  .figureWrap.tri svg{max-height:135mm;}

  .miniGrid{display:grid; grid-template-columns:repeat(4, 1fr); gap:6mm; align-items:stretch; justify-items:stretch;}
  .miniCell{border:0; padding:0; margin:0;}
  .miniCell svg{width:100%; height:auto; max-height:90mm; display:block;}

  .writeBox{
    border:1px solid #cbd5e1;
    border-radius:12px;
    padding:6mm 6mm;
    height:120mm;
    background:
      repeating-linear-gradient(
        to bottom,
        transparent 0,
        transparent 16px,
        rgba(148,163,184,.95) 16px,
        rgba(148,163,184,.95) 17px
      );
  }

  .answer{margin-top:4mm; font-size:13px; font-weight:800;}

  /* Styles SVG */
  svg .boardLine{stroke:#111827; stroke-width:3.2; fill:none; stroke-linecap:round; stroke-linejoin:round;}
  svg .thinLine{stroke:#111827; stroke-width:2.2; fill:none; stroke-linecap:round; stroke-linejoin:round;}
  svg .rightAngle{stroke:#111827; stroke-width:3.2; fill:none; opacity:.35; stroke-linecap:round; stroke-linejoin:round;}
  svg .piece{stroke:#111827; stroke-width:3.2; stroke-linejoin:round;}
  svg .tag{font-size:26px; font-weight:900; fill:#111827; paint-order:stroke; stroke:#fff; stroke-width:9px;}
  svg .abc{font-size:28px; font-weight:900; fill:#111827; paint-order:stroke; stroke:#fff; stroke-width:8px;}

  @media print{
    .noprint{display:none;}
  }
</style>
</head>
<body>
  <div class="noprint">
    <button onclick="window.print()">Imprimer</button>
    <button onclick="window.close()">Fermer</button>
    <div class="sp"></div>
    <div style="font-size:12px; color:#334155;">A4 paysage • ${dateStr}</div>
  </div>

  <!-- PAGE 1 -->
  <section class="page">
    <div class="hdr">
      <div>
        <p class="title">Activité — Moulin de Pythagore</p>
        <p class="sub">Découpe &amp; recomposition.</p>
      </div>
    </div>

    <p class="consigne"><b>Consigne :</b> Découpe les <b>pièces du moulin 1</b>, puis reconstitue le <b>carré blanc</b> du <b>moulin 2</b> en les déplaçant. <span style="color:#334155;">(Ne découpe pas le moulin 2.)</span></p>

    <div class="figureWrap">
      ${svgPage1}
    </div>
  </section>

  <!-- PAGE 2 -->
  <section class="page">
    <div class="hdr">
      <div>
        <p class="title">Bilan</p>
        <p class="sub">Les aires des trois carrés.</p>
      </div>
    </div>

    <p class="q"><b>1.</b> Quel lien y a-t-il entre l’aire du <b>petit carré</b>, du <b>moyen carré</b> et du <b>grand carré</b> ? <span style="font-weight:700;">Explique avec tes mots.</span></p>
    <div class="writeBox"></div>
  </section>

  <!-- PAGE 3 -->
  <section class="page">
    <div class="hdr">
      <div>
        <p class="title">Application — Calculer BC</p>
        <p class="sub">Triangle rectangle en A.</p>
      </div>
    </div>

    <p class="q">AB = <b>5 cm</b> et AC = <b>12 cm</b>. À l’aide de la relation sur les aires, calcule la longueur <b>BC</b>.</p>

    <div class="figureWrap tri">
      ${svgTriangle}
    </div>

    <div class="answer">BC = ____________________ cm</div>
  </section>

  <!-- PAGE 4 -->
  <section class="page">
    <div class="figureWrap">
      ${svgEmptyDouble}
    </div>
  </section>

  <!-- PAGE 5 -->
  <section class="page last">
    ${miniSheet}
  </section>

</body>
</html>`;
  }
  function buildPage1SVG(){
    const L = state.moulins?.L;
    const R = state.moulins?.R;
    if (!L || !R) return `<svg viewBox="0 0 10 10"></svg>`;

    // On calcule un viewBox serré autour des deux moulins + pièces "au départ",
    // sans ajouter de marge inutile (pour que ça rentre sur une seule page).
    const pts = [];
    for (const m of [L,R]){
      const a = m.mold.a, b = m.mold.b;
      pts.push(m.A, m.B, m.C, m.TL, m.TR, m.Bw, m.Cw, {x:m.A.x-a,y:m.A.y}, {x:m.C.x-a,y:m.C.y});
      pts.push(...m.mold.corners);
    }
    for (const p of state.pieces.values()){
      const vs = getPieceVerticesGlobal(p, p.home.x, p.home.y, p.home.rot);
      pts.push(...vs);
    }

    const bb = bboxOfPoints(pts);
    const pad = 28;
    const vb = `${(bb.minX-pad).toFixed(2)} ${(bb.minY-pad).toFixed(2)} ${(bb.w+2*pad).toFixed(2)} ${(bb.h+2*pad).toFixed(2)}`;

    // Petites étiquettes "1" et "2" DANS les carrés (ne change pas le viewBox)
    const tag1 = {x: L.A.x + 14, y: (L.A.y - L.mold.b) + 30};
    const tag2 = {x: R.A.x + 14, y: (R.A.y - R.mold.b) + 30};

    return `<svg viewBox="${vb}" xmlns="http://www.w3.org/2000/svg" aria-label="Deux moulins de Pythagore à imprimer">
      <text class="tag" x="${tag1.x}" y="${tag1.y}">1</text>
      <text class="tag" x="${tag2.x}" y="${tag2.y}">2</text>

      ${drawMoulinStatic(L)}
      ${drawMoulinStatic(R)}
    </svg>`;
  }

  function drawMoulinStatic(m){
    const a = m.mold.a, b = m.mold.b;
    const B = m.B, C = m.C, Bw = m.Bw, Cw = m.Cw;

    const ra = Math.max(18, Math.min(34, b*0.08));
    const raPts = [
      {x:m.A.x, y:m.A.y},
      {x:m.A.x+ra, y:m.A.y},
      {x:m.A.x+ra, y:m.A.y+ra},
      {x:m.A.x, y:m.A.y+ra},
    ];

    const bigSqPts = [B,C,Cw,Bw].map(p=>`${p.x.toFixed(2)},${p.y.toFixed(2)}`).join(" ");
    const order = ["yellow","blue","gray","magenta","green"];

    const piecesSvg = order.map(key=>{
      const id = `${m.moulinId}-${key}`;
      const p = state.pieces.get(id);
      if (!p) return "";
      const vs = getPieceVerticesGlobal(p, p.home.x, p.home.y, p.home.rot);
      const ptsStr = vs.map(q=>`${q.x.toFixed(2)},${q.y.toFixed(2)}`).join(" ");
      return `<polygon class="piece" fill="${p.fill}" points="${ptsStr}"/>`;
    }).join("\n");

    return `<g>
      <rect class="boardLine" x="${m.A.x}" y="${m.A.y - b}" width="${b}" height="${b}"/>
      <rect class="boardLine" x="${m.A.x - a}" y="${m.A.y}" width="${a}" height="${a}"/>

      <line class="thinLine" x1="${m.A.x}" y1="${m.A.y}" x2="${m.B.x}" y2="${m.B.y}"/>
      <line class="thinLine" x1="${m.A.x}" y1="${m.A.y}" x2="${m.C.x}" y2="${m.C.y}"/>
      <line class="thinLine" x1="${m.B.x}" y1="${m.B.y}" x2="${m.C.x}" y2="${m.C.y}"/>

      <polygon class="boardLine" points="${bigSqPts}"/>

      <polyline class="rightAngle" points="${raPts.map(p=>`${p.x},${p.y}`).join(" ")}"/>

      ${piecesSvg}
    </g>`;
  }


  // ===== Impression : squelettes vides =====
  function drawMoulinSkeleton(m){
    const a = m.mold.a, b = m.mold.b;
    const B = m.B, C = m.C, Bw = m.Bw, Cw = m.Cw;

    const bigSqPts = [B,C,Cw,Bw].map(p=>`${p.x.toFixed(2)},${p.y.toFixed(2)}`).join(" ");

    // Petit angle droit en A (triangle rectangle)
    const ra = Math.max(18, Math.min(34, b*0.08));
    const raPts = [
      {x:m.A.x, y:m.A.y},
      {x:m.A.x+ra, y:m.A.y},
      {x:m.A.x+ra, y:m.A.y+ra},
      {x:m.A.x, y:m.A.y+ra},
    ];

    // Positions des lettres (A un peu plus à gauche, comme tu le souhaites)
    const labA = {x: m.A.x - 34, y: m.A.y - 12, t:"A"};
    const labB = {x: m.B.x + 10, y: m.B.y + 8, t:"B"};
    const labC = {x: m.C.x - 16, y: m.C.y + 30, t:"C"};

    return `<g>
      <rect class="boardLine" x="${m.A.x}" y="${m.A.y - b}" width="${b}" height="${b}"/>
      <rect class="boardLine" x="${m.A.x - a}" y="${m.A.y}" width="${a}" height="${a}"/>

      <line class="thinLine" x1="${m.A.x}" y1="${m.A.y}" x2="${m.B.x}" y2="${m.B.y}"/>
      <line class="thinLine" x1="${m.A.x}" y1="${m.A.y}" x2="${m.C.x}" y2="${m.C.y}"/>
      <line class="thinLine" x1="${m.B.x}" y1="${m.B.y}" x2="${m.C.x}" y2="${m.C.y}"/>

      <polygon class="boardLine" points="${bigSqPts}"/>

      <polyline class="rightAngle" points="${raPts.map(p=>`${p.x},${p.y}`).join(" ")}"/>


      <text class="abc" x="${labA.x}" y="${labA.y}">${labA.t}</text>
      <text class="abc" x="${labB.x}" y="${labB.y}">${labB.t}</text>
      <text class="abc" x="${labC.x}" y="${labC.y}">${labC.t}</text>
    </g>`;
  }

  function buildEmptyDoubleSVG(){
    const L = state.moulins?.L;
    const R = state.moulins?.R;
    if (!L || !R) return `<svg viewBox="0 0 10 10"></svg>`;

    const pts = [];
    for (const m of [L,R]){
      const a = m.mold.a, b = m.mold.b;
      pts.push(m.A, m.B, m.C, m.TL, m.TR, m.Bw, m.Cw, {x:m.A.x-a,y:m.A.y}, {x:m.C.x-a,y:m.C.y});
      pts.push(...m.mold.corners);
    }
    const bb = bboxOfPoints(pts);
    const pad = 26;
    const vb = `${(bb.minX-pad).toFixed(2)} ${(bb.minY-pad).toFixed(2)} ${(bb.w+2*pad).toFixed(2)} ${(bb.h+2*pad).toFixed(2)}`;

    return `<svg viewBox="${vb}" xmlns="http://www.w3.org/2000/svg" aria-label="Deux moulins vides (squelettes)">
      ${drawMoulinSkeleton(L)}
      ${drawMoulinSkeleton(R)}
    </svg>`;
  }

  function buildSingleSkeletonSVG(){
    const m = state.moulins?.L;
    if (!m) return `<svg viewBox="0 0 10 10"></svg>`;

    const a = m.mold.a, b = m.mold.b;
    const pts = [m.A,m.B,m.C,m.TL,m.TR,m.Bw,m.Cw,{x:m.A.x-a,y:m.A.y},{x:m.C.x-a,y:m.C.y}, ...m.mold.corners];
    const bb = bboxOfPoints(pts);
    const pad = 18;
    const vb = `${(bb.minX-pad).toFixed(2)} ${(bb.minY-pad).toFixed(2)} ${(bb.w+2*pad).toFixed(2)} ${(bb.h+2*pad).toFixed(2)}`;

    return `<svg viewBox="${vb}" xmlns="http://www.w3.org/2000/svg" aria-label="Moulin vide (squelette)">
      ${drawMoulinSkeleton(m)}
    </svg>`;
  }

  function buildMiniSkeletonSheetHTML(count){
    const single = buildSingleSkeletonSVG();
    const cells = Array.from({length:count}, () => `<div class="miniCell">${single}</div>`).join("");
    return `<div class="miniGrid" aria-label="Feuille de squelettes vides">${cells}</div>`;
  }


  function buildTriangleSVG(abCm, acCm){
    const scale = 22; // px par cm (visuel)
    const ab = abCm * scale;
    const ac = acCm * scale;

    const margin = 38;
    const A = {x: margin + ac + 40, y: margin + ab + 40};
    const B = {x: A.x + ab, y: A.y};
    const C = {x: A.x, y: A.y + ac};

    // Carré sur AB (au-dessus)
    const AB2 = {x: B.x, y: B.y - ab};
    const AA2 = {x: A.x, y: A.y - ab};

    // Carré sur AC (à gauche)
    const CC2 = {x: C.x - ac, y: C.y};
    const AA3 = {x: A.x - ac, y: A.y};

    // Carré sur BC
    const w = {x: ac, y: ab};
    const Bw = {x: B.x + w.x, y: B.y + w.y};
    const Cw = {x: C.x + w.x, y: C.y + w.y};

    const ra = 26;
    const raPts = [
      {x:A.x, y:A.y},
      {x:A.x+ra, y:A.y},
      {x:A.x+ra, y:A.y+ra},
      {x:A.x, y:A.y+ra},
    ];

    const ptsAll = [A,B,C,AB2,AA2,CC2,AA3,Bw,Cw];
    const bb = bboxOfPoints(ptsAll);
    const pad = 35;
    const vb = `${(bb.minX-pad).toFixed(2)} ${(bb.minY-pad).toFixed(2)} ${(bb.w+2*pad).toFixed(2)} ${(bb.h+2*pad).toFixed(2)}`;

    const mid = (p,q)=>({x:(p.x+q.x)/2, y:(p.y+q.y)/2});
    const mAB = mid(A,B);
    const mAC = mid(A,C);
    const mBC = mid(B,C);

    return `<svg viewBox="${vb}" xmlns="http://www.w3.org/2000/svg" aria-label="Triangle rectangle avec carrés">
      <!-- carrés -->
      <polygon class="boardLine" points="${[A,B,AB2,AA2].map(p=>`${p.x},${p.y}`).join(" ")}"/>
      <polygon class="boardLine" points="${[A,C,CC2,AA3].map(p=>`${p.x},${p.y}`).join(" ")}"/>
      <polygon class="boardLine" points="${[B,C,Cw,Bw].map(p=>`${p.x},${p.y}`).join(" ")}"/>

      <!-- triangle -->
      <line class="thinLine" x1="${A.x}" y1="${A.y}" x2="${B.x}" y2="${B.y}"/>
      <line class="thinLine" x1="${A.x}" y1="${A.y}" x2="${C.x}" y2="${C.y}"/>
      <line class="thinLine" x1="${B.x}" y1="${B.y}" x2="${C.x}" y2="${C.y}"/>
      <polyline class="rightAngle" points="${raPts.map(p=>`${p.x},${p.y}`).join(" ")}"/>

      <!-- points -->
      <circle cx="${A.x}" cy="${A.y}" r="4" fill="#111827"/>
      <circle cx="${B.x}" cy="${B.y}" r="4" fill="#111827"/>
      <circle cx="${C.x}" cy="${C.y}" r="4" fill="#111827"/>

      <!-- labels -->
      <text class="mSubtitle" x="${A.x-16}" y="${A.y-14}">A</text>
      <text class="mSubtitle" x="${B.x+10}" y="${B.y+8}">B</text>
      <text class="mSubtitle" x="${C.x-16}" y="${C.y+28}">C</text>

      <text class="mSubtitle" x="${mAB.x}" y="${mAB.y-16}" text-anchor="middle">AB = ${abCm} cm</text>
      <text class="mSubtitle" x="${mAC.x-18}" y="${mAC.y}" text-anchor="end">AC = ${acCm} cm</text>
      <text class="mSubtitle" x="${mBC.x+18}" y="${mBC.y+10}" text-anchor="start">BC = ? cm</text>
    </svg>`;
  }

// UI
  btnModeEleves.addEventListener("click", () => setMode("eleves"));
  btnModeVide.addEventListener("click", () => setMode("vide"));
  toggleLetters.addEventListener("click", () => {
    state.lettersEnabled = !state.lettersEnabled;
    setToggle(toggleLetters, state.lettersEnabled);
    stage.classList.toggle("showLetters", state.lettersEnabled);
  });



  btnEnonce.addEventListener("click", openEnonce);

  btnReset.addEventListener("click", () => {
    for (const p of state.pieces.values()){
      p.pos.x = p.home.x;
      p.pos.y = p.home.y;
      p.rot = p.home.rot;
      applyPieceTransform(p);
    }
    setSelected(null);
  });

  btnFullscreen.addEventListener("click", async () => {
    const el = document.documentElement;
    try{
      if (!document.fullscreenElement){
        await el.requestFullscreen();
      } else {
        await document.exitFullscreen();
      }
    }catch(e){}
  });


  window.addEventListener("resize", () => fitWorldToViewport());

  buildScene();
})();
</script>
</body>
</html>
