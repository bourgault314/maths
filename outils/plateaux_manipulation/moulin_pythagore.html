<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Moulin de Pythagore — Puzzles stables</title>
<style>
  :root{
    --bg:#ffffff;
    --ink:#0f172a;
    --muted:#64748b;
    --border:#cbd5e1;
    --shadow:0 2px 10px rgba(0,0,0,.08);
    --btn:#ffffff;
    --btnHover:#f1f5f9;
    --accent:#2563eb;
    --danger:#dc2626;
  }
  html,body{height:100%; margin:0; background:var(--bg); font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;}
  #app{height:100%; display:flex; flex-direction:column;}

  #toolbar{
    display:flex; flex-wrap:wrap; gap:8px;
    padding:10px 12px;
    border-bottom:1px solid var(--border);
    background:#fff;
    align-items:center;
    box-shadow:var(--shadow);
    z-index:2;
  }
  .group{display:flex; gap:8px; align-items:center; border-right:1px solid #e2e8f0; padding-right:12px; margin-right:4px;}
  .group:last-child{border-right:none;}
  .spacer{flex:1;}

  button, .toggle, select{
    border:1px solid var(--border);
    background:var(--btn);
    padding:8px 10px;
    border-radius:10px;
    font-size:14px;
    color:var(--ink);
    cursor:pointer;
    user-select:none;
    font-family:inherit;
  }
  select{padding-right:24px; font-weight:600; max-width: 320px;}
  button:hover, .toggle:hover, select:hover{background:var(--btnHover);}
  button:active{transform:translateY(1px);}

  button.primary{border-color:rgba(37,99,235,.45);}
  button.primary.on{background:rgba(37,99,235,.12); border-color:rgba(37,99,235,.7);}
  button.danger{border-color:rgba(220,38,38,.45);}
  button.danger:hover{background:rgba(220,38,38,.08);}

  .toggle{display:flex; gap:10px; align-items:center;}
  .pill{
    width:36px; height:22px; border-radius:999px;
    background:#e2e8f0;
    position:relative;
    border:1px solid var(--border);
    flex:0 0 auto;
  }
  .pill::after{
    content:"";
    width:18px; height:18px; border-radius:50%;
    position:absolute; top:1px; left:1px;
    background:#fff;
    box-shadow:0 1px 2px rgba(0,0,0,.15);
    transition:all .15s ease;
  }
  .toggle.on .pill{background:rgba(37,99,235,.18); border-color:rgba(37,99,235,.5);}
  .toggle.on .pill::after{left:17px;}

  #stageWrap{flex:1; position:relative; overflow:hidden; background:#fff; touch-action:none;}
  svg{width:100%; height:100%; display:block; touch-action:none;}

  .boardLine{stroke:#111827; stroke-width:3; fill:none; stroke-linecap:round; stroke-linejoin:round;}
  .thinLine{stroke:#111827; stroke-width:2.2; fill:none; stroke-linecap:round; stroke-linejoin:round;}
  .rightAngle{stroke:#111827; stroke-width:3; fill:none; stroke-linecap:round; stroke-linejoin:round; opacity:1;}
  .label{font-size:22px; font-weight:700; fill:#111827; paint-order:stroke; stroke:#fff; stroke-width:5px; display:none;}
  .showLetters .label{display:block;}

  .piecePoly{stroke:#111827; stroke-width:3.2; stroke-linejoin:round; cursor:grab;}
  .piecePoly:active{cursor:grabbing;}
  .previewPoly{stroke:#111827; stroke-width:3.2; stroke-linejoin:round; opacity:.9; pointer-events:none;}

  .pieceSelected .piecePoly{stroke-width:5.2;}
  .handle{pointer-events:auto; cursor:crosshair;}
  .handleLine{stroke:#111827; stroke-width:3; opacity:.8;}
  .handleDot{fill:#fff; stroke:#111827; stroke-width:3;}

  /* Mode vide = moulin centré (à gauche) sans pièces ni lettres */
  .modeVide #pieces,
  .modeVide #boardsR,
  .modeVide .handle{display:none;}

  /* Modal Énoncé */
  #enonceModal{
    position:absolute; inset:0;
    display:none;
    align-items:center; justify-content:center;
    background:rgba(15,23,42,.55);
    z-index:10;
    padding:16px;
  }
  #enonceCard{
    width:min(860px, 96vw);
    max-height:min(84vh, 900px);
    overflow:auto;
    background:#fff;
    border:1px solid var(--border);
    border-radius:16px;
    box-shadow:0 20px 60px rgba(0,0,0,.25);
    padding:16px 16px 12px;
  }
  #enonceHead{display:flex; align-items:flex-start; gap:12px;}
  #enonceTitle{margin:0; font-size:18px;}
  #enonceClose{margin-left:auto; border-radius:12px;}
  #enonceBody{color:var(--ink); line-height:1.35; font-size:14px;}
  #enonceBody .muted{color:var(--muted);}
  #enonceBody ul{margin:8px 0 0 18px;}

  @media (pointer: coarse), (max-width: 900px){
    #toolbar{gap:6px; padding:8px 10px;}
    button, .toggle, select{padding:10px 12px; font-size:15px;}
    .group{border:none; padding:0; margin:0;}
  }
</style>
</head>
<body>
<div id="app">
  <div id="toolbar">
    <div class="group">
      <select id="puzzleSelect">
      <option value="perigal" selected>1. Périgal (5 pièces)</option>
      <option value="bhaskara">2. Bhaskara (4 triangles + 1 carré)</option>
      <option value="leitzmann">3. Leitzmann (8 triangles)</option>
      <option value="quatreIdentiques">4. 4 pièces identiques + 1 carré</option>
    </select>
    </div>

    <div class="group">
      <button id="modeEleves" class="primary on">Élèves</button>
      <button id="modeVide" class="primary">Vide</button>
    </div>

    <div class="group">
      <div id="toggleLetters" class="toggle">
        <span>ABC</span><span class="pill"></span>
      </div>
    </div>

    <div class="group">
      <button id="flip" class="primary">Retourner</button>
      <button id="reset" class="danger">Réinitialiser</button>
    </div>

    <div class="spacer"></div>

    <div class="group">
      <button id="enonce">Énoncé</button>
      <button id="fullscreen">⛶</button>
    </div>
  </div>

  <div id="stageWrap">
    <svg id="stage" xmlns="http://www.w3.org/2000/svg">
      <g id="world"></g>
    </svg>

    <!-- Modal Énoncé (fermeture uniquement via le bouton) -->
    <div id="enonceModal" role="dialog" aria-modal="true">
      <div id="enonceCard">
        <div id="enonceHead">
          <h3 id="enonceTitle">Énoncé</h3>
          <button id="enonceClose">✕</button>
        </div>
        <div id="enonceBody"></div>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  "use strict";

  const BASE = { b: 420, ratio: 0.5, gap: 170, margin: 60 };
  const COLORS = {
    green: "#009900", magenta: "#cc0066", yellow: "#ffcc66", blue: "#0099ff",
    gray: "#808080", red: "#e74c3c", purple: "#9b59b6", orange: "#e67e22",
    teal: "#1abc9c", lightblue: "#90caf9", darkblue: "#1565c0", brown: "#795548",
    softGray: "#bdc3c7",
    black: "#111827"
  };

  const SNAP = { pos: 22, posStrong: 28, rot: 7 };
  const DOUBLE_TAP_MS = 380;
  const TAP_MOVE_TOL = 6; // en unités monde

  function lineIntersection(p1,p2, p3,p4){
    const x1=p1.x,y1=p1.y,x2=p2.x,y2=p2.y;
    const x3=p3.x,y3=p3.y,x4=p4.x,y4=p4.y;
    const den = (x1-x2)*(y3-y4) - (y1-y2)*(x3-x4);
    if (Math.abs(den) < 1e-9) return null;
    return {
      x: ((x1*y2 - y1*x2)*(x3-x4) - (x1-x2)*(x3*y4 - y3*x4)) / den,
      y: ((x1*y2 - y1*x2)*(y3-y4) - (y1-y2)*(x3*y4 - y3*x4)) / den
    };
  }

  function deg(rad){ return rad * 180 / Math.PI; }
  function rad(deg){ return deg * Math.PI / 180; }
  function normAngleDeg(a){ let x = a % 360; return x < -180 ? x+360 : (x>180 ? x-360 : x); }

  function polygonCentroid(pts){
    let A=0, cx=0, cy=0;
    for(let i=0; i<pts.length; i++){
      const p=pts[i], q=pts[(i+1)%pts.length], cross=p.x*q.y-q.x*p.y;
      A+=cross; cx+=(p.x+q.x)*cross; cy+=(p.y+q.y)*cross;
    }
    A*=0.5;
    if(Math.abs(A)<1e-9) return {x:pts[0].x, y:pts[0].y};
    return {x:cx/(6*A), y:cy/(6*A)};
  }

  function bboxOfPoints(pts){
    let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
    for(const p of pts){ minX=Math.min(minX,p.x); minY=Math.min(minY,p.y); maxX=Math.max(maxX,p.x); maxY=Math.max(maxY,p.y); }
    return {minX, minY, maxX, maxY, w:maxX-minX, h:maxY-minY};
  }

  function svgEl(name, attrs = {}){
    const el = document.createElementNS("http://www.w3.org/2000/svg", name);
    for(const [k,v] of Object.entries(attrs)) el.setAttribute(k, String(v));
    return el;
  }

  const stage = document.getElementById("stage");
  const world = document.getElementById("world");
  const stageWrap = document.getElementById("stageWrap");
  const btnModeEleves = document.getElementById("modeEleves");
  const btnModeVide = document.getElementById("modeVide");
  const puzzleSelect = document.getElementById("puzzleSelect");
  const toggleLetters = document.getElementById("toggleLetters");
  const btnReset = document.getElementById("reset");
  const btnFlip = document.getElementById("flip");
  const btnFullscreen = document.getElementById("fullscreen");
  const btnEnonce = document.getElementById("enonce");

  const modal = document.getElementById("enonceModal");
  const modalTitle = document.getElementById("enonceTitle");
  const modalBody = document.getElementById("enonceBody");
  const modalClose = document.getElementById("enonceClose");

  const state = {
    mode: "eleves",
    puzzle: "perigal",
    snapEnabled: true,
    angleSnapEnabled: true,
    lettersEnabled: false,
    selectedId: null,
    dragging: null,
    pieces: new Map(),
    snapPoints: [],
    molds: [],
    moulins: {L:null, R:null},
    worldTransform: {s: 1, tx: 0, ty: 0},
    lastTap: null,
    lastPointerWorld: null
  };

  function applyWorldTransform(){
    const {s, tx, ty} = state.worldTransform;
    world.setAttribute("transform", `translate(${tx},${ty}) scale(${s})`);
  }

  function clientToWorld(evt){
    const pt = stage.createSVGPoint();
    pt.x = evt.clientX; pt.y = evt.clientY;
    const m = world.getScreenCTM();
    return pt.matrixTransform(m.inverse());
  }

  function pieceWorldVertices(piece){
    const t=rad(piece.rot), c=Math.cos(t), s=Math.sin(t);
    const sx = piece.flipX ? -1 : 1;
    return piece.verticesLocal.map(v => {
      const x0 = sx * v.x;
      const y0 = v.y;
      return {
        x: piece.pos.x + (x0*c - y0*s),
        y: piece.pos.y + (x0*s + y0*c)
      };
    });
  }

  function applyPieceTransform(p){
    const sx = p.flipX ? -1 : 1;
    p.el.setAttribute("transform", `translate(${p.pos.x},${p.pos.y}) rotate(${p.rot}) scale(${sx},1)`);
  }

  function setSelected(id){
    if(state.selectedId && state.pieces.has(state.selectedId)){
      const prev=state.pieces.get(state.selectedId);
      prev.el.classList.remove("pieceSelected");
      prev.handleEl.style.display="none";
    }
    state.selectedId=id;
    if(id && state.pieces.has(id)){
      const p=state.pieces.get(id);
      p.el.classList.add("pieceSelected");
      p.handleEl.style.display="block";
      // au premier plan
      p.el.parentNode.appendChild(p.el);
    }
  }

  function flipPiece(id){
    if(!id || !state.pieces.has(id)) return;
    const p = state.pieces.get(id);
    p.flipX = !p.flipX;
    applyPieceTransform(p);
  }

  function fitWorldToViewport(){
  // Centre et ajuste le zoom en se basant uniquement sur le plateau (pas sur les pièces),
  // pour éviter que le centrage bouge quand on déplace les pièces.
  const W = stageWrap.clientWidth || 1;
  const H = stageWrap.clientHeight || 1;

  const gBoards = document.getElementById("boards");
  const gBoardsL = document.getElementById("boardsL");

  // En mode vide, on centre uniquement le moulin gauche (R est masqué)
  const target = (state.mode === "vide" ? (gBoardsL || gBoards) : gBoards) || world;
  const bb = target.getBBox();

  const pad = 32;           // marge autour du plateau
  const yShift = -8;       // léger biais vers le haut (plus proche du menu)       // léger biais vers le haut (plus proche du menu)
  const contentW = bb.width  + pad * 2;
  const contentH = bb.height + pad * 2;

  const s = Math.min(W / contentW, H / contentH, 1.35);

  state.worldTransform.s  = s;
  state.worldTransform.tx = (W - contentW * s) / 2 - bb.x * s + pad * s;
  state.worldTransform.ty = (H - contentH * s) / 2 - bb.y * s + pad * s + yShift;

  applyWorldTransform();
}

// ---------- PUZZLES ----------

  const PUZZLES = {
    perigal: {
      name: "Périgal",
      generate: (Ax, Ay, b, ratio) => {
        const a = b * ratio;
        const A={x:Ax, y:Ay}, B={x:Ax+b, y:Ay}, C={x:Ax, y:Ay+a};
        const TL={x:A.x, y:A.y-b}, TR={x:B.x, y:B.y-b}, L={x:A.x, y:A.y-(b-a)}, T={x:A.x+(b-a), y:A.y-b};
        const P = lineIntersection(L, TR, B, T);
        return [
          { key:"y",  fill:COLORS.yellow, points:[ TL, T, P, L ] },
          { key:"b",  fill:COLORS.blue,   points:[ T, TR, P ] },
          { key:"g",  fill:COLORS.gray,   points:[ B, TR, P ] },
          { key:"m",  fill:COLORS.magenta,points:[ A, B, P, L ] },
          { key:"sq", fill:COLORS.green,  points:[ {x:A.x-a, y:A.y}, {x:A.x, y:A.y}, {x:C.x, y:C.y}, {x:C.x-a, y:C.y} ] },
        ];
      }
    },

    bhaskara: {
      name: "Bhaskara",
      generate: (Ax, Ay, b, ratio) => {
        const a = b * ratio;
        const mkTri = (ox, oy, w, h) => [ {x:ox, y:oy}, {x:ox+w, y:oy}, {x:ox, y:oy+h} ];
        const sq = { key:"sq", fill:COLORS.softGray, points:[ {x:Ax-a, y:Ay}, {x:Ax, y:Ay}, {x:Ax, y:Ay+a}, {x:Ax-a, y:Ay+a} ]};
        const TopL = {x:Ax, y:Ay-b};
        return [
          { key:"t1", fill:COLORS.yellow, points: mkTri(TopL.x,     TopL.y,   a,  b) },
          { key:"t2", fill:COLORS.blue,   points: mkTri(TopL.x+a,   TopL.y+b, -a, -b) },
          { key:"t3", fill:COLORS.red,    points: mkTri(TopL.x+a,   TopL.y,   a,  b) },
          { key:"t4", fill:COLORS.green,  points: mkTri(TopL.x+2*a, TopL.y+b, -a, -b) },
          sq
        ];
      }
    },

    // Liu Hui (construction stable inspirée du document fourni)
    // 1 droite passant par A parallèle à l'hypoténuse BC
    // 1 droite passant par TL perpendiculaire à BC
    // => découpe du carré b² en 4 pièces + le carré a² entier
    leitzmann: {
      name: "Leitzmann",
      generate: (Ax, Ay, b, ratio) => {
        const a = b * ratio;
        const t = b / (a + b); // position du point sur la diagonale (construction Leitzmann)

        // Carré b² (sur AB, au-dessus)
        const A  = {x:Ax,   y:Ay};
        const B  = {x:Ax+b, y:Ay};
        const TL = {x:Ax,   y:Ay-b};
        const TR = {x:Ax+b, y:Ay-b};

        const Xb = { x: A.x + t*b, y: A.y - t*b }; // sur la diagonale A→TR
        const bTop    = { key:"bTop",    fill:COLORS.blue,      points:[ TL, TR, Xb ] };
        const bLeft   = { key:"bLeft",   fill:COLORS.lightblue, points:[ TL, A,  Xb ] };
        const bBottom = { key:"bBottom", fill:COLORS.teal,      points:[ A,  B,  Xb ] };
        const bRight  = { key:"bRight",  fill:COLORS.darkblue,  points:[ B,  TR, Xb ] };

        // Carré a² (sur AC, à gauche)
        const Aw = {x:Ax-a, y:Ay};
        const C  = {x:Ax,   y:Ay+a};
        const Cw = {x:Ax-a, y:Ay+a};

        const Xa = { x: Cw.x + t*a, y: Cw.y - t*a }; // sur la diagonale Cw→A
        const aTop    = { key:"aTop",    fill:COLORS.red,    points:[ Aw, A,  Xa ] };
        const aLeft   = { key:"aLeft",   fill:COLORS.orange, points:[ Aw, Cw, Xa ] };
        const aBottom = { key:"aBottom", fill:COLORS.yellow, points:[ Cw, C,  Xa ] };
        const aRight  = { key:"aRight",  fill:COLORS.green,  points:[ C,  A,  Xa ] };

        // Astuce : éviter 2 pièces identiques en "noir" (on n'en met pas)
        return [ bTop, bLeft, bBottom, bRight, aTop, aLeft, aBottom, aRight ];
      }
    }
,
    quatreIdentiques: {
      name: "4 pièces identiques",
      generate: (Ax, Ay, b, ratio) => {
        const a = b * ratio;
        const c = Math.hypot(a, b);

        // Direction parallèle à l'hypoténuse BC (sens quelconque)
        const u = { x: b / c, y: -a / c };
        const v = { x: a / c, y:  b / c }; // perpendiculaire

        function lineSquareIntersections(cx, cy, dx, dy, xmin, xmax, ymin, ymax){
          const pts = [];
          const eps = 1e-9;

          // x = xmin / xmax
          if(Math.abs(dx) > eps){
            let t = (xmin - cx)/dx;
            let y = cy + t*dy;
            if(y >= ymin-eps && y <= ymax+eps) pts.push({x:xmin, y, edge:"left"});
            t = (xmax - cx)/dx;
            y = cy + t*dy;
            if(y >= ymin-eps && y <= ymax+eps) pts.push({x:xmax, y, edge:"right"});
          }
          // y = ymin / ymax
          if(Math.abs(dy) > eps){
            let t = (ymin - cy)/dy;
            let x = cx + t*dx;
            if(x >= xmin-eps && x <= xmax+eps) pts.push({x, y:ymin, edge:"top"});
            t = (ymax - cy)/dy;
            x = cx + t*dx;
            if(x >= xmin-eps && x <= xmax+eps) pts.push({x, y:ymax, edge:"bottom"});
          }

          // dédoublonnage (cas où la droite passe pile par un coin)
          const uniq = [];
          for(const p of pts){
            if(!uniq.some(q => Math.hypot(p.x-q.x, p.y-q.y) < 1e-6)) uniq.push(p);
          }
          return uniq;
        }

        function pickEdgePoint(points, edge, corner){
          const candidates = points.filter(p=>p.edge===edge);
          if(!candidates.length) return null;
          let best=candidates[0], bestD=Infinity;
          for(const p of candidates){
            const d=Math.hypot(p.x-corner.x, p.y-corner.y);
            if(d<bestD){bestD=d; best=p;}
          }
          return {x:best.x, y:best.y};
        }

        function cutSquare4(xmin, xmax, ymin, ymax, center, u, v){
          const cx=center.x, cy=center.y;
          const all = [
            ...lineSquareIntersections(cx,cy,u.x,u.y,xmin,xmax,ymin,ymax),
            ...lineSquareIntersections(cx,cy,v.x,v.y,xmin,xmax,ymin,ymax)
          ];

          const TL={x:xmin,y:ymin}, TR={x:xmax,y:ymin}, BR={x:xmax,y:ymax}, BL={x:xmin,y:ymax};
          const C0={x:cx,y:cy};

          const top_TL    = pickEdgePoint(all,"top",TL);
          const left_TL   = pickEdgePoint(all,"left",TL);

          const right_TR  = pickEdgePoint(all,"right",TR);
          const top_TR    = pickEdgePoint(all,"top",TR);

          const bottom_BR = pickEdgePoint(all,"bottom",BR);
          const right_BR  = pickEdgePoint(all,"right",BR);

          const left_BL   = pickEdgePoint(all,"left",BL);
          const bottom_BL = pickEdgePoint(all,"bottom",BL);

          // ultra-sûr : si une intersection manque (cas extrême), on abandonne proprement
          if(!top_TL || !left_TL || !right_TR || !top_TR || !bottom_BR || !right_BR || !left_BL || !bottom_BL){
            return [];
          }

          return [
            { key:"q1", fill:COLORS.red,    points:[ TL, top_TL, C0, left_TL ] },
            { key:"q2", fill:COLORS.yellow, points:[ TR, right_TR, C0, top_TR ] },
            { key:"q3", fill:COLORS.blue,   points:[ BR, bottom_BR, C0, right_BR ] },
            { key:"q4", fill:COLORS.green,  points:[ BL, left_BL, C0, bottom_BL ] }
          ];
        }

        // Carrés : b² (au-dessus de A) et a² (à gauche de A)
        const aSquarePts = [
          {x:Ax-a, y:Ay}, {x:Ax, y:Ay}, {x:Ax, y:Ay+a}, {x:Ax-a, y:Ay+a}
        ];
        const bSquarePts = [
          {x:Ax, y:Ay-b}, {x:Ax+b, y:Ay-b}, {x:Ax+b, y:Ay}, {x:Ax, y:Ay}
        ];

        // Règle : le petit carré reste entier, le grand est découpé en 4 pièces identiques
        const keepA = a <= b;

        if(keepA){
          // a² entier, découpe b²
          const xmin=Ax, xmax=Ax+b, ymin=Ay-b, ymax=Ay;
          const center={x:(xmin+xmax)/2, y:(ymin+ymax)/2};
          const four = cutSquare4(xmin,xmax,ymin,ymax,center,u,v);
          const small = { key:"aSq", fill:COLORS.purple, points:aSquarePts };
          return [...four, small];
        } else {
          // b² entier, découpe a²
          const xmin=Ax-a, xmax=Ax, ymin=Ay, ymax=Ay+a;
          const center={x:(xmin+xmax)/2, y:(ymin+ymax)/2};
          const four = cutSquare4(xmin,xmax,ymin,ymax,center,u,v);
          const small = { key:"bSq", fill:COLORS.purple, points:bSquarePts };
          return [...four, small];
        }
      }
    }
  };

  // ---------- ÉNONCÉS ----------
  const ENONCES = {
    perigal: {
      title: "Puzzle 1 — Périgal",
      html: `
        <p><strong>Objectif :</strong> déplacer les <strong>5 pièces</strong> provenant de <em>a²</em> et <em>b²</em> pour reconstituer le carré de l'hypoténuse <em>c²</em>.</p>
        <p class="muted">Conseil : commence par placer la grande pièce quadrilatère, puis complète avec les triangles.</p>
        <ul>
          <li>Tu peux <strong>tourner</strong> (poignée ↻) et <strong>retourner</strong> une pièce (bouton <em>Retourner</em> ou double-clic rapide).</li>
          <li>Le <strong>snap</strong> est actif : relâche près d'un sommet (carré / autres pièces) pour aimanter.</li>
        </ul>
      `
    },
    bhaskara: {
      title: "Puzzle 2 — Bhāskara",
      html: `
        <p><strong>Objectif :</strong> placer <strong>4 triangles</strong> et le <strong>carré</strong> pour reconstruire <em>c²</em>.</p>
        <p class="muted">Indice : les 4 triangles forment une sorte de cadre ; le petit carré comble le trou central.</p>
      `
    },
    leitzmann: {
      title: "Puzzle 4 — Leitzmann",
      html: `
        <p><strong>Objectif :</strong> reconstituer <em>c²</em> avec <strong>8 triangles</strong> (4 venant de <em>a²</em> et 4 de <em>b²</em>).</p>
        <p class="muted">Indice : commence par placer 4 triangles pour dessiner le contour de <em>c²</em>, puis remplis.</p>
      `
    }
,
    quatreIdentiques: {
      title: "5. 4 pièces identiques + 1 carré",
      html: `
        <p>Le <strong>petit carré</strong> reste <strong>entier</strong>. L’autre carré est découpé en <strong>4 pièces identiques</strong>.</p>
        <p>Objectif : déplacer ces <strong>5 pièces</strong> pour reconstituer le carré incliné <em>c²</em>.</p>
        <ul>
          <li>Astuce : place d’abord le carré entier dans un coin de <em>c²</em>.</li>
          <li>Les 4 pièces identiques se complètent bien quand leurs arêtes « obliques » sont alignées avec le bord de <em>c²</em>.</li>
          <li>Tu peux <strong>retourner</strong> une pièce (bouton <em>Retourner</em> ou double‑clic).</li>
        </ul>
      `
    }
  };

  // ---------- Construction du moulin + snap ----------
  function buildMoulin(moulinId, Ax, Ay, b, ratio){
    const a=b*ratio;
    const c=Math.hypot(b, a);
    const A={x:Ax, y:Ay};
    const B={x:Ax+b, y:Ay};
    const C={x:Ax, y:Ay+a};

    // carré sur l'hypoténuse (incliné) : à partir de BC
    const w={x:a, y:b};
    const Bw={x:B.x+w.x, y:B.y+w.y};
    const Cw={x:C.x+w.x, y:C.y+w.y};

    const mold = {
      id:moulinId,
      a, b, c,
      corners:[B, C, Cw, Bw],
      uvec:{x:(B.x-C.x)/c, y:(B.y-C.y)/c},
      vvec:{x:(Cw.x-C.x)/c, y:(Cw.y-C.y)/c},
      bbox:bboxOfPoints([B,C,Cw,Bw])
    };

    // points d'aimantation dans le carré incliné (coins + quelques points utiles)
    const snapsUV = [
      {u:0,v:0},{u:c,v:0},{u:0,v:c},{u:c,v:c},
      {u:a,v:0},{u:0,v:a},{u:a,v:a},{u:a,v:c},{u:c,v:a},{u:c/2,v:c/2}
    ];
    const snapPoints = snapsUV.map(s => ({
      x:C.x + s.u*mold.uvec.x + s.v*mold.vvec.x,
      y:C.y + s.u*mold.uvec.y + s.v*mold.vvec.y,
      moulinId
    }));

    const piecesDef = PUZZLES[state.puzzle].generate(Ax, Ay, b, ratio);
    return {moulinId, A,B,C, Bw,Cw, pieces: piecesDef, mold, snapPoints};
  }

  function buildScene(){
    while(world.firstChild) world.removeChild(world.firstChild);
    state.pieces.clear();
    state.snapPoints=[];
    state.molds=[];

    const b=BASE.b, r=BASE.ratio, a=b*r;
    const left = buildMoulin("L", BASE.margin+a, BASE.margin+b, b, r);
    const right = buildMoulin("R", BASE.margin+a+(b+2*a)+BASE.gap, BASE.margin+b, b, r);

    state.moulins = {L:left, R:right};
    state.molds.push(left.mold, right.mold);
    state.snapPoints.push(...left.snapPoints, ...right.snapPoints);

    const gB=svgEl("g", {id:"boards"});
    const gP=svgEl("g", {id:"pieces"});
    const gL=svgEl("g", {id:"labels"});
    world.append(gB, gP, gL);

    [left, right].forEach(m => {
      const {A,B,C,Bw,Cw} = m;

      const gBM = svgEl("g", {id:"boards"+m.moulinId});
      gB.appendChild(gBM);

      // Carrés des deux côtés de l'angle droit
      gBM.append(
        svgEl("rect",{x:A.x,y:A.y-b,width:b,height:b,class:"boardLine"}),
        svgEl("rect",{x:A.x-a,y:A.y,width:a,height:a,class:"boardLine"})
      );

      // Triangle ABC
      gBM.append(
        svgEl("line",{x1:A.x,y1:A.y,x2:B.x,y2:B.y,class:"thinLine"}),
        svgEl("line",{x1:A.x,y1:A.y,x2:C.x,y2:C.y,class:"thinLine"}),
        svgEl("line",{x1:B.x,y1:B.y,x2:C.x,y2:C.y,class:"thinLine"})
      );

      // Carré sur l'hypoténuse
      gBM.appendChild(svgEl("polygon", {
        points:`${B.x},${B.y} ${C.x},${C.y} ${Cw.x},${Cw.y} ${Bw.x},${Bw.y}`,
        class:"boardLine"
      }));

      // Angle droit (repère)
      const ra=24;
      gBM.appendChild(svgEl("polyline", {
        points:`${A.x},${A.y} ${A.x+ra},${A.y} ${A.x+ra},${A.y+ra} ${A.x},${A.y+ra}`,
        class:"rightAngle"
      }));

      // Lettres
      [{x:A.x-28,y:A.y-14,t:"A"},{x:B.x+10,y:B.y+6,t:"B"},{x:C.x-14,y:C.y+26,t:"C"}].forEach(l=>{
        const t=svgEl("text",{x:l.x,y:l.y,class:"label","data-side":m.moulinId});
        t.textContent=l.t;
        gL.appendChild(t);
      });


      // Aperçu des pièces sur le moulin de droite (non déplaçable)
      if(m.moulinId === "R"){
        const gPrev = svgEl("g",{id:"previewR"});
        m.pieces.forEach(pdef => {
          const pts = pdef.points.map(p => `${p.x.toFixed(2)},${p.y.toFixed(2)}`).join(" ");
          gPrev.appendChild(svgEl("polygon",{points:pts, fill:(pdef.fill||"#cccccc"), class:"previewPoly"}));
        });
        gBM.appendChild(gPrev);
      }

      if(m.moulinId === "L"){

      // Pièces
      m.pieces.forEach(pdef => {
        const id=`${m.moulinId}-${pdef.key}`;
        const ctr=polygonCentroid(pdef.points);
        const lPts=pdef.points.map(q=>({x:q.x-ctr.x,y:q.y-ctr.y}));

        const g=svgEl("g",{"data-id":id});
        const poly=svgEl("polygon",{
          class:"piecePoly",
          fill:pdef.fill,
          points:lPts.map(q=>`${q.x},${q.y}`).join(" ")
        });

        const gh=svgEl("g",{class:"handle","data-id":id,style:"display:none;"});
        gh.append(
          svgEl("line",{x1:0,y1:0,x2:0,y2:-64,class:"handleLine"}),
          svgEl("circle",{cx:0,cy:-64,r:18,class:"handleDot"})
        );
        const it=svgEl("text",{x:0,y:-64,"text-anchor":"middle","dominant-baseline":"central",style:"font-size:22px;font-weight:900;"});
        it.textContent="↻";
        gh.appendChild(it);

        g.append(poly, gh);
        gP.appendChild(g);

        const p={
          id,
          pos:{...ctr},
          rot:0,
          flipX:false,
          home:{...ctr},
          el:g,
          polyEl:poly,
          handleEl:gh,
          verticesLocal:lPts
        };

        state.pieces.set(id,p);
        applyPieceTransform(p);

        poly.addEventListener("pointerdown", onPiecePointerDown);
        gh.addEventListener("pointerdown", onHandlePointerDown);

        // Double-clic natif si le navigateur le laisse passer
        poly.addEventListener("dblclick", (e)=>{
          e.preventDefault(); e.stopPropagation();
          setSelected(id);
          flipPiece(id);
        });
      });
      }
    });

    fitWorldToViewport();
  }

  // ---------- Interactions ----------
  function onPiecePointerDown(evt){
    evt.preventDefault();
    evt.stopPropagation();
    const id=evt.currentTarget.closest("g").getAttribute("data-id");
    setSelected(id);
    const p0 = clientToWorld(evt);
    state.dragging={
      type:"move",
      pieceId:id,
      startPointer:p0,
      startPos:{...state.pieces.get(id).pos}
    };
    evt.currentTarget.setPointerCapture(evt.pointerId);
  }

  function onHandlePointerDown(evt){
    evt.preventDefault();
    evt.stopPropagation();
    const id=evt.currentTarget.getAttribute("data-id");
    const p0=clientToWorld(evt);
    const piece=state.pieces.get(id);
    setSelected(id);
    state.dragging={
      type:"rotate",
      pieceId:id,
      startPointer:p0,
      startAngleRad:Math.atan2(p0.y-piece.pos.y,p0.x-piece.pos.x),
      startRot:piece.rot
    };
    evt.currentTarget.setPointerCapture(evt.pointerId);
  }

  stage.addEventListener("pointermove", evt => {
    if(!state.dragging) return;
    const piece=state.pieces.get(state.dragging.pieceId);
    const p=clientToWorld(evt);
    state.lastPointerWorld = p;

    if(state.dragging.type==="move"){
      piece.pos.x=state.dragging.startPos.x+(p.x-state.dragging.startPointer.x);
      piece.pos.y=state.dragging.startPos.y+(p.y-state.dragging.startPointer.y);
    } else {
      const a=Math.atan2(p.y-piece.pos.y,p.x-piece.pos.x);
      piece.rot=state.dragging.startRot+deg(a-state.dragging.startAngleRad);
      if(state.angleSnapEnabled && !evt.shiftKey){
        const candidates=[0,90,180,270];
        let best=null, bestD=Infinity;
        candidates.forEach(c=>{
          const d=Math.abs(normAngleDeg(piece.rot-c));
          if(d<bestD){bestD=d;best=c;}
        });
        if(bestD<SNAP.rot) piece.rot=best;
      }
    }
    applyPieceTransform(piece);
  });

  stage.addEventListener("pointerup", (evt) => {
    if(!state.dragging) return;
    const id = state.dragging.pieceId;
    const piece = state.pieces.get(id);

    // Détection double-clic/ double-tap "maison" (robuste SVG)
    const endP = state.lastPointerWorld || clientToWorld(evt);
    const moveDist = Math.hypot(endP.x - state.dragging.startPointer.x, endP.y - state.dragging.startPointer.y);
    const isTap = moveDist <= TAP_MOVE_TOL;

    const now = performance.now();
    if(isTap){
      if(state.lastTap && state.lastTap.pieceId===id && (now - state.lastTap.time) <= DOUBLE_TAP_MS){
        flipPiece(id);
        state.lastTap = null;
      } else {
        state.lastTap = {pieceId:id, time:now};
      }
    }

    state.dragging=null;

    // Snap : vers le carré c² + vers les sommets des autres pièces (pour aider à fermer le pavage)
    if(piece && state.snapEnabled){
      const verts = pieceWorldVertices(piece);
      const targets = [...state.snapPoints];

      for(const [oid, op] of state.pieces.entries()){
        if(oid === id) continue;
        const oVerts = pieceWorldVertices(op);
        for(const v of oVerts) targets.push({x:v.x, y:v.y});
      }

      let bestDelta=null, minD=Infinity;
      const threshold = SNAP.posStrong;

      for(const v of verts){
        for(const t of targets){
          const d=Math.hypot(v.x-t.x,v.y-t.y);
          if(d < minD && d < threshold){
            minD=d;
            bestDelta={x:t.x-v.x,y:t.y-v.y};
          }
        }
      }

      if(bestDelta){
        piece.pos.x += bestDelta.x;
        piece.pos.y += bestDelta.y;
        applyPieceTransform(piece);
      }
    }
  });

  // Sélection via clic sur le fond
  stage.addEventListener("pointerdown", (evt)=>{
    // si clic sur le fond du SVG (pas sur une pièce)
    if(evt.target === stage || evt.target === world){
      setSelected(null);
    }
  });

  // ---------- UI ----------
  function setMode(mode){
    state.mode = mode;
    if(mode === "vide"){
      btnModeVide.classList.add("on");
      btnModeEleves.classList.remove("on");
      stage.classList.add("modeVide");

    } else {
      btnModeEleves.classList.add("on");
      btnModeVide.classList.remove("on");
      stage.classList.remove("modeVide");
    }
    
    // Visibilité robuste (pour le centrage et pour que #labels puisse fonctionner en mode vide)
    const gPieces = document.getElementById("pieces");
    const gBoardsR = document.getElementById("boardsR");
    if(gPieces)  gPieces.style.display  = (mode === "vide") ? "none" : "";
    if(gBoardsR) gBoardsR.style.display = (mode === "vide") ? "none" : "";
    // On masque aussi les lettres du moulin droit en mode vide (sinon elles peuvent influencer le centrage)
    document.querySelectorAll('.label[data-side="R"]').forEach(el=>{
      el.style.display = (mode === "vide") ? "none" : "";
    });
    fitWorldToViewport();
  }

  btnModeEleves.onclick = () => setMode("eleves");
  btnModeVide.onclick   = () => setMode("vide");

  toggleLetters.onclick = () => {
    state.lettersEnabled = !state.lettersEnabled;
    toggleLetters.classList.toggle("on", state.lettersEnabled);
    stage.classList.toggle("showLetters", state.lettersEnabled);
    if(state.mode === "vide") fitWorldToViewport();
  };

  btnReset.onclick = () => {
    state.pieces.forEach(p=>{
      p.pos={...p.home};
      p.rot=0;
      p.flipX=false;
      applyPieceTransform(p);
    });
    setSelected(null);
  };

  btnFlip.onclick = () => {
    if(state.mode === "vide") return;
    if(state.selectedId) flipPiece(state.selectedId);
  };

  puzzleSelect.onchange = (e) => {
    state.puzzle = e.target.value;
    buildScene();
    // garder le mode actuel
    if(state.mode === "vide") stage.classList.add("modeVide");
    fitWorldToViewport();
  };

  btnFullscreen.onclick = () => {
    if(!document.fullscreenElement) document.documentElement.requestFullscreen();
    else document.exitFullscreen();
  };


  // ---------- Énoncé (impression) ----------
  btnEnonce.onclick = openEnonce;

  function openEnonce(){
    const html = buildEnonceHTML();
    const w = window.open("", "_blank");
    if(!w){
      modalTitle.textContent = "Énoncé";
      modalBody.innerHTML = `<p class="muted">Le navigateur a bloqué l’ouverture de la fenêtre d’impression. Autorise les pop-ups pour cette page (ou clique à nouveau après autorisation), puis réessaie.</p>`;
      modal.style.display = "flex";
      return;
    }
    w.document.open();
    w.document.write(html);
    w.document.close();
    w.focus();
  }

  // Énoncé (impression) — reprise fidèle de l’énoncé d’origine, mais adaptable au puzzle sélectionné
  function buildEnonceHTML() {
  const puzzleLabel = state.puzzleLabel || "Puzzle";
  const svgPage1 = buildPage1SVG();
  const svgEmptyDouble = buildEmptyDoubleSVG();
  const svgApplication = buildApplicationMoulinSVG(5, 12);
  const miniSheet = buildMiniSkeletonSheetHTML(8);

  return `
<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8"/>
  <title>Énoncé – Moulin de Pythagore</title>
  <style>
    @page { size: A4 landscape; margin: 7mm; }
    * { box-sizing: border-box; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 0; color: #0f172a; }
    .page { break-after: page; padding: 0; }
    .page:last-child { break-after: auto; }

    h1 { margin: 0 0 8px; font-size: 22px; }
    h2 { margin: 0 0 6px; font-size: 18px; }
    p { margin: 6px 0; font-size: 14px; line-height: 1.25; }

    .hint { font-size: 13px; color: #334155; }
    .row { display: flex; gap: 14px; align-items: flex-start; }
    .col { flex: 1; min-width: 0; }
    .figureWrap { border: 0; border-radius: 0; padding: 0; margin-top: 8px; }
    .bilanBox { border: 2.4px solid #0f172a; border-radius: 12px; height: 160mm; margin-top: 10px; }
    .bigLine { font-size: 18px; margin-top: 10px; }

    svg { width: 100%; height: auto; display: block; }
    .sq { stroke:#0f172a; stroke-width:2; }
    .sqEmpty { fill: #ffffff; stroke:#0f172a; stroke-width:2.6; }
    .edge { stroke:#0f172a; stroke-width:2.2; }
    .bigSq { fill:#ffffff; stroke:#0f172a; stroke-width:2.6; }
    .rightAngle { fill:none; stroke:#0f172a; stroke-width:3.0; }
    .piece { stroke:#0f172a; stroke-width:1.6; fill-opacity:0.88; }
    .label { font-size: 22px; font-weight: 700; }
    .tag { font-size: 22px; font-weight: 800; }
    .data { font-size: 18px; font-weight: 650; fill:#0f172a; }

    /* Styles pour les squelettes (évite les remplissages noirs par défaut) */
    .boardLine { fill:none; stroke:#0f172a; stroke-width:2.6; }
    .thinLine { fill:none; stroke:#0f172a; stroke-width:2.2; }
    .abc { font-size: 22px; font-weight: 700; fill:#0f172a; }
    .subtitle { font-size: 20px; font-weight: 650; fill:#0f172a; }

    /* Application : on force une taille qui tient sur la page */
    .appFigure{ display:flex; justify-content:center; }
    .appFigure svg{ width: 175mm; height: auto; }

    /* Mini moulins : exactement le même dessin, juste réduit */
    .miniGrid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; break-inside: avoid; }
    .miniCell { border: 0; padding: 0; break-inside: avoid; }
    .miniCell svg { width: 100%; height: auto; display: block; }
  </style>
</head>
<body onload="window.print()">

  <!-- PAGE 1 -->
  <section class="page">
    <h1>Moulin de Pythagore – ${escapeHTML(puzzleLabel)}</h1>
    <p><b>Consigne :</b> Découpe les pièces du moulin <b>1</b>. Sans découper le moulin <b>2</b>, reconstitue le grand carré blanc du moulin 2 à l'aide des pièces découpées.</p>
    <p class="hint">Conseil : commence par placer les plus grandes pièces, puis complète avec les plus petites.</p>
    <div class="figureWrap">${svgPage1}</div>
  </section>

  <!-- PAGE 2 -->
  <section class="page">
    <h2>Bilan</h2>
    <p><b>Question :</b> Quels liens y a-t-il entre l'aire du petit carré, du moyen carré et du grand carré ? Explique avec tes mots.</p>
    <div class="bilanBox"></div>
  </section>

  <!-- PAGE 3 -->
  <section class="page">
    <h2>Application – Calculer BC</h2>
    <p>On considère un triangle rectangle en A avec <b>AB = 5 cm</b> et <b>AC = 12 cm</b>.</p>
    <p>En utilisant le moulin ci-dessous (on écrit directement dans les carrés), calcule <b>BC</b>.</p>
    <div class="figureWrap appFigure">${svgApplication}</div>
    <div class="bigLine"><b>BC =</b> ____________________ cm</div>
  </section>

  <!-- PAGE 4 -->
  <section class="page">
    <h2>Moulins vides</h2>
    <p>Tu peux t'entraîner : remplis les carrés (aires) puis déduis la longueur manquante.</p>
    <div class="figureWrap">${svgEmptyDouble}</div>
  </section>

  <!-- PAGE 5 -->
  <section class="page">
    ${miniSheet}
  </section>

</body>
</html>`;
}

  // ----- SVG : page 1 (deux moulins) -----
  function buildPage1SVG() {
  const L = state.moulins?.L;
  const R = state.moulins?.R;
  if (!L || !R) return `<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"></svg>`;

  const pts = [];
  for (const m of [L, R]) {
    const { a, b } = m.mold;
    const TL = { x: m.A.x, y: m.A.y - b };
    const TR = { x: m.B.x, y: m.B.y - b };
    pts.push(m.A, m.B, m.C, m.Bw, m.Cw, TL, TR, { x: m.A.x - a, y: m.A.y }, { x: m.A.x - a, y: m.C.y });
    pts.push(...m.mold.corners);
    if (Array.isArray(m.pieces)) {
      for (const pd of m.pieces) pts.push(...pd.points);
    }
  }

  const bb = bboxOfPoints(pts);
  const pad = 28;
  const vb = `${(bb.minX - pad).toFixed(2)} ${(bb.minY - pad).toFixed(2)} ${(bb.w + 2 * pad).toFixed(2)} ${(bb.h + 2 * pad).toFixed(2)}`;

  const tag1x = L.A.x + 14, tag1y = (L.A.y - L.mold.b) + 30;
  const tag2x = R.A.x + 14, tag2y = (R.A.y - R.mold.b) + 30;

  return `
<svg viewBox="${vb}" xmlns="http://www.w3.org/2000/svg" aria-label="Deux moulins de Pythagore">
  <text class="tag" x="${tag1x}" y="${tag1y}">1</text>
  <text class="tag" x="${tag2x}" y="${tag2y}">2</text>
  ${drawMoulinStatic(L, true)}
  ${drawMoulinStatic(R, true)}
</svg>`;
}

  function drawMoulinStatic(m, withPieces = true) {
  const { a, b } = m.mold;

  const TL = { x: m.A.x, y: m.A.y - b };
  const TR = { x: m.B.x, y: m.B.y - b };

  // Petit marqueur d'angle droit (au point A)
  const raSize = 18;
  const ra = [
    `${m.A.x},${m.A.y}`,
    `${m.A.x + raSize},${m.A.y}`,
    `${m.A.x + raSize},${m.A.y + raSize}`,
    `${m.A.x},${m.A.y + raSize}`,
  ].join(" ");

  // Carré de l'hypoténuse (grand carré blanc)
  const bigSqPts = [m.B, m.C, m.Cw, m.Bw].map(p => `${p.x},${p.y}`).join(" ");

  // Carrés colorés (a² et b²) — couleurs lisibles à l'impression
  const fillB = COLORS.lightBlue;
  const fillA = COLORS.lightRed;

  let piecesSvg = "";
  if (withPieces && Array.isArray(m.pieces)) {
    // On dessine les pièces "au repos" (dans les petits carrés), telles que générées par le puzzle
    for (const pd of m.pieces) {
      const pts = pd.points.map(p => `${p.x.toFixed(2)},${p.y.toFixed(2)}`).join(" ");
      const fill = pd.fill || "#cccccc";
      piecesSvg += `<polygon class="piece" points="${pts}" fill="${fill}"></polygon>`;
    }
  }

  return `
  <g class="moulinStatic">
    <!-- Carré b² (au-dessus de AB) -->
    <rect x="${m.A.x}" y="${m.A.y - b}" width="${b}" height="${b}" class="sq" fill="${fillB}"></rect>
    <!-- Carré a² (à gauche de AC) -->
    <rect x="${m.A.x - a}" y="${m.A.y}" width="${a}" height="${a}" class="sq" fill="${fillA}"></rect>

    <!-- Triangle + grand carré -->
    <polygon class="bigSq" points="${bigSqPts}"></polygon>
    <line class="edge" x1="${m.A.x}" y1="${m.A.y}" x2="${m.B.x}" y2="${m.B.y}"></line>
    <line class="edge" x1="${m.A.x}" y1="${m.A.y}" x2="${m.C.x}" y2="${m.C.y}"></line>
    <line class="edge" x1="${m.B.x}" y1="${m.B.y}" x2="${m.C.x}" y2="${m.C.y}"></line>

    <polyline class="rightAngle" points="${ra}"></polyline>

    ${piecesSvg}

    <!-- Lettres -->
    <text class="label" x="${m.A.x - 34}" y="${m.A.y - 18}">A</text>
    <text class="label" x="${m.B.x + 12}" y="${m.B.y - 14}">B</text>
    <text class="label" x="${m.C.x - 26}" y="${m.C.y + 40}">C</text>
  </g>`;
}

  // ----- SVG : squelettes vides -----
  function drawMoulinSkeleton(m){
    const a = m.mold.a, b = m.mold.b;
    const B = m.B, C = m.C, Bw = m.Bw, Cw = m.Cw;

    const bigSqPts = [B,C,Cw,Bw].map(p=>`${p.x.toFixed(2)},${p.y.toFixed(2)}`).join(" ");

    const ra = Math.max(18, Math.min(34, b*0.08));
    const raPts = [
      {x:m.A.x, y:m.A.y},
      {x:m.A.x+ra, y:m.A.y},
      {x:m.A.x+ra, y:m.A.y+ra},
      {x:m.A.x, y:m.A.y+ra},
    ];

    const labA = {x: m.A.x - 34, y: m.A.y - 12, t:"A"};
    const labB = {x: m.B.x + 10, y: m.B.y + 8, t:"B"};
    const labC = {x: m.C.x - 16, y: m.C.y + 30, t:"C"};

    return `<g>
      <rect class="boardLine" x="${m.A.x}" y="${m.A.y - b}" width="${b}" height="${b}"/>
      <rect class="boardLine" x="${m.A.x - a}" y="${m.A.y}" width="${a}" height="${a}"/>

      <line class="thinLine" x1="${m.A.x}" y1="${m.A.y}" x2="${m.B.x}" y2="${m.B.y}"/>
      <line class="thinLine" x1="${m.A.x}" y1="${m.A.y}" x2="${m.C.x}" y2="${m.C.y}"/>
      <line class="thinLine" x1="${m.B.x}" y1="${m.B.y}" x2="${m.C.x}" y2="${m.C.y}"/>

      <polygon class="boardLine" points="${bigSqPts}"/>

      <polyline class="rightAngle" points="${raPts.map(p=>`${p.x},${p.y}`).join(" ")}"/>

      <text class="abc" x="${labA.x}" y="${labA.y}">${labA.t}</text>
      <text class="abc" x="${labB.x}" y="${labB.y}">${labB.t}</text>
      <text class="abc" x="${labC.x}" y="${labC.y}">${labC.t}</text>
    </g>`;
  }

  function buildEmptyDoubleSVG() {
  const L = state.moulins?.L;
  const R = state.moulins?.R;
  if (!L || !R) return `<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"></svg>`;

  const pts = [];
  for (const m of [L, R]) {
    const { a, b } = m.mold;
    const TL = { x: m.A.x, y: m.A.y - b };
    const TR = { x: m.B.x, y: m.B.y - b };
    pts.push(m.A, m.B, m.C, m.Bw, m.Cw, TL, TR, { x: m.A.x - a, y: m.A.y }, { x: m.A.x - a, y: m.C.y });
    pts.push(...m.mold.corners);
  }
  const bb = bboxOfPoints(pts);
  const pad = 26;
  const vb = `${(bb.minX - pad).toFixed(2)} ${(bb.minY - pad).toFixed(2)} ${(bb.w + 2 * pad).toFixed(2)} ${(bb.h + 2 * pad).toFixed(2)}`;

  return `
<svg viewBox="${vb}" xmlns="http://www.w3.org/2000/svg" aria-label="Deux moulins vides">
  ${drawMoulinSkeleton(L)}
  ${drawMoulinSkeleton(R)}
</svg>`;
}

function buildApplicationMoulinSVG(AB_cm = 5, AC_cm = 12) {
  // Grand moulin "vide" pour écrire dedans (application du théorème de Pythagore)
  const ratio = AC_cm / AB_cm;

  // Dimensions "visuelles" (en unités SVG) : on veut un grand carré assez large pour écrire dedans
  const b = 150;               // correspond à AB (visuel)
  const a = b * ratio;         // correspond à AC (visuel)
  const Ax = 0, Ay = 0;

  // Géométrie du moulin (sans dépendre d'un puzzle particulier)
  const A = { x: Ax, y: Ay };
  const B = { x: Ax + b, y: Ay };
  const C = { x: Ax, y: Ay + a };
  const w = { x: a, y: b };
  const Bw = { x: B.x + w.x, y: B.y + w.y };
  const Cw = { x: C.x + w.x, y: C.y + w.y };

  const mold = {
    a, b,
    c: Math.hypot(a, b),
    corners: [A, B, C, Bw, Cw, { x: Ax - a, y: Ay }, { x: Ax - a, y: Ay + a }, { x: Ax, y: Ay - b }, { x: Ax + b, y: Ay - b }]
  };

  const m = { A, B, C, Bw, Cw, mold };

  // BBox
  const bb = bboxOfPoints(mold.corners);
  const pad = 30;
  const vb = `${(bb.minX - pad).toFixed(2)} ${(bb.minY - pad).toFixed(2)} ${(bb.w + 2 * pad).toFixed(2)} ${(bb.h + 2 * pad).toFixed(2)}`;

  // Labels
  const midAB = { x: (A.x + B.x) / 2, y: (A.y + B.y) / 2 };
  const midAC = { x: (A.x + C.x) / 2, y: (A.y + C.y) / 2 };

  const raSize = 18;
  const ra = [
    `${A.x},${A.y}`,
    `${A.x + raSize},${A.y}`,
    `${A.x + raSize},${A.y + raSize}`,
    `${A.x},${A.y + raSize}`,
  ].join(" ");

  const bigSqPts = [B, C, Cw, Bw].map(p => `${p.x},${p.y}`).join(" ");

  return `
<svg viewBox="${vb}" xmlns="http://www.w3.org/2000/svg" aria-label="Moulin vide pour application">
  <g class="moulinStatic">
    <!-- Carrés vides -->
    <rect x="${A.x}" y="${A.y - b}" width="${b}" height="${b}" class="sqEmpty"></rect>
    <rect x="${A.x - a}" y="${A.y}" width="${a}" height="${a}" class="sqEmpty"></rect>
    <polygon class="bigSq" points="${bigSqPts}"></polygon>

    <!-- Triangle -->
    <line class="edge" x1="${A.x}" y1="${A.y}" x2="${B.x}" y2="${B.y}"></line>
    <line class="edge" x1="${A.x}" y1="${A.y}" x2="${C.x}" y2="${C.y}"></line>
    <line class="edge" x1="${B.x}" y1="${B.y}" x2="${C.x}" y2="${C.y}"></line>
    <polyline class="rightAngle" points="${ra}"></polyline>

    <!-- Lettres -->
    <text class="label" x="${A.x - 34}" y="${A.y - 18}">A</text>
    <text class="label" x="${B.x + 12}" y="${B.y - 14}">B</text>
    <text class="label" x="${C.x - 26}" y="${C.y + 40}">C</text>

    <!-- Données -->
    <text class="data" x="${midAB.x}" y="${midAB.y - 12}" text-anchor="middle">AB = ${AB_cm} cm</text>
    <text class="data" x="${midAC.x - 10}" y="${midAC.y}" text-anchor="end" dominant-baseline="middle">AC = ${AC_cm} cm</text>
  </g>
</svg>`;
}


  function buildSingleSkeletonSVG(){
    const m = state.moulins?.L;
    if(!m) return `<svg viewBox="0 0 10 10"></svg>`;

    const pts = [];
    const a = m.mold.a, b = m.mold.b;
    pts.push(m.A,m.B,m.C,m.Bw,m.Cw);
    pts.push({x:m.A.x, y:m.A.y-b}, {x:m.A.x+b, y:m.A.y-b}, {x:m.A.x+b, y:m.A.y}, {x:m.A.x, y:m.A.y});
    pts.push({x:m.A.x-a, y:m.A.y}, {x:m.A.x-a, y:m.A.y+a}, {x:m.A.x, y:m.A.y+a});
    pts.push(...m.mold.corners);

    const bb = bboxOfPoints(pts);
    const pad = 14;
    const vb = `${(bb.minX-pad).toFixed(2)} ${(bb.minY-pad).toFixed(2)} ${(bb.w+2*pad).toFixed(2)} ${(bb.h+2*pad).toFixed(2)}`;

    return `<svg viewBox="${vb}" xmlns="http://www.w3.org/2000/svg" aria-label="Moulin vide (squelette)">
      ${drawMoulinSkeleton(m)}
    </svg>`;
  }

  function buildMiniSkeletonSheetHTML(count = 12) {
  // Mini moulins vides : EXACTEMENT le même dessin que le moulin principal, simplement réduit via CSS.
  // (Ainsi, c’est une vraie réduction, pas un autre moulin “reconstruit” avec des dimensions différentes.)
  const baseSVG = buildSingleSkeletonSVG();
  const cells = Array.from({ length: count }, () => `<div class="miniCell">${baseSVG}</div>`).join("");
  return `<div class="miniGrid">${cells}</div>`;
}


  // ----- SVG : triangle rectangle (AB, AC donnés) -----
  function buildTriangleSVG(abCm, acCm){
    // (copie fidèle de l’énoncé d’origine : juste la figure + les longueurs, sans zones "calculs")
    const scale = 12; // px par mm (approximatif)
    const ab = abCm * 10 * scale;
    const ac = acCm * 10 * scale;

    const margin = 70;
    const A = {x: margin + ac + 120, y: margin + ab + 120};
    const B = {x: A.x + ab, y: A.y};
    const C = {x: A.x, y: A.y + ac};

    // Carré sur AB (au-dessus)
    const AB2 = {x: B.x, y: B.y - ab};
    const AA2 = {x: A.x, y: A.y - ab};

    // Carré sur AC (à gauche)
    const CC2 = {x: C.x - ac, y: C.y};
    const AA3 = {x: A.x - ac, y: A.y};

    // Carré sur BC
    const w = {x: ac, y: ab};
    const Bw = {x: B.x + w.x, y: B.y + w.y};
    const Cw = {x: C.x + w.x, y: C.y + w.y};

    const ra = 70;
    const raPts = [
      {x:A.x, y:A.y},
      {x:A.x+ra, y:A.y},
      {x:A.x+ra, y:A.y+ra},
      {x:A.x, y:A.y+ra},
    ];

    const ptsAll = [A,B,C,AB2,AA2,CC2,AA3,Bw,Cw];
    const bb = bboxOfPoints(ptsAll);
    const pad = 90;
    const vb = `${(bb.minX-pad).toFixed(2)} ${(bb.minY-pad).toFixed(2)} ${(bb.w+2*pad).toFixed(2)} ${(bb.h+2*pad).toFixed(2)}`;

    return `<svg viewBox="${vb}" xmlns="http://www.w3.org/2000/svg" aria-label="Triangle rectangle avec carrés">
      <!-- carrés -->
      <polygon class="boardLine" points="${[A,B,AB2,AA2].map(p=>`${p.x},${p.y}`).join(" ")}"/>
      <polygon class="boardLine" points="${[A,C,CC2,AA3].map(p=>`${p.x},${p.y}`).join(" ")}"/>
      <polygon class="boardLine" points="${[B,C,Cw,Bw].map(p=>`${p.x},${p.y}`).join(" ")}"/>

      <!-- triangle -->
      <line class="thinLine" x1="${A.x}" y1="${A.y}" x2="${B.x}" y2="${B.y}"/>
      <line class="thinLine" x1="${A.x}" y1="${A.y}" x2="${C.x}" y2="${C.y}"/>
      <line class="thinLine" x1="${B.x}" y1="${B.y}" x2="${C.x}" y2="${C.y}"/>
      <polyline class="rightAngle" points="${raPts.map(p=>`${p.x},${p.y}`).join(" ")}"/>

      <!-- points -->
      <circle cx="${A.x}" cy="${A.y}" r="10" fill="#000"/>
      <circle cx="${B.x}" cy="${B.y}" r="10" fill="#000"/>
      <circle cx="${C.x}" cy="${C.y}" r="10" fill="#000"/>

      <!-- labels -->
      <text class="subtitle" x="${A.x-30}" y="${A.y-30}">A</text>
      <text class="subtitle" x="${B.x+20}" y="${B.y+20}">B</text>
      <text class="subtitle" x="${C.x-30}" y="${C.y+55}">C</text>

      <text class="subtitle" x="${(A.x+B.x)/2}" y="${A.y-24}" text-anchor="middle">AB = ${abCm} cm</text>
      <text class="subtitle" x="${A.x-24}" y="${(A.y+C.y)/2}" text-anchor="end">AC = ${acCm} cm</text>
      <text class="subtitle" x="${(B.x+C.x)/2 + 28}" y="${(B.y+C.y)/2 + 18}" text-anchor="start">BC = ? cm</text>
    </svg>`;
  }

// ----- utilitaires (impression) -----
  function pieceVerticesAt(piece, cx, cy, rotDeg, flipX){
    const vs = piece.verticesLocal || [];
    const out = [];
    const ang = rotDeg ? (Math.PI * rotDeg / 180) : 0;
    const cos = Math.cos(ang), sin = Math.sin(ang);
    for(const v of vs){
      const lx = flipX ? -v.x : v.x;
      const ly = v.y;
      // rotation autour du centroïde (cx,cy)
      const rx = (lx * cos) - (ly * sin);
      const ry = (lx * sin) + (ly * cos);
      out.push({x: cx + rx, y: cy + ry});
    }
    return out;
  }

  function escapeHTML(str){
    return String(str)
      .replace(/&/g,"&amp;")
      .replace(/</g,"&lt;")
      .replace(/>/g,"&gt;")
      .replace(/"/g,"&quot;")
      .replace(/'/g,"&#039;");
  }


  // On garde le modal en secours (popup bloquée) + clic de fond neutralisé
  function closeEnonce(){ modal.style.display = "none"; }
  modalClose.onclick = closeEnonce;
  modal.addEventListener("pointerdown", (e)=>{ e.preventDefault(); e.stopPropagation(); });

  // ---------- init ----------
  buildScene();
  window.addEventListener("resize", fitWorldToViewport);
})();
</script>
</body>
</html>
