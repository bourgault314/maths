<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stats City - La ville des statistiques</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;800&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Fredoka', sans-serif;
            background-color: #0f172a;
            color: white;
            overflow: hidden;
            user-select: none;
            touch-action: none;
        }

        /* --- UI ELEMENTS --- */
        .nav-btn {
            padding: 8px 20px; border-radius: 12px; font-weight: 800; font-size: 1rem;
            transition: all 0.2s; border: 2px solid transparent;
            background: rgba(30, 41, 59, 0.5); color: #94a3b8; cursor: pointer;
        }
        .nav-btn:hover { background: rgba(51, 65, 85, 0.8); color: white; }
        .nav-btn.active {
            background: #3b82f6; /* Bleu */
            color: white; border-color: #60a5fa;
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.4);
            transform: scale(1.05);
        }
        .nav-btn.active-construct {
            background: #e11d48; /* Rose/Rouge pour constructeur */
            border-color: #fb7185;
            box-shadow: 0 0 20px rgba(225, 29, 72, 0.4);
        }

        .sub-mode-btn {
            padding: 4px 12px; border-radius: 8px; font-weight: 600; font-size: 0.85rem;
            background: #1e293b; color: #cbd5e1; border: 1px solid #334155;
            transition: all 0.2s;
        }
        .sub-mode-btn:hover { background: #334155; }
        .sub-mode-btn.active { background: #0ea5e9; color: white; border-color: #38bdf8; }

        /* Style sp√©cifique pour les onglets constructeur */
        .construct-tab-btn {
            padding: 4px 12px; border-radius: 8px; font-weight: 600; font-size: 0.85rem;
            background: #334155; color: #cbd5e1; border: 1px solid #475569;
            transition: all 0.2s;
        }
        .construct-tab-btn:hover { background: #475569; }
        .construct-tab-btn.active { 
            background: #f43f5e; color: white; border-color: #fb7185; /* Rose */
        }
        .construct-tab-btn.filter-active {
            background: #8b5cf6; color: white; border-color: #a78bfa; /* Violet pour les filtres */
        }

        .lvl-btn {
            padding: 4px 12px; border-radius: 20px; font-size: 0.8rem; font-weight: bold;
            background: #334155; color: #94a3b8; border: 1px solid #475569;
            transition: all 0.2s;
        }
        .lvl-btn:hover { background: #475569; color: white; }
        .lvl-btn.active {
            background: #22c55e; color: white; border-color: #4ade80;
            box-shadow: 0 0 10px rgba(34, 197, 94, 0.4);
        }

        /* Verify Button */
        .btn-verify {
            background: linear-gradient(135deg, #16a34a 0%, #15803d 100%);
            color: white; font-weight: 900; letter-spacing: 1px;
            padding: 10px 24px; border-radius: 50px;
            border: 2px solid #4ade80;
            box-shadow: 0 4px 15px rgba(22, 163, 74, 0.4);
            transition: all 0.2s;
        }
        .btn-verify:hover { transform: scale(1.05); box-shadow: 0 6px 20px rgba(22, 163, 74, 0.6); }
        .btn-verify:active { transform: scale(0.95); }

        /* SC√àNE */
        #city-container {
            position: absolute; inset: 0; width: 100%; height: 100%;
            display: flex; justify-content: center; perspective: 1000px; z-index: 10;
        }
        
        #drawing-canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 60; pointer-events: none;
        }

        #custom-cursor { position: fixed; pointer-events: none; z-index: 9999; display: none; }
        .hide-cursor, .hide-cursor * { cursor: none !important; }

        /* IMMEUBLES */
        .building-wrapper {
            position: absolute; bottom: 24px;
            display: flex; flex-direction: column; align-items: center; justify-content: flex-end;
            z-index: 20; touch-action: none;
            transition: left 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        }
        .mode-mean .building-wrapper, .mode-build .building-wrapper { transition: none; }
        .mode-range .building-wrapper { cursor: pointer; }

        .building-wrapper.is-dragging .building {
            transform: scale(1.05) translateY(-10px);
            box-shadow: 0 0 30px rgba(34, 211, 238, 0.6);
            border-color: #67e8f9 !important; z-index: 100;
            filter: brightness(1.1);
        }
        .building-wrapper.is-dragging .value-badge {
            transform: translateY(-20px) scale(1.1);
            z-index: 101;
            border: 2px solid #67e8f9;
        }

        /* STYLE "GRATTE-CIEL" */
        .building {
            width: 60px;
            background: linear-gradient(180deg, #38bdf8 0%, #0284c7 100%);
            border: 3px solid #7dd3fc; border-bottom: none; border-radius: 8px 8px 0 0;
            box-shadow: 0 5px 15px rgba(0,0,0,0.4);
            cursor: grab; position: relative; overflow: hidden;
            display: flex; flex-direction: column-reverse;
            background-image: radial-gradient(rgba(255,255,255,0.4) 20%, transparent 20%);
            background-size: 12px 20px; background-position: center 6px;
            transition: height 0.3s cubic-bezier(0.25, 0.8, 0.25, 1), transform 0.2s, box-shadow 0.2s, opacity 0.5s, filter 0.5s;
        }

        .building.highlight-odd {
            background: 
                radial-gradient(rgba(255,255,255,0.4) 20%, transparent 20%),
                linear-gradient(180deg, #facc15 0%, #ca8a04 100%) !important; 
            background-size: 12px 20px, 100% 100% !important;
            background-position: center 6px, 0 0 !important;
            border-color: #fef08a !important; 
            box-shadow: 0 0 50px rgba(250, 204, 21, 0.9) !important;
            z-index: 30; transform: scale(1.05);
            opacity: 1 !important;
        }
        .building.highlight-range {
            border-color: #a855f7 !important;
            box-shadow: 0 0 30px rgba(168, 85, 247, 0.8) !important;
            transform: scale(1.05); z-index: 30;
        }
        .building.dimmed { opacity: 0.3; filter: grayscale(0.8); }

        .building.mean-mode {
            background: transparent !important; border: none !important; box-shadow: none !important;
            background-image: none !important; overflow: visible !important;
        }
        
        .brick {
            width: 60px; box-sizing: border-box;
            background: #3b82f6; border: 1px solid #1d4ed8; 
            border-top: 1px solid #60a5fa; position: relative; height: 20px;
        }
        .brick.is-top { cursor: grab; }
        .brick.is-top:hover { filter: brightness(1.1); }
        .brick.half-brick { background: #a855f7; border-color: #7e22ce; }
        .brick.half-brick::after {
            content: '¬Ω'; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 10px; color: white; opacity: 0.9; font-weight: bold;
        }
        .brick.cut-visual::before {
            content: ''; position: absolute; top: 50%; left: 0; right: 0; height: 0;
            border-top: 2px dashed #e9d5ff; z-index: 10;
        }

        .value-badge {
            background: white; color: #0f172a; font-weight: 800;
            padding: 4px 12px; border-radius: 20px; font-size: 1.5rem;
            margin-bottom: 8px; box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            z-index: 30; cursor: pointer; transition: all 0.3s;
            border: 2px solid transparent;
        }
        .value-badge:hover { transform: scale(1.15); background-color: #f0f9ff; color: #0284c7; }
        .value-badge.highlight-neighbor {
            background-color: #fff7ed !important; color: #ea580c !important;
            border: 2px solid #fb923c !important; transform: scale(1.1);
            box-shadow: 0 0 15px rgba(251, 146, 60, 0.5);
        }

        /* PANNEAU MEDIANE */
        #median-tool {
            position: absolute; bottom: 24px; width: 6px; 
            background: #ec4899; z-index: 50; display: none;
            align-items: flex-start; justify-content: center;
            cursor: grab; touch-action: none;
            transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
            transform: translateX(-50%);
            pointer-events: auto; border-radius: 4px 4px 0 0;
            box-shadow: 0 0 15px rgba(236, 72, 153, 0.8);
        }
        
        #median-tool.ghost-building {
            width: 60px !important; 
            background: linear-gradient(180deg, rgba(250, 204, 21, 0.8) 0%, rgba(202, 138, 4, 0.8) 100%) !important;
            border: 3px solid rgba(254, 240, 138, 0.9) !important;
            border-bottom: none; border-radius: 8px 8px 0 0;
            box-shadow: 0 0 40px rgba(250, 204, 21, 0.6) !important;
            background-image: radial-gradient(rgba(255,255,255,0.6) 20%, transparent 20%) !important;
            background-size: 12px 20px !important; background-position: center 6px !important;
            pointer-events: none; z-index: 40;
        }
        #median-tool.ghost-building.no-windows { background-image: none !important; }
        
        #median-tool:active { cursor: grabbing; }
        
        #tool-handle {
            position: absolute; bottom: 50%; width: 60px; height: 32px;
            background: white; border: 3px solid #ec4899; border-radius: 20px;
            display: flex; align-items: center; justify-content: space-between;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3); color: #ec4899; padding: 0 8px;
            transition: border-color 0.5s, color 0.5s;
        }
        #median-tool.ghost-building #tool-handle { display: none !important; }
        
        /* PANCARTE DU PANNEAU (Label) */
        #tool-label {
            position: absolute; top: 0; 
            transform: translateY(-100%) translateY(-10px); 
            background: #ec4899; color: white; 
            padding: 8px 16px; border-radius: 12px; font-weight: 900; font-size: 2rem;
            white-space: nowrap; box-shadow: 0 5px 20px rgba(236, 72, 153, 0.6);
            pointer-events: none; z-index: 60; text-align: center; transition: all 0.3s;
            min-width: 60px; opacity: 1; border: 2px solid white;
        }
        #tool-label::after {
            content: ''; position: absolute; bottom: -8px; left: 50%; transform: translateX(-50%);
            border-left: 8px solid transparent; border-right: 8px solid transparent; border-top: 8px solid #ec4899;
        }
        
        #median-tool.ghost-building #tool-label {
            background: transparent; color: #facc15; border: none; box-shadow: none;
            font-size: 3rem; text-shadow: 0 2px 10px rgba(0,0,0,0.8), 0 0 20px rgba(250, 204, 21, 0.5);
            transform: translateY(-90%);
        }
        #median-tool.ghost-building #tool-label::after { display: none; }

        #range-arrow {
            position: absolute; top: 25%; left: 0; height: 40px; pointer-events: none;
            display: none; z-index: 45; align-items: center;
        }
        .range-line {
            height: 6px; background: #a855f7; border-radius: 3px;
            box-shadow: 0 0 15px #a855f7; width: 0; transition: width 0.8s ease-out;
        }
        .range-tip {
            width: 0; height: 0; border-top: 10px solid transparent; border-bottom: 10px solid transparent;
            opacity: 0; transition: opacity 0.3s 0.8s;
        }
        .range-tip-left { border-right: 15px solid #a855f7; margin-right: -2px; }
        .range-tip-right { border-left: 15px solid #a855f7; margin-left: -2px; }

        .ground {
            position: absolute; bottom: 0; width: 100%; height: 24px;
            background: #1e293b; border-top: 4px solid #334155; z-index: 10;
            box-shadow: inset 0 10px 20px rgba(0,0,0,0.5);
        }

        #floating-result {
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            text-align: center; pointer-events: none; z-index: 60;
            opacity: 0; transition: opacity 0.5s; width: 90%;
        }
        #floating-result h2 {
            font-size: 3rem; font-weight: 800; text-shadow: 0 4px 10px rgba(0,0,0,0.5); margin-bottom: 0; line-height: 1;
        }
        #floating-result p {
            color: #cbd5e1; font-size: 1.2rem; margin-top: 5px; text-shadow: 0 2px 5px rgba(0,0,0,0.8); display: inline-block;
        }

        .construct-slot {
            width: 70px; height: 10px; background: #334155; 
            border-radius: 4px; margin-bottom: 24px; position: absolute; bottom: 0;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.5);
        }
        #brick-supply {
            position: absolute; bottom: 100px; left: 15%;
            width: 80px; height: 120px; background: rgba(30, 41, 59, 0.8);
            border: 2px dashed #475569; border-radius: 12px;
            display: none; flex-direction: column; align-items: center; justify-content: center;
            z-index: 40; cursor: grab;
        }
        #brick-supply::after { content: 'BRIQUES'; font-size: 10px; color: #94a3b8; font-weight: bold; margin-top: 10px; }
        
        #construct-goals {
            position: absolute; top: 10px; right: 20px;
            background: rgba(15, 23, 42, 0.95); padding: 15px; border-radius: 16px;
            border: 1px solid #334155; display: none; flex-direction: column; gap: 10px;
            z-index: 40; box-shadow: 0 10px 20px rgba(0,0,0,0.5); width: 240px;
        }
        .goal-item { display: flex; align-items: center; justify-content: space-between; color: #94a3b8; font-weight: 600; font-size: 0.9rem; transition: color 0.3s; }
        .goal-item.success { color: #4ade80; text-shadow: 0 0 10px rgba(74, 222, 128, 0.3); }
        .goal-item.error { color: #f87171; text-shadow: 0 0 10px rgba(248, 113, 113, 0.3); }
        
        .goal-check { 
            width: 14px; height: 14px; border-radius: 50%; background: #475569;
            transition: all 0.3s; margin-left: 10px; border: 2px solid #334155;
        }
        .goal-item.success .goal-check { background: #22c55e; border-color: #22c55e; box-shadow: 0 0 8px #22c55e; }
        .goal-item.error .goal-check { background: #ef4444; border-color: #ef4444; box-shadow: 0 0 8px #ef4444; }

        .flying-brick {
            position: fixed; width: 60px; height: 20px;
            background: #3b82f6; border: 1px solid #1d4ed8; border-top: 1px solid #60a5fa;
            z-index: 9999; pointer-events: none; opacity: 0.95;
            box-shadow: 0 15px 30px rgba(0,0,0,0.4);
        }
        .flying-brick.half { height: 10px; background: #9333ea; border-color: #581c87; }
    </style>
</head>
<body class="h-screen flex flex-col">

    <div id="custom-cursor">
        <!-- NOUVELLE ICONE CRAYON PLUS PROPRE -->
        <svg id="cursor-pen-svg" class="drop-shadow-lg" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z" stroke="#ffffff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="rgba(255,255,255,0.2)"/>
        </svg>
    </div>

    <!-- HEADER -->
    <div class="bg-slate-950/90 backdrop-blur border-b border-slate-800 p-2 flex flex-col sm:flex-row justify-between items-center z-50 shrink-0 gap-4">
        <div class="flex items-center gap-3 pl-2">
            <span class="text-3xl">üèôÔ∏è</span>
            <div>
                <h1 class="text-xl font-bold text-slate-100">Stats City</h1>
                <p class="text-slate-500 text-xs font-semibold tracking-wide">La ville des statistiques</p>
            </div>
        </div>

        <!-- MAIN NAVIGATION -->
        <div class="flex gap-4">
            <button onclick="setMainMode('CALCUL')" id="nav-calcul" class="nav-btn active">
                üßÆ Mode Calcul
            </button>
            <button onclick="setMainMode('BUILD')" id="nav-build" class="nav-btn">
                üèóÔ∏è Mode Constructeur
            </button>
        </div>

        <!-- ZONE DE RESULTAT (Tout en haut) -->
        <div id="info-message" class="flex-1 text-center transition-all duration-500 min-h-[40px] flex items-center justify-center">
            <h2 id="msg-title" class="text-lg sm:text-2xl font-bold text-slate-300 drop-shadow-md"></h2>
        </div>
    </div>

    <!-- TOOLBAR (z-index 70 to be ABOVE canvas z-60) -->
    <div class="bg-slate-900 border-b border-slate-700 p-2 flex justify-between items-center z-[70] shrink-0 relative min-h-[50px]">
        
        <!-- SUB-NAVIGATION: CALCUL -->
        <div id="subnav-calcul" class="flex gap-2 items-center">
            <button onclick="setSubMode('MEDIAN')" id="btn-mode-median" class="sub-mode-btn active">M√âDIANE</button>
            <button onclick="setSubMode('MEAN')" id="btn-mode-mean" class="sub-mode-btn">MOYENNE</button>
            <button onclick="setSubMode('RANGE')" id="btn-mode-range" class="sub-mode-btn">√âTENDUE</button>
        </div>

        <!-- SUB-NAVIGATION: BUILD (TABS VIEWS) -->
        <div id="subnav-build" class="hidden flex gap-2 items-center">
            <div class="mr-4 flex gap-1">
                <div class="text-slate-400 text-xs font-bold uppercase tracking-widest self-center mr-2">Niveau:</div>
                <button onclick="setConstructLevel(1)" class="lvl-btn active" id="btn-lvl-1">1</button>
                <button onclick="setConstructLevel(2)" class="lvl-btn" id="btn-lvl-2">2</button>
                <button onclick="setConstructLevel(3)" class="lvl-btn" id="btn-lvl-3">3</button>
            </div>
            <div class="w-px h-6 bg-slate-700 mx-2"></div>
            <!-- FILTRES CONSTRUCTEUR -->
            <button onclick="setBuildSubMode('EDIT')" id="tab-build-edit" class="construct-tab-btn active">üî® Construction</button>
            <button onclick="setBuildSubMode('MEDIAN')" id="tab-build-median" class="construct-tab-btn">M√©diane</button>
            <button onclick="setBuildSubMode('MEAN')" id="tab-build-mean" class="construct-tab-btn">Moyenne</button>
            <button onclick="setBuildSubMode('RANGE')" id="tab-build-range" class="construct-tab-btn">√âtendue</button>
        </div>

        <!-- GENERATEUR (CALCUL SEULEMENT) -->
        <div id="controls-gen" class="flex items-center gap-3 bg-slate-800 p-1 pr-2 rounded-xl border border-slate-600">
            <div class="flex items-center gap-1 px-2 border-r border-slate-600">
                <button onclick="updateCount(-1)" class="w-6 h-6 rounded bg-slate-700 text-white font-bold hover:bg-slate-600">-</button>
                <span id="count-display" class="w-6 text-center font-bold text-sky-400">5</span>
                <button onclick="updateCount(1)" class="w-6 h-6 rounded bg-slate-700 text-white font-bold hover:bg-slate-600">+</button>
            </div>
            <button onclick="generateRandomCity()" class="bg-indigo-600 hover:bg-indigo-500 text-white px-3 py-1 rounded font-bold text-sm shadow flex items-center gap-2">
                <svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" /></svg>
                Nouveau
            </button>
        </div>

        <!-- TOOLS COMMON (Shifted to right) -->
        <div class="flex gap-2 items-center absolute left-[65%] -translate-x-1/2">
            <div class="flex items-center gap-1 bg-slate-800 p-1 rounded-lg border border-slate-600">
                <button onclick="setTool('hand')" id="tool-hand" class="p-2 rounded bg-slate-600 text-white shadow"><svg class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 11.5V14m0-2.5v-6a1.5 1.5 0 113 0m-3 6a1.5 1.5 0 00-3 0v2a7.5 7.5 0 0015 0v-5a1.5 1.5 0 00-3 0m-6-3V11m0-5.5v-1a1.5 1.5 0 013 0v1m0 0V11m0-5.5a1.5 1.5 0 013 0v3m0 0V11" /></svg></button>
                <button onclick="setTool('pen')" id="tool-pen" class="p-2 rounded text-slate-400 hover:text-white"><svg class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z" /></svg></button>
                <button onclick="clearCanvas()" class="p-2 rounded text-red-400 hover:text-red-200"><svg class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg></button>
            </div>
            
            <!-- CISEAUX (Mode Moyenne ou Build) -->
            <div id="scissors-container" class="hidden items-center gap-1 bg-purple-900/30 p-1 rounded-lg border border-purple-600/50">
                <button onclick="setTool('hand')" id="tool-mean-hand" class="p-2 rounded text-purple-300 hover:bg-purple-800 hover:text-white" title="Main">
                     <svg class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 11.5V14m0-2.5v-6a1.5 1.5 0 113 0m-3 6a1.5 1.5 0 00-3 0v2a7.5 7.5 0 0015 0v-5a1.5 1.5 0 00-3 0m-6-3V11m0-5.5v-1a1.5 1.5 0 013 0v1m0 0V11m0-5.5a1.5 1.5 0 013 0v3m0 0V11" /></svg>
                </button>
                <button onclick="setTool('scissors')" id="tool-scissors" class="p-2 rounded text-purple-300 hover:bg-purple-800 hover:text-white" title="Couper en deux (0.5)">
                    <svg class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.121 14.121L19 19m-7-7l7-7m-7 7l-2.879 2.879M12 12L9.121 9.121m0 5.758a3 3 0 10-4.243 4.243 3 3 0 004.243-4.243zm0-5.758a3 3 0 10-4.243-4.243 3 3 0 004.243 4.243z" /></svg>
                </button>
            </div>
        </div>
        
        <div id="mini-instruction" class="text-[10px] text-slate-400 border border-slate-700 rounded px-2 py-1 hidden sm:block ml-auto">
            Cliquez sur une bulle pour changer la valeur ‚Ä¢ Glissez pour ranger
        </div>
    </div>

    <!-- MAIN -->
    <main id="main-area" class="flex-1 relative bg-slate-800 overflow-hidden w-full cursor-crosshair">
        <canvas id="drawing-canvas"></canvas>

        <div id="city-container">
            <!-- Buildings generated here -->
            <div id="group-left" class="group-indicator"><span class="group-label"></span></div>
            <div id="group-right" class="group-indicator"><span class="group-label"></span></div>
            
            <div id="median-tool">
                <div id="tool-label">?</div>
                <div id="tool-handle">
                    <!-- Fl√®ches gauche/droite -->
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M15 19l-7-7 7-7" /></svg>
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M9 5l7 7-7 7" /></svg>
                </div>
            </div>
            
            <div id="range-arrow">
                <div class="range-tip range-tip-left"></div>
                <div class="range-line"></div>
                <div class="range-tip range-tip-right"></div>
            </div>
            
            <!-- Resultat Flottant (Au dessus de tout) -->
            <div id="floating-result">
                <h2 id="res-title"></h2>
                <p id="res-sub"></p>
            </div>
            
            <!-- Constructeur Supply (Visible uniquement en mode EDIT) -->
            <div id="brick-supply" onmousedown="startDragSupply(event)" ontouchstart="startDragSupply(event)">
                <div class="brick" style="width: 40px; height: 12px; border-top: 2px solid #60a5fa; border-radius: 2px; margin-bottom:2px;"></div>
                <div class="brick" style="width: 40px; height: 12px; margin-bottom:2px;"></div>
                <div class="brick" style="width: 40px; height: 12px;"></div>
            </div>
            
            <!-- Objectifs Constructeur HUD (MANUEL) -->
            <div id="construct-goals">
                <div class="text-slate-300 text-sm font-bold mb-3 border-b border-slate-700 pb-2 flex justify-between">
                    <span>üéØ Objectifs</span>
                    <button onclick="startNewChallenge()" class="px-2 py-0.5 bg-indigo-600 rounded text-[10px] text-white hover:bg-indigo-500">Nouveau D√©fi</button>
                </div>
                <div class="flex flex-col gap-2">
                    <div class="goal-item"><span id="goal-text-count">...</span> <div id="check-count" class="goal-check"></div></div>
                    <div class="goal-item"><span id="goal-text-med">...</span> <div id="check-med" class="goal-check"></div></div>
                    <div class="goal-item"><span id="goal-text-range">...</span> <div id="check-range" class="goal-check"></div></div>
                    <div class="goal-item hidden" id="goal-item-mean"><span id="goal-text-mean">...</span> <div id="check-mean" class="goal-check"></div></div>
                    <div class="goal-item hidden" id="goal-item-special"><span id="goal-text-special">...</span> <div id="check-special" class="goal-check"></div></div>
                </div>
            </div>

            <div class="ground"></div>
        </div>
    </main>

    <!-- FOOTER: CALCUL / MEDIANE -->
    <footer id="footer-median" class="footer-group bg-slate-900 border-t border-slate-700 p-4 pb-8 flex justify-center items-center gap-8 min-h-[80px]">
        <button id="btn-sort" onclick="autoSort()" class="px-6 py-2 bg-blue-600 hover:bg-blue-500 text-white rounded-full font-bold shadow-lg flex items-center gap-2 transition-all active:scale-95">
            <span>üìä</span> 1. RANGER
        </button>
        <div class="w-px h-8 bg-slate-700"></div>
        <button id="btn-median" onclick="solveMedian()" disabled class="px-6 py-2 bg-slate-700 text-slate-500 rounded-full font-bold border border-slate-600 flex items-center gap-2 cursor-not-allowed opacity-50 transition-all">
            <span id="median-icon">üîí</span> 2. SOLUTION
        </button>
    </footer>

    <!-- FOOTER: CALCUL / RANGE -->
    <footer id="footer-range" class="footer-group hidden bg-slate-900 border-t border-slate-700 p-4 pb-8 justify-center items-center gap-8 min-h-[80px]">
        <button onclick="autoSort()" class="px-6 py-2 bg-blue-600 hover:bg-blue-500 text-white rounded-full font-bold shadow-lg flex items-center gap-2 transition-all active:scale-95">
            <span>üìä</span> RANGER
        </button>
        <div class="text-slate-400 text-sm font-medium flex items-center gap-2">
            <span class="text-2xl">üìè</span>
            <span>S√©lectionnez le Min et le Max</span>
        </div>
    </footer>
    
    <!-- FOOTER: CALCUL / MEAN -->
    <footer id="footer-mean" class="footer-group hidden bg-slate-900 border-t border-slate-700 p-4 pb-8 justify-center items-center min-h-[80px]">
        <div class="text-slate-400 text-sm font-medium flex items-center gap-2">
            <span class="text-2xl">üèóÔ∏è</span>
            <span>D√©placez les briques pour √©galiser les hauteurs</span>
        </div>
    </footer>
    
    <!-- FOOTER: BUILDER -->
    <footer id="footer-build" class="footer-group hidden bg-slate-900 border-t border-slate-700 p-4 pb-8 justify-center items-center gap-4 min-h-[80px]">
        <div class="text-slate-400 text-sm mr-4">Une fois termin√© :</div>
        <button onclick="verifyConstruction()" class="btn-verify">
            V√âRIFIER
        </button>
    </footer>

    <!-- FOOTER: BUILDER FILTER VIEW (MEDIAN/MEAN/RANGE in BUILD) -->
    <footer id="footer-build-view" class="footer-group hidden bg-slate-900 border-t border-slate-700 p-4 pb-8 justify-center items-center gap-4 min-h-[80px]">
        <div class="text-sky-400 text-sm font-bold flex items-center gap-2">
             <span class="text-2xl">üëÅÔ∏è</span> Mode Simulation
        </div>
        <div class="text-slate-500 text-xs">Retournez √† "Construction" pour modifier</div>
    </footer>

    <script>
        const CONFIG = {
            buildingWidth: 60,
            gap: 20,
            floorHeight: 20,
            maxFloors: 25,
            minFloors: 1
        };

        const medianTool = document.getElementById('median-tool');

        let state = {
            mainMode: 'CALCUL', // 'CALCUL' or 'BUILD'
            subMode: 'MEDIAN', // 'MEDIAN', 'MEAN', 'RANGE' or 'EDIT' (for build)
            
            count: 5,
            buildings: [], // Current displayed buildings
            
            // For Build Mode Snapshots
            constructionSnapshot: null, // Stores the real construction when viewing filters
            
            isSorted: false,
            isMedianFound: false,
            isMeanFound: false,
            isRangeFound: false,
            rangeSelection: [],
            currentTool: 'hand',
            
            constructLevel: 1,
            targetMedian: 0,
            targetRange: 0,
            targetMean: 0,
            targetSpecial: null
        };

        // UI Refs
        const container = document.getElementById('city-container');
        const toolLabel = document.getElementById('tool-label');
        const groupLeft = document.getElementById('group-left');
        const groupRight = document.getElementById('group-right');
        const ground = document.querySelector('.ground');
        const rangeArrow = document.getElementById('range-arrow');
        const floatRes = document.getElementById('floating-result');
        const resTitle = document.getElementById('res-title');
        const resSub = document.getElementById('res-sub');
        const btnMedian = document.getElementById('btn-median');
        const brickSupply = document.getElementById('brick-supply');
        const constructGoals = document.getElementById('construct-goals');
        const controlsGen = document.getElementById('controls-gen');
        const scissorsContainer = document.getElementById('scissors-container');

        // --- CORE FUNCTIONS ---

        function init() {
            window.addEventListener('resize', () => { 
                resizeCanvas(); 
                repositionBuildings(); 
            });
            setTimeout(resizeCanvas, 100);
            
            generateRandomCity(); 
            updateUIForMode();
            
            document.addEventListener('mousemove', (e) => {
                if(state.currentTool === 'pen') {
                    const cursorDiv = document.getElementById('custom-cursor');
                    const x = e.touches ? e.touches[0].clientX : e.clientX;
                    const y = e.touches ? e.touches[0].clientY : e.clientY;
                    // CALCUL EXACT : Pointe √† (2, 22) dans 24x24
                    cursorDiv.style.left = (x - 2) + 'px';
                    cursorDiv.style.top = (y - 22) + 'px';
                }
            });
        }

        function setMainMode(mode) {
            state.mainMode = mode;
            if (mode === 'BUILD') {
                if (state.targetMedian === 0) startNewChallenge();
                setBuildSubMode('EDIT'); // Default to edit
            } else {
                setSubMode('MEDIAN'); // Default to median in Calcul
            }
            updateUIForMode();
        }

        function setSubMode(sub) {
            state.subMode = sub;
            resetLogicFlags();
            // Reset to clean state for Calcul mode
            if (state.mainMode === 'CALCUL') {
                state.buildings.forEach(b => {
                    b.value = b.originalVal || b.value;
                    b.cutTop = false; 
                });
            }
            updateUIForMode();
        }

        // New function for Builder Tabs
        function setBuildSubMode(sub) {
            // Restore snapshot if we were in a view and now switching
            if (state.constructionSnapshot) {
                // Restore original construction
                state.buildings = JSON.parse(state.constructionSnapshot);
                // Re-link DOM elements is tricky, simpler to re-render
                // But wait, refreshCityFromState handles creating DOM.
                // We just need to restore data.
                state.constructionSnapshot = null;
            }

            // If switching TO a view (not EDIT), save snapshot first
            if (sub !== 'EDIT') {
                state.constructionSnapshot = JSON.stringify(state.buildings);
                // In Mean view, we might modify bricks, so snapshot is crucial.
            }

            state.subMode = sub; // Can be 'EDIT', 'MEDIAN', 'MEAN', 'RANGE'
            resetLogicFlags();
            
            // In Builder View modes, we might need to reset cuts
            if (sub !== 'MEAN') {
                 state.buildings.forEach(b => b.cutTop = false);
            }
            
            updateUIForMode();
        }

        function resetLogicFlags() {
            state.isMedianFound = false;
            state.isMeanFound = false;
            state.isRangeFound = false;
            state.isSorted = false;
            state.rangeSelection = [];
            document.getElementById('range-arrow').style.display = 'none';
        }

        function updateUIForMode() {
            // Main Nav
            document.getElementById('nav-calcul').className = `nav-btn ${state.mainMode === 'CALCUL' ? 'active' : ''}`;
            document.getElementById('nav-build').className = `nav-btn ${state.mainMode === 'BUILD' ? 'active-construct' : ''}`;

            const isCalcul = (state.mainMode === 'CALCUL');
            const isBuild = (state.mainMode === 'BUILD');

            document.getElementById('subnav-calcul').style.display = isCalcul ? 'flex' : 'none';
            document.getElementById('subnav-build').style.display = isBuild ? 'flex' : 'none';
            controlsGen.style.visibility = isCalcul ? 'visible' : 'hidden'; 
            
            // Sub Nav (Calcul)
            document.querySelectorAll('.sub-mode-btn').forEach(b => b.classList.remove('active'));
            if(isCalcul) {
                if(state.subMode === 'MEDIAN') document.getElementById('btn-mode-median').classList.add('active');
                if(state.subMode === 'MEAN') document.getElementById('btn-mode-mean').classList.add('active');
                if(state.subMode === 'RANGE') document.getElementById('btn-mode-range').classList.add('active');
            }

            // Sub Nav (Build)
            document.querySelectorAll('.construct-tab-btn').forEach(b => b.classList.remove('active', 'filter-active'));
            if(isBuild) {
                if(state.subMode === 'EDIT') document.getElementById('tab-build-edit').classList.add('active');
                else if(state.subMode === 'MEDIAN') document.getElementById('tab-build-median').classList.add('filter-active');
                else if(state.subMode === 'MEAN') document.getElementById('tab-build-mean').classList.add('filter-active');
                else if(state.subMode === 'RANGE') document.getElementById('tab-build-range').classList.add('filter-active');
            }

            // Footers & Tools
            document.querySelectorAll('.footer-group').forEach(f => f.classList.remove('flex', 'hidden'));
            document.querySelectorAll('.footer-group').forEach(f => f.classList.add('hidden'));

            brickSupply.style.display = 'none';
            constructGoals.style.display = 'none';
            scissorsContainer.classList.remove('flex');
            scissorsContainer.classList.add('hidden');

            const mini = document.getElementById('mini-instruction');

            if (isCalcul) {
                if (state.subMode === 'MEDIAN') {
                    document.getElementById('footer-median').classList.remove('hidden');
                    document.getElementById('footer-median').classList.add('flex');
                    showMessage("La ville est pr√™te");
                    mini.innerText = "Glissez les immeubles pour les ranger";
                    state.buildings.sort((a,b) => a.id - b.id);
                } else if (state.subMode === 'MEAN') {
                    document.getElementById('footer-mean').classList.remove('hidden');
                    document.getElementById('footer-mean').classList.add('flex');
                    scissorsContainer.classList.remove('hidden'); scissorsContainer.classList.add('flex');
                    showMessage("√âgalisez les hauteurs");
                    mini.innerText = "Les ciseaux permettent de couper une brique en deux";
                    state.buildings.sort((a,b) => a.originalId - b.originalId);
                } else if (state.subMode === 'RANGE') {
                    document.getElementById('footer-range').classList.remove('hidden');
                    document.getElementById('footer-range').classList.add('flex');
                    showMessage("Calculez l'√©tendue");
                    mini.innerText = "Cliquez sur Min et Max";
                    state.buildings.sort((a,b) => a.originalId - b.originalId);
                }
            } else {
                // BUILDER MODES
                constructGoals.style.display = 'flex'; // Always show goals
                
                if (state.subMode === 'EDIT') {
                    // Main Construction View
                    document.getElementById('footer-build').classList.remove('hidden');
                    document.getElementById('footer-build').classList.add('flex');
                    brickSupply.style.display = 'flex';
                    scissorsContainer.classList.remove('hidden'); scissorsContainer.classList.add('flex'); // Allow editing bricks
                    showMessage("Mode Constructeur");
                    mini.innerText = "Construisez pour atteindre les objectifs";
                    // No sort in EDIT
                } else {
                    // Filter Views in Builder
                    document.getElementById('footer-build-view').classList.remove('hidden'); // Show generic "Simulation" footer
                    document.getElementById('footer-build-view').classList.add('flex');

                    if (state.subMode === 'MEDIAN') {
                         showMessage("Simulation M√©diane", "Triez pour v√©rifier");
                    } else if (state.subMode === 'MEAN') {
                         scissorsContainer.classList.remove('hidden'); scissorsContainer.classList.add('flex');
                         showMessage("Simulation Moyenne", "√âgalisez pour v√©rifier");
                    } else if (state.subMode === 'RANGE') {
                         showMessage("Simulation √âtendue", "V√©rifiez l'√©cart");
                    }
                }
            }

            setTool('hand');
            refreshCityFromState();
        }

        function updateCount(delta) {
            let n = state.count + delta;
            if (n < 2) n = 2;
            if (n > 12) n = 12;
            state.count = n;
            document.getElementById('count-display').innerText = n;
            generateRandomCity();
        }

        function generateRandomCity() {
            clearCanvas();
            state.isSorted = false;
            state.isMedianFound = false;
            state.isMeanFound = false;
            state.isRangeFound = false;
            state.rangeSelection = [];
            
            state.buildings = [];
            for(let i=0; i<state.count; i++) {
                let val = Math.floor(Math.random() * 19) + 2; 
                state.buildings.push({ id: i, value: val, originalVal: val, originalId: i });
            }
            
            let sum = state.buildings.reduce((a,b)=>a+b.value, 0);
            const canHaveHalf = (state.count % 2 === 0);
            const forceInteger = !canHaveHalf || (Math.random() > 0.5); 

            while (true) {
                const mean = sum / state.count;
                const isInteger = (mean % 1 === 0);
                const isHalf = (mean % 1 === 0.5);
                if (forceInteger && isInteger) break;
                if (!forceInteger && isHalf) break;
                state.buildings[state.count-1].value += 1;
                state.buildings[state.count-1].originalVal += 1;
                sum++;
            }

            refreshCityFromState();
            playSound('pop');
        }

        function refreshCityFromState() {
            container.innerHTML = '';
            container.appendChild(medianTool);
            container.appendChild(groupLeft);
            container.appendChild(groupRight);
            container.appendChild(rangeArrow);
            container.appendChild(floatRes);
            container.appendChild(brickSupply);
            container.appendChild(constructGoals);
            container.appendChild(ground);

            medianTool.style.display = 'none';
            medianTool.style.height = '380px';
            medianTool.style.pointerEvents = 'auto'; 
            medianTool.classList.remove('solved', 'ghost-building', 'no-windows'); 
            document.getElementById('tool-handle').style.display = 'flex';

            toolLabel.style.opacity = '1'; 
            toolLabel.innerText = "?";
            toolLabel.style.top = ''; 
            toolLabel.style.transform = ''; 
            
            groupLeft.style.opacity = '0';
            groupRight.style.opacity = '0';
            floatRes.style.opacity = '0';
            rangeArrow.style.display = 'none';
            
            const useMeanStyle = (state.mainMode === 'CALCUL' && state.subMode === 'MEAN') || 
                                 (state.mainMode === 'BUILD' && (state.subMode === 'EDIT' || state.subMode === 'MEAN'));
            
            if(useMeanStyle) container.classList.add('mode-mean');
            else container.classList.remove('mode-mean');
            
            // Sorting Logic
            // In BUILD_EDIT: Never sort automatically (preserve user construction order)
            if (state.mainMode === 'BUILD' && state.subMode === 'EDIT') {
                 // No sort, they are in creation order
            } 
            // In Calcul Mean or Build Mean: visual order usually by ID to avoid jumping, or just unsorted
            else if (state.subMode === 'MEAN') {
                 state.buildings.sort((a,b) => a.originalId - b.originalId);
            }
            // In Median/Range: depends on if sorted
            else if (state.subMode === 'MEDIAN' || state.subMode === 'RANGE') {
                 if (state.isSorted) {
                     state.buildings.sort((a,b) => a.value - b.value);
                 } else {
                     // If we are in simulation, restore original ID sort for clarity? Or keep shuffled?
                     // In Calc mode we shuffle. In Build mode, we keep original construction order.
                     state.buildings.sort((a,b) => a.originalId - b.originalId);
                 }
            }

            state.buildings.forEach((bData) => {
                createBuildingDOM(bData);
            });
            
            setTool(state.currentTool);
            repositionBuildings();
            
            if(state.subMode === 'MEDIAN') checkSorted();

            // BUG FIX: Check Mean Win immediately if entering Mean mode
            if(state.subMode === 'MEAN') checkMeanWin();
        }

        function createBuildingDOM(bObj) {
            const wrapper = document.createElement('div');
            wrapper.className = 'building-wrapper';
            
            const badge = document.createElement('div');
            badge.className = 'value-badge';
            badge.innerText = bObj.value;
            
            const building = document.createElement('div');
            
            const isMedian = (state.subMode === 'MEDIAN');
            const isRange = (state.subMode === 'RANGE');
            const isMeanOrBuild = (state.subMode === 'MEAN' || state.subMode === 'EDIT');

            if (isMedian) {
                building.className = 'building'; 
                building.style.height = (bObj.value * CONFIG.floorHeight) + 'px';
                
                wrapper.addEventListener('mousedown', (e) => startDragBuilding(e, wrapper, bObj.id));
                wrapper.addEventListener('touchstart', (e) => startDragBuilding(e, wrapper, bObj.id), {passive: false});
                badge.addEventListener('mousedown', (e) => { e.stopPropagation(); editBuilding(bObj.id); });
                badge.addEventListener('touchstart', (e) => { e.stopPropagation(); editBuilding(bObj.id); });
                building.addEventListener('click', () => trySelectMedian(bObj.id));
            } 
            else if (isMeanOrBuild) {
                building.className = 'building mean-mode'; 
                renderBricks(building, bObj.value, bObj.cutTop);
                building.style.height = 'auto';
                
                building.addEventListener('mousedown', (e) => handleBrickInteraction(e, bObj.id));
                building.addEventListener('touchstart', (e) => handleBrickInteraction(e, bObj.id), {passive: false});
                badge.addEventListener('mousedown', (e) => { e.stopPropagation(); editBuilding(bObj.id); });
            }
            else if (isRange) {
                building.className = 'building'; 
                building.style.height = (bObj.value * CONFIG.floorHeight) + 'px';
                badge.addEventListener('mousedown', (e) => { e.stopPropagation(); editBuilding(bObj.id); });
                building.addEventListener('click', () => selectRangeBuilding(bObj.id));
            }

            wrapper.appendChild(badge);
            wrapper.appendChild(building);
            container.insertBefore(wrapper, medianTool);

            bObj.element = wrapper;
            bObj.buildingEl = building;
            bObj.badgeEl = badge;
        }

        function renderBricks(container, value, cutTop = false) {
            container.innerHTML = '';
            let count = Math.floor(value);
            let hasHalf = (value % 1 !== 0);
            
            for(let i=0; i<count; i++) {
                let b = document.createElement('div');
                b.className = 'brick';
                if(i === count-1 && !hasHalf && cutTop) {
                    b.classList.add('cut-visual');
                }
                if(i === count-1 && !hasHalf) b.classList.add('is-top');
                b.style.height = CONFIG.floorHeight + 'px';
                container.appendChild(b);
            }
            if(hasHalf) {
                let b = document.createElement('div');
                b.className = 'brick half-brick is-top'; 
                b.style.height = (CONFIG.floorHeight / 2) + 'px';
                container.appendChild(b);
            }
        }

        function repositionBuildings(skipItem = null) {
            let extraGap = 0;
            let splitIndex = -1;

            if (state.subMode === 'MEDIAN' && state.isMedianFound && state.count % 2 === 0) {
                extraGap = CONFIG.buildingWidth + CONFIG.gap; 
                splitIndex = state.count / 2;
            }

            const totalW = (state.count * CONFIG.buildingWidth) + ((state.count - 1) * CONFIG.gap) + extraGap;
            const startX = (container.offsetWidth - totalW) / 2;

            let list = state.buildings;
            
            if (state.mainMode === 'CALCUL' && state.subMode === 'MEDIAN') {
                 if(state.isSorted) list.sort((a,b) => a.value - b.value);
            } else if (state.mainMode === 'CALCUL' && state.subMode === 'RANGE') {
                 if(state.isSorted) list.sort((a,b) => a.value - b.value);
                 else list.sort((a,b) => a.originalId - b.originalId);
            } else {
                 list.sort((a,b) => a.originalId - b.originalId);
            }

            list.forEach((b, i) => {
                if (b === skipItem) return;
                let x = startX + i * (CONFIG.buildingWidth + CONFIG.gap);
                if (splitIndex !== -1 && i >= splitIndex) {
                    x += extraGap;
                }
                if(b.element) {
                    b.element.style.left = x + 'px';
                    b.element.style.transform = '';
                }
            });
        }

        function showMessage(title, sub = "", color = "text-slate-300") {
            const h = document.getElementById('msg-title');
            h.innerText = title;
            h.className = "text-lg sm:text-2xl font-bold drop-shadow-md " + color;
        }
        
        function showFloatingResult(title, sub, colorClass = "text-yellow-400") {
            resTitle.innerText = title;
            resTitle.className = "font-extrabold text-4xl " + colorClass; 
            resSub.innerText = sub;
            floatRes.style.opacity = '1';
        }

        // --- MEDIAN LOGIC ---

        function checkSorted() {
            if(state.subMode !== 'MEDIAN') return;
            
            let asc = true, desc = true;
            for(let i=0; i<state.buildings.length-1; i++) {
                if (state.buildings[i].value > state.buildings[i+1].value) asc = false;
                if (state.buildings[i].value < state.buildings[i+1].value) desc = false;
            }
            state.isSorted = (asc || desc);

            const icon = document.getElementById('median-icon');
            if (state.isSorted) {
                if(btnMedian) {
                    btnMedian.disabled = false;
                    btnMedian.classList.remove('bg-slate-700', 'text-slate-500', 'cursor-not-allowed', 'opacity-50');
                    btnMedian.classList.add('bg-pink-600', 'text-white', 'cursor-pointer', 'shadow-lg');
                }
                
                if(!state.isMedianFound) {
                    showMessage("La ville est rang√©e !");
                    medianTool.style.display = 'flex';
                    medianTool.style.pointerEvents = 'auto';

                    const maxVal = Math.max(...state.buildings.map(b => b.value));
                    const toolH = (maxVal * CONFIG.floorHeight) + 60;
                    medianTool.style.height = toolH + 'px';
                    
                    medianTool.style.left = '50px'; 
                    toolLabel.style.opacity = '1';
                    toolLabel.innerText = "?";
                }
            } else {
                if(btnMedian) {
                    btnMedian.disabled = true;
                    btnMedian.classList.add('bg-slate-700', 'text-slate-500', 'cursor-not-allowed', 'opacity-50');
                    btnMedian.classList.remove('bg-pink-600', 'text-white', 'cursor-pointer', 'shadow-lg');
                }
                medianTool.style.display = 'none';
            }
        }

        function solveMedian() {
            if (state.isMedianFound) return;
            state.isMedianFound = true;
            playSound('ding');
            const n = state.buildings.length;
            const mid = Math.floor(n/2);
            const isOdd = (n % 2 !== 0);
            
            const totalW = (state.count * CONFIG.buildingWidth) + ((state.count - 1) * CONFIG.gap);
            const startX = (container.offsetWidth - totalW) / 2;

            if (isOdd) {
                const target = state.buildings[mid];
                target.buildingEl.style.opacity = '1'; 
                target.badgeEl.style.opacity = '1';
                medianTool.style.display = 'none';
                
                target.buildingEl.classList.add('highlight-odd');
                target.badgeEl.style.backgroundColor = '#facc15';
                target.badgeEl.style.color = '#000';
                target.badgeEl.style.transform = 'scale(1.5) translateY(-15px)'; 
                target.badgeEl.style.border = '3px solid white';
                
                state.buildings.forEach((b,i) => { if(i!==mid) b.buildingEl.classList.add('dimmed'); });
                
                showFloatingResult(`M√©diane = ${target.value} √©tages`, ``, "text-yellow-400");
            } else {
                const b1 = state.buildings[mid-1];
                const b2 = state.buildings[mid];
                const med = (b1.value + b2.value) / 2;
                
                repositionBuildings();

                medianTool.style.display = 'flex';
                medianTool.classList.remove('solved'); 
                medianTool.classList.add('ghost-building', 'no-windows');
                
                medianTool.style.pointerEvents = 'none';
                document.getElementById('tool-label').innerText = med;
                
                const centerX = container.offsetWidth / 2;
                medianTool.style.left = centerX + 'px';
                
                medianTool.style.height = (med * CONFIG.floorHeight) + 'px';
                
                const tl = document.getElementById('tool-label');
                tl.style.opacity = '1';
                
                b1.badgeEl.classList.add('highlight-neighbor');
                b2.badgeEl.classList.add('highlight-neighbor');
                state.buildings.forEach(b => b.buildingEl.classList.add('dimmed'));
                
                showFloatingResult(`M√©diane = ${med} √©tages`, ``, "text-yellow-400");
            }
            if(btnMedian) btnMedian.disabled = true; 
            if(btnMedian) btnMedian.classList.add('opacity-50', 'cursor-not-allowed');
        }

        // --- MEAN MODE LOGIC ---
        let draggedBrick = null;
        
        function handleBrickInteraction(e, colId) {
            if ((state.mainMode !== 'BUILD') && !(state.mainMode === 'CALCUL' && state.subMode === 'MEAN')) {
                 // Also allow if in Build View of Mean
                 if(state.mainMode === 'BUILD' && (state.subMode === 'MEAN' || state.subMode === 'EDIT')) {
                     // pass
                 } else {
                     return;
                 }
            }
            if (state.mainMode === 'CALCUL' && state.isMeanFound) return;

            const bObj = state.buildings.find(b => b.id === colId);

            if (state.currentTool === 'scissors') {
                if (bObj.value > 0 && bObj.value % 1 === 0) {
                    playSound('pop'); 
                    bObj.cutTop = !bObj.cutTop;
                    renderBricks(bObj.buildingEl, bObj.value, bObj.cutTop);
                }
            } else if (state.currentTool === 'hand') {
                startDragBrick(e, colId);
            }
        }
        
        function startDragBrick(e, colId) {
            e.preventDefault();
            const bObj = state.buildings.find(b => b.id === colId);
            if (bObj.value <= 0) return;

            let amount = 1;
            if (bObj.value % 1 !== 0 || bObj.cutTop) amount = 0.5;
            
            const ghost = document.createElement('div');
            ghost.className = amount === 0.5 ? 'flying-brick half' : 'flying-brick';
            document.body.appendChild(ghost);
            
            bObj.value -= amount;
            if(bObj.value < 0) bObj.value = 0;
            
            updateBuildingVisuals(bObj);
            bObj.cutTop = false; 
            
            if(state.subMode === 'EDIT') resetGoalStatus();

            draggedBrick = {
                sourceId: colId,
                amount: amount,
                element: ghost,
                startX: e.touches ? e.touches[0].clientX : e.clientX,
                startY: e.touches ? e.touches[0].clientY : e.clientY
            };
            
            updateGhostPos(e.touches ? e.touches[0] : e);
            document.addEventListener('mousemove', onBrickDrag);
            document.addEventListener('touchmove', onBrickDrag, {passive: false});
            document.addEventListener('mouseup', endBrickDrag);
            document.addEventListener('touchend', endBrickDrag);
        }
        
        function startDragSupply(e) {
            // Supply only active in Edit mode
            if(state.subMode !== 'EDIT') return;

            e.preventDefault();
            const ghost = document.createElement('div');
            ghost.className = 'flying-brick';
            document.body.appendChild(ghost);
            draggedBrick = { sourceId: 'SUPPLY', amount: 1, element: ghost };
            updateGhostPos(e.touches?e.touches[0]:e);
            document.addEventListener('mousemove', onBrickDrag);
            document.addEventListener('touchmove', onBrickDrag, {passive: false});
            document.addEventListener('mouseup', endBrickDrag);
            document.addEventListener('touchend', endBrickDrag);
        }

        function onBrickDrag(e) {
            if(!draggedBrick) return;
            e.preventDefault();
            updateGhostPos(e.touches ? e.touches[0] : e);
        }

        function updateGhostPos(e) {
            draggedBrick.element.style.left = (e.clientX - 30) + 'px';
            draggedBrick.element.style.top = (e.clientY - 10) + 'px';
        }

        function endBrickDrag(e) {
            if(!draggedBrick) return;
            
            const clientX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
            const containerRect = container.getBoundingClientRect();
            
            const totalW = (state.count * CONFIG.buildingWidth) + ((state.count - 1) * CONFIG.gap);
            const startX = (containerRect.width - totalW) / 2;
            const relativeX = clientX - containerRect.left - startX;
            
            let targetIdx = Math.floor((relativeX + CONFIG.gap/2) / (CONFIG.buildingWidth + CONFIG.gap));
            
            let success = false;
            if (targetIdx >= 0 && targetIdx < state.count) {
                // In Mean mode, buildings might be sorted differently.
                // We need to find the building at visual index `targetIdx`.
                // state.buildings is ALREADY sorted for visual display in refreshCityFromState
                // So state.buildings[targetIdx] is correct visual mapping.
                
                const targetObj = state.buildings[targetIdx];
                
                if (targetObj && targetObj.id !== draggedBrick.sourceId) {
                    if (targetObj.value + draggedBrick.amount <= CONFIG.maxFloors) {
                        targetObj.value += draggedBrick.amount;
                        updateBuildingVisuals(targetObj);
                        playSound('pop');
                        
                        if(state.subMode === 'MEAN') checkMeanWin(); // Check if in Mean Sim or Calc Mean
                        success = true;
                    }
                }
            }

            if (!success) {
                if (draggedBrick.sourceId !== 'SUPPLY') {
                    const sourceObj = state.buildings.find(b => b.id === draggedBrick.sourceId);
                    sourceObj.value += draggedBrick.amount;
                    updateBuildingVisuals(sourceObj);
                }
            }
            draggedBrick.element.remove();
            draggedBrick = null;
            document.removeEventListener('mousemove', onBrickDrag);
            document.removeEventListener('touchmove', onBrickDrag);
            document.removeEventListener('mouseup', endBrickDrag);
            document.removeEventListener('touchend', endBrickDrag);
        }

        function updateBuildingVisuals(bObj) {
            bObj.badgeEl.innerText = bObj.value;
            renderBricks(bObj.buildingEl, bObj.value);
        }

        function checkMeanWin() {
            // Only visual win, doesn't affect builder verify
            const first = state.buildings[0].value;
            const allEqual = state.buildings.every(b => Math.abs(b.value - first) < 0.001);
            if (allEqual) {
                state.isMeanFound = true;
                playSound('ding');
                showFloatingResult(`Moyenne = ${first} √©tages par immeuble`, "", "text-green-400");
                state.buildings.forEach(b => {
                    b.badgeEl.style.backgroundColor = '#22c55e';
                    b.badgeEl.style.color = 'white';
                });
            }
        }

        // --- RANGE MODE LOGIC ---
        function selectRangeBuilding(id) {
            if(state.subMode !== 'RANGE' || state.isRangeFound) return;
            const b = state.buildings.find(x => x.id === id);
            
            if(state.rangeSelection.includes(id)) {
                state.rangeSelection = state.rangeSelection.filter(sid => sid !== id);
                b.buildingEl.classList.remove('highlight-range');
            } else {
                if(state.rangeSelection.length < 2) {
                    state.rangeSelection.push(id);
                    b.buildingEl.classList.add('highlight-range');
                    playSound('pop');
                    if(state.rangeSelection.length === 2) checkRange();
                }
            }
        }
        
        function checkRange() {
            const b1 = state.buildings.find(x => x.id === state.rangeSelection[0]);
            const b2 = state.buildings.find(x => x.id === state.rangeSelection[1]);
            
            // Values from currently displayed state (could be snapshot)
            const values = state.buildings.map(b => b.value);
            const min = Math.min(...values); const max = Math.max(...values);
            
            const v1 = b1.value; const v2 = b2.value;
            
            if ( (v1 === min && v2 === max) || (v1 === max && v2 === min) ) {
                state.isRangeFound = true;
                playSound('ding');
                const range = max - min;
                showFloatingResult(`√âtendue = ${range} √©tages`, "", "text-violet-400");
                
                [b1, b2].forEach(b => {
                    b.buildingEl.classList.remove('selected-range');
                    b.buildingEl.classList.add('highlight-range');
                });
                
                state.buildings.forEach(b => {
                    if(b.id !== b1.id && b.id !== b2.id) b.buildingEl.classList.add('dimmed');
                });
            } else {
                setTimeout(() => {
                    state.rangeSelection = [];
                    [b1, b2].forEach(b => b.buildingEl.classList.remove('highlight-range'));
                    showMessage("Rat√© ! Cherchez le plus petit et le plus grand.");
                }, 500);
            }
        }

        // --- CONSTRUCT MODE ---
        function setConstructLevel(lvl) {
            state.constructLevel = lvl;
            document.querySelectorAll('.lvl-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(`btn-lvl-${lvl}`).classList.add('active');
            startNewChallenge();
        }

        function startNewChallenge() {
            clearCanvas();
            const lvl = state.constructLevel;
            
            state.count = Math.floor(Math.random() * 7) + 3;
            
            let virtualBuildings = [];
            for(let i=0; i<state.count; i++) virtualBuildings.push(Math.floor(Math.random() * 10) + 1);
            virtualBuildings.sort((a,b)=>a-b);
            
            const vMin = virtualBuildings[0];
            const vMax = virtualBuildings[state.count-1];
            
            const mid = Math.floor(state.count/2);
            let tM;
            if(state.count % 2 !== 0) tM = virtualBuildings[mid];
            else tM = (virtualBuildings[mid-1] + virtualBuildings[mid]) / 2;
            
            const tR = vMax - vMin;
            
            let tMean = Math.floor(virtualBuildings.reduce((a,b)=>a+b,0)/state.count);
            if(tMean < 2) tMean = 3;
            
            const tSpec = virtualBuildings[Math.floor(Math.random()*state.count)];

            state.targetMedian = tM; 
            state.targetRange = tR;
            state.targetMean = tMean;
            state.targetSpecial = tSpec;

            state.buildings = [];
            for(let i=0; i<state.count; i++) {
                const bObj = { id: i, value: 0, originalVal: 0, originalId: i };
                state.buildings.push(bObj);
            }
            
            document.getElementById('goal-text-count').innerText = `${state.count} Immeubles`;
            document.getElementById('goal-text-med').innerText = `M√©diane : ${tM}`;
            document.getElementById('goal-text-range').innerText = `√âtendue : ${tR}`;
            
            const elMean = document.getElementById('goal-item-mean');
            const elSpec = document.getElementById('goal-item-special');
            
            if(lvl >= 2) {
                elMean.classList.remove('hidden');
                document.getElementById('goal-text-mean').innerText = `Moyenne : ~${tMean}`;
            } else elMean.classList.add('hidden');
            
            if(lvl === 3) {
                elSpec.classList.remove('hidden');
                document.getElementById('goal-text-special').innerText = `Un immeuble de ${tSpec} √©tages`;
            } else elSpec.classList.add('hidden');
            
            resetGoalStatus();
            setBuildSubMode('EDIT'); // Force Edit on new challenge
            playSound('pop');
        }
        
        function resetGoalStatus() {
            document.querySelectorAll('.goal-item').forEach(el => {
                el.classList.remove('success', 'error');
            });
            document.getElementById('floating-result').style.opacity = '0';
        }

        function verifyConstruction() {
            // Verify based on Snapshot (Real Construction) if currently in a view
            // OR based on current buildings if in Edit view.
            
            let vals;
            if(state.constructionSnapshot && state.subMode !== 'EDIT') {
                 // User is verifying while in Mean/Median view?
                 // Usually verification happens on the "Real" construction.
                 // If they are in Mean view, state.buildings is the modified mean version.
                 // We should probably check the SNAPSHOT (the real construction) if it exists.
                 vals = JSON.parse(state.constructionSnapshot).map(b => b.value).sort((a,b)=>a-b);
            } else {
                 vals = state.buildings.map(b => b.value).sort((a,b)=>a-b);
            }

            const mid = Math.floor(vals.length/2);
            const currMed = (vals.length % 2 !== 0) ? vals[mid] : (vals[mid-1]+vals[mid])/2;
            const currRange = Math.max(...vals) - Math.min(...vals);
            const currMean = vals.reduce((a,b)=>a+b, 0) / (vals.length || 1);
            
            let win = true;
            
            const check = (id, condition) => {
                const el = document.getElementById(id);
                if(!el) return;
                const parent = el.parentElement;
                parent.classList.remove('success', 'error');
                if(condition) {
                    parent.classList.add('success');
                } else {
                    parent.classList.add('error');
                    win = false;
                }
            };

            check('check-count', true); 
            check('check-med', currMed === state.targetMedian);
            check('check-range', currRange === state.targetRange);
            
            if(state.constructLevel >= 2) {
                check('check-mean', Math.abs(currMean - state.targetMean) < 0.1); 
            }
            if(state.constructLevel === 3) {
                check('check-special', vals.includes(state.targetSpecial));
            }
            
            if(win) {
                playSound('ding');
                showFloatingResult("BRAVO ! D√©fi R√©ussi !", "Vous pouvez changer de mode ou relancer", "text-green-400");
            } else {
                playSound('lock');
                showFloatingResult("Pas tout √† fait...", "V√©rifiez les objectifs en rouge", "text-red-400");
                setTimeout(() => {
                    if(!win) floatRes.style.opacity = '0';
                }, 2000);
            }
        }

        // --- DRAG & EDIT COMMON ---
        
        function editBuilding(id) {
            // Edit not allowed in Simulation views in Builder, only in Edit
            if(state.mainMode === 'BUILD' && state.subMode !== 'EDIT') return;

            const b = state.buildings.find(x => x.id === id);
            let v = prompt("Hauteur :", b.value);
            if(v) { 
                v = parseFloat(v); 
                if(!isNaN(v) && v>=0 && v<=CONFIG.maxFloors) { 
                    v = (state.subMode === 'MEDIAN') ? Math.round(v) : v;
                    if(state.mainMode === 'BUILD' && v % 0.5 !== 0) v = Math.round(v); 
                    
                    b.value = v;
                    b.originalVal = v;
                    
                    resetGoalStatus();
                    state.isMedianFound=false; 
                    state.isMeanFound=false;
                    state.isRangeFound=false;
                    medianTool.style.display='none';
                    floatRes.style.opacity='0';
                    
                    if(state.subMode === 'MEDIAN') {
                        checkSorted();
                        b.badgeEl.innerText = v;
                        b.buildingEl.style.height = (v * CONFIG.floorHeight) + 'px';
                    } else {
                        updateBuildingVisuals(b);
                    }
                }
            }
        }

        function startDragBuilding(e, wrapper, id) {
            if (state.currentTool !== 'hand') return;
            // Drag building is allowed only in Median and Range
            // In Build mode, only allowed in Median/Range views (Simulations)
            // Not allowed in Build Edit (fixed slots) or Build Mean
            
            if(state.subMode === 'EDIT' || state.subMode === 'MEAN') return;

            e.preventDefault();
            const bObj = state.buildings.find(b => b.id === id);
            wrapper.classList.add('is-dragging');
            
            const onDrag = (e) => {
                e.preventDefault();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const containerRect = container.getBoundingClientRect();
                
                let extraGap = 0; let splitIndex = -1;
                if (state.subMode === 'MEDIAN' && state.isMedianFound && state.count % 2 === 0) {
                    extraGap = CONFIG.buildingWidth + CONFIG.gap; splitIndex = state.count / 2;
                }
                const totalW = (state.count * CONFIG.buildingWidth) + ((state.count - 1) * CONFIG.gap) + extraGap;
                
                const startX = (containerRect.width - totalW) / 2;
                const mouseRelativeX = clientX - containerRect.left;
                
                wrapper.style.left = (mouseRelativeX - CONFIG.buildingWidth/2) + 'px';
                
                let rawX = mouseRelativeX - startX;
                let newIndex = Math.floor((rawX + CONFIG.gap/2) / (CONFIG.buildingWidth + CONFIG.gap));
                
                if (newIndex < 0) newIndex = 0; 
                if (newIndex >= state.count) newIndex = state.count - 1;
                
                const oldIndex = state.buildings.indexOf(bObj);
                if (newIndex !== oldIndex) {
                    state.buildings.splice(oldIndex, 1);
                    state.buildings.splice(newIndex, 0, bObj);
                    repositionBuildings(bObj);
                    playSound('pop');
                }
            };
            
            const stopDrag = () => {
                wrapper.classList.remove('is-dragging');
                repositionBuildings();
                if(state.subMode === 'MEDIAN') checkSorted();
                document.removeEventListener('mousemove', onDrag);
                document.removeEventListener('touchmove', onDrag);
                document.removeEventListener('mouseup', stopDrag);
                document.removeEventListener('touchend', stopDrag);
            };
            document.addEventListener('mousemove', onDrag);
            document.addEventListener('touchmove', onDrag, {passive: false});
            document.addEventListener('mouseup', stopDrag);
            document.addEventListener('touchend', stopDrag);
        }

        // --- MISSING FUNCTIONS ADDED BACK ---
        
        function autoSort() {
            state.isSorted = true;
            state.buildings.sort((a,b)=>a.value-b.value);
            repositionBuildings();
            playSound('slide');
            if(state.subMode === 'MEDIAN') checkSorted();
            // Reset Range findings if sorting
            if(state.subMode === 'RANGE') {
                state.rangeSelection = [];
                state.buildings.forEach(b=>b.buildingEl.classList.remove('highlight-range', 'dimmed'));
                document.getElementById('range-arrow').style.display = 'none';
                floatRes.style.opacity = '0';
            }
        }

        function trySelectMedian(id) {
            if(state.subMode !== 'MEDIAN') return;
            const n = state.buildings.length;
            if(n%2===0 || !state.isSorted) return;
            const mid = Math.floor(n/2);
            if(state.buildings[mid].id === id) solveMedian();
            else playSound('lock');
        }

        // --- MEDIAN TOOL ---
        let isToolDragging = false;
        medianTool.addEventListener('mousedown', startToolDrag);
        medianTool.addEventListener('touchstart', startToolDrag, {passive: false});
        function startToolDrag(e) {
            if(state.isMedianFound || state.subMode !== 'MEDIAN') return;
            e.preventDefault(); e.stopPropagation();
            isToolDragging = true;
            document.addEventListener('mousemove', onToolDrag);
            document.addEventListener('touchmove', onToolDrag, {passive: false});
            document.addEventListener('mouseup', stopToolDrag);
            document.addEventListener('touchend', stopToolDrag);
        }
        function onToolDrag(e) {
            if(!isToolDragging) return;
            const cx = e.touches ? e.touches[0].clientX : e.clientX;
            const r = container.getBoundingClientRect();
            let x = cx - r.left; if(x<0) x=0; if(x>r.width) x=r.width;
            medianTool.style.left = x + 'px';
            const snap = getClosestSnap(x);
            if(snap) toolLabel.innerText = snap.val; else toolLabel.innerText = "?";
        }
        function stopToolDrag(e) {
            isToolDragging = false;
            const r = medianTool.getBoundingClientRect();
            const tx = r.left + r.width/2 - container.getBoundingClientRect().left;
            const snap = getClosestSnap(tx);
            if(snap && snap.isMedian) { medianTool.style.left = snap.x + 'px'; solveMedian(); }
            document.removeEventListener('mousemove', onToolDrag);
            document.removeEventListener('touchmove', onToolDrag);
            document.removeEventListener('mouseup', stopToolDrag);
            document.removeEventListener('touchend', stopToolDrag);
        }
        function getClosestSnap(x) {
            const totalW = (state.count * CONFIG.buildingWidth) + ((state.count - 1) * CONFIG.gap);
            const startX = (container.offsetWidth - totalW) / 2;
            let best = null, minD = 9999;
            const n = state.buildings.length;
            const isOdd = n%2!==0;
            const mid = Math.floor(n/2);
            
            state.buildings.forEach((b, i) => {
                const bx = startX + i * (CONFIG.buildingWidth + CONFIG.gap) + CONFIG.buildingWidth/2;
                const d = Math.abs(x - bx);
                if(d < minD) { minD = d; best = { x:bx, isMedian:(isOdd && i===mid), val:b.value, type:'BUILDING' }; }
            });
            
            for(let i=0; i<n-1; i++) {
                const gx = startX + i * (CONFIG.buildingWidth + CONFIG.gap) + CONFIG.buildingWidth + CONFIG.gap/2;
                const d = Math.abs(x - gx);
                if(d < minD) { 
                    minD = d; 
                    best = { x:gx, isMedian:(!isOdd && i===mid-1), val: (state.buildings[i].value+state.buildings[i+1].value)/2, type:'GAP' }; 
                }
            }
            return best;
        }

        // --- DRAWING ---
        const canvas = document.getElementById('drawing-canvas');
        const ctx = canvas.getContext('2d');
        const cursorDiv = document.getElementById('custom-cursor');
        let isDrawing = false, lastX=0, lastY=0;
        function resizeCanvas() {
            const rect = document.getElementById('city-container').getBoundingClientRect();
            canvas.width = rect.width; canvas.height = rect.height;
            if(state.currentTool === 'pen') { 
                ctx.globalCompositeOperation = 'source-over'; 
                ctx.strokeStyle = '#ffffff'; 
                ctx.lineWidth = 4; 
                ctx.lineCap = 'round'; 
            }
        }
        function setTool(tool) {
            state.currentTool = tool;
            const h=document.getElementById('tool-hand'), p=document.getElementById('tool-pen'), s=document.getElementById('tool-scissors'), sh=document.getElementById('tool-mean-hand');
            [h,p,s,sh].forEach(el => { if(el) el.className = "p-2 rounded text-slate-400 hover:text-white"; });
            canvas.style.pointerEvents = 'none'; document.body.classList.remove('hide-cursor'); cursorDiv.style.display = 'none'; medianTool.style.pointerEvents = 'auto';
            if(tool === 'hand') {
                 if(h) h.className = "p-2 rounded bg-slate-600 text-white shadow";
                 if(sh) sh.className = "p-2 rounded bg-purple-600 text-white shadow";
            }
            else if(tool === 'pen') {
                p.className = "p-2 rounded bg-slate-600 text-white shadow"; canvas.style.pointerEvents = 'auto';
                document.body.classList.add('hide-cursor'); cursorDiv.style.display = 'block'; medianTool.style.pointerEvents = 'none';
                resizeCanvas();
            } else if(tool === 'scissors') s.className = "p-2 rounded bg-purple-600 text-white shadow";
        }
        function clearCanvas() { ctx.clearRect(0,0,canvas.width,canvas.height); }
        function getPos(e) { const r = canvas.getBoundingClientRect(); return { x: (e.touches?e.touches[0].clientX:e.clientX)-r.left, y: (e.touches?e.touches[0].clientY:e.clientY)-r.top }; }
        function startDraw(e) { if(state.currentTool!=='pen')return; isDrawing=true; const p=getPos(e); lastX=p.x; lastY=p.y; }
        
        function draw(e) { 
            if(!isDrawing)return; 
            e.preventDefault(); 
            const p=getPos(e); 
            ctx.beginPath(); 
            ctx.moveTo(lastX,lastY); 
            ctx.lineTo(p.x,p.y); 
            ctx.stroke(); 
            lastX=p.x; 
            lastY=p.y; 
            
            const cx = e.touches ? e.touches[0].clientX : e.clientX;
            const cy = e.touches ? e.touches[0].clientY : e.clientY;
            
            // CORRECTION: Application du m√™me d√©calage que dans init() pour aligner la mine
            cursorDiv.style.left = (cx - 2) + 'px'; 
            cursorDiv.style.top = (cy - 22) + 'px'; 
        }
        
        function endDraw() { isDrawing=false; }
        canvas.addEventListener('mousedown', startDraw); canvas.addEventListener('mousemove', draw); canvas.addEventListener('mouseup', endDraw);
        canvas.addEventListener('touchstart', startDraw, {passive:false}); canvas.addEventListener('touchmove', draw, {passive:false}); canvas.addEventListener('touchend', endDraw);

        // --- AUDIO ---
        const audioCtx = new (window.AudioContext||window.webkitAudioContext)();
        function playSound(type) {
            if(audioCtx.state==='suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator(); const g = audioCtx.createGain();
            osc.connect(g); g.connect(audioCtx.destination);
            if(type==='pop'){ osc.frequency.setValueAtTime(400,audioCtx.currentTime); g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime+0.1); }
            else if(type==='ding'){ osc.type='triangle'; osc.frequency.setValueAtTime(600,audioCtx.currentTime); g.gain.linearRampToValueAtTime(0, audioCtx.currentTime+0.5); }
            else if(type==='slide'){ osc.frequency.linearRampToValueAtTime(200, audioCtx.currentTime+0.3); }
            else if(type==='lock'){ osc.frequency.setValueAtTime(150,audioCtx.currentTime); osc.type='sawtooth'; g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime+0.3); }
            osc.start(); osc.stop(audioCtx.currentTime+(type==='ding'?0.5:0.3));
        }

        init();
    </script>
</body>
</html>
