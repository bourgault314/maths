<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stats City - La ville des statistiques</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;800&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Fredoka', sans-serif;
            background-color: #0f172a;
            color: white;
            overflow: hidden;
            user-select: none;
            touch-action: none;
        }

        /* --- UI ELEMENTS --- */
        .mode-btn {
            padding: 6px 16px; border-radius: 8px; font-weight: bold; font-size: 0.9rem;
            transition: all 0.2s; border: 1px solid rgba(255,255,255,0.1);
            background: rgba(30, 41, 59, 0.8); color: #94a3b8;
        }
        .mode-btn:hover { background: rgba(51, 65, 85, 0.9); color: white; }
        .mode-btn.active {
            background: #e11d48; /* Rose vif */
            color: white; border-color: #fb7185;
            box-shadow: 0 0 15px rgba(225, 29, 72, 0.4);
        }

        .lvl-btn {
            padding: 4px 12px; border-radius: 20px; font-size: 0.8rem; font-weight: bold;
            background: #334155; color: #94a3b8; border: 1px solid #475569;
            transition: all 0.2s;
        }
        .lvl-btn:hover { background: #475569; color: white; }
        .lvl-btn.active {
            background: #22c55e; color: white; border-color: #4ade80;
            box-shadow: 0 0 10px rgba(34, 197, 94, 0.4);
        }

        /* SC√àNE */
        #city-container {
            position: absolute; inset: 0; width: 100%; height: 100%;
            display: flex; justify-content: center; perspective: 1000px; z-index: 10;
        }
        
        #drawing-canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 60; pointer-events: none;
        }

        #custom-cursor { position: fixed; pointer-events: none; z-index: 9999; display: none; }
        .hide-cursor, .hide-cursor * { cursor: none !important; }

        /* IMMEUBLES */
        .building-wrapper {
            position: absolute; bottom: 24px;
            display: flex; flex-direction: column; align-items: center; justify-content: flex-end;
            z-index: 20; touch-action: none;
            transition: left 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        }
        .mode-mean .building-wrapper, .mode-build .building-wrapper { transition: none; }
        .mode-range .building-wrapper { cursor: pointer; }

        /* Dragging Style (Cyan) */
        .building-wrapper.is-dragging .building {
            transform: scale(1.05) translateY(-10px);
            box-shadow: 0 0 30px rgba(34, 211, 238, 0.6);
            border-color: #67e8f9 !important; z-index: 100;
            filter: brightness(1.1);
        }

        /* STYLE "GRATTE-CIEL" */
        .building {
            width: 60px;
            background: linear-gradient(180deg, #38bdf8 0%, #0284c7 100%);
            border: 3px solid #7dd3fc; border-bottom: none; border-radius: 8px 8px 0 0;
            box-shadow: 0 5px 15px rgba(0,0,0,0.4);
            cursor: grab; position: relative; overflow: hidden;
            display: flex; flex-direction: column-reverse;
            background-image: radial-gradient(rgba(255,255,255,0.4) 20%, transparent 20%);
            background-size: 12px 20px; background-position: center 6px;
            transition: height 0.3s cubic-bezier(0.25, 0.8, 0.25, 1), transform 0.2s, box-shadow 0.2s, opacity 0.5s, filter 0.5s;
        }

        .building.highlight-odd {
            background: linear-gradient(180deg, #facc15 0%, #ca8a04 100%) !important;
            border-color: #fef08a !important; 
            box-shadow: 0 0 50px rgba(250, 204, 21, 0.9) !important;
            z-index: 30; transform: scale(1.05);
        }
        .building.highlight-range {
            border-color: #a855f7 !important;
            box-shadow: 0 0 30px rgba(168, 85, 247, 0.8) !important;
            transform: scale(1.05); z-index: 30;
        }
        .building.dimmed { opacity: 0.3; filter: grayscale(0.8); }

        /* MODE MOYENNE : STYLE BRIQUES UNIES */
        .building.mean-mode {
            background: transparent !important; border: none !important; box-shadow: none !important;
            background-image: none !important; overflow: visible !important;
        }
        
        .brick {
            width: 60px; box-sizing: border-box;
            background: #3b82f6; /* Bleu solide */
            border: 1px solid #1d4ed8; 
            border-top: 1px solid #60a5fa; 
            position: relative; height: 20px;
        }
        /* Top brick style - Uniforme */
        .brick.is-top {
            cursor: grab;
        }
        .brick.is-top:hover { filter: brightness(1.1); }
        
        .brick.half-brick {
            background: #a855f7; border-color: #7e22ce;
        }
        .brick.half-brick::after {
            content: '¬Ω'; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 10px; color: white; opacity: 0.9; font-weight: bold;
        }
        
        /* Ciseaux Visual - Ligne centr√©e (CORRIG√â: Plus de double ligne) */
        .brick.cut-visual::before {
            content: ''; 
            position: absolute; top: 50%; left: 0; right: 0; height: 0;
            border-top: 2px dashed #e9d5ff; z-index: 10;
        }

        /* Badge Valeur */
        .value-badge {
            background: white; color: #0f172a; font-weight: 800;
            padding: 4px 12px; border-radius: 20px; font-size: 1.5rem;
            margin-bottom: 8px; box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            z-index: 30; cursor: pointer; transition: all 0.3s;
            border: 2px solid transparent;
        }
        .value-badge:hover { transform: scale(1.15); background-color: #f0f9ff; color: #0284c7; }
        .value-badge.highlight-neighbor { /* Orange */
            background-color: #fff7ed !important; color: #ea580c !important;
            border: 2px solid #fb923c !important; transform: scale(1.1);
            box-shadow: 0 0 15px rgba(251, 146, 60, 0.5);
        }

        /* PANNEAU MEDIANE */
        #median-tool {
            position: absolute; bottom: 24px; width: 6px; 
            background: #ec4899; z-index: 50; display: none;
            align-items: flex-start; justify-content: center;
            cursor: grab; touch-action: none;
            transition: opacity 0.3s, height 0.5s cubic-bezier(0.34, 1.56, 0.64, 1), background-color 0.5s;
            transform: translateX(-50%);
            pointer-events: auto; border-radius: 4px 4px 0 0;
            box-shadow: 0 0 15px rgba(236, 72, 153, 0.8);
        }
        
        /* MODIFICATION: Style "R√©solu/Or" pour le b√¢ton */
        #median-tool.solved {
            background-color: #facc15 !important;
            box-shadow: 0 0 25px rgba(250, 204, 21, 0.9) !important;
            width: 8px; /* Un peu plus √©pais pour le style "pilier" */
        }
        
        #median-tool:active { cursor: grabbing; }
        
        #tool-handle {
            position: absolute; bottom: 50%; width: 60px; height: 32px;
            background: white; border: 3px solid #ec4899; border-radius: 20px;
            display: flex; align-items: center; justify-content: space-between;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3); color: #ec4899; padding: 0 8px;
            transition: border-color 0.5s, color 0.5s;
        }
        /* MODIFICATION: On cache la poign√©e quand c'est r√©solu */
        #median-tool.solved #tool-handle { 
            display: none !important;
        }
        
        /* PANCARTE DU PANNEAU (Label) */
        #tool-label {
            position: absolute; top: 0; 
            transform: translateY(-100%) translateY(-10px); 
            background: #ec4899; color: white; 
            padding: 8px 16px; border-radius: 12px; font-weight: 900; font-size: 2rem;
            white-space: nowrap; box-shadow: 0 5px 20px rgba(236, 72, 153, 0.6);
            pointer-events: none; z-index: 60; text-align: center; transition: all 0.3s;
            min-width: 60px; opacity: 1; border: 2px solid white;
        }
        
        #tool-label::after {
            content: ''; position: absolute; bottom: -8px; left: 50%; transform: translateX(-50%);
            border-left: 8px solid transparent; border-right: 8px solid transparent; border-top: 8px solid #ec4899;
        }
        
        /* MODIFICATION: Style "Surbrillance" quand c'est r√©solu */
        #median-tool.solved #tool-label {
            background: transparent;
            color: #facc15;
            border: none;
            box-shadow: none;
            font-size: 3.5rem; /* Plus gros */
            text-shadow: 0 4px 10px rgba(0,0,0,0.8), 0 0 20px rgba(250, 204, 21, 0.6);
            transform: translateY(-100%); /* On enl√®ve le -10px suppl√©mentaire pour coller au b√¢ton */
        }
        #median-tool.solved #tool-label::after { 
            display: none; 
        }

        /* FLECHE D'ETENDUE - SUPPRIM√âE AU DISPLAY */
        #range-arrow {
            position: absolute; top: 25%; left: 0; height: 40px; pointer-events: none;
            display: none; z-index: 45; align-items: center;
        }
        .range-line {
            height: 6px; background: #a855f7; border-radius: 3px;
            box-shadow: 0 0 15px #a855f7; width: 0; transition: width 0.8s ease-out;
        }
        .range-tip {
            width: 0; height: 0; border-top: 10px solid transparent; border-bottom: 10px solid transparent;
            opacity: 0; transition: opacity 0.3s 0.8s;
        }
        .range-tip-left { border-right: 15px solid #a855f7; margin-right: -2px; }
        .range-tip-right { border-left: 15px solid #a855f7; margin-left: -2px; }

        /* Sol */
        .ground {
            position: absolute; bottom: 0; width: 100%; height: 24px;
            background: #1e293b; border-top: 4px solid #334155; z-index: 10;
            box-shadow: inset 0 10px 20px rgba(0,0,0,0.5);
        }

        /* Resultat Flottant (Tout en haut) */
        #floating-result {
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            text-align: center; pointer-events: none; z-index: 60;
            opacity: 0; transition: opacity 0.5s; width: 90%;
        }
        #floating-result h2 {
            font-size: 3rem; font-weight: 800; text-shadow: 0 4px 10px rgba(0,0,0,0.5);
            margin-bottom: 0; line-height: 1;
        }
        #floating-result p {
            color: #cbd5e1; font-size: 1.2rem; margin-top: 5px;
            text-shadow: 0 2px 5px rgba(0,0,0,0.8); display: inline-block;
        }

        /* Constructeur Slots */
        .construct-slot {
            width: 70px; height: 10px; background: #334155; 
            border-radius: 4px; margin-bottom: 24px; position: absolute; bottom: 0;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.5);
        }
        #brick-supply {
            position: absolute; bottom: 100px; left: 15%;
            width: 80px; height: 120px; background: rgba(30, 41, 59, 0.8);
            border: 2px dashed #475569; border-radius: 12px;
            display: none; flex-direction: column; align-items: center; justify-content: center;
            z-index: 40; cursor: grab;
        }
        #brick-supply::after { content: 'BRIQUES'; font-size: 10px; color: #94a3b8; font-weight: bold; margin-top: 10px; }
        
        /* Objectifs HUD */
        #construct-goals {
            position: absolute; top: 10px; right: 20px;
            background: rgba(15, 23, 42, 0.95); padding: 15px; border-radius: 16px;
            border: 1px solid #334155; display: none; flex-direction: column; gap: 10px;
            z-index: 40; box-shadow: 0 10px 20px rgba(0,0,0,0.5); width: 240px;
        }
        .goal-item { display: flex; align-items: center; justify-content: space-between; color: #94a3b8; font-weight: 600; font-size: 0.9rem; transition: color 0.3s; }
        .goal-item.done { color: #4ade80; text-shadow: 0 0 10px rgba(74, 222, 128, 0.3); }
        .goal-check { 
            width: 12px; height: 12px; border-radius: 50%; background: #475569;
            transition: all 0.3s; margin-left: 10px;
        }
        .goal-item.done .goal-check { background: #22c55e; box-shadow: 0 0 8px #22c55e; }

        .flying-brick {
            position: fixed; width: 60px; height: 20px;
            background: #3b82f6; border: 1px solid #1d4ed8; border-top: 1px solid #60a5fa;
            z-index: 9999; pointer-events: none; opacity: 0.95;
            box-shadow: 0 15px 30px rgba(0,0,0,0.4);
        }
        .flying-brick.half { height: 10px; background: #9333ea; border-color: #581c87; }
    </style>
</head>
<body class="h-screen flex flex-col">

    <div id="custom-cursor">
        <svg id="cursor-pen-svg" class="drop-shadow-lg" width="34" height="34" viewBox="0 0 34 34" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M27 7 L13 21" stroke="#38bdf8" stroke-width="6" stroke-linecap="round"/>
            <path d="M13 21 L8 32" stroke="#0f172a" stroke-width="4" stroke-linecap="round"/>
            <path d="M8 32 L12 28 L16 32 Z" fill="#111827"/>
            <circle cx="8" cy="32" r="1" fill="white"/>
        </svg>
    </div>

    <!-- HEADER -->
    <div class="bg-slate-950/90 backdrop-blur border-b border-slate-800 p-2 flex flex-col sm:flex-row justify-between items-center z-50 shrink-0 gap-2">
        <div class="flex items-center gap-3 pl-2">
            <span class="text-3xl">üèôÔ∏è</span>
            <div>
                <h1 class="text-xl font-bold text-slate-100">Stats City</h1>
                <p class="text-slate-500 text-xs font-semibold tracking-wide">La ville des statistiques</p>
            </div>
        </div>

        <!-- ZONE DE RESULTAT (Tout en haut) -->
        <div id="info-message" class="flex-1 text-center transition-all duration-500 min-h-[40px] flex items-center justify-center">
            <h2 id="msg-title" class="text-lg sm:text-2xl font-bold text-slate-300 drop-shadow-md"></h2>
        </div>

        <div class="flex gap-2 pr-2">
            <button onclick="setMode('MEDIAN')" id="btn-mode-median" class="mode-btn active">M√âDIANE</button>
            <button onclick="setMode('MEAN')" id="btn-mode-mean" class="mode-btn">MOYENNE</button>
            <button onclick="setMode('RANGE')" id="btn-mode-range" class="mode-btn">√âTENDUE</button>
            <button onclick="setMode('BUILD')" id="btn-mode-build" class="mode-btn">CONSTRUCTEUR</button>
        </div>
    </div>

    <!-- TOOLBAR -->
    <div class="bg-slate-900 border-b border-slate-700 p-2 flex justify-between items-center z-40 shrink-0 relative">
        <div class="flex gap-2 items-center">
            <div class="flex items-center gap-1 bg-slate-800 p-1 rounded-lg border border-slate-600">
                <button onclick="setTool('hand')" id="tool-hand" class="p-2 rounded bg-slate-600 text-white shadow"><svg class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 11.5V14m0-2.5v-6a1.5 1.5 0 113 0m-3 6a1.5 1.5 0 00-3 0v2a7.5 7.5 0 0015 0v-5a1.5 1.5 0 00-3 0m-6-3V11m0-5.5v-1a1.5 1.5 0 013 0v1m0 0V11m0-5.5a1.5 1.5 0 013 0v3m0 0V11" /></svg></button>
                <button onclick="setTool('pen')" id="tool-pen" class="p-2 rounded text-slate-400 hover:text-white"><svg class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z" /></svg></button>
                <button onclick="clearCanvas()" class="p-2 rounded text-red-400 hover:text-red-200"><svg class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg></button>
            </div>

            <div id="mini-instruction" class="text-[10px] text-slate-400 border border-slate-700 rounded px-2 py-1 hidden sm:block">
                Cliquez sur une bulle pour changer la valeur ‚Ä¢ Glissez pour ranger
            </div>

            <!-- CISEAUX (Mode Moyenne) : Ajout du bouton Main -->
            <div id="scissors-container" class="hidden items-center gap-1 bg-purple-900/30 p-1 rounded-lg border border-purple-600/50">
                <button onclick="setTool('hand')" id="tool-mean-hand" class="p-2 rounded text-purple-300 hover:bg-purple-800 hover:text-white" title="Main">
                     <svg class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 11.5V14m0-2.5v-6a1.5 1.5 0 113 0m-3 6a1.5 1.5 0 00-3 0v2a7.5 7.5 0 0015 0v-5a1.5 1.5 0 00-3 0m-6-3V11m0-5.5v-1a1.5 1.5 0 013 0v1m0 0V11m0-5.5a1.5 1.5 0 013 0v3m0 0V11" /></svg>
                </button>
                <button onclick="setTool('scissors')" id="tool-scissors" class="p-2 rounded text-purple-300 hover:bg-purple-800 hover:text-white" title="Couper en deux (0.5)">
                    <svg class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.121 14.121L19 19m-7-7l7-7m-7 7l-2.879 2.879M12 12L9.121 9.121m0 5.758a3 3 0 10-4.243 4.243 3 3 0 004.243-4.243zm0-5.758a3 3 0 10-4.243-4.243 3 3 0 004.243 4.243z" /></svg>
                </button>
            </div>
        </div>

        <!-- GENERATEUR -->
        <div id="controls-gen" class="flex items-center gap-3 bg-slate-800 p-1 pr-2 rounded-xl border border-slate-600">
            <div class="flex items-center gap-1 px-2 border-r border-slate-600">
                <button onclick="updateCount(-1)" class="w-6 h-6 rounded bg-slate-700 text-white font-bold hover:bg-slate-600">-</button>
                <span id="count-display" class="w-6 text-center font-bold text-sky-400">5</span>
                <button onclick="updateCount(1)" class="w-6 h-6 rounded bg-slate-700 text-white font-bold hover:bg-slate-600">+</button>
            </div>
            <button onclick="generateCity(true)" class="bg-indigo-600 hover:bg-indigo-500 text-white px-3 py-1 rounded font-bold text-sm shadow flex items-center gap-2">
                <svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" /></svg>
                Nouveau
            </button>
        </div>
    </div>

    <!-- MAIN -->
    <main id="main-area" class="flex-1 relative bg-slate-800 overflow-hidden w-full cursor-crosshair">
        <canvas id="drawing-canvas"></canvas>

        <div id="city-container">
            <!-- Buildings generated here -->
            <div id="group-left" class="group-indicator"><span class="group-label"></span></div>
            <div id="group-right" class="group-indicator"><span class="group-label"></span></div>
            
            <div id="median-tool">
                <div id="tool-label">?</div>
                <div id="tool-handle">
                    <!-- Fl√®ches gauche/droite -->
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M15 19l-7-7 7-7" /></svg>
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M9 5l7 7-7 7" /></svg>
                </div>
            </div>
            
            <div id="range-arrow">
                <div class="range-tip range-tip-left"></div>
                <div class="range-line"></div>
                <div class="range-tip range-tip-right"></div>
            </div>
            
            <!-- Resultat Flottant (Au dessus de tout) -->
            <div id="floating-result">
                <h2 id="res-title"></h2>
                <p id="res-sub"></p>
            </div>
            
            <!-- Constructeur Supply -->
            <div id="brick-supply" onmousedown="startDragSupply(event)" ontouchstart="startDragSupply(event)">
                <div class="brick" style="width: 40px; height: 12px; border-top: 2px solid #60a5fa; border-radius: 2px; margin-bottom:2px;"></div>
                <div class="brick" style="width: 40px; height: 12px; margin-bottom:2px;"></div>
                <div class="brick" style="width: 40px; height: 12px;"></div>
            </div>
            
            <!-- Objectifs Constructeur HUD (AUTOMATIQUE) -->
            <div id="construct-goals">
                <div class="text-slate-300 text-sm font-bold mb-3 border-b border-slate-700 pb-2 flex justify-between">
                    <span>üéØ Objectifs</span>
                    <span id="level-display" class="text-xs text-sky-400">Niveau 1</span>
                </div>
                <div class="flex flex-col gap-2">
                    <div class="goal-item"><span id="goal-text-count">...</span> <div id="check-count" class="goal-check"></div></div>
                    <div class="goal-item"><span id="goal-text-med">...</span> <div id="check-med" class="goal-check"></div></div>
                    <div class="goal-item"><span id="goal-text-range">...</span> <div id="check-range" class="goal-check"></div></div>
                    <div class="goal-item hidden" id="goal-item-mean"><span id="goal-text-mean">...</span> <div id="check-mean" class="goal-check"></div></div>
                    <div class="goal-item hidden" id="goal-item-special"><span id="goal-text-special">...</span> <div id="check-special" class="goal-check"></div></div>
                </div>
            </div>

            <div class="ground"></div>
        </div>
    </main>

    <!-- FOOTER MEDIANE -->
    <footer id="footer-median" class="bg-slate-900 border-t border-slate-700 p-4 flex justify-center items-center gap-8 min-h-[80px]">
        <button id="btn-sort" onclick="autoSort()" class="px-6 py-2 bg-blue-600 hover:bg-blue-500 text-white rounded-full font-bold shadow-lg flex items-center gap-2 transition-all active:scale-95">
            <span>üìä</span> 1. RANGER
        </button>
        <div class="w-px h-8 bg-slate-700"></div>
        <button id="btn-median" onclick="solveMedian()" disabled class="px-6 py-2 bg-slate-700 text-slate-500 rounded-full font-bold border border-slate-600 flex items-center gap-2 cursor-not-allowed opacity-50 transition-all">
            <span id="median-icon">üîí</span> 2. SOLUTION
        </button>
    </footer>

    <!-- FOOTER RANGE -->
    <footer id="footer-range" class="hidden bg-slate-900 border-t border-slate-700 p-4 justify-center items-center gap-8 min-h-[80px]">
        <button onclick="autoSort()" class="px-6 py-2 bg-blue-600 hover:bg-blue-500 text-white rounded-full font-bold shadow-lg flex items-center gap-2 transition-all active:scale-95">
            <span>üìä</span> RANGER
        </button>
        <div class="text-slate-400 text-sm font-medium flex items-center gap-2">
            <span class="text-2xl">üìè</span>
            <span>S√©lectionnez le Min et le Max</span>
        </div>
    </footer>
    
    <!-- FOOTER MOYENNE -->
    <footer id="footer-mean" class="hidden bg-slate-900 border-t border-slate-700 p-4 justify-center items-center min-h-[80px]">
        <div class="text-slate-400 text-sm font-medium flex items-center gap-2">
            <span class="text-2xl">üèóÔ∏è</span>
            <span>D√©placez les briques pour √©galiser les hauteurs</span>
        </div>
    </footer>
    
    <!-- FOOTER BUILD -->
    <footer id="footer-build" class="hidden bg-slate-900 border-t border-slate-700 p-4 justify-center items-center gap-4 min-h-[80px]">
        <div class="text-slate-400 text-xs font-bold uppercase tracking-widest">Difficult√© :</div>
        <button onclick="setConstructLevel(1)" class="lvl-btn active" id="btn-lvl-1">Apprenti</button>
        <button onclick="setConstructLevel(2)" class="lvl-btn" id="btn-lvl-2">Architecte</button>
        <button onclick="setConstructLevel(3)" class="lvl-btn" id="btn-lvl-3">Expert</button>
    </footer>

    <script>
        const CONFIG = {
            buildingWidth: 60,
            gap: 20,
            floorHeight: 20,
            maxFloors: 25,
            minFloors: 1
        };

        let state = {
            mode: 'MEDIAN',
            count: 5,
            buildings: [], 
            isSorted: false,
            isMedianFound: false,
            isMeanFound: false,
            isRangeFound: false,
            rangeSelection: [],
            currentTool: 'hand',
            
            // Construct
            constructLevel: 1,
            targetMedian: 0,
            targetRange: 0,
            targetMean: 0,
            targetSpecial: null
        };

        // UI Refs
        const container = document.getElementById('city-container');
        const mainArea = document.getElementById('main-area');
        const medianTool = document.getElementById('median-tool');
        const toolLabel = document.getElementById('tool-label');
        const groupLeft = document.getElementById('group-left');
        const groupRight = document.getElementById('group-right');
        const ground = document.querySelector('.ground');
        const rangeArrow = document.getElementById('range-arrow');
        
        const floatRes = document.getElementById('floating-result');
        const resTitle = document.getElementById('res-title');
        const resSub = document.getElementById('res-sub');
        
        const headerInfoTitle = document.getElementById('msg-title');

        const footerMedian = document.getElementById('footer-median');
        const footerMean = document.getElementById('footer-mean');
        const footerRange = document.getElementById('footer-range');
        const footerBuild = document.getElementById('footer-build');
        const btnMedian = document.getElementById('btn-median');
        
        const brickSupply = document.getElementById('brick-supply');
        const constructGoals = document.getElementById('construct-goals');
        const controlsGen = document.getElementById('controls-gen');
        const scissorsContainer = document.getElementById('scissors-container');

        // --- CORE FUNCTIONS ---

        function init() {
            window.addEventListener('resize', () => { 
                resizeCanvas(); 
                repositionBuildings(); 
            });
            setTimeout(resizeCanvas, 100);
            generateCity(true); 
        }

        function setMode(mode) {
            if(state.mode === mode) return;
            
            // RESET
            if(state.mode !== 'BUILD' && mode !== 'BUILD') {
                state.buildings.forEach(b => {
                    b.value = b.originalVal;
                    b.cutTop = false; 
                });
            }

            state.mode = mode;
            state.rangeSelection = [];
            state.isMedianFound = false;
            state.isMeanFound = false;
            state.isRangeFound = false;
            state.isSorted = false;

            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            if(mode === 'MEDIAN') document.getElementById('btn-mode-median').classList.add('active');
            if(mode === 'MEAN') document.getElementById('btn-mode-mean').classList.add('active');
            if(mode === 'RANGE') document.getElementById('btn-mode-range').classList.add('active');
            if(mode === 'BUILD') document.getElementById('btn-mode-build').classList.add('active');

            footerMedian.classList.add('hidden'); footerMedian.classList.remove('flex');
            footerMean.classList.add('hidden'); footerMean.classList.remove('flex');
            footerRange.classList.add('hidden'); footerRange.classList.remove('flex');
            footerBuild.classList.add('hidden'); footerBuild.classList.remove('flex');
            scissorsContainer.classList.add('hidden'); scissorsContainer.classList.remove('flex');
            brickSupply.style.display = 'none';
            constructGoals.style.display = 'none';
            controlsGen.style.visibility = 'visible';
            
            const mini = document.getElementById('mini-instruction');

            if (mode === 'MEDIAN') {
                footerMedian.classList.remove('hidden'); footerMedian.classList.add('flex');
                showMessage("La ville est pr√™te");
                // MODIFICATION DEMAND√âE : Changement du texte
                mini.innerText = "Glissez les immeubles pour les ranger";
                // Restore sorting by ID
                state.buildings.sort((a,b) => a.id - b.id);
            } else if (mode === 'MEAN') {
                footerMean.classList.remove('hidden'); footerMean.classList.add('flex');
                scissorsContainer.classList.remove('hidden'); scissorsContainer.classList.add('flex');
                showMessage("√âgalisez les hauteurs");
                mini.innerText = "Les ciseaux permettent de couper une brique en deux";
            } else if (mode === 'RANGE') {
                footerRange.classList.remove('hidden'); footerRange.classList.add('flex');
                showMessage("Calculez l'√©tendue");
                mini.innerText = "Cliquez sur Min et Max";
                state.rangeSelection = [];
                // Restore original order
                state.buildings.sort((a,b) => a.originalId - b.originalId);
            } else if (mode === 'BUILD') {
                footerBuild.classList.remove('hidden'); footerBuild.classList.add('flex');
                brickSupply.style.display = 'flex';
                constructGoals.style.display = 'flex';
                controlsGen.style.visibility = 'hidden';
                showMessage("Mode Constructeur");
                mini.innerText = "Construisez pour atteindre les objectifs";
                initConstructMode(state.constructLevel);
                return;
            }
            
            setTool('hand');
            refreshCityFromState();
        }

        function updateCount(delta) {
            let n = state.count + delta;
            if (n < 2) n = 2;
            if (n > 12) n = 12;
            state.count = n;
            document.getElementById('count-display').innerText = n;
            generateCity(true);
        }

        function generateCity(randomize = false) {
            clearCanvas();
            state.isSorted = false;
            state.isMedianFound = false;
            state.isMeanFound = false;
            state.isRangeFound = false;
            state.rangeSelection = [];
            
            if (randomize) {
                state.buildings = [];
                for(let i=0; i<state.count; i++) {
                    let val = Math.floor(Math.random() * 19) + 2; 
                    state.buildings.push({ id: i, value: val, originalVal: val, originalId: i });
                }
                
                // LOGIQUE MODIFI√âE: 
                // 1. Si nombre impair d'immeubles: La moyenne DOIT √™tre enti√®re (math√©matiquement impossible d'avoir .5 avec des briques de 0.5 si le compte est impair, car Sum/N = X.5 => Sum = N*X + N/2 => Impossible pour Sum entier).
                // 2. Si nombre pair: On choisit al√©atoirement entre moyenne enti√®re et moyenne .5
                
                let sum = state.buildings.reduce((a,b)=>a+b.value, 0);
                
                // Est-ce qu'on peut avoir une moyenne en demi ? (Seulement si Count est pair)
                const canHaveHalf = (state.count % 2 === 0);
                
                // Pile ou face pour forcer un entier, sauf si on ne peut pas avoir de demi (alors on force entier)
                const forceInteger = !canHaveHalf || (Math.random() > 0.5); 

                while (true) {
                    const mean = sum / state.count;
                    const isInteger = (mean % 1 === 0);
                    const isHalf = (mean % 1 === 0.5);

                    if (forceInteger && isInteger) break;
                    if (!forceInteger && isHalf) break;
                    
                    // Ajustement
                    state.buildings[state.count-1].value += 1;
                    state.buildings[state.count-1].originalVal += 1;
                    sum++;
                }
            }

            refreshCityFromState();
            if(randomize) playSound('pop');
        }

        function refreshCityFromState() {
            container.innerHTML = '';
            container.appendChild(medianTool);
            container.appendChild(groupLeft);
            container.appendChild(groupRight);
            container.appendChild(rangeArrow);
            container.appendChild(floatRes);
            container.appendChild(brickSupply);
            container.appendChild(constructGoals);
            container.appendChild(ground);

            medianTool.style.display = 'none';
            medianTool.style.height = '380px';
            // BUG FIX: Reset pointer events and solved class so it can be moved again
            medianTool.style.pointerEvents = 'auto'; 
            medianTool.classList.remove('solved');
            document.getElementById('tool-handle').style.display = 'flex'; // Reset handle visibility

            toolLabel.style.opacity = '1'; 
            toolLabel.innerText = "?";
            toolLabel.style.minWidth = "60px";
            // RESET STYLE of label
            toolLabel.style.top = ''; 
            toolLabel.style.transform = ''; 
            
            groupLeft.style.opacity = '0';
            groupRight.style.opacity = '0';
            floatRes.style.opacity = '0';
            rangeArrow.style.display = 'none';
            
            if(state.mode === 'MEAN') container.classList.add('mode-mean');
            else container.classList.remove('mode-mean');
            
            if(state.mode === 'BUILD') {
                container.innerHTML += '<div class="absolute top-1/2 left-1/2 -translate-x-1/2 text-slate-500"></div>';
                return;
            }

            // Restore order for Mean
            if(state.mode === 'MEAN' || !state.isSorted) {
                state.buildings.sort((a,b) => a.originalId - b.originalId);
            }

            state.buildings.forEach((bData) => {
                createBuildingDOM(bData);
            });
            
            repositionBuildings();
            if(state.mode === 'MEDIAN') checkSorted();
        }

        function createBuildingDOM(bObj) {
            const wrapper = document.createElement('div');
            wrapper.className = 'building-wrapper';
            
            const badge = document.createElement('div');
            badge.className = 'value-badge';
            badge.innerText = bObj.value;
            
            const building = document.createElement('div');
            
            if (state.mode === 'MEDIAN') {
                building.className = 'building'; 
                building.style.height = (bObj.value * CONFIG.floorHeight) + 'px';
                
                wrapper.addEventListener('mousedown', (e) => startDragBuilding(e, wrapper, bObj.id));
                wrapper.addEventListener('touchstart', (e) => startDragBuilding(e, wrapper, bObj.id), {passive: false});
                badge.addEventListener('mousedown', (e) => { e.stopPropagation(); editBuilding(bObj.id); });
                badge.addEventListener('touchstart', (e) => { e.stopPropagation(); editBuilding(bObj.id); });
                building.addEventListener('click', () => trySelectMedian(bObj.id));
            } 
            else if (state.mode === 'MEAN') {
                building.className = 'building mean-mode'; 
                renderBricks(building, bObj.value, bObj.cutTop);
                building.style.height = 'auto';
                
                building.addEventListener('mousedown', (e) => handleBrickInteraction(e, bObj.id));
                building.addEventListener('touchstart', (e) => handleBrickInteraction(e, bObj.id), {passive: false});
                badge.addEventListener('mousedown', (e) => { e.stopPropagation(); editBuilding(bObj.id); });
            }
            else if (state.mode === 'RANGE') {
                building.className = 'building'; 
                building.style.height = (bObj.value * CONFIG.floorHeight) + 'px';
                badge.addEventListener('mousedown', (e) => { e.stopPropagation(); editBuilding(bObj.id); });
                building.addEventListener('click', () => selectRangeBuilding(bObj.id));
            }

            wrapper.appendChild(badge);
            wrapper.appendChild(building);
            container.insertBefore(wrapper, medianTool);

            bObj.element = wrapper;
            bObj.buildingEl = building;
            bObj.badgeEl = badge;
        }

        function renderBricks(container, value, cutTop = false) {
            container.innerHTML = '';
            let count = Math.floor(value);
            let hasHalf = (value % 1 !== 0);
            
            for(let i=0; i<count; i++) {
                let b = document.createElement('div');
                b.className = 'brick';
                // Add visual cut if this is top and marked cut
                if(i === count-1 && !hasHalf && cutTop) {
                    b.classList.add('cut-visual');
                }
                if(i === count-1 && !hasHalf) b.classList.add('is-top');
                b.style.height = CONFIG.floorHeight + 'px';
                container.appendChild(b);
            }
            if(hasHalf) {
                let b = document.createElement('div');
                b.className = 'brick half-brick is-top'; 
                b.style.height = (CONFIG.floorHeight / 2) + 'px';
                container.appendChild(b);
            }
        }

        function repositionBuildings(skipItem = null) {
            if(state.mode === 'BUILD') {
                 const slots = document.querySelectorAll('.construct-slot');
                 const totalW = (state.count * CONFIG.buildingWidth) + ((state.count - 1) * CONFIG.gap);
                 const startX = (container.offsetWidth - totalW) / 2;
                 slots.forEach((s, i) => s.style.left = (startX + i * (CONFIG.buildingWidth + CONFIG.gap)) + 'px');
                 state.buildings.forEach((b, i) => b.element.style.left = (startX + i * (CONFIG.buildingWidth + CONFIG.gap)) + 'px');
                 return;
            }

            const totalW = (state.count * CONFIG.buildingWidth) + ((state.count - 1) * CONFIG.gap);
            const startX = (container.offsetWidth - totalW) / 2;

            let list = state.buildings;
            // Sorting logic per mode
            if (state.mode === 'MEDIAN') {
                 if(state.isSorted) list.sort((a,b) => a.value - b.value);
            } else if(state.mode === 'RANGE') {
                 if(state.isSorted) list.sort((a,b) => a.value - b.value);
                 else list.sort((a,b) => a.originalId - b.originalId);
            } else if(state.mode === 'MEAN') {
                 list.sort((a,b) => a.originalId - b.originalId);
            }

            list.forEach((b, i) => {
                if (b === skipItem) return;
                const x = startX + i * (CONFIG.buildingWidth + CONFIG.gap);
                if(b.element) {
                    b.element.style.left = x + 'px';
                    b.element.style.transform = '';
                }
            });
        }

        function showMessage(title, sub = "", color = "text-slate-300") {
            const h = document.getElementById('msg-title');
            h.innerText = title;
            h.className = "text-lg sm:text-2xl font-bold drop-shadow-md " + color;
        }
        
        function showFloatingResult(title, sub, colorClass = "text-yellow-400") {
            resTitle.innerText = title;
            resTitle.className = "font-extrabold text-4xl " + colorClass; 
            resSub.innerText = sub;
            floatRes.style.opacity = '1';
        }

        // --- MEDIAN LOGIC ---

        function checkSorted() {
            if(state.mode !== 'MEDIAN') return;
            let asc = true, desc = true;
            for(let i=0; i<state.buildings.length-1; i++) {
                if (state.buildings[i].value > state.buildings[i+1].value) asc = false;
                if (state.buildings[i].value < state.buildings[i+1].value) desc = false;
            }
            state.isSorted = (asc || desc);

            const icon = document.getElementById('median-icon');
            if (state.isSorted) {
                btnMedian.disabled = false;
                btnMedian.classList.remove('bg-slate-700', 'text-slate-500', 'cursor-not-allowed', 'opacity-50');
                btnMedian.classList.add('bg-pink-600', 'text-white', 'cursor-pointer', 'shadow-lg');
                icon.innerText = "üéØ";
                if(!state.isMedianFound) {
                    showMessage("La ville est rang√©e !");
                    medianTool.style.display = 'flex';
                    // BUG FIX: Ensure it is movable
                    medianTool.style.pointerEvents = 'auto';

                    // Calculate height taller than tallest building
                    const maxVal = Math.max(...state.buildings.map(b => b.value));
                    const toolH = (maxVal * CONFIG.floorHeight) + 60;
                    medianTool.style.height = toolH + 'px';
                    
                    medianTool.style.left = '50px'; 
                    // Make label visible
                    toolLabel.style.opacity = '1';
                    toolLabel.innerText = "?";
                }
            } else {
                btnMedian.disabled = true;
                btnMedian.classList.add('bg-slate-700', 'text-slate-500', 'cursor-not-allowed', 'opacity-50');
                btnMedian.classList.remove('bg-pink-600', 'text-white', 'cursor-pointer', 'shadow-lg');
                icon.innerText = "üîí";
                // Pas de message sur le plateau
                medianTool.style.display = 'none';
            }
        }

        function solveMedian() {
            if (state.isMedianFound) return;
            state.isMedianFound = true;
            playSound('ding');
            const n = state.buildings.length;
            const mid = Math.floor(n/2);
            const isOdd = (n % 2 !== 0);
            
            const totalW = (state.count * CONFIG.buildingWidth) + ((state.count - 1) * CONFIG.gap);
            const startX = (container.offsetWidth - totalW) / 2;

            if (isOdd) {
                const target = state.buildings[mid];
                medianTool.style.display = 'none'; 
                
                target.buildingEl.classList.add('highlight-odd');
                target.badgeEl.style.backgroundColor = '#facc15';
                target.badgeEl.style.transform = 'scale(1.3)';
                target.badgeEl.style.border = '3px solid white';
                
                state.buildings.forEach((b,i) => { if(i!==mid) b.buildingEl.classList.add('dimmed'); });
                
                showFloatingResult(`M√©diane = ${target.value} √©tages`, ``, "text-yellow-400");
            } else {
                // CAS PAIR (MODIFI√â)
                const b1 = state.buildings[mid-1];
                const b2 = state.buildings[mid];
                const med = (b1.value + b2.value) / 2;
                
                medianTool.style.display = 'flex';
                medianTool.classList.add('solved'); // ACTIVE LE STYLE DOR√â SANS CADRE
                medianTool.style.pointerEvents = 'none';
                document.getElementById('tool-label').innerText = med;
                
                const centerX = startX + (mid-1)*(CONFIG.buildingWidth+CONFIG.gap) + CONFIG.buildingWidth + CONFIG.gap/2;
                medianTool.style.left = centerX + 'px';
                
                // ADJUST HEIGHT (MODIFI√â: Le b√¢ton prend la hauteur exacte de la m√©diane)
                medianTool.style.height = (med * CONFIG.floorHeight) + 'px';
                
                // FORCE VISIBILITY OF LABEL (Sans le d√©calage top manuel)
                const tl = document.getElementById('tool-label');
                tl.style.opacity = '1';
                // Note: La classe CSS .solved g√®re le retrait du translateY extra
                
                b1.badgeEl.classList.add('highlight-neighbor');
                b2.badgeEl.classList.add('highlight-neighbor');
                state.buildings.forEach(b => b.buildingEl.classList.add('dimmed'));
                
                showFloatingResult(`M√©diane = ${med} √©tages`, ``, "text-yellow-400");
            }
            btnMedian.disabled = true; btnMedian.classList.add('opacity-50', 'cursor-not-allowed');
        }

        // --- MEAN MODE LOGIC ---
        let draggedBrick = null;
        
        function handleBrickInteraction(e, colId) {
            if (state.mode !== 'MEAN' && state.mode !== 'BUILD') return;
            if (state.isMeanFound && state.mode === 'MEAN') return;
            const bObj = state.buildings.find(b => b.id === colId);

            if (state.currentTool === 'scissors') {
                if (bObj.value > 0 && bObj.value % 1 === 0) {
                    playSound('pop'); 
                    // Toggle visual cut
                    bObj.cutTop = !bObj.cutTop;
                    renderBricks(bObj.buildingEl, bObj.value, bObj.cutTop);
                }
            } else if (state.currentTool === 'hand') {
                startDragBrick(e, colId);
            }
        }
        
        function startDragBrick(e, colId) {
            e.preventDefault();
            const bObj = state.buildings.find(b => b.id === colId);
            if (bObj.value <= 0) return;

            let amount = 1;
            // Take half if: value is X.5 OR if it was cut
            if (bObj.value % 1 !== 0 || bObj.cutTop) {
                amount = 0.5;
            }
            
            const ghost = document.createElement('div');
            ghost.className = amount === 0.5 ? 'flying-brick half' : 'flying-brick';
            document.body.appendChild(ghost);
            
            // Immediate visual update of source
            renderBricks(bObj.buildingEl, bObj.value - amount);
            bObj.badgeEl.innerText = bObj.value - amount;
            bObj.cutTop = false; 

            draggedBrick = {
                sourceId: colId,
                amount: amount,
                element: ghost,
                startX: e.touches ? e.touches[0].clientX : e.clientX,
                startY: e.touches ? e.touches[0].clientY : e.clientY
            };
            
            updateGhostPos(e.touches ? e.touches[0] : e);
            document.addEventListener('mousemove', onBrickDrag);
            document.addEventListener('touchmove', onBrickDrag, {passive: false});
            document.addEventListener('mouseup', endBrickDrag);
            document.addEventListener('touchend', endBrickDrag);
        }

        function onBrickDrag(e) {
            if(!draggedBrick) return;
            e.preventDefault();
            updateGhostPos(e.touches ? e.touches[0] : e);
        }

        function updateGhostPos(e) {
            draggedBrick.element.style.left = (e.clientX - 30) + 'px';
            draggedBrick.element.style.top = (e.clientY - 10) + 'px';
        }

        function endBrickDrag(e) {
            if(!draggedBrick) return;
            
            const clientX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
            const containerRect = container.getBoundingClientRect();
            
            const totalW = (state.count * CONFIG.buildingWidth) + ((state.count - 1) * CONFIG.gap);
            const startX = (containerRect.width - totalW) / 2;
            const relativeX = clientX - containerRect.left - startX;
            
            let targetIdx = Math.floor((relativeX + CONFIG.gap/2) / (CONFIG.buildingWidth + CONFIG.gap));
            
            let success = false;
            if (targetIdx >= 0 && targetIdx < state.count) {
                const targetObj = state.buildings[targetIdx];
                const sourceObj = state.buildings.find(b => b.id === draggedBrick.sourceId);
                
                if (targetObj && targetObj.id !== draggedBrick.sourceId) {
                    if (targetObj.value + draggedBrick.amount <= CONFIG.maxFloors) {
                        sourceObj.value -= draggedBrick.amount;
                        targetObj.value += draggedBrick.amount;
                        
                        updateBuildingVisuals(sourceObj);
                        updateBuildingVisuals(targetObj);
                        playSound('pop');
                        checkMeanWin();
                        success = true;
                    }
                }
            }

            if (!success) {
                // Restore source
                const sourceObj = state.buildings.find(b => b.id === draggedBrick.sourceId);
                updateBuildingVisuals(sourceObj);
            }
            draggedBrick.element.remove();
            draggedBrick = null;
            document.removeEventListener('mousemove', onBrickDrag);
            document.removeEventListener('touchmove', onBrickDrag);
            document.removeEventListener('mouseup', endBrickDrag);
            document.removeEventListener('touchend', endBrickDrag);
        }

        function updateBuildingVisuals(bObj) {
            bObj.badgeEl.innerText = bObj.value;
            renderBricks(bObj.buildingEl, bObj.value);
        }

        function checkMeanWin() {
            const first = state.buildings[0].value;
            const allEqual = state.buildings.every(b => Math.abs(b.value - first) < 0.001);
            if (allEqual) {
                state.isMeanFound = true;
                playSound('ding');
                showFloatingResult(`Moyenne = ${first} √©tages par immeuble`, "", "text-green-400");
                state.buildings.forEach(b => {
                    b.badgeEl.style.backgroundColor = '#22c55e';
                    b.badgeEl.style.color = 'white';
                });
            }
        }

        // --- RANGE MODE LOGIC ---
        function selectRangeBuilding(id) {
            if(state.mode !== 'RANGE' || state.isRangeFound) return;
            const b = state.buildings.find(x => x.id === id);
            
            if(state.rangeSelection.includes(id)) {
                state.rangeSelection = state.rangeSelection.filter(sid => sid !== id);
                b.buildingEl.classList.remove('highlight-range');
            } else {
                if(state.rangeSelection.length < 2) {
                    state.rangeSelection.push(id);
                    b.buildingEl.classList.add('highlight-range');
                    playSound('pop');
                    if(state.rangeSelection.length === 2) checkRange();
                }
            }
        }
        
        function checkRange() {
            const b1 = state.buildings.find(x => x.id === state.rangeSelection[0]);
            const b2 = state.buildings.find(x => x.id === state.rangeSelection[1]);
            const values = state.buildings.map(b => b.value);
            const min = Math.min(...values); const max = Math.max(...values);
            
            const v1 = b1.value; const v2 = b2.value;
            
            // Allow any min/max selection even if duplicates
            if ( (v1 === min && v2 === max) || (v1 === max && v2 === min) ) {
                state.isRangeFound = true;
                playSound('ding');
                const range = max - min;
                showFloatingResult(`√âtendue = ${range} √©tages`, "", "text-violet-400");
                
                [b1, b2].forEach(b => {
                    b.buildingEl.classList.remove('selected-range');
                    b.buildingEl.classList.add('highlight-range');
                });
                
                // ARROW REMOVED BY REQUEST
                // We keep only buildings highlight and text

                state.buildings.forEach(b => {
                    if(b.id !== b1.id && b.id !== b2.id) b.buildingEl.classList.add('dimmed');
                });
            } else {
                setTimeout(() => {
                    state.rangeSelection = [];
                    [b1, b2].forEach(b => b.buildingEl.classList.remove('highlight-range'));
                    showMessage("Rat√© ! Cherchez le plus petit et le plus grand.");
                }, 500);
            }
        }

        // --- CONSTRUCT MODE ---
        function setConstructLevel(lvl) {
            state.constructLevel = lvl;
            document.querySelectorAll('.lvl-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(`btn-lvl-${lvl}`).classList.add('active');
            initConstructMode(lvl);
        }

        function initConstructMode(lvl) {
            clearCanvas();
            container.innerHTML = '';
            container.appendChild(brickSupply);
            container.appendChild(constructGoals);
            container.appendChild(floatRes);
            container.appendChild(ground);
            
            // REMIS EN FONCTION : Initialisation correcte des variables cibles
            const tM = Math.floor(Math.random() * 6) + 3; 
            const tR = Math.floor(Math.random() * 5) + 3;
            const tMean = Math.floor(Math.random() * 5) + 2; 
            const tSpec = Math.floor(Math.random() * 8) + 2;

            state.targetMedian = tM; 
            state.targetRange = tR;
            state.targetMean = tMean;
            state.targetSpecial = tSpec;

            state.buildings = [];
            for(let i=0; i<state.count; i++) {
                const slot = document.createElement('div');
                slot.className = 'construct-slot';
                container.appendChild(slot);
                
                const bObj = { id: i, value: 0 };
                const wrapper = document.createElement('div');
                wrapper.className = 'building-wrapper';
                const badge = document.createElement('div');
                badge.className = 'value-badge';
                badge.innerText = 0;
                const building = document.createElement('div');
                building.className = 'building mean-mode';
                building.style.height = 'auto';
                
                wrapper.appendChild(badge); wrapper.appendChild(building);
                container.appendChild(wrapper);
                bObj.element = wrapper; bObj.buildingEl = building; bObj.badgeEl = badge;
                state.buildings.push(bObj);
            }
            
            document.getElementById('goal-text-count').innerText = `${state.count} Immeubles`;
            document.getElementById('goal-text-med').innerText = `M√©diane : ${tM}`;
            document.getElementById('goal-text-range').innerText = `√âtendue : ${tR}`;
            
            const elMean = document.getElementById('goal-item-mean');
            const elSpec = document.getElementById('goal-item-special');
            
            if(lvl >= 2) {
                elMean.classList.remove('hidden');
                document.getElementById('goal-text-mean').innerText = `Moyenne : ${tMean}`;
            } else elMean.classList.add('hidden');
            
            if(lvl === 3) {
                elSpec.classList.remove('hidden');
                document.getElementById('goal-text-special').innerText = `Un immeuble de ${tSpec}`;
            } else elSpec.classList.add('hidden');
            
            document.querySelectorAll('.goal-check').forEach(c => c.classList.remove('ok'));
            document.querySelectorAll('.goal-item').forEach(c => c.classList.remove('done'));
            
            // REMIS EN FONCTION : Appel de repositionBuildings et reset outil
            setTool('hand');
            repositionBuildings();
            checkConstructWin(); 
        }
        
        function startDragSupply(e) {
            e.preventDefault();
            const ghost = document.createElement('div');
            ghost.className = 'flying-brick';
            document.body.appendChild(ghost);
            draggedBrick = { sourceId: 'SUPPLY', amount: 1, element: ghost };
            updateGhostPos(e.touches?e.touches[0]:e);
            document.addEventListener('mousemove', onBrickDrag);
            document.addEventListener('touchmove', onBrickDrag, {passive: false});
            document.addEventListener('mouseup', endBrickDragConstruct);
            document.addEventListener('touchend', endBrickDragConstruct);
        }
        
        function endBrickDragConstruct(e) {
            if(!draggedBrick) return;
            const clientX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
            const containerRect = container.getBoundingClientRect();
            const totalW = (state.count * CONFIG.buildingWidth) + ((state.count - 1) * CONFIG.gap);
            const startX = (containerRect.width - totalW) / 2;
            const relativeX = clientX - containerRect.left - startX;
            let targetIdx = Math.floor((relativeX + CONFIG.gap/2) / (CONFIG.buildingWidth + CONFIG.gap));
            
            if (targetIdx >= 0 && targetIdx < state.count) {
                const targetObj = state.buildings[targetIdx];
                if (targetObj.value < CONFIG.maxFloors) {
                    targetObj.value += 1;
                    updateBuildingVisuals(targetObj);
                    playSound('pop');
                    checkConstructWin();
                }
            }
            draggedBrick.element.remove();
            draggedBrick = null;
            document.removeEventListener('mousemove', onBrickDrag);
            document.removeEventListener('touchmove', onBrickDrag);
            document.removeEventListener('mouseup', endBrickDragConstruct);
            document.removeEventListener('touchend', endBrickDragConstruct);
        }
        
        function checkConstructWin() {
            const vals = state.buildings.map(b => b.value).sort((a,b)=>a-b);
            const mid = Math.floor(vals.length/2);
            const currMed = (vals.length % 2 !== 0) ? vals[mid] : (vals[mid-1]+vals[mid])/2;
            const currRange = Math.max(...vals) - Math.min(...vals);
            const currMean = vals.reduce((a,b)=>a+b, 0) / (vals.length || 1);
            
            let win = true;
            
            const updateItem = (id, cond) => {
                const el = document.getElementById(id);
                if (!el) return;
                if(cond) { 
                    if(el.parentElement) el.parentElement.classList.add('done'); 
                    el.classList.add('ok'); 
                } else { 
                    if(el.parentElement) el.parentElement.classList.remove('done'); 
                    el.classList.remove('ok'); 
                    win = false; 
                }
            };

            updateItem('check-med', currMed === state.targetMedian);
            updateItem('check-range', currRange === state.targetRange);
            updateItem('check-count', true);
            
            if(state.constructLevel >= 2) {
                // REMIS EN FONCTION : Logique Moyenne (tol√©rance float minime)
                updateItem('check-mean', Math.abs(currMean - state.targetMean) < 0.01);
            }
            if(state.constructLevel === 3) {
                // REMIS EN FONCTION : Logique Sp√©ciale (au moins un immeuble de hauteur X)
                updateItem('check-special', vals.includes(state.targetSpecial));
            }
            
            if(win) { playSound('ding'); showFloatingResult("Mission R√©ussie !", "", "text-green-400"); }
            else { floatRes.style.opacity = '0'; }
        }

        // --- COMMON TOOLS ---
        function editBuilding(id) {
            const b = state.buildings.find(x => x.id === id);
            let v = prompt("Hauteur :", b.value);
            if(v) { 
                v = parseFloat(v); 
                if(!isNaN(v) && v>0 && v<=CONFIG.maxFloors) { 
                    v = Math.round(v);
                    b.value=v; 
                    if(state.mode === 'MEDIAN') {
                        b.badgeEl.innerText = v;
                        b.buildingEl.style.height = (v * CONFIG.floorHeight) + 'px';
                        state.isMedianFound=false; 
                        medianTool.style.display='none';
                        floatRes.style.opacity='0';
                        checkSorted();
                    } else if(state.mode === 'MEAN' || state.mode === 'BUILD') {
                        updateBuildingVisuals(b);
                        if(state.mode === 'MEAN') checkMeanWin();
                        if(state.mode === 'BUILD') checkConstructWin();
                    } else {
                         b.badgeEl.innerText = v;
                         b.buildingEl.style.height = (v * CONFIG.floorHeight) + 'px';
                         if(state.mode === 'RANGE') {
                             state.rangeSelection = [];
                             state.buildings.forEach(b=>b.buildingEl.classList.remove('highlight-range', 'dimmed'));
                             rangeArrow.style.display = 'none';
                             state.isRangeFound = false;
                         }
                    }
                }
            }
        }
        function startDragBuilding(e, wrapper, id) {
            if (state.currentTool !== 'hand' || state.isMedianFound || (state.mode !== 'MEDIAN' && state.mode !== 'RANGE')) return;
            e.preventDefault();
            const bObj = state.buildings.find(b => b.id === id);
            wrapper.classList.add('is-dragging');
            const onDrag = (e) => {
                e.preventDefault();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const containerRect = container.getBoundingClientRect();
                const mouseRelativeX = clientX - containerRect.left;
                const totalW = (state.count * CONFIG.buildingWidth) + ((state.count - 1) * CONFIG.gap);
                const startX = (containerRect.width - totalW) / 2;
                wrapper.style.left = (mouseRelativeX - CONFIG.buildingWidth/2) + 'px';
                let newIndex = Math.floor((mouseRelativeX - startX + CONFIG.gap/2) / (CONFIG.buildingWidth + CONFIG.gap));
                if (newIndex < 0) newIndex = 0; if (newIndex >= state.count) newIndex = state.count - 1;
                const oldIndex = state.buildings.indexOf(bObj);
                if (newIndex !== oldIndex) {
                    state.buildings.splice(oldIndex, 1);
                    state.buildings.splice(newIndex, 0, bObj);
                    repositionBuildings(bObj);
                    playSound('pop');
                }
            };
            const stopDrag = () => {
                wrapper.classList.remove('is-dragging');
                repositionBuildings();
                if(state.mode === 'MEDIAN') checkSorted();
                document.removeEventListener('mousemove', onDrag);
                document.removeEventListener('touchmove', onDrag);
                document.removeEventListener('mouseup', stopDrag);
                document.removeEventListener('touchend', stopDrag);
            };
            document.addEventListener('mousemove', onDrag);
            document.addEventListener('touchmove', onDrag, {passive: false});
            document.addEventListener('mouseup', stopDrag);
            document.addEventListener('touchend', stopDrag);
        }
        function autoSort() {
            state.isSorted = true;
            state.buildings.sort((a,b)=>a.value-b.value);
            repositionBuildings();
            playSound('slide');
            if(state.mode === 'MEDIAN') checkSorted();
            if(state.mode === 'RANGE') {
                state.rangeSelection = [];
                state.buildings.forEach(b=>b.buildingEl.classList.remove('highlight-range', 'dimmed'));
                document.getElementById('range-arrow').style.display = 'none';
                floatRes.style.opacity = '0';
            }
        }
        function trySelectMedian(id) {
            if(state.mode !== 'MEDIAN') return;
            const n = state.buildings.length;
            if(n%2===0 || !state.isSorted) return;
            const mid = Math.floor(n/2);
            if(state.buildings[mid].id === id) solveMedian();
            else playSound('lock');
        }

        // --- MEDIAN TOOL ---
        let isToolDragging = false;
        const mt = document.getElementById('median-tool');
        mt.addEventListener('mousedown', startToolDrag);
        mt.addEventListener('touchstart', startToolDrag, {passive: false});
        function startToolDrag(e) {
            if(state.isMedianFound || state.mode !== 'MEDIAN') return;
            e.preventDefault(); e.stopPropagation();
            isToolDragging = true;
            document.addEventListener('mousemove', onToolDrag);
            document.addEventListener('touchmove', onToolDrag, {passive: false});
            document.addEventListener('mouseup', stopToolDrag);
            document.addEventListener('touchend', stopToolDrag);
        }
        function onToolDrag(e) {
            if(!isToolDragging) return;
            const cx = e.touches ? e.touches[0].clientX : e.clientX;
            const r = container.getBoundingClientRect();
            let x = cx - r.left; if(x<0) x=0; if(x>r.width) x=r.width;
            mt.style.left = x + 'px';
            
            // UPDATE LABEL DYNAMICALLY
            const snap = getClosestSnap(x);
            if(snap) {
                toolLabel.innerText = snap.val;
            } else {
                toolLabel.innerText = "?";
            }
        }
        function stopToolDrag(e) {
            isToolDragging = false;
            const r = mt.getBoundingClientRect();
            const tx = r.left + r.width/2 - container.getBoundingClientRect().left;
            const snap = getClosestSnap(tx);
            if(snap && snap.isMedian) { mt.style.left = snap.x + 'px'; solveMedian(); }
            document.removeEventListener('mousemove', onToolDrag);
            document.removeEventListener('touchmove', onToolDrag);
            document.removeEventListener('mouseup', stopToolDrag);
            document.removeEventListener('touchend', stopToolDrag);
        }
        function getClosestSnap(x) {
            const totalW = (state.count * CONFIG.buildingWidth) + ((state.count - 1) * CONFIG.gap);
            const startX = (container.offsetWidth - totalW) / 2;
            let best = null, minD = 9999;
            const n = state.buildings.length;
            const isOdd = n%2!==0;
            const mid = Math.floor(n/2);
            
            // Check Buildings Centers
            state.buildings.forEach((b, i) => {
                const bx = startX + i * (CONFIG.buildingWidth + CONFIG.gap) + CONFIG.buildingWidth/2;
                const d = Math.abs(x - bx);
                // On snap si on est proche, mais pour l'affichage (drag) on prend toujours le plus proche
                if(d < minD) { minD = d; best = { x:bx, isMedian:(isOdd && i===mid), val:b.value, type:'BUILDING' }; }
            });
            
            // Check Gaps Centers
            for(let i=0; i<n-1; i++) {
                const gx = startX + i * (CONFIG.buildingWidth + CONFIG.gap) + CONFIG.buildingWidth + CONFIG.gap/2;
                const d = Math.abs(x - gx);
                if(d < minD) { 
                    minD = d; 
                    best = { x:gx, isMedian:(!isOdd && i===mid-1), val: (state.buildings[i].value+state.buildings[i+1].value)/2, type:'GAP' }; 
                }
            }
            return best;
        }

        // --- DRAWING ---
        const canvas = document.getElementById('drawing-canvas');
        const ctx = canvas.getContext('2d');
        const cursorDiv = document.getElementById('custom-cursor');
        let isDrawing = false, lastX=0, lastY=0;
        function resizeCanvas() {
            const rect = document.getElementById('city-container').getBoundingClientRect();
            canvas.width = rect.width; canvas.height = rect.height;
            if(state.currentTool === 'pen') { ctx.globalCompositeOperation = 'source-over'; ctx.strokeStyle = '#38bdf8'; ctx.lineWidth = 4; ctx.lineCap = 'round'; }
        }
        function setTool(tool) {
            state.currentTool = tool;
            const h=document.getElementById('tool-hand'), p=document.getElementById('tool-pen'), s=document.getElementById('tool-scissors'), sh=document.getElementById('tool-mean-hand');
            [h,p,s,sh].forEach(el => { if(el) el.className = "p-2 rounded text-slate-400 hover:text-white"; });
            canvas.style.pointerEvents = 'none'; document.body.classList.remove('hide-cursor'); cursorDiv.style.display = 'none'; mt.style.pointerEvents = 'auto';
            if(tool === 'hand') {
                 if(h) h.className = "p-2 rounded bg-slate-600 text-white shadow";
                 if(sh) sh.className = "p-2 rounded bg-purple-600 text-white shadow";
            }
            else if(tool === 'pen') {
                p.className = "p-2 rounded bg-slate-600 text-white shadow"; canvas.style.pointerEvents = 'auto';
                document.body.classList.add('hide-cursor'); cursorDiv.style.display = 'block'; mt.style.pointerEvents = 'none';
            } else if(tool === 'scissors') s.className = "p-2 rounded bg-purple-600 text-white shadow";
        }
        function clearCanvas() { ctx.clearRect(0,0,canvas.width,canvas.height); }
        function getPos(e) { const r = canvas.getBoundingClientRect(); return { x: (e.touches?e.touches[0].clientX:e.clientX)-r.left, y: (e.touches?e.touches[0].clientY:e.clientY)-r.top }; }
        function startDraw(e) { if(state.currentTool!=='pen')return; isDrawing=true; const p=getPos(e); lastX=p.x; lastY=p.y; }
        function draw(e) { if(!isDrawing)return; e.preventDefault(); const p=getPos(e); ctx.beginPath(); ctx.moveTo(lastX,lastY); ctx.lineTo(p.x,p.y); ctx.stroke(); lastX=p.x; lastY=p.y; cursorDiv.style.left=(e.touches?e.touches[0].clientX:e.clientX)+'px'; cursorDiv.style.top=(e.touches?e.touches[0].clientY:e.clientY)+'px'; }
        function endDraw() { isDrawing=false; }
        canvas.addEventListener('mousedown', startDraw); canvas.addEventListener('mousemove', draw); canvas.addEventListener('mouseup', endDraw);
        canvas.addEventListener('touchstart', startDraw, {passive:false}); canvas.addEventListener('touchmove', draw, {passive:false}); canvas.addEventListener('touchend', endDraw);

        // --- AUDIO ---
        const audioCtx = new (window.AudioContext||window.webkitAudioContext)();
        function playSound(type) {
            if(audioCtx.state==='suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator(); const g = audioCtx.createGain();
            osc.connect(g); g.connect(audioCtx.destination);
            if(type==='pop'){ osc.frequency.setValueAtTime(400,audioCtx.currentTime); g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime+0.1); }
            else if(type==='ding'){ osc.type='triangle'; osc.frequency.setValueAtTime(600,audioCtx.currentTime); g.gain.linearRampToValueAtTime(0, audioCtx.currentTime+0.5); }
            else if(type==='slide'){ osc.frequency.linearRampToValueAtTime(200, audioCtx.currentTime+0.3); }
            osc.start(); osc.stop(audioCtx.currentTime+(type==='ding'?0.5:0.1));
        }

        init();
    </script>
</body>
</html>
