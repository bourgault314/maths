<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Géométrie : Bandes Magnétiques</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;800&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Fredoka', sans-serif;
            background-color: #f0f9ff;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            cursor: default;
        }

        /* --- UI ELEMENTS --- */
        .tool-btn {
            transition: all 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        .tool-btn:active {
            transform: scale(0.9);
        }
        .tool-btn.active {
            background-color: #dbeafe; /* blue-100 */
            border-color: #3b82f6; /* blue-500 */
            color: #1d4ed8;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.05);
        }
        .tool-btn.active-red {
            background-color: #fee2e2; /* red-100 */
            border-color: #ef4444; /* red-500 */
            color: #b91c1c;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.05);
        }
        .tool-btn.active-teal { 
            background-color: #ccfbf1; /* teal-100 */
            border-color: #14b8a6; /* teal-500 */
            color: #0f766e;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.05);
        }
        .tool-btn.active-orange {
            background-color: #ffedd5; /* orange-100 */
            border-color: #f97316; /* orange-500 */
            color: #c2410c;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.05);
        }

        /* Classes pour le Drag & Drop sidebar */
        .strip-dragger {
            cursor: grab;
            touch-action: none;
        }
        .strip-dragger:active {
            cursor: grabbing;
        }

        /* Header Trash Zone State */
        header {
            transition: background-color 0.2s, border-color 0.2s;
        }
        header.trash-active {
            background-color: #fef2f2 !important; /* red-50 */
            border-color: #fecaca !important; /* red-200 */
        }
        header.trash-active .trash-label {
            display: flex !important;
            opacity: 1 !important;
        }
        header.trash-active .header-tools {
            opacity: 0.2;
            pointer-events: none;
        }

        /* Background Image Styling */
        #bg-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
            pointer-events: none;
            opacity: 0.9;
        }

        /* Scrollbar masquée */
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }

        /* --- DESSIN & CANVAS --- */
        #layer-container {
            position: relative;
            flex: 1;
            overflow: hidden;
            background-color: white;
            cursor: crosshair;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        #strips-canvas { z-index: 10; }
        #drawing-canvas { z-index: 20; pointer-events: none; }
        
        /* Outils Géométrie (Équerre/Rapporteur) - Au dessus du dessin */
        #geometry-tools-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 30;
            pointer-events: none; /* Laisse passer les clics sauf sur les outils */
            overflow: hidden;
        }

        .geo-tool {
            pointer-events: auto;
            position: absolute;
            filter: drop-shadow(0 4px 6px rgba(0,0,0,0.1));
            touch-action: none;
        }
        
        .geo-handle {
            transition: transform 0.1s, background-color 0.1s, border-color 0.1s;
            background-color: white;
            border: 2px solid #e5e7eb;
            color: #4b5563;
            z-index: 50; /* Ensure clickable */
        }
        
        .geo-handle:hover {
            border-color: #3b82f6;
            color: #3b82f6;
        }

        /* Specific hover scales to avoid layout shift / jitter */
        /* Rotation handle centered at top */
        .rotate-handle:hover {
            transform: translate(-50%, 0) scale(1.1) !important;
        }
        
        /* Resize handle at bottom right */
        .resize-handle:hover {
            transform: scale(1.1) !important;
        }
        
        /* Control buttons inside the row */
        .geo-control-row .geo-handle:hover {
            transform: scale(1.1);
        }

        /* CURSEUR VIRTUEL */
        #custom-cursor {
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            display: none;
            transform-origin: top left;
        }
        .hide-cursor, .hide-cursor * {
            cursor: none !important;
        }
    </style>
</head>
<body class="h-screen w-screen flex flex-col overflow-hidden text-slate-700">

    <!-- INPUT FICHIER CACHÉ -->
    <input type="file" id="bg-uploader" accept="image/*,.pdf" class="hidden">

    <!-- CURSEUR PERSONNALISÉ (Crayon) -->
    <div id="custom-cursor">
        <svg class="drop-shadow-lg" width="34" height="34" viewBox="0 0 34 34" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path id="cursor-color-1" d="M27 7 L13 21" stroke="#2563eb" stroke-width="6" stroke-linecap="round"/>
            <path d="M13 21 L8 32" stroke="#0f172a" stroke-width="4" stroke-linecap="round"/>
            <path d="M8 32 L12 28 L16 32 Z" fill="#111827"/>
            <circle cx="8" cy="32" r="1" fill="white"/>
        </svg>
    </div>

    <!-- HEADER (Zone de suppression) -->
    <header id="main-header" class="bg-white shadow-sm z-30 flex flex-col shrink-0 relative transition-colors duration-200">
        
        <!-- Overlay Supprimer -->
        <div class="trash-label absolute inset-0 hidden items-center justify-center pointer-events-none z-50">
             <div class="flex items-center gap-2 text-rose-500 font-bold text-lg bg-white/80 px-4 py-2 rounded-full shadow-sm backdrop-blur-sm border border-rose-100">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                </svg>
                <span>Relâcher pour jeter</span>
             </div>
        </div>

        <div class="header-tools flex items-center justify-between p-2 gap-2 sm:gap-4 w-full border-b border-slate-100 min-h-[60px] transition-opacity">
            
            <!-- GAUCHE : Reset -->
            <div class="flex items-center gap-2">
                 <button onclick="resetBoard()" class="tool-btn bg-rose-50 text-rose-600 hover:bg-rose-100 p-2 rounded-xl font-bold border-2 border-rose-100 flex items-center gap-2" title="Tout effacer">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                    </svg>
                    <span class="hidden sm:inline text-sm">Reset</span>
                </button>
                
                <!-- Bouton Image Fond -->
                <button onclick="document.getElementById('bg-uploader').click()" class="tool-btn text-slate-500 hover:bg-slate-50 p-2 rounded-xl border border-slate-200" title="Image de fond">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                        <circle cx="8.5" cy="8.5" r="1.5"/>
                        <polyline points="21 15 16 10 5 21"/>
                    </svg>
                </button>
            </div>

            <!-- CENTRE : Titre -->
            <div class="flex-1 flex justify-center items-center gap-4">
                <span class="text-slate-400 font-bold text-lg tracking-tight pointer-events-none hidden md:inline">Bandes Magnétiques</span>
            </div>

            <!-- DROITE : Outils -->
            <div class="flex items-center gap-2 shrink-0">
                
                <!-- EXERCICE GENERATOR -->
                <div class="flex items-center bg-orange-50 p-1 rounded-xl border border-orange-200 gap-1">
                    <button onclick="generateExercise()" class="tool-btn text-orange-600 hover:bg-orange-100 p-2 rounded-lg" title="Générer Exercice">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="10"/>
                            <circle cx="12" cy="12" r="6"/>
                            <circle cx="12" cy="12" r="2"/>
                        </svg>
                    </button>
                    <!-- Precision Select -->
                    <button onclick="cycleExercisePrecision()" id="btn-ex-prec" class="text-[10px] font-bold text-orange-600 bg-white border border-orange-200 rounded px-1 h-6 w-8 flex items-center justify-center">
                        10°
                    </button>
                </div>

                <!-- Toggle Fine Strips -->
                <button onclick="toggleStripMode()" id="btn-stripmode" class="tool-btn text-teal-600 hover:bg-teal-50 p-2 rounded-xl border border-teal-200" title="Bandes/Segments">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <rect x="4" y="12" width="16" height="2" rx="0.5" stroke="currentColor" stroke-width="2"/>
                    </svg>
                </button>

                <div class="w-px h-8 bg-slate-200 mx-1"></div>

                <!-- Toggle Équerre -->
                <button onclick="toggleSetSquare()" id="btn-setsquare" class="tool-btn bg-yellow-50 text-yellow-600 hover:bg-yellow-100 p-2 rounded-xl border border-yellow-200" title="Équerre">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M4 20L4 4L20 20H4Z" stroke="currentColor" stroke-width="2" stroke-linejoin="round"/>
                        <circle cx="8" cy="16" r="1.5" fill="currentColor"/>
                    </svg>
                </button>

                <!-- Toggle Rapporteur -->
                <button onclick="toggleProtractor()" id="btn-protractor" class="tool-btn bg-indigo-50 text-indigo-600 hover:bg-indigo-100 p-2 rounded-xl border border-indigo-200" title="Rapporteur">
                     <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M12 20H3C3 15.0294 7.02944 11 12 11C16.9706 11 21 15.0294 21 20H12Z" stroke="currentColor" stroke-width="2"/>
                        <circle cx="12" cy="20" r="1.5" fill="currentColor"/>
                    </svg>
                </button>

                <div class="w-px h-8 bg-slate-200 mx-1"></div>

                <!-- Stylo -->
                <div class="flex items-center gap-1 bg-slate-100 p-1 rounded-xl border border-slate-200">
                    <button onclick="setTool('hand')" id="tool-hand" class="tool-btn active p-2 rounded-lg" title="Main">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 11.5V14m0-2.5v-6a1.5 1.5 0 113 0m-3 6a1.5 1.5 0 00-3 0v2a7.5 7.5 0 0015 0v-5a1.5 1.5 0 00-3 0m-6-3V11m0-5.5v-1a1.5 1.5 0 013 0v1m0 0V11m0-5.5a1.5 1.5 0 013 0v3m0 0V11" />
                        </svg>
                    </button>
                    <button onclick="setTool('pen', 'blue')" id="tool-pen-blue" class="tool-btn text-blue-500 hover:bg-blue-50 p-2 rounded-lg" title="Stylo Bleu">
                        <div class="w-4 h-4 bg-blue-600 rounded-full border border-blue-700"></div>
                    </button>
                    <button onclick="setTool('pen', 'red')" id="tool-pen-red" class="tool-btn text-red-500 hover:bg-red-50 p-2 rounded-lg" title="Stylo Rouge">
                        <div class="w-4 h-4 bg-red-600 rounded-full border border-red-700"></div>
                    </button>
                    <button onclick="clearDrawings()" class="tool-btn text-slate-400 hover:text-rose-500 hover:bg-rose-50 p-2 rounded-lg" title="Effacer Annotations">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                        </svg>
                    </button>
                </div>
            </div>
        </div>
    </header>

    <div class="flex flex-1 overflow-hidden relative">
        
        <!-- SIDEBAR -->
        <aside class="w-20 sm:w-24 bg-white border-r border-slate-200 flex flex-col items-center py-6 gap-6 z-20 shadow-[4px_0_24px_rgba(0,0,0,0.02)] shrink-0 overflow-y-auto">
            
            <div class="strip-dragger group flex flex-col items-center gap-1 transition active:scale-95" data-type="yellow" title="Bande XL">
                <div class="w-3 h-20 bg-amber-400 rounded-full shadow-md border border-amber-500 group-hover:scale-110 transition-transform relative pointer-events-none">
                    <div class="absolute top-1 left-1/2 -translate-x-1/2 w-1.5 h-1.5 bg-black/20 rounded-full"></div>
                    <div class="absolute bottom-1 left-1/2 -translate-x-1/2 w-1.5 h-1.5 bg-black/20 rounded-full"></div>
                </div>
            </div>

            <div class="strip-dragger group flex flex-col items-center gap-1 transition active:scale-95" data-type="red" title="Bande Longue (5)">
                <div class="w-3 h-16 bg-red-500 rounded-full shadow-md border border-red-600 group-hover:scale-110 transition-transform relative pointer-events-none">
                    <div class="absolute top-1 left-1/2 -translate-x-1/2 w-1.5 h-1.5 bg-black/20 rounded-full"></div>
                    <div class="absolute bottom-1 left-1/2 -translate-x-1/2 w-1.5 h-1.5 bg-black/20 rounded-full"></div>
                </div>
            </div>

            <div class="strip-dragger group flex flex-col items-center gap-1 transition active:scale-95" data-type="blue" title="Bande Moyenne (4)">
                <div class="w-3 h-12 bg-blue-500 rounded-full shadow-md border border-blue-600 group-hover:scale-110 transition-transform relative pointer-events-none">
                    <div class="absolute top-1 left-1/2 -translate-x-1/2 w-1.5 h-1.5 bg-black/20 rounded-full"></div>
                    <div class="absolute bottom-1 left-1/2 -translate-x-1/2 w-1.5 h-1.5 bg-black/20 rounded-full"></div>
                </div>
            </div>

            <div class="strip-dragger group flex flex-col items-center gap-1 transition active:scale-95" data-type="green" title="Bande Courte (3)">
                <div class="w-3 h-8 bg-green-500 rounded-full shadow-md border border-green-600 group-hover:scale-110 transition-transform relative pointer-events-none">
                    <div class="absolute top-1 left-1/2 -translate-x-1/2 w-1.5 h-1.5 bg-black/20 rounded-full"></div>
                    <div class="absolute bottom-1 left-1/2 -translate-x-1/2 w-1.5 h-1.5 bg-black/20 rounded-full"></div>
                </div>
            </div>
            
            <div class="strip-dragger group flex flex-col items-center gap-1 transition active:scale-95" data-type="purple" title="Bande Mini (2)">
                <div class="w-3 h-6 bg-purple-500 rounded-full shadow-md border border-purple-600 group-hover:scale-110 transition-transform relative pointer-events-none">
                    <div class="absolute top-1 left-1/2 -translate-x-1/2 w-1.5 h-1.5 bg-black/20 rounded-full"></div>
                    <div class="absolute bottom-1 left-1/2 -translate-x-1/2 w-1.5 h-1.5 bg-black/20 rounded-full"></div>
                </div>
            </div>

            <div class="flex-1"></div>

            <div class="w-8 h-px bg-slate-100 my-2"></div>
            <div class="text-[10px] text-center text-slate-300 px-2 leading-tight pb-4">
                Double-clic sur un magnet pour détacher
            </div>

        </aside>

        <!-- ESPACE DE TRAVAIL -->
        <main id="layer-container" class="cursor-grab active:cursor-grabbing">
            <!-- BACKGROUND LAYER -->
            <div id="bg-layer"></div>
            
            <canvas id="strips-canvas"></canvas>
            <canvas id="drawing-canvas"></canvas>

            <!-- Layer Outils -->
            <div id="geometry-tools-layer"></div>
        </main>
    </div>

    <!-- SCRIPT -->
    <script>
        /* --- CONFIGURATION --- */
        const CONFIG = {
            snapDistance: 45, 
            normalStripWidth: 26,
            thinStripWidth: 4, // Encore plus fin (était 8)
            currentStripWidth: 26, 
            colors: {
                yellow: { fill: '#f59e0b', stroke: '#b45309', length: 320 }, 
                red:    { fill: '#ef4444', stroke: '#b91c1c', length: 250 }, 
                blue:   { fill: '#3b82f6', stroke: '#1d4ed8', length: 200 }, 
                green:  { fill: '#22c55e', stroke: '#15803d', length: 150 }, 
                purple: { fill: '#a855f7', stroke: '#7e22ce', length: 100 }  
            }
        };

        /* --- ÉTAT GLOBAL --- */
        const state = {
            points: [], 
            strips: [], 
            tool: 'hand', 
            penColor: 'blue', 
            stripMode: 'normal', 
            exercisePrecision: 10, // 10, 5, or 1
            draggingPoint: null,
            draggingStrip: null, 
            dragOffset: {x:0, y:0},
            nextId: 1,
            tools: {
                setSquare: {
                    id: 'setSquare',
                    visible: false,
                    x: 0, y: 0,
                    rotation: 0,
                    scale: 1,
                    pivot: {x: 20, y: 220} 
                },
                protractor: {
                    id: 'protractor',
                    visible: false,
                    x: 0, y: 0,
                    rotation: 0,
                    scale: 1.5,
                    gradMode: 0, 
                    direction: 0,
                    showNumbers: false,
                    pivot: {x: 120, y: 120} 
                }
            },
            activeGeoTool: null
        };

        const canvasStrips = document.getElementById('strips-canvas');
        const ctxStrips = canvasStrips.getContext('2d');
        const canvasDraw = document.getElementById('drawing-canvas');
        const ctxDraw = canvasDraw.getContext('2d');
        const container = document.getElementById('layer-container');
        const toolsLayer = document.getElementById('geometry-tools-layer');
        const header = document.getElementById('main-header');
        const bgLayer = document.getElementById('bg-layer');
        const bgUploader = document.getElementById('bg-uploader');

        /* --- IMAGE DE FOND --- */
        bgUploader.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (evt) => {
                bgLayer.style.backgroundImage = `url(${evt.target.result})`;
            };
            reader.readAsDataURL(file);
        });

        /* --- INIT OUTILS --- */
        function initGeometryTools() {
            createGeoToolElement('setSquare', getSetSquareSVG(), '20px 220px');
            createGeoToolElement('protractor', getProtractorSVG(), '120px 120px', '240px', '140px');
        }

        function getSetSquareSVG() {
            return `
                <svg width="100%" height="100%" viewBox="0 0 240 240" style="overflow: visible;">
                    <path d="M20 220 L 220 220 L 20 20 Z" fill="rgba(255, 255, 255, 0.7)" stroke="#ca8a04" stroke-width="2" vector-effect="non-scaling-stroke" />
                    <path d="M20 190 L 50 190 L 50 220" fill="none" stroke="#ca8a04" stroke-width="1.5" opacity="0.6"/>
                    <line x1="20" y1="220" x2="220" y2="220" stroke="#ca8a04" stroke-width="1" stroke-dasharray="10 10" opacity="0.5" />
                    <line x1="20" y1="220" x2="20" y2="20" stroke="#ca8a04" stroke-width="1" stroke-dasharray="10 10" opacity="0.5" />
                </svg>
                <!-- Rotation Handle -->
                <div class="geo-handle rotate-handle absolute w-10 h-10 rounded-full shadow-lg flex items-center justify-center cursor-pointer bg-white" style="top: -40px; right: -40px; transform: translate(50%, -50%);" title="Tourner">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 12a9 9 0 1 1-9-9c2.52 0 4.85.99 6.57 2.57L21 8"/>
                        <path d="M21 3v5h-5"/>
                    </svg>
                </div>
            `;
        }

        function getProtractorSVG() {
            const mode = state.tools.protractor.gradMode;
            const direction = state.tools.protractor.direction;
            const showNumbers = state.tools.protractor.showNumbers;
            let marks = "";
            
            for (let i = 0; i <= 180; i++) {
                if (mode === 0 && i % 10 !== 0) continue;
                if (mode === 1 && i % 5 !== 0) continue;
                
                const angle = Math.PI - (i * Math.PI / 180);
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                
                let x1, y1, x2, y2;
                let width = 0.8;
                let opacity = 0.5;

                if (i % 10 === 0) {
                    x1 = 120 + 100 * cos;
                    y1 = 120 - 100 * sin;
                    x2 = 120 + 25 * cos;
                    y2 = 120 - 25 * sin;
                    width = 1.2;
                    opacity = 0.4;
                } else if (i % 5 === 0) {
                    x1 = 120 + 100 * cos;
                    y1 = 120 - 100 * sin;
                    x2 = 120 + 85 * cos;
                    y2 = 120 - 85 * sin;
                } else {
                    x1 = 120 + 100 * cos;
                    y1 = 120 - 100 * sin;
                    x2 = 120 + 92 * cos;
                    y2 = 120 - 92 * sin;
                }
                
                marks += `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="#4f46e5" stroke-width="${width}" opacity="${opacity}" />`;
                
                // Numbers
                if (showNumbers && i % 10 === 0 && i !== 180 && i !== 0) {
                    const val = direction === 0 ? i : (180 - i);
                    const tx = 120 + 115 * cos;
                    const ty = 120 - 115 * sin;
                    marks += `<text x="${tx}" y="${ty}" text-anchor="middle" dominant-baseline="middle" font-size="11" font-weight="bold" fill="#4338ca" style="pointer-events: none;">${val}</text>`;
                }
            }
            
            if (showNumbers) {
                const leftVal = direction === 0 ? "0" : "180";
                const rightVal = direction === 0 ? "180" : "0";
                marks += `<text x="10" y="115" text-anchor="middle" font-size="11" font-weight="bold" fill="#4338ca">${leftVal}</text>`;
                marks += `<text x="230" y="115" text-anchor="middle" font-size="11" font-weight="bold" fill="#4338ca">${rightVal}</text>`;
            }

            return `
                <svg width="100%" height="100%" viewBox="-30 -30 300 200" style="overflow: visible;">
                     <path d="M20 120 A 100 100 0 0 1 220 120 L 120 120 Z" fill="rgba(255, 255, 255, 0.4)" stroke="#4f46e5" stroke-width="2" />
                     
                     <!-- MARQUES ROUGES -->
                     <line x1="20" y1="120" x2="220" y2="120" stroke="#dc2626" stroke-width="2.5" opacity="0.9" />
                     <line x1="120" y1="120" x2="120" y2="20" stroke="#dc2626" stroke-width="2" opacity="0.6" stroke-dasharray="6 4" />

                     <!-- Centre -->
                     <circle cx="120" cy="120" r="4" fill="none" stroke="#dc2626" stroke-width="2"/>
                     <line x1="120" y1="110" x2="120" y2="130" stroke="#dc2626" stroke-width="2" />
                     
                     ${marks}
                </svg>
                
                <!-- Rotation Handle (Rapproché) -->
                <div class="geo-handle rotate-handle absolute w-10 h-10 rounded-full shadow-lg flex items-center justify-center cursor-pointer bg-white" style="top: -25px; left: 50%; transform: translate(-50%, 0);" title="Tourner">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 12a9 9 0 1 1-9-9c2.52 0 4.85.99 6.57 2.57L21 8"/>
                        <path d="M21 3v5h-5"/>
                    </svg>
                </div>
                <!-- Resize Handle (Rapproché) -->
                <div class="geo-handle resize-handle absolute w-8 h-8 rounded-full shadow-lg flex items-center justify-center cursor-pointer bg-white" style="bottom: 5px; right: 0px;" title="Redimensionner">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M15 3h6v6M9 21H3v-6M21 3l-7 7M3 21l7-7"/></svg>
                </div>
                
                <!-- Controls Row (Déplacé SOUS LA RÈGLE, hors du corps) -->
                <div class="geo-control-row absolute flex gap-1 items-center justify-center" style="bottom: -25px; left: 50%; transform: translate(-50%, 0);">
                    <div class="geo-handle style-handle no-translate h-5 px-2 bg-indigo-600 text-white font-bold text-[9px] rounded-full shadow flex items-center justify-center cursor-pointer border border-indigo-200" title="Précision">
                        ${mode === 0 ? "10°" : (mode === 1 ? "5°" : "1°")}
                    </div>
                    <div class="geo-handle numbers-handle no-translate h-5 w-5 text-indigo-600 font-bold text-[9px] rounded-full shadow flex items-center justify-center cursor-pointer border border-indigo-200" title="Afficher Valeurs">
                        ${showNumbers ? "123" : "..."}
                    </div>
                    <div class="geo-handle direction-handle no-translate h-5 w-5 text-indigo-600 font-bold text-[9px] rounded-full shadow flex items-center justify-center cursor-pointer border border-indigo-200" title="Inverser Sens">
                        <svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 12h16M4 12l4-4m-4 4l4 4M20 12l-4-4m4 4l-4 4"/></svg>
                    </div>
                </div>
            `;
        }

        function createGeoToolElement(key, html, origin, w='240px', h='240px') {
            const toolState = state.tools[key];
            const el = document.createElement('div');
            el.id = `tool-${toolState.id}`;
            el.className = 'geo-tool hidden absolute select-none';
            el.style.width = w;
            el.style.height = h;
            el.style.transformOrigin = origin;
            el.innerHTML = html;
            setupToolEvents(el, key);
            toolsLayer.appendChild(el);
        }

        function setupToolEvents(el, key) {
            el.addEventListener('mousedown', (e) => handleGeoToolStart(e, key));
            el.addEventListener('touchstart', (e) => handleGeoToolStart(e, key), {passive: false});
        }

        /* --- EXERCICE GENERATOR --- */
        function cycleExercisePrecision() {
            const btn = document.getElementById('btn-ex-prec');
            if (state.exercisePrecision === 10) state.exercisePrecision = 5;
            else if (state.exercisePrecision === 5) state.exercisePrecision = 1;
            else state.exercisePrecision = 10;
            btn.innerText = state.exercisePrecision + "°";
        }

        function generateExercise() {
            resetBoard();
            const rect = container.getBoundingClientRect();
            // Zone utile (on évite les bords)
            const margin = 50;
            const w = rect.width - 2 * margin;
            const h = rect.height - 2 * margin;
            
            // On veut 6 angles : 2x3 grille
            const cols = 3;
            const rows = 2;
            const cellW = w / cols;
            const cellH = h / rows;

            // Types d'angles: 2 Aigus, 2 Obtus, 1 Droit, 1 Plat ou Nul
            let anglesTypes = ['acute', 'acute', 'obtuse', 'obtuse', 'right', 'flat_or_zero'];
            anglesTypes = anglesTypes.sort(() => Math.random() - 0.5);

            let idx = 0;
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const cx = margin + c * cellW + cellW/2;
                    const cy = margin + r * cellH + cellH/2;
                    const type = anglesTypes[idx];
                    createAngleAt(cx, cy, type);
                    idx++;
                }
            }
            playSound('pop');
            render(); // Redessiner pour afficher les nouveaux angles
        }

        function createAngleAt(cx, cy, type) {
            // Déterminer la valeur de l'angle
            let angleDeg = 0;
            const prec = state.exercisePrecision;

            if (type === 'right') {
                angleDeg = 90;
            } else if (type === 'flat_or_zero') {
                angleDeg = (Math.random() > 0.5) ? 180 : 0;
            } else if (type === 'acute') {
                // Entre 10 et 89, multiple de prec
                let min = 10, max = 89;
                angleDeg = Math.floor(Math.random() * ((max - min)/prec + 1)) * prec + min;
            } else if (type === 'obtuse') {
                // Entre 91 et 179
                let min = 91, max = 179;
                angleDeg = Math.floor(Math.random() * ((max - min)/prec + 1)) * prec + min;
            } else {
                // Fallback (random safe)
                let min = 15, max = 160;
                angleDeg = Math.floor(Math.random() * ((max - min)/prec + 1)) * prec + min;
            }

            // Orientation aléatoire de la première branche
            const baseAngle = Math.random() * Math.PI * 2;
            
            // Choix des couleurs et longueurs (Random parmi toutes les couleurs)
            const availableTypes = ['red', 'yellow', 'blue', 'green'];
            const type1 = availableTypes[Math.floor(Math.random() * availableTypes.length)];
            const type2 = availableTypes[Math.floor(Math.random() * availableTypes.length)];
            
            const L1 = CONFIG.colors[type1].length;
            const L2 = CONFIG.colors[type2].length;

            const S = { id: state.nextId++, x: cx, y: cy, pinned: false };
            state.points.push(S);

            const A = { 
                id: state.nextId++, 
                x: cx + L1 * Math.cos(baseAngle), 
                y: cy + L1 * Math.sin(baseAngle), 
                pinned: false 
            };
            
            const angleRad = angleDeg * (Math.PI / 180);
            const B = { 
                id: state.nextId++, 
                x: cx + L2 * Math.cos(baseAngle + angleRad), 
                y: cy + L2 * Math.sin(baseAngle + angleRad), 
                pinned: false 
            };

            state.points.push(A, B);

            state.strips.push({ id: state.nextId++, p1: S.id, p2: A.id, type: type1 });
            state.strips.push({ id: state.nextId++, p1: S.id, p2: B.id, type: type2 });
        }

        /* --- TOGGLES --- */
        function toggleStripMode() {
            state.stripMode = state.stripMode === 'normal' ? 'thin' : 'normal';
            CONFIG.currentStripWidth = state.stripMode === 'normal' ? CONFIG.normalStripWidth : CONFIG.thinStripWidth;
            
            const btn = document.getElementById('btn-stripmode');
            if (state.stripMode === 'thin') {
                btn.classList.add('active-teal');
            } else {
                btn.classList.remove('active-teal');
            }
            render();
        }

        function toggleSetSquare() { toggleTool('setSquare'); }
        function toggleProtractor() { toggleTool('protractor'); }

        function toggleTool(key) {
            const tool = state.tools[key];
            tool.visible = !tool.visible;
            const el = document.getElementById(`tool-${tool.id}`);
            const btn = document.getElementById(key === 'setSquare' ? 'btn-setsquare' : 'btn-protractor');
            
            if (tool.visible) {
                el.classList.remove('hidden');
                const colorClass = key === 'setSquare' ? 'bg-yellow-100' : 'bg-indigo-100';
                btn.classList.add('active', colorClass);
                
                if (tool.x === 0 && tool.y === 0) {
                    const rect = container.getBoundingClientRect();
                    tool.x = rect.width / 2 - tool.pivot.x; 
                    tool.y = rect.height / 2 - tool.pivot.y; 
                }
                updateGeoToolTransform(key);
                playSound('pop');
            } else {
                el.classList.add('hidden');
                btn.classList.remove('active', 'bg-yellow-100', 'bg-indigo-100');
            }
        }

        function updateGeoToolTransform(key) {
            const tool = state.tools[key];
            const el = document.getElementById(`tool-${tool.id}`);
            if (!el) return;
            el.style.left = tool.x + 'px';
            el.style.top = tool.y + 'px';
            el.style.transform = `rotate(${tool.rotation}rad) scale(${tool.scale})`;
        }

        function updateProtractorVisuals() {
            const el = document.getElementById(`tool-protractor`);
            el.innerHTML = getProtractorSVG();
        }

        /* --- LOGIQUE OUTILS GÉOMÉTRIQUES --- */
        let geoDragState = {
            active: false,
            key: null,
            mode: null, 
            offsetX: 0, offsetY: 0,
            rotationOffset: 0,
            initialScale: 1,
            initialDist: 0
        };

        function handleGeoToolStart(e, key) {
            e.stopPropagation();
            e.preventDefault();
            
            if (key === 'protractor') {
                if (e.target.closest('.style-handle')) {
                    const tool = state.tools.protractor;
                    tool.gradMode = (tool.gradMode + 1) % 3;
                    updateProtractorVisuals();
                    playSound('click');
                    return;
                }
                if (e.target.closest('.numbers-handle')) {
                    const tool = state.tools.protractor;
                    tool.showNumbers = !tool.showNumbers;
                    updateProtractorVisuals();
                    playSound('click');
                    return;
                }
                if (e.target.closest('.direction-handle')) {
                    const tool = state.tools.protractor;
                    tool.direction = tool.direction === 0 ? 1 : 0;
                    updateProtractorVisuals();
                    playSound('click');
                    return;
                }
            }

            const pos = getPos(e);
            const tool = state.tools[key];
            const pivotAbsX = tool.x + tool.pivot.x;
            const pivotAbsY = tool.y + tool.pivot.y;

            if (e.target.closest('.rotate-handle')) {
                geoDragState.mode = 'rotate';
                const currentMouseAngle = Math.atan2(pos.y - pivotAbsY, pos.x - pivotAbsX);
                geoDragState.rotationOffset = tool.rotation - currentMouseAngle;
            } else if (e.target.closest('.resize-handle')) {
                geoDragState.mode = 'resize';
                geoDragState.initialScale = tool.scale;
                geoDragState.initialDist = Math.hypot(pos.x - pivotAbsX, pos.y - pivotAbsY);
            } else {
                geoDragState.mode = 'drag';
                geoDragState.offsetX = pos.x - tool.x;
                geoDragState.offsetY = pos.y - tool.y;
            }

            geoDragState.active = true;
            geoDragState.key = key;

            document.addEventListener('mousemove', handleGeoToolMove);
            document.addEventListener('touchmove', handleGeoToolMove, {passive: false});
            document.addEventListener('mouseup', handleGeoToolEnd);
            document.addEventListener('touchend', handleGeoToolEnd);
        }

        function handleGeoToolMove(e) {
            e.preventDefault();
            if (!geoDragState.active) return;
            
            const pos = getPos(e);
            const tool = state.tools[geoDragState.key];
            const pivotAbsX = tool.x + tool.pivot.x;
            const pivotAbsY = tool.y + tool.pivot.y;

            if (geoDragState.mode === 'drag') {
                tool.x = pos.x - geoDragState.offsetX;
                tool.y = pos.y - geoDragState.offsetY;
                
                const clientPos = getClientPos(e);
                const headerRect = header.getBoundingClientRect();
                if (clientPos.y <= headerRect.bottom) header.classList.add('trash-active');
                else header.classList.remove('trash-active');

            } else if (geoDragState.mode === 'rotate') {
                const currentMouseAngle = Math.atan2(pos.y - pivotAbsY, pos.x - pivotAbsX);
                tool.rotation = currentMouseAngle + geoDragState.rotationOffset;
            } else if (geoDragState.mode === 'resize') {
                const currentDist = Math.hypot(pos.x - pivotAbsX, pos.y - pivotAbsY);
                let newScale = geoDragState.initialScale * (currentDist / geoDragState.initialDist);
                newScale = Math.max(0.5, Math.min(newScale, 4.0)); // up to 4.0
                tool.scale = newScale;
            }
            updateGeoToolTransform(geoDragState.key);
        }

        function handleGeoToolEnd(e) {
            if (geoDragState.mode === 'drag') {
                const cy = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;
                const headerRect = header.getBoundingClientRect();
                if (cy <= headerRect.bottom) {
                    toggleTool(geoDragState.key);
                    playSound('trash');
                }
            }
            header.classList.remove('trash-active');

            geoDragState.active = false;
            document.removeEventListener('mousemove', handleGeoToolMove);
            document.removeEventListener('touchmove', handleGeoToolMove);
            document.removeEventListener('mouseup', handleGeoToolEnd);
            document.removeEventListener('touchend', handleGeoToolEnd);
        }


        /* --- COMMON EVENTS & LOGIC --- */

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            const now = audioCtx.currentTime;

            if (type === 'snap') {
                osc.type = 'square'; osc.frequency.setValueAtTime(800, now); osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
                gain.gain.setValueAtTime(0.05, now); gain.gain.linearRampToValueAtTime(0, now + 0.1);
                osc.start(now); osc.stop(now + 0.1);
            } else if (type === 'pop') {
                osc.type = 'sine'; osc.frequency.setValueAtTime(400, now); osc.frequency.exponentialRampToValueAtTime(600, now + 0.1);
                gain.gain.setValueAtTime(0.05, now); gain.gain.linearRampToValueAtTime(0, now + 0.1);
                osc.start(now); osc.stop(now + 0.1);
            } else if (type === 'detach') {
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(200, now);
                gain.gain.setValueAtTime(0.05, now); gain.gain.linearRampToValueAtTime(0, now + 0.15);
                osc.start(now); osc.stop(now + 0.15);
            } else if (type === 'trash') {
                osc.type = 'triangle'; osc.frequency.setValueAtTime(150, now); osc.frequency.exponentialRampToValueAtTime(50, now + 0.2);
                gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now + 0.2);
                osc.start(now); osc.stop(now + 0.2);
            } else if (type === 'click') {
                osc.type = 'square'; osc.frequency.setValueAtTime(600, now);
                gain.gain.setValueAtTime(0.02, now); gain.gain.linearRampToValueAtTime(0, now + 0.05);
                osc.start(now); osc.stop(now + 0.05);
            }
        }

        /* --- GESTION DES TAILLES --- */
        function resize() {
            const rect = container.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            [canvasStrips, canvasDraw].forEach(c => {
                c.width = rect.width * dpr;
                c.height = rect.height * dpr;
                c.style.width = rect.width + 'px';
                c.style.height = rect.height + 'px';
                c.getContext('2d').setTransform(dpr, 0, 0, dpr, 0, 0);
            });
            render();
        }
        window.addEventListener('resize', resize);
        setTimeout(resize, 100);

        /* --- LOGIQUE DRAG & DROP DEPUIS LA SIDEBAR --- */
        function initSidebarDrag() {
            const draggers = document.querySelectorAll('.strip-dragger');
            draggers.forEach(btn => {
                const startDrag = (e) => {
                    const type = btn.dataset.type;
                    const length = CONFIG.colors[type].length;
                    const color = CONFIG.colors[type].fill;
                    const border = CONFIG.colors[type].stroke;
                    
                    const ghost = document.createElement('div');
                    ghost.style.position = 'fixed';
                    ghost.style.width = length + 'px';
                    ghost.style.height = CONFIG.currentStripWidth + 'px'; 
                    ghost.style.backgroundColor = color;
                    ghost.style.border = `2px solid ${border}`;
                    ghost.style.borderRadius = (CONFIG.currentStripWidth/2) + 'px';
                    ghost.style.opacity = '0.8';
                    ghost.style.zIndex = '9999';
                    ghost.style.pointerEvents = 'none';
                    ghost.style.boxShadow = '0 10px 15px -3px rgba(0, 0, 0, 0.3)';
                    ghost.style.transform = 'translate(-50%, -50%)'; 
                    document.body.appendChild(ghost);
                    
                    const startX = e.touches ? e.touches[0].clientX : e.clientX;
                    const startY = e.touches ? e.touches[0].clientY : e.clientY;
                    ghost.style.left = startX + 'px'; ghost.style.top = startY + 'px';

                    const moveDrag = (ev) => {
                        ev.preventDefault(); 
                        const clientX = ev.touches ? ev.touches[0].clientX : ev.clientX;
                        const clientY = ev.touches ? ev.touches[0].clientY : ev.clientY;
                        ghost.style.left = clientX + 'px'; ghost.style.top = clientY + 'px';
                    };
                    
                    const endDrag = (ev) => {
                        const clientX = ev.changedTouches ? ev.changedTouches[0].clientX : ev.clientX;
                        const clientY = ev.changedTouches ? ev.changedTouches[0].clientY : ev.clientY;
                        const canvasRect = container.getBoundingClientRect();
                        if (clientX >= canvasRect.left && clientX <= canvasRect.right && clientY >= canvasRect.top && clientY <= canvasRect.bottom) {
                            const x = clientX - canvasRect.left;
                            const y = clientY - canvasRect.top;
                            addStrip(type, x, y);
                        }
                        ghost.remove();
                        document.removeEventListener('mousemove', moveDrag); document.removeEventListener('touchmove', moveDrag);
                        document.removeEventListener('mouseup', endDrag); document.removeEventListener('touchend', endDrag);
                    };
                    document.addEventListener('mousemove', moveDrag); document.addEventListener('touchmove', moveDrag, {passive: false});
                    document.addEventListener('mouseup', endDrag); document.addEventListener('touchend', endDrag);
                };
                btn.addEventListener('mousedown', startDrag); btn.addEventListener('touchstart', startDrag, {passive: false});
            });
        }
        initSidebarDrag();

        /* --- MOTEUR PHYSIQUE --- */
        function solveConstraints() {
            for (let i = 0; i < 5; i++) {
                state.strips.forEach(strip => {
                    const p1 = state.points.find(p => p.id === strip.p1);
                    const p2 = state.points.find(p => p.id === strip.p2);
                    if (!p1 || !p2) return;

                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const dist = Math.hypot(dx, dy);
                    const targetLen = CONFIG.colors[strip.type].length;
                    
                    if (dist === 0) return;
                    const diff = (dist - targetLen) / dist;
                    const offsetX = dx * diff * 0.5;
                    const offsetY = dy * diff * 0.5;

                    if (!p1.pinned) { p1.x += offsetX; p1.y += offsetY; }
                    if (!p2.pinned) { p2.x -= offsetX; p2.y -= offsetY; }
                    if (p1.pinned && !p2.pinned) { p2.x -= offsetX; p2.y -= offsetY; }
                    if (!p1.pinned && p2.pinned) { p1.x += offsetX; p1.y += offsetY; }
                });
            }
        }

        /* --- ACTIONS --- */
        function addStrip(type, x = null, y = null) {
            playSound('pop');
            const rect = container.getBoundingClientRect();
            const cx = x !== null ? x : rect.width / 2;
            const cy = y !== null ? y : rect.height / 2;
            const len = CONFIG.colors[type].length;

            const p1 = { id: state.nextId++, x: cx - len/2, y: cy, pinned: false };
            const p2 = { id: state.nextId++, x: cx + len/2, y: cy, pinned: false };
            
            state.points.push(p1, p2);
            state.strips.push({ id: state.nextId++, p1: p1.id, p2: p2.id, type: type });
            render();
        }

        function removeStrip(strip) {
            state.strips = state.strips.filter(s => s.id !== strip.id);
            const usedPointIds = new Set();
            state.strips.forEach(s => { usedPointIds.add(s.p1); usedPointIds.add(s.p2); });
            state.points = state.points.filter(p => usedPointIds.has(p.id));
            playSound('trash');
            render();
        }

        function resetBoard() {
            state.points = [];
            state.strips = [];
            ['setSquare', 'protractor'].forEach(key => {
                state.tools[key].visible = false;
                const el = document.getElementById(`tool-${state.tools[key].id}`);
                el.classList.add('hidden');
            });
            document.getElementById('btn-setsquare').classList.remove('active', 'bg-yellow-100');
            document.getElementById('btn-protractor').classList.remove('active', 'bg-indigo-100');
            bgLayer.style.backgroundImage = ''; 
            clearDrawings();
            render();
        }

        /* --- GESTION SOURIS / TOUCH --- */
        function getPos(e) {
            const rect = container.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return { x: clientX - rect.left, y: clientY - rect.top };
        }
        
        function getClientPos(e) {
             return {
                x: e.touches ? e.touches[0].clientX : e.clientX,
                y: e.touches ? e.touches[0].clientY : e.clientY
            };
        }

        function getPointAt(x, y) { return state.points.find(p => Math.hypot(p.x - x, p.y - y) < 45); }

        function getStripAt(x, y) {
            return state.strips.find(s => {
                const p1 = state.points.find(p => p.id === s.p1);
                const p2 = state.points.find(p => p.id === s.p2);
                if(!p1 || !p2) return false;
                const A = x - p1.x; const B = y - p1.y; const C = p2.x - p1.x; const D = p2.y - p1.y;
                const dot = A * C + B * D; const lenSq = C * C + D * D;
                let param = -1; if (lenSq !== 0) param = dot / lenSq;
                let xx, yy;
                if (param < 0) { xx = p1.x; yy = p1.y; } else if (param > 1) { xx = p2.x; yy = p2.y; } else { xx = p1.x + param * C; yy = p1.y + param * D; }
                const dx = x - xx; const dy = y - yy;
                return Math.hypot(dx, dy) < (CONFIG.normalStripWidth / 2); 
            });
        }

        function getAllConnectedPoints(startStrip) {
            const pointsToMove = new Set(); const stripsChecked = new Set(); const queue = [startStrip];
            while(queue.length > 0) {
                const s = queue.shift();
                if(stripsChecked.has(s.id)) continue;
                stripsChecked.add(s.id);
                pointsToMove.add(s.p1); pointsToMove.add(s.p2);
                state.strips.forEach(neighbor => {
                    if(!stripsChecked.has(neighbor.id)) {
                        if(neighbor.p1 === s.p1 || neighbor.p1 === s.p2 || neighbor.p2 === s.p1 || neighbor.p2 === s.p2) queue.push(neighbor);
                    }
                });
            }
            return Array.from(pointsToMove).map(id => state.points.find(p => p.id === id));
        }

        container.addEventListener('mousedown', handleStart);
        container.addEventListener('touchstart', handleStart, {passive: false});

        function handleStart(e) {
            if (state.tool === 'pen') return;
            const pos = getPos(e);
            
            const point = getPointAt(pos.x, pos.y);
            if (point) {
                state.draggingPoint = point; point.pinned = true; return;
            }

            const strip = getStripAt(pos.x, pos.y);
            if (strip) {
                state.draggingStrip = getAllConnectedPoints(strip);
                state.draggingStripRef = strip; state.dragOffset = pos;
                state.draggingStrip.forEach(p => p.pinned = true); return;
            }
        }

        window.addEventListener('mousemove', handleMove);
        window.addEventListener('touchmove', handleMove, {passive: false});

        function handleMove(e) {
            if (geoDragState.active) return;
            const pos = getPos(e);
            const clientPos = getClientPos(e);

            if (state.tool === 'pen') { updateCustomCursor(e); return; }

            const hoverPoint = getPointAt(pos.x, pos.y);
            if (!e.target.closest('.geo-tool')) {
                container.style.cursor = hoverPoint ? 'crosshair' : (getStripAt(pos.x, pos.y) ? 'move' : 'default');
            }

            if (state.draggingPoint) {
                e.preventDefault();
                let targetX = pos.x; let targetY = pos.y;
                
                const self = state.draggingPoint;
                const snapTarget = state.points.find(p => p.id !== self.id && Math.hypot(p.x - pos.x, p.y - pos.y) < CONFIG.snapDistance);
                if (snapTarget) { targetX = snapTarget.x; targetY = snapTarget.y; }

                state.draggingPoint.x = targetX; state.draggingPoint.y = targetY;
                solveConstraints(); render();

            } else if (state.draggingStrip) {
                e.preventDefault();
                const headerRect = header.getBoundingClientRect();
                if (clientPos.y <= headerRect.bottom) header.classList.add('trash-active'); else header.classList.remove('trash-active');

                const dx = pos.x - state.dragOffset.x; const dy = pos.y - state.dragOffset.y;
                state.draggingStrip.forEach(p => { p.x += dx; p.y += dy; });
                state.dragOffset = pos;
                solveConstraints(); render();
            }
        }

        window.addEventListener('mouseup', handleEnd);
        window.addEventListener('touchend', handleEnd);

        function handleEnd(e) {
            header.classList.remove('trash-active');

            if (state.draggingPoint) {
                const self = state.draggingPoint;
                const target = state.points.find(p => p.id !== self.id && Math.hypot(p.x - self.x, p.y - self.y) < CONFIG.snapDistance);

                if (target) {
                    playSound('snap');
                    state.strips.forEach(s => {
                        if (s.p1 === self.id) s.p1 = target.id;
                        if (s.p2 === self.id) s.p2 = target.id;
                    });
                    state.points = state.points.filter(p => p.id !== self.id);
                } 
                self.pinned = false; state.draggingPoint = null; render();
            }

            if (state.draggingStrip) {
                const clientY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;
                const headerRect = header.getBoundingClientRect();
                if (clientY <= headerRect.bottom) { if (state.draggingStripRef) removeStrip(state.draggingStripRef); }
                state.draggingStrip.forEach(p => p.pinned = false);
                state.draggingStrip = null; state.draggingStripRef = null;
            }
        }
        
        container.addEventListener('dblclick', (e) => {
            if (state.tool === 'pen' || e.target.closest('.geo-tool')) return;
            const pos = getPos(e);
            const point = getPointAt(pos.x, pos.y);
            
            if (point) {
                const connectedStrips = state.strips.filter(s => s.p1 === point.id || s.p2 === point.id);
                if (connectedStrips.length > 1) {
                    playSound('detach');
                    for (let i = 1; i < connectedStrips.length; i++) {
                        const s = connectedStrips[i];
                        const newP = { id: state.nextId++, x: point.x + (Math.random()*20 - 10), y: point.y + (Math.random()*20 - 10), pinned: false };
                        state.points.push(newP);
                        if (s.p1 === point.id) s.p1 = newP.id; else s.p2 = newP.id;
                    }
                    render();
                }
            }
        });

        /* --- RENDU --- */
        function render() {
            ctxStrips.clearRect(0, 0, canvasStrips.width, canvasStrips.height);

            // 2. Bandes
            const sortedStrips = [...state.strips].sort((a, b) => {
                const lenA = CONFIG.colors[a.type].length;
                const lenB = CONFIG.colors[b.type].length;
                return lenB - lenA; 
            });

            ctxStrips.shadowColor = "rgba(0,0,0,0.2)";
            ctxStrips.shadowBlur = 6;
            ctxStrips.shadowOffsetY = 3;

            sortedStrips.forEach(strip => {
                const p1 = state.points.find(p => p.id === strip.p1);
                const p2 = state.points.find(p => p.id === strip.p2);
                if (!p1 || !p2) return;

                const style = CONFIG.colors[strip.type];
                
                ctxStrips.beginPath();
                ctxStrips.lineWidth = CONFIG.currentStripWidth;
                ctxStrips.lineCap = 'round';
                ctxStrips.strokeStyle = style.fill;
                ctxStrips.moveTo(p1.x, p1.y);
                ctxStrips.lineTo(p2.x, p2.y);
                ctxStrips.stroke();
            });
            
            ctxStrips.shadowColor = "rgba(0,0,0,0.3)";
            ctxStrips.shadowBlur = 2;
            ctxStrips.shadowOffsetY = 1;

            state.points.forEach(p => {
                const connectionCount = state.strips.filter(s => s.p1 === p.id || s.p2 === p.id).length;
                
                ctxStrips.beginPath();
                // Adapter la taille du rivet si le trait est fin
                const rivetSize = state.stripMode === 'thin' ? 4 : 6;
                ctxStrips.arc(p.x, p.y, rivetSize, 0, Math.PI * 2);
                ctxStrips.fillStyle = connectionCount > 1 ? '#475569' : '#f1f5f9'; 
                ctxStrips.fill();
                ctxStrips.strokeStyle = '#334155';
                ctxStrips.lineWidth = 2;
                ctxStrips.stroke();
            });
        }

        /* --- LOGIQUE CRAYON --- */
        let isDrawing = false;
        let lastX = 0, lastY = 0;

        function setTool(t, color = null) {
            state.tool = t;
            if (color) state.penColor = color;

            const cursorDiv = document.getElementById('custom-cursor');
            const handBtn = document.getElementById('tool-hand');
            const penBlueBtn = document.getElementById('tool-pen-blue');
            const penRedBtn = document.getElementById('tool-pen-red');
            const cursorPath = document.getElementById('cursor-color-1');

            handBtn.classList.remove('active', 'bg-slate-200');
            penBlueBtn.classList.remove('active', 'bg-blue-100');
            penRedBtn.classList.remove('active-red', 'bg-red-50');

            if (t === 'hand') {
                container.classList.remove('hide-cursor');
                cursorDiv.style.display = 'none';
                canvasDraw.style.pointerEvents = 'none';
                handBtn.classList.add('active', 'bg-slate-200');
            } else {
                container.classList.add('hide-cursor');
                cursorDiv.style.display = 'block';
                canvasDraw.style.pointerEvents = 'auto';
                
                if (state.penColor === 'blue') {
                    penBlueBtn.classList.add('active', 'bg-blue-100');
                    ctxDraw.strokeStyle = '#2563eb';
                    cursorPath.setAttribute('stroke', '#2563eb');
                } else {
                    penRedBtn.classList.add('active-red', 'bg-red-50');
                    ctxDraw.strokeStyle = '#dc2626';
                    cursorPath.setAttribute('stroke', '#dc2626');
                }
                
                ctxDraw.lineCap = 'round';
                ctxDraw.lineJoin = 'round';
                ctxDraw.lineWidth = 3;
            }
        }

        function updateCustomCursor(e) {
            const cursorDiv = document.getElementById('custom-cursor');
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            cursorDiv.style.left = clientX + 'px';
            cursorDiv.style.top = clientY + 'px';
            cursorDiv.style.transform = 'translate(-2px, -30px)';
        }

        function startDraw(e) {
            if (state.tool !== 'pen') return;
            isDrawing = true;
            const pos = getPos(e);
            lastX = pos.x; lastY = pos.y;
            ctxDraw.beginPath();
            ctxDraw.moveTo(lastX, lastY);
        }

        function draw(e) {
            if (!isDrawing || state.tool !== 'pen') return;
            e.preventDefault(); 
            const pos = getPos(e);
            ctxDraw.lineTo(pos.x, pos.y);
            ctxDraw.stroke();
            lastX = pos.x; lastY = pos.y;
        }

        function stopDraw() { isDrawing = false; }
        
        function clearDrawings() {
            ctxDraw.clearRect(0, 0, canvasDraw.width, canvasDraw.height);
        }

        canvasDraw.addEventListener('mousedown', startDraw);
        canvasDraw.addEventListener('mousemove', draw);
        canvasDraw.addEventListener('mouseup', stopDraw);
        canvasDraw.addEventListener('touchstart', startDraw, {passive: false});
        canvasDraw.addEventListener('touchmove', draw, {passive: false});
        canvasDraw.addEventListener('touchend', stopDraw);

        // Init
        initGeometryTools();
        render();

    </script>
</body>
</html>
