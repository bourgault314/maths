<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Atelier : Unités d'Aire (V32 - full SVG stable + calques par unité)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;800&display=swap" rel="stylesheet">
    <style>
        :root {
            --view-scale: 1;
            --inv-scale: 1;
            --ghost-border: 2px;
        }

        body {
            font-family: 'Fredoka', sans-serif;
            background-color: #f8fafc;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            transition: background-color 0.5s;
        }

        #app-container {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            overflow: hidden;
            cursor: crosshair;
        }

        #svg-world {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 5;
        }

        #grid-layer {
            position: absolute; top: 0; left: 0;
            z-index: 10;
            pointer-events: none;
        }

        #draw-layer {
            position: absolute; top: 0; left: 0;
            z-index: 20;
            pointer-events: none;
        }

        #ghost {
            position: absolute; top: 0; left: 0;
            z-index: 30;
            pointer-events: none;
            border: var(--ghost-border) solid currentColor;
            background: rgba(255,255,255,0.3);
            display: none;
        }

        /* UI */
        .ui-panel {
            background: white; border: 1px solid #cbd5e1;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08); border-radius: 12px;
            pointer-events: auto;
        }
        .tool-btn {
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            padding: 6px; border-radius: 8px; color: #64748b; min-width: 50px; transition: all 0.1s;
        }
        .tool-btn:active { transform: scale(0.95); }
        .tool-btn.active { background-color: #e0f2fe; color: #0284c7; font-weight: bold; }
        .tool-btn svg { width: 24px; height: 24px; margin-bottom: 2px; }

        .unit-pill {
            padding: 6px 14px; border-radius: 6px; font-weight: 600; font-size: 13px;
            cursor: pointer; background: white; border: 1px solid #cbd5e1; color: #64748b;
        }
        .unit-pill.active { background-color: #3b82f6; color: white; border-color: #2563eb; }

        .toggle-btn {
            display: flex; align-items: center; gap: 6px; background: white;
            padding: 6px 12px; border-radius: 6px; border: 1px solid #cbd5e1;
            font-size: 12px; font-weight: 600; color: #64748b; cursor: pointer;
        }
        .toggle-btn.active { background-color: #dcfce7; border-color: #16a34a; color: #15803d; }

        .modal-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.5); backdrop-filter: blur(2px);
            z-index: 999; display: flex; align-items: center; justify-content: center;
        }

        /* SVG : on masque les textes tant que le mode 123 n'est pas actif */
        body:not(.show-values) .tile-text { display: none; }
    </style>
</head>
<body oncontextmenu="return false;">

<div id="app-container">
    <svg id="svg-world" xmlns="http://www.w3.org/2000/svg">
        <g id="camera"></g>
    </svg>
    <canvas id="grid-layer"></canvas>
    <canvas id="draw-layer"></canvas>
    <div id="ghost"></div>
</div>

<!-- UI HAUT -->
<div class="absolute top-4 left-0 right-0 flex flex-col items-center gap-2 pointer-events-none z-50">
    <div class="flex flex-wrap gap-2 pointer-events-auto bg-white/95 p-1.5 rounded-lg border shadow-sm">
        <div class="unit-pill" onclick="app.setUnit('mm')" id="btn-mm">mm<sup>2</sup></div>
        <div class="unit-pill active" onclick="app.setUnit('cm')" id="btn-cm">cm<sup>2</sup></div>
        <div class="unit-pill" onclick="app.setUnit('dm')" id="btn-dm">dm<sup>2</sup></div>
        <div class="unit-pill" onclick="app.setUnit('m')" id="btn-m">m<sup>2</sup></div>
        <div class="unit-pill" onclick="app.setUnit('dam')" id="btn-dam" title="= 1 are (a)">dam<sup>2</sup></div>
        <div class="unit-pill" onclick="app.setUnit('hm')" id="btn-hm" title="= 1 hectare (ha)">hm<sup>2</sup></div>
        <div class="unit-pill" onclick="app.setUnit('km')" id="btn-km">km<sup>2</sup></div>
    </div>
    <div class="flex gap-2 pointer-events-auto">
        <button id="btn-grid-toggle" class="toggle-btn" onclick="app.cycleGridMode()" style="display:none">Grille: Normale</button>
        <button id="btn-values" class="toggle-btn" onclick="app.toggleValues()">Valeur</button>
    </div>
</div>

<!-- UI BAS -->
<div class="absolute bottom-6 left-0 right-0 flex justify-center items-end gap-4 pointer-events-none z-50">
    <!-- Zoom -->
    <div class="ui-panel flex flex-col gap-1 p-1.5 pointer-events-auto">
        <button onclick="app.zoom(1)" class="tool-btn w-10 h-10 bg-white hover:bg-slate-50 rounded shadow-sm flex items-center justify-center">
            <svg fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2.5"><path d="M12 4v16m8-8H4"/></svg>
        </button>
        <button onclick="app.zoom(-1)" class="tool-btn w-10 h-10 bg-white hover:bg-slate-50 rounded shadow-sm flex items-center justify-center">
            <svg fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2.5"><path d="M20 12H4"/></svg>
        </button>
    </div>

    <!-- Outils -->
    <div class="ui-panel flex items-center gap-1 p-1.5 pointer-events-auto">
        <button onclick="app.undo()" class="tool-btn" title="Annuler">
            <svg fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6"/></svg>
        </button>
        <div class="w-px h-8 bg-slate-200 mx-1"></div>

        <button id="tool-hand" onclick="app.setTool('hand')" class="tool-btn" title="Bouger la vue">
            <svg fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M7 11.5V14m0-2.5v-6a1.5 1.5 0 113 0m-3 6a1.5 1.5 0 00-3 0v2a7.5 7.5 0 0015 0v-5a1.5 1.5 0 00-3 0m-6-3V11m0-5.5v-1a1.5 1.5 0 013 0v1m0 0V11m0-5.5a1.5 1.5 0 013 0v3m0 0V11"/></svg>
            <span class="text-[10px] mt-0.5">Bouger</span>
        </button>

        <button id="tool-paint" onclick="app.setTool('paint')" class="tool-btn active" title="Placer des carrés">
            <svg fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"/></svg>
            <span class="text-[10px] mt-0.5">Placer</span>
        </button>

        <button id="tool-eraser" onclick="app.setTool('eraser')" class="tool-btn" title="Enlever des blocs">
            <svg fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" class="text-rose-500">
                <path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
                <path stroke-linecap="round" stroke-linejoin="round" d="M10 11v6m4-6v6"/>
            </svg>
            <span class="text-[10px] mt-0.5">Enlever</span>
        </button>

        <div class="w-px h-8 bg-slate-200 mx-1"></div>

        <button id="tool-pen" onclick="app.setTool('pen')" class="tool-btn" title="Écrire">
            <svg fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"/></svg>
            <span class="text-[10px] mt-0.5">Stylo</span>
        </button>

        <button onclick="app.clearDrawings()" class="tool-btn text-orange-500 hover:text-orange-700 hover:bg-orange-50" title="Effacer Dessins">
            <svg fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><rect x="4" y="4" width="16" height="10" rx="2" stroke="currentColor" fill="none"/><path d="M4 14l16 0" stroke="currentColor"/><path d="M7 14v4a2 2 0 002 2h6a2 2 0 002-2v-4" stroke="currentColor" fill="none"/></svg>
            <span class="text-[10px] mt-0.5">Gomme</span>
        </button>

        <div class="w-px h-8 bg-slate-200 mx-1"></div>

        <button onclick="app.openModal()" class="tool-btn text-indigo-600" title="Rectangle Précis">
            <svg fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><rect x="3" y="5" width="18" height="14" rx="2" /></svg>
            <span class="text-[10px] mt-0.5">Rect.</span>
        </button>
        <button onclick="app.clear()" class="tool-btn text-rose-600 hover:text-rose-800 hover:bg-rose-50" title="Tout Effacer">
            <svg fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/></svg>
        </button>
    </div>
</div>

<!-- MODALE -->
<div id="rect-modal" class="modal-overlay hidden">
    <div class="bg-white rounded-xl p-6 w-80 shadow-2xl">
        <h3 class="text-lg font-bold mb-4 text-slate-700">Nouveau Rectangle</h3>
        <div class="flex gap-4 mb-4">
            <div class="flex-1">
                <label class="block text-xs font-bold text-slate-400">LARGEUR</label>
                <input type="number" id="rect-w" value="5" class="w-full text-center font-bold text-xl p-2 border rounded">
            </div>
            <div class="flex items-center font-bold">×</div>
            <div class="flex-1">
                <label class="block text-xs font-bold text-slate-400">HAUTEUR</label>
                <input type="number" id="rect-h" value="3" class="w-full text-center font-bold text-xl p-2 border rounded">
            </div>
        </div>
        <!-- Aire masquée volontairement : peut servir d'exercice -->
        <div class="text-center text-sm mb-4 font-bold text-slate-600 hidden">
            Aire : <span id="rect-preview">15</span>
        </div>
        <div class="flex gap-2">
            <button onclick="document.getElementById('rect-modal').classList.add('hidden')" class="flex-1 py-2 font-bold text-slate-500 hover:bg-slate-100 rounded">Annuler</button>
            <button onclick="app.addRect()" class="flex-1 py-2 font-bold text-white bg-blue-600 hover:bg-blue-700 rounded">Créer</button>
        </div>
    </div>
</div>

<script>
    const BASE_PX = 50;
    const SVG_NS = 'http://www.w3.org/2000/svg';

    const CONFIG = {
        units: {
            'mm': { color: 'rgba(239, 68, 68, 0.5)', bg: '#fff1f2', label: 'mm²', realSize: 0.1, zoom: 8.0, step: 0.1 },
            'cm': { color: 'rgba(59, 130, 246, 0.5)', bg: '#eff6ff', label: 'cm²', realSize: 1.0, zoom: 1.0, step: 1 },
            'dm': { color: 'rgba(16, 185, 129, 0.5)', bg: '#f0fdf4', label: 'dm²', realSize: 10.0, zoom: 0.35, step: 10 },
            'm':  { color: 'rgba(245, 158, 11, 0.5)', bg: '#fffbeb', label: 'm²',  realSize: 100.0, zoom: 0.04, step: 100 },
            'dam': { color: 'rgba(20, 184, 166, 0.5)', bg: '#ecfeff', label: 'dam²', realSize: 1000.0, zoom: 0.004, step: 1000 },
            'hm': { color: 'rgba(139, 92, 246, 0.5)', bg: '#f5f3ff', label: 'hm²', realSize: 10000.0, zoom: 0.0004, step: 10000 },
            'km': { color: 'rgba(100, 116, 139, 0.5)', bg: '#f1f5f9', label: 'km²', realSize: 100000.0, zoom: 0.00004, step: 100000 }
        }
    };

    function labelHtml(lbl) {
        return (lbl && lbl.endsWith('²')) ? (lbl.slice(0, -1) + '<sup>2</sup>') : lbl;
    }

    function createUnitTextParts(lbl) {
        // lbl ex: "cm²" -> {base:"cm", sup:"2"}
        if (!lbl) return { base: '', sup: '' };
        if (lbl.endsWith('²')) return { base: lbl.slice(0, -1), sup: '2' };
        return { base: lbl, sup: '' };
    }

    function makeSvgEl(tag, attrs = {}) {
        const el = document.createElementNS(SVG_NS, tag);
        for (const [k, v] of Object.entries(attrs)) el.setAttribute(k, String(v));
        return el;
    }

    function makeLabelText(x, y, fontSizePx, countStr, unitLabel, noSpace) {
        const parts = createUnitTextParts(unitLabel);
        const text = makeSvgEl('text', {
            x, y,
            'text-anchor': 'middle',
            'dominant-baseline': 'central',
            class: 'tile-text'
        });
        text.setAttribute('fill', '#000');
        text.setAttribute('font-family', 'sans-serif');
        text.setAttribute('font-weight', '700');
        text.setAttribute('font-size', String(fontSizePx));

        const t1 = makeSvgEl('tspan');
        const space = noSpace ? '' : ' ';
        t1.textContent = countStr + space + parts.base;
        text.appendChild(t1);

        if (parts.sup) {
            const t2 = makeSvgEl('tspan', {
                'baseline-shift': 'super',
                'font-size': '0.7em'
            });
            t2.textContent = parts.sup;
            text.appendChild(t2);
        }

        // Métadonnées : utile pour ajuster la taille du texte lorsque celui-ci est "verrouillé" (hm/km)
        const chars = (String(countStr).length) + (noSpace ? 0 : 1) + (parts.base ? parts.base.length : 0) + (parts.sup ? 0.7 : 0);
        text.setAttribute('data-base-font', String(fontSizePx));
        text.setAttribute('data-chars', String(chars));
        text.setAttribute('data-nospace', noSpace ? '1' : '0');

        return text;
    }

    class App {
        constructor() {
            this.state = {
                unit: 'cm', tool: 'paint', x: window.innerWidth / 2, y: window.innerHeight / 2, scale: 1,
                gridMode: 0, showValues: false, isDragging: false, lastX: 0, lastY: 0
            };

            this.drawings = [];
            this.currentStroke = null;
            this.history = [];

            // Perf / stabilite (full SVG)
            this._renderQueued = false;
            this._wheelZoomSteps = 0;
            this._wheelRAF = null;
            this._zoomAnimToken = 0;
            this._hasLockedText = false;

            this.svg = document.getElementById('svg-world');
            this.camera = document.getElementById('camera');

            // Calques : le plus petit au-dessus (mm au-dessus de cm, etc.)
            this.ensureLayers();
            this.ghost = document.getElementById('ghost');
            this.elViewport = document.getElementById('app-container');

            this.canvasGrid = document.getElementById('grid-layer');
            this.ctxGrid = this.canvasGrid.getContext('2d');
            this.canvasDraw = document.getElementById('draw-layer');
            this.ctxDraw = this.canvasDraw.getContext('2d');

            this.elViewport.addEventListener('pointerdown', e => this.onDown(e));
            window.addEventListener('pointermove', e => this.onMove(e));
            window.addEventListener('pointerup', e => this.onUp(e));
            this.elViewport.addEventListener('wheel', e => this.onWheel(e), { passive: false });
            window.addEventListener('resize', () => this.requestRender());

            const updatePreview = () => {
                const w = document.getElementById('rect-w').value;
                const h = document.getElementById('rect-h').value;
                document.getElementById('rect-preview').innerHTML = (w * h) + ' ' + labelHtml(CONFIG.units[this.state.unit].label);
            };
            document.getElementById('rect-w').addEventListener('input', updatePreview);
            document.getElementById('rect-h').addEventListener('input', updatePreview);

            this.setUnit('cm');
        }

        ensureSvgSize() {
            const w = window.innerWidth;
            const h = window.innerHeight;
            this.svg.setAttribute('viewBox', `0 0 ${w} ${h}`);
        }

        requestRender() {

            if (this._renderQueued) return;

            this._renderQueued = true;

            requestAnimationFrame(() => {

                this._renderQueued = false;

                this.renderAllImmediate();

            });

        }


        renderAllImmediate() {
            this.ensureSvgSize();

            document.documentElement.style.setProperty('--view-scale', String(this.state.scale));
            document.documentElement.style.setProperty('--inv-scale', String(1 / this.state.scale));

            this.drawGrid();
            this.drawDrawings();

            // Matrix : screen = scale*world + translate
            const s = this.state.scale;
            const tx = this.state.x;
            const ty = this.state.y;
            this.camera.setAttribute('transform', `matrix(${s} 0 0 ${s} ${tx} ${ty})`);

            this.updateLockedText();
        }

        updateLockedText() {
            if (!this._hasLockedText) return;
            const inv = 1 / this.state.scale;
            const groups = this.camera.querySelectorAll('[data-lock-text="1"]');
            groups.forEach(g => {
                const cx = parseFloat(g.getAttribute('data-cx') || '0');
                const cy = parseFloat(g.getAttribute('data-cy') || '0');
                // Annule l'effet du zoom uniquement sur ce groupe de texte
                g.setAttribute('transform', `translate(${cx} ${cy}) scale(${inv}) translate(${-cx} ${-cy})`);

                const tile = g.closest('.tile-svg');
                if (!tile) return;

                const wpx = parseFloat(tile.getAttribute('data-wpx') || '0');
                const hpx = parseFloat(tile.getAttribute('data-hpx') || '0');
                const screenW = wpx * this.state.scale;
                const screenH = hpx * this.state.scale;

                const texts = g.querySelectorAll('text.tile-text');
                texts.forEach(t => {
                    const base = parseFloat(t.getAttribute('data-base-font') || t.getAttribute('font-size') || '14');
                    const chars = parseFloat(t.getAttribute('data-chars') || '4');
                    const limitW = (chars > 0) ? (screenW * 1.5) / chars : base;
                    const limitH = screenH * 0.55;
                    let fs = Math.min(base, limitW, limitH);

                    if (!isFinite(fs) || fs <= 0) fs = base;

                    if (fs < 6 || screenW < 14 || screenH < 10) {
                        t.style.display = 'none';
                    } else {
                        t.style.display = '';
                        t.setAttribute('font-size', fs.toFixed(2));
                    }
                });
            });
        }

        drawGrid() {
            const w = window.innerWidth, h = window.innerHeight;
            if (this.canvasGrid.width !== w || this.canvasGrid.height !== h) {
                this.canvasGrid.width = w; this.canvasGrid.height = h;
            }
            const ctx = this.ctxGrid;
            ctx.clearRect(0, 0, w, h);

            if (this.state.gridMode === 2) return;

            const u = CONFIG.units[this.state.unit];
            const stepSize = (this.state.unit === 'mm') ? 0.1 : u.step;
            const stepPx = BASE_PX * stepSize * this.state.scale;
            if (stepPx < 5) return;

            const offsetX = this.state.x % stepPx;
            const offsetY = this.state.y % stepPx;

            ctx.beginPath();
            if (this.state.gridMode === 1 && this.state.unit === 'cm') {
                const subStep = BASE_PX * 0.5 * this.state.scale;
                const subOffX = this.state.x % subStep;
                const subOffY = this.state.y % subStep;
                ctx.strokeStyle = "rgba(59, 130, 246, 0.5)";
                ctx.lineWidth = 1;
                for (let x = subOffX; x < w; x += subStep) { ctx.moveTo(x, 0); ctx.lineTo(x, h); }
                for (let y = subOffY; y < h; y += subStep) { ctx.moveTo(0, y); ctx.lineTo(w, y); }
            } else {
                ctx.strokeStyle = "rgba(0, 0, 0, 0.35)";
                ctx.lineWidth = 1;
                for (let x = offsetX; x < w; x += stepPx) { ctx.moveTo(x, 0); ctx.lineTo(x, h); }
                for (let y = offsetY; y < h; y += stepPx) { ctx.moveTo(0, y); ctx.lineTo(w, y); }
            }
            ctx.stroke();
        }

        drawDrawings() {
            const w = window.innerWidth, h = window.innerHeight;
            if (this.canvasDraw.width !== w || this.canvasDraw.height !== h) {
                this.canvasDraw.width = w; this.canvasDraw.height = h;
            }
            const ctx = this.ctxDraw;
            ctx.clearRect(0, 0, w, h);

            ctx.save();
            ctx.translate(this.state.x, this.state.y);
            ctx.scale(this.state.scale, this.state.scale);
            ctx.lineCap = 'round'; ctx.lineJoin = 'round';

            let penWidth = 4 / Math.sqrt(this.state.scale);
            if (this.state.scale > 5) penWidth = 1 / Math.sqrt(this.state.scale) * 4;
            ctx.lineWidth = penWidth;

            const drawStroke = (stroke) => {
                if (stroke.points.length < 2) return;
                ctx.beginPath();
                ctx.strokeStyle = stroke.color;
                ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
                for (let i = 1; i < stroke.points.length; i++) ctx.lineTo(stroke.points[i].x, stroke.points[i].y);
                ctx.stroke();
            };
            this.drawings.forEach(drawStroke);
            if (this.currentStroke) drawStroke(this.currentStroke);
            ctx.restore();
        }

        screenToWorld(sx, sy) {
            const wx = (sx - this.state.x) / this.state.scale;
            const wy = (sy - this.state.y) / this.state.scale;
            return { x: wx / BASE_PX, y: wy / BASE_PX };
        }

        onDown(e) {
            if (e.target.closest('.tool-btn, .toggle-btn, .unit-pill')) return;
            this.state.isDragging = true;
            this.state.lastX = e.clientX;
            this.state.lastY = e.clientY;

            if (e.button === 2) { this.actionErase(e); return; }

            if (this.state.tool === 'pen') {
                const pos = this.screenToWorld(e.clientX, e.clientY);
                this.currentStroke = { color: '#2563eb', points: [{ x: pos.x * BASE_PX, y: pos.y * BASE_PX }] };
                this.requestRender();
            }
            else if (this.state.tool === 'paint') this.actionPaint(e);
            else if (this.state.tool === 'eraser') this.actionErase(e);
            else if (this.state.tool === 'hand') document.body.style.cursor = 'grabbing';
        }

        onMove(e) {
            this.updateGhost(e);
            if (!this.state.isDragging) return;

            if (this.state.tool === 'hand') {
                this.state.x += e.clientX - this.state.lastX;
                this.state.y += e.clientY - this.state.lastY;
                this.state.lastX = e.clientX;
                this.state.lastY = e.clientY;
                this.requestRender();
            }
            else if (this.state.tool === 'pen') {
                const pos = this.screenToWorld(e.clientX, e.clientY);
                if (this.currentStroke) {
                    this.currentStroke.points.push({ x: pos.x * BASE_PX, y: pos.y * BASE_PX });
                    this.drawDrawings();
                }
            }
            else {
                if (e.buttons === 0) { this.state.isDragging = false; return; }
                if (this.state.tool === 'eraser' || e.buttons === 2) this.actionErase(e);
                else if (this.state.tool === 'paint') this.actionPaint(e);
            }
        }

        onUp(e) {
            this.state.isDragging = false;
            document.body.style.cursor = 'default';
            if (this.state.tool === 'pen' && this.currentStroke) {
                this.drawings.push(this.currentStroke);
                this.currentStroke = null;
            } else if (this.state.tool !== 'hand') {
                this.saveHistory();
            }
        }

        onWheel(e) {
            e.preventDefault();
            this.queueWheelZoom(e.deltaY > 0 ? -1 : 1);
        }

        updateGhost(e) {
            if (this.state.tool !== 'paint') { this.ghost.style.display = 'none'; return; }
            const u = CONFIG.units[this.state.unit];
            const pos = this.screenToWorld(e.clientX, e.clientY);

            const gx = Math.floor(pos.x / u.realSize) * u.realSize;
            const gy = Math.floor(pos.y / u.realSize) * u.realSize;

            const screenX = gx * BASE_PX * this.state.scale + this.state.x;
            const screenY = gy * BASE_PX * this.state.scale + this.state.y;
            const sizePx = u.realSize * BASE_PX * this.state.scale;

            this.ghost.style.display = 'block';
            this.ghost.style.width = sizePx + 'px';
            this.ghost.style.height = sizePx + 'px';
            this.ghost.style.left = screenX + 'px';
            this.ghost.style.top = screenY + 'px';
            this.ghost.style.borderColor = u.color.replace('0.5', '1');
            this.ghost.style.backgroundColor = u.color.replace('0.5', '0.2');
        }

        actionPaint(e) {
            const u = CONFIG.units[this.state.unit];
            const pos = this.screenToWorld(e.clientX, e.clientY);
            const gx = Math.round((Math.floor(pos.x / u.realSize) * u.realSize) * 1000) / 1000;
            const gy = Math.round((Math.floor(pos.y / u.realSize) * u.realSize) * 1000) / 1000;
            const id = `t_${gx}_${gy}_${u.realSize}`;
            if (document.getElementById(id)) return;
            this.addTile(gx, gy, u.realSize, u.realSize, u.color, id);
        }

        actionErase(e) {
            this.ghost.style.display = 'none';
            const el = document.elementFromPoint(e.clientX, e.clientY);
            if (this.state.tool === 'paint') this.ghost.style.display = 'block';
            const tile = el ? el.closest('.tile-svg') : null;
            if (tile) tile.remove();
        }

        // --- Calques : on force le plus petit au-dessus (mm au-dessus de cm, etc.)
        ensureLayers() {
            // Ordre DOM = ordre d'affichage : ce qui est le plus tard dans le DOM est au-dessus.
            // On veut : mm au-dessus de cm, au-dessus de dm, ...
            if (this.camera.querySelector('#layer-mm')) return;

            // Robustesse : si des tuiles existent déjà sans calques, on les récupère.
            const existingTiles = Array.from(this.camera.querySelectorAll('.tile-svg'));
            existingTiles.forEach(t => t.remove());

            const orderBackToFront = ['km', 'hm', 'dam', 'm', 'dm', 'cm', 'mm'];
            for (const u of orderBackToFront) {
                const g = makeSvgEl('g', { id: `layer-${u}` });
                this.camera.appendChild(g);
            }

            for (const t of existingTiles) {
                const unit = t.getAttribute('data-unit') || 'cm';
                const layer = this.camera.querySelector(`#layer-${unit}`) || this.camera.querySelector('#layer-cm');
                layer.appendChild(t);
            }

            this._hasLockedText = this.camera.querySelector('[data-lock-text="1"]') !== null;
        }

        getLayerForUnit(unit) {
            this.ensureLayers();
            return this.camera.querySelector(`#layer-${unit}`) || this.camera;
        }


        addTile(x, y, w, h, color, id) {
            const u = CONFIG.units[this.state.unit];
            const unitW = w / u.realSize;
            const unitH = h / u.realSize;
            const cols = Math.round(unitW);
            const rows = Math.round(unitH);

            const xPx = x * BASE_PX;
            const yPx = y * BASE_PX;
            const wPx = w * BASE_PX;
            const hPx = h * BASE_PX;
            const cellPx = u.realSize * BASE_PX;

            const gTile = makeSvgEl('g', {
                id: id || `t_${Date.now()}_${Math.random()}`,
                class: 'tile-svg',
                'data-unit': this.state.unit,
                transform: `translate(${xPx} ${yPx})`
            });

            gTile.setAttribute('data-wpx', String(wPx));
            gTile.setAttribute('data-hpx', String(hPx));

            // Fill
            const fill = makeSvgEl('rect', { x: 0, y: 0, width: wPx, height: hPx });
            fill.setAttribute('fill', color);
            gTile.appendChild(fill);

            // Outline + grid with non-scaling stroke
            const outerAlpha = (this.state.unit === 'mm') ? 0.82 : 0.85;
            const innerAlpha = (this.state.unit === 'mm') ? 0.18 : 0.25;
            const outerW = (this.state.unit === 'mm') ? 0.7 : 1.0;
            const innerW = (this.state.unit === 'mm') ? 0.35 : 0.6;

            const outline = makeSvgEl('rect', { x: 0, y: 0, width: wPx, height: hPx, fill: 'none' });
            outline.setAttribute('stroke', `rgba(0,0,0,${outerAlpha})`);
            outline.setAttribute('stroke-width', String(outerW));
            outline.setAttribute('vector-effect', 'non-scaling-stroke');
            outline.setAttribute('shape-rendering', 'crispEdges');
            gTile.appendChild(outline);

            if (cols > 1 || rows > 1) {
                // Vertical lines
                for (let c = 1; c < cols; c++) {
                    const xLine = c * cellPx;
                    const line = makeSvgEl('line', { x1: xLine, y1: 0, x2: xLine, y2: hPx });
                    line.setAttribute('stroke', `rgba(0,0,0,${innerAlpha})`);
                    line.setAttribute('stroke-width', String(innerW));
                    line.setAttribute('vector-effect', 'non-scaling-stroke');
                    line.setAttribute('shape-rendering', 'crispEdges');
                    gTile.appendChild(line);
                }
                // Horizontal lines
                for (let r = 1; r < rows; r++) {
                    const yLine = r * cellPx;
                    const line = makeSvgEl('line', { x1: 0, y1: yLine, x2: wPx, y2: yLine });
                    line.setAttribute('stroke', `rgba(0,0,0,${innerAlpha})`);
                    line.setAttribute('stroke-width', String(innerW));
                    line.setAttribute('vector-effect', 'non-scaling-stroke');
                    line.setAttribute('shape-rendering', 'crispEdges');
                    gTile.appendChild(line);
                }
            }

            // Values (123)
            const textLayer = makeSvgEl('g');
            const lockText = (this.state.unit === 'hm' || this.state.unit === 'km');
            if (lockText) {
                this._hasLockedText = true;
                textLayer.setAttribute('data-lock-text', '1');
                textLayer.setAttribute('data-cx', String(wPx / 2));
                textLayer.setAttribute('data-cy', String(hPx / 2));
            }

            let fontSize;
            if (this.state.unit === 'mm') fontSize = 1.0;         // ecran: ~8px en zoom x8
            else if (this.state.unit === 'dm') fontSize = 120;
            else if (this.state.unit === 'm') fontSize = 1000;
            else if (this.state.unit === 'dam') fontSize = 10000;
            else if (this.state.unit === 'hm') fontSize = 22;
            else if (this.state.unit === 'km') fontSize = 22;
            else fontSize = 14;

            const noSpace = (this.state.unit === 'mm');
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const tx = (c + 0.5) * cellPx;
                    const ty = (r + 0.5) * cellPx;
                    const t = makeLabelText(tx, ty, fontSize, '1', u.label, noSpace);
                    textLayer.appendChild(t);
                }
            }
            gTile.appendChild(textLayer);

            this.getLayerForUnit(this.state.unit).appendChild(gTile);
            this.updateLockedText();
        }

        addRect() {
            const w = parseInt(document.getElementById('rect-w').value);
            const h = parseInt(document.getElementById('rect-h').value);
            const u = CONFIG.units[this.state.unit];
            const center = this.screenToWorld(window.innerWidth / 2, window.innerHeight / 2);
            const gx = Math.floor(center.x / u.realSize) * u.realSize;
            const gy = Math.floor(center.y / u.realSize) * u.realSize;
            this.addTile(gx, gy, w * u.realSize, h * u.realSize, u.color, null);
            this.saveHistory();
            document.getElementById('rect-modal').classList.add('hidden');
        }

        setUnit(unit) {
            this.state.unit = unit;

            if (unit === 'mm') {
                document.documentElement.style.setProperty('--ghost-border', '1px');
            } else {
                document.documentElement.style.setProperty('--ghost-border', '2px');
            }

            document.body.style.backgroundColor = CONFIG.units[unit].bg;
            document.querySelectorAll('.unit-pill').forEach(b => b.classList.toggle('active', b.id === 'btn-' + unit));

            const btnGrid = document.getElementById('btn-grid-toggle');
            if (unit === 'cm') {
                btnGrid.style.display = 'flex';
                this.state.gridMode = 0;
                btnGrid.innerText = "Grille: Normale";
                btnGrid.classList.remove('active');
            } else {
                btnGrid.style.display = 'none';
                this.state.gridMode = 0;
            }

            this.animateZoom(CONFIG.units[unit].zoom);
        }

        setTool(t) {
            this.state.tool = t;
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            const btn = document.getElementById('tool-' + t);
            if (btn) btn.classList.add('active');
            this.ghost.style.display = t === 'paint' ? 'block' : 'none';
        }

        toggleValues() {
            this.state.showValues = !this.state.showValues;
            document.getElementById('btn-values').classList.toggle('active');
            document.body.classList.toggle('show-values');
        }

        cycleGridMode() {
            this.state.gridMode = (this.state.gridMode + 1) % 3;
            const btn = document.getElementById('btn-grid-toggle');
            const labels = ["Grille: Normale", "Grille: Cahier", "Grille: Aucune"];
            btn.innerText = labels[this.state.gridMode];
            btn.classList.toggle('active', this.state.gridMode === 1);
            this.drawGrid();
        }

        cancelZoomAnim() {
            this._zoomAnimToken++;
        }

        zoom(dir) {
            this.cancelZoomAnim();
            const factor = dir > 0 ? 1.2 : (1 / 1.2);
            this.zoomByFactor(factor);
        }

        zoomByFactor(factor) {
            const newScale = Math.min(Math.max(0.00001, this.state.scale * factor), 50);

            const rect = this.elViewport.getBoundingClientRect();
            const cx = rect.width / 2; const cy = rect.height / 2;
            const ratio = newScale / this.state.scale;
            this.state.x = cx - (cx - this.state.x) * ratio;
            this.state.y = cy - (cy - this.state.y) * ratio;

            this.state.scale = newScale;
            this.requestRender();
        }

        queueWheelZoom(dir) {
            // dir: +1 zoom in, -1 zoom out
            this.cancelZoomAnim();
            this._wheelZoomSteps += (dir > 0 ? 1 : -1);
            if (this._wheelRAF) return;
            this._wheelRAF = requestAnimationFrame(() => {
                this._wheelRAF = null;
                const steps = Math.max(-4, Math.min(4, this._wheelZoomSteps));
                this._wheelZoomSteps = 0;
                if (steps === 0) return;
                const factor = steps > 0 ? Math.pow(1.2, steps) : Math.pow(1 / 1.2, -steps);
                this.zoomByFactor(factor);
            });
        }

        animateZoom(target) {
            const token = ++this._zoomAnimToken;

            const start = this.state.scale;
            const rect = this.elViewport.getBoundingClientRect();
            const cx = rect.width / 2; const cy = rect.height / 2;
            const ratio = target / start;
            const targetX = cx - (cx - this.state.x) * ratio;
            const targetY = cy - (cy - this.state.y) * ratio;
            const startX = this.state.x;
            const startY = this.state.y;

            const duration = 500;
            let startTime = null;
            const step = (t) => {
                if (token !== this._zoomAnimToken) return;
                if (!startTime) startTime = t;
                const p = Math.min((t - startTime) / duration, 1);
                const ease = 1 - Math.pow(1 - p, 3);
                this.state.scale = start + (target - start) * ease;
                this.state.x = startX + (targetX - startX) * ease;
                this.state.y = startY + (targetY - startY) * ease;
                this.renderAllImmediate();
                if (p < 1) requestAnimationFrame(step);
            };
            requestAnimationFrame(step);
        }

        clear() {
            this.camera.innerHTML = '';
            this.ensureLayers();
            this._hasLockedText = false;
            this.drawings = [];
            this.requestRender();
            this.saveHistory();
        }

        clearDrawings() {
            this.drawings = [];
            this.requestRender();
        }

        undo() {
            if (this.history.length > 0) {
                this.camera.innerHTML = this.history.pop();
                this.ensureLayers();
                this._hasLockedText = this.camera.querySelector('[data-lock-text="1"]') !== null;
                this.requestRender();
            }
        }

        saveHistory() {
            if (this.history.length > 10) this.history.shift();
            this.history.push(this.camera.innerHTML);
        }

        openModal() {
            document.getElementById('rect-preview').innerHTML =
                (document.getElementById('rect-w').value * document.getElementById('rect-h').value) + ' ' + labelHtml(CONFIG.units[this.state.unit].label);
            document.getElementById('rect-modal').classList.remove('hidden');
        }
    }

    const app = new App();
</script>
</body>
</html>

