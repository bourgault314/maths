<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Calcul Littéral - Équations (1er Degré)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css">
    <style>
        body { font-family: 'Fredoka', sans-serif; background-color: #f0f9ff; overflow: hidden; user-select: none; touch-action: none; }
        
        /* --- TUILES PLATEAU --- */
        .token {
            position: absolute; display: flex; align-items: center; justify-content: center;
            font-weight: 600; color: white; box-shadow: 0 4px 6px rgba(0,0,0,0.25);
            cursor: grab; transition: transform 0.1s, background-color 0.5s; z-index: 10;
            font-family: 'Times New Roman', serif; font-style: italic; font-size: 1.2rem;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3); transform-origin: 0 0;
        }
        .token.dragging { transition: none !important; z-index: 1000 !important; cursor: grabbing; box-shadow: 0 15px 30px rgba(0,0,0,0.4); transform: scale(1.1); }
        .token.animating { transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1), left 0.5s ease-in-out, top 0.5s ease-in-out, background-color 0.5s !important; }
        .vanish { animation: vanish 0.45s ease-in forwards; pointer-events: none; }
        @keyframes vanish { 0% { transform: scale(1); opacity: 1; } 
/* Pour éviter que le badge '0' ne saute (translate) et pour synchroniser la disparition */
.zero-badge.vanish { animation: vanishBadge 0.45s ease-in forwards; }
@keyframes vanishBadge {
    0%   { transform: translate(-50%, -50%) scale(1);   opacity: 1; }
    100% { transform: translate(-50%, -50%) scale(0.1); opacity: 0; }
}
100% { transform: scale(0.1); opacity: 0; } }

        .token.scaling-transition { transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1) !important; }

        .token.green { background: radial-gradient(circle at 30% 30%, #4ade80, #16a34a); border: 2px solid #14532d; }
        .token.red { background: radial-gradient(circle at 30% 30%, #f87171, #dc2626); border: 2px solid #7f1d1d; }
.token.is-zero { background: #9ca3af !important; opacity: 0.6; border: 2px solid #6b7280; box-shadow: none; z-index: 5; color: rgba(255,255,255,0.5); }
        .token.fading-gray { background: #9ca3af !important; border-color: #6b7280 !important; box-shadow: none !important; filter: grayscale(1); }
        .token.ghost { opacity: 0.5; filter: grayscale(0.8); pointer-events: none; }

        .token.type-unit { width: 40px; height: 40px; border-radius: 4px; font-style: normal; }
        .token.type-x { width: 90px; height: 40px; border-radius: 4px; }

        .zero-badge { 
            position: absolute; font-size: 2rem; font-weight: 800; color: #374151; 
            pointer-events: none; z-index: 20; text-shadow: 0 0 10px rgba(255,255,255,1); 
            animation: popIn 0.3s; transform: translate(-50%, -50%);
        }
        @keyframes popIn { from { transform: translate(-50%, -50%) scale(0); opacity: 0; } to { transform: translate(-50%, -50%) scale(1); opacity: 1; } }

        /* STRUCTURE */
        #board-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; padding-bottom: 150px; cursor: ns-resize; }
        #board-container.panning { cursor: grabbing; }
        #board-world { position: absolute; top: 0; left: 0; transform-origin: 0 0; width: 0; height: 0; }
        
        #equation-divider {
            position: absolute; top: -5000px; bottom: -5000px; left: 0; width: 4px;
            background-color: #cbd5e1; border-left: 2px dashed #94a3b8; border-right: 2px dashed #94a3b8;
            transform: translateX(-2px); pointer-events: none; z-index: 0;
        }

        #bottom-bar {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 150px;
            background: white; border-top: 1px solid #cbd5e1;
            display: flex; z-index: 50; box-shadow: 0 -4px 10px rgba(0,0,0,0.05);
        }
        .side-panel { flex: 1; display: flex; align-items: center; justify-content: center; padding: 5px 10px; gap: 10px; position: relative; }
        .side-panel.left { border-right: none; background: #f8fafc; }
        .side-panel.right { background: #fff; }
        
        #menu-divider {
            position: absolute; left: 50%; top: 0; bottom: 0; width: 4px;
            background-color: #cbd5e1; border-left: 2px dashed #94a3b8; border-right: 2px dashed #94a3b8;
            transform: translateX(-2px); pointer-events: none; z-index: 51;
        }

        #center-actions {
            position: absolute; left: 50%; top: 10px; transform: translateX(-50%);
            z-index: 60; display: flex; flex-direction: column; align-items: center;
        }

        #phase-tab{
            position:absolute;
            left:50%;
            top:-78px; /* légèrement plus haut : posé dans la zone de travail, sans chevaucher Diviser */ /* à la jonction menu/plateau, comme les étiquettes des membres */
            transform:translateX(-50%);
            z-index: 59; /* sous les actions centrales, au cas où */
            display:flex;
            flex-direction:column;
            align-items:center;
            pointer-events:auto;
        }
        #phase-tab .action-btn.big{ padding: 8px 14px; font-size: 0.9rem; border-radius: 10px; }
        @media (max-width: 600px){
            #phase-tab .action-btn.big{ padding: 7px 12px; font-size: 0.85rem; min-width: 160px !important; }
            #phase-tab{ top:-70px; }
        }


        .tiles-zone { display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; padding: 5px; }
        .tools-zone { display: flex; flex-direction: column; gap: 4px; align-items: stretch; min-width: 120px; }
        .tools-row { display: flex; gap: 4px; justify-content: center; }

        .tile-btn { 
            position: relative; background: transparent; border: none; cursor: grab; 
            display: flex; align-items: center; justify-content: center; transition: transform 0.1s; 
        }
        .tile-btn:active { cursor: grabbing; transform: scale(0.95); }
        .tile-btn:hover { transform: translateY(-2px); }
        
        .preview-shape { 
            display: flex; align-items: center; justify-content: center; border-radius: 4px; 
            color: white; font-weight: bold; font-family: 'Times New Roman', serif; font-style: italic; 
            text-shadow: 0 1px 2px rgba(0,0,0,0.3); box-shadow: 0 3px 5px rgba(0,0,0,0.2); pointer-events: none; 
        }
        .ps-green { background: radial-gradient(circle at 30% 30%, #4ade80, #16a34a); border: 1px solid #14532d; } 
        .ps-red { background: radial-gradient(circle at 30% 30%, #f87171, #dc2626); border: 1px solid #7f1d1d; }

        .token.menu-ghost {
            position: fixed; z-index: 9999; pointer-events: none; opacity: 0.9;
            box-shadow: 0 10px 20px rgba(0,0,0,0.3); transform-origin: center;
        }
        
        .action-btn { font-size: 0.7rem; font-weight: bold; padding: 6px 10px; border-radius: 6px; border: 1px solid #cbd5e1; background: white; color: #475569; transition: all 0.1s; box-shadow: 0 1px 2px rgba(0,0,0,0.05); cursor: pointer; }
        .action-btn:hover { background: #f1f5f9; border-color: #94a3b8; } .action-btn:active { transform: translateY(1px); }
        
        
        .action-btn.big { font-size: 0.95rem; padding: 10px 16px; border-radius: 9px; }

        /* Equation: keep '=' centered on the vertical divider */
        .equation-grid { display: grid; grid-template-columns: 1fr auto 1fr; align-items: center; column-gap: 10px; width: 100%; }
        .equation-grid .eq-left { justify-self: end; text-align: right; }
        .equation-grid .eq-right { justify-self: start; text-align: left; }
        .equation-grid .eq-equal { justify-self: center; }

        
        /* Equation: do not shift '=' because of the eye button */
        .equation-pill { padding-right: 44px; }
        .equation-pill .eye-btn { position: absolute; right: 14px; top: 50%; transform: translateY(-50%); margin-left: 0 !important; }
.topbar { position: relative; }
        .topbar .left-controls { position: relative; z-index: 70; }
        .topbar .equation-holder { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); z-index: 60; width: min(1100px, calc(100% - 520px)); }
        @media (max-width: 900px) { .topbar .equation-holder { width: calc(100% - 40px); } }
.toggle-mode { background-color: #fef08a; color: #854d0e; border: 1px solid #eab308; }
        .toggle-mode.solve { background-color: #dcfce7; color: #166534; border-color: #22c55e; }
        .equation-blur { filter: blur(5px); opacity: 0.5; }
        
        #custom-cursor { position: fixed; pointer-events: none; z-index: 9999; display: none; }
        .hide-cursor, .hide-cursor * { cursor: none !important; }

        .side-label {
            position: absolute; top: -12px; left: 50%; transform: translateX(-50%);
            background: #e2e8f0; color: #64748b; font-size: 0.6rem; padding: 2px 8px;
            border-radius: 10px; font-weight: bold; z-index: 5;
        }
        
        /* CANEVAS DESSIN */
        #drawing-canvas { position: absolute; top: 0; left: 0; pointer-events: none; z-index: 5; }
        .drawing-active #drawing-canvas { pointer-events: auto; z-index: 100; }
    
        /* --- Division hints (Phase 2) --- */
        .division-hints{
            position:absolute;
            left:0; right:0;
            bottom:6px;
            padding:0 18px;
            display:flex;
            justify-content:space-between;
            pointer-events:none;
            opacity:0;
            transform:translateY(4px);
            transition:opacity 180ms ease, transform 180ms ease;
            font-size:0.85rem;
            font-weight:700;
            color:#6b21a8; /* purple-800-ish */
            text-shadow:0 1px 0 rgba(255,255,255,0.8);
        }
        .division-hints.show{
            opacity:1;
            transform:translateY(0);
        }
        .division-hint{
            min-width:80px;
            text-align:center;
        }
        #btn-diviser:disabled{
            opacity:0.45 !important;
            cursor:not-allowed !important;
            filter:saturate(0.8);
        }
    

        
        /* --- Division hints ON BOARD (big, left & right) --- */
        .division-hints-board{
            position:absolute;
            inset:0;
            display:flex;
            align-items:center;
            justify-content:space-between;
            padding:0 14%;
            pointer-events:none;
            opacity:0;
            transform:scale(0.98);
            transition:opacity 180ms ease, transform 180ms ease;
            z-index:120;
        }
        .division-hints-board.show{
            opacity:1;
            transform:scale(1);
        }
        .division-hint-board{
            font-size: clamp(42px, 6vw, 72px);
            font-weight: 800;
            color: rgba(107,33,168,0.92);
            text-shadow: 0 2px 0 rgba(255,255,255,0.9), 0 10px 30px rgba(0,0,0,0.18);
            padding: 10px 18px;
            border-radius: 18px;
            background: rgba(255,255,255,0.55);
            border: 1px solid rgba(203,213,225,0.9);
            backdrop-filter: blur(2px);
            -webkit-backdrop-filter: blur(2px);
        }
/* Diviser bigger (Phase 2) */
        #btn-diviser{
            font-size: 1.15rem;
            padding: 14px 26px;
            border-radius: 12px;
            min-width: 190px;
        }
        @media (max-width: 600px){
            #btn-diviser{ font-size: 1.05rem; padding: 12px 20px; min-width: 170px; }
        }

</style>
</head>
<body class="h-screen w-screen flex flex-col overflow-hidden">

    <div id="custom-cursor" class="fixed pointer-events-none z-50 hidden">
        <svg width="18" height="18" viewBox="0 0 18 18" fill="none" aria-hidden="true">
            <path d="M9 1 V17" stroke="#1d4ed8" stroke-width="2" stroke-linecap="round"/>
            <path d="M1 9 H17" stroke="#1d4ed8" stroke-width="2" stroke-linecap="round"/>
            <circle cx="9" cy="9" r="1.2" fill="#0f172a"/>
        </svg>
    </div>

    <!-- HEADER -->
    <header class="bg-white p-2 shadow-md z-30 flex flex-wrap items-center gap-4 shrink-0 justify-between topbar">
        <div class="left-controls flex items-center gap-2">
            <button onclick="app.resetBoard()" class="bg-rose-100 text-rose-600 hover:bg-rose-200 p-2 rounded-lg font-bold border border-rose-200 shadow-sm" title="Tout effacer">
                <svg class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>
            </button>
            <button onclick="app.undo()" class="bg-slate-100 text-slate-600 hover:bg-slate-200 p-2 rounded-lg font-bold border border-slate-200 shadow-sm" title="Annuler">
                <svg class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6" /></svg>
            </button>
            <div class="h-8 w-px bg-slate-200 mx-1"></div>
            <button id="btn-mode" onclick="app.toggleMode()" class="toggle-mode px-4 py-2 rounded-lg font-bold text-sm transition flex items-center gap-2 shadow-sm hidden">
                <span id="mode-text">Phase 1 : Poser l'équation</span>
            </button>
        </div>

        <div class="equation-holder">
            <div class="flex items-center gap-2 bg-slate-50 px-6 py-2 rounded-full border border-slate-200 shadow-inner w-full max-w-5xl equation-pill relative">
                <div id="equation-display" class="equation-grid text-3xl font-bold text-slate-700 tracking-tight font-mono transition-all duration-300">
                    <span id="eq-left" class="eq-left"></span>
                    <span id="eq-eq" class="eq-equal"></span>
                    <span id="eq-right" class="eq-right"></span>
                </div>
                <div id="division-hints" class="division-hints" aria-hidden="true">
                    <span id="div-hint-left" class="division-hint"></span>
                    <span class="division-hint-spacer"></span>
                    <span id="div-hint-right" class="division-hint"></span>
                </div>

                <button onclick="app.toggleEquationVisibility()" class="ml-2 text-slate-400 hover:text-slate-600 focus:outline-none eye-btn">
                    <svg id="eye-icon" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
                    </svg>
                </button>
            </div>
        </div>

        <div class="flex items-center gap-1 bg-gray-100 p-1 rounded-lg">
            <button onclick="app.setTool('hand')" class="p-2 rounded bg-white shadow text-gray-700"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 11.5V14m0-2.5v-6a1.5 1.5 0 113 0m-3 6a1.5 1.5 0 00-3 0v2a7.5 7.5 0 0015 0v-5a1.5 1.5 0 00-3 0m-6-3V11m0-5.5v-1a1.5 1.5 0 013 0v1m0 0V11m0-5.5a1.5 1.5 0 013 0v3m0 0V11"/></svg></button>
            <button onclick="app.setTool('pen')" class="p-2 rounded text-gray-500 hover:bg-gray-200"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"/></svg></button>
            <button onclick="app.clearDrawing()" class="p-2 rounded text-red-400 hover:bg-red-50"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/></svg></button>
        </div>
    </header>

    <main id="board" class="flex-1 relative bg-white overflow-hidden">
        <div class="absolute inset-0 opacity-10 pointer-events-none" style="background-image: linear-gradient(#94a3b8 1px, transparent 1px), linear-gradient(90deg, #94a3b8 1px, transparent 1px); background-size: 40px 40px;"></div>
        
        <div id="division-hints-board" class="division-hints-board" aria-hidden="true">
            <div id="div-hint-left-board" class="division-hint-board left"></div>
            <div id="div-hint-right-board" class="division-hint-board right"></div>
            
        </div>
<div id="board-container">
            <div id="board-world">
                <div id="equation-divider"></div>

                </div>
                <canvas id="drawing-canvas"></canvas>
            </div>
        </div>
    </main>

    <div id="bottom-bar">
        <div id="menu-divider"></div>
        <div id="phase-tab">
            <button id="btn-phase1" onclick="app.toggleMode()" class="toggle-mode action-btn big" style="min-width: 190px; line-height: 1.1;">
                <div style="font-size: 0.95rem;">Phase 1</div>
                <div style="font-size: 0.8rem;">Poser l’équation</div>
                <div style="font-size: 0.72rem; font-weight: 600; opacity: 0.9; margin-top: 2px;">Cliquez quand vous avez fini</div>
            </button>

            <button id="btn-phase2" onclick="app.toggleMode()" class="toggle-mode solve action-btn big hidden" style="min-width: 190px; line-height: 1.1;">
                <div style="font-size: 0.95rem;">Phase 2</div>
                <div style="font-size: 0.8rem;">Résoudre l’équation</div>
            </button>
        </div>

        <div id="center-actions">
            <div id="solve-actions" class="flex flex-col items-center gap-2 hidden">
                <button id="btn-diviser" onclick="app.performDivision()" class="action-btn big bg-purple-50 text-purple-700 border border-purple-200 hover:bg-purple-100 shadow-md">Diviser</button>
            </div>
        </div>

        <!-- GAUCHE -->
        <div class="side-panel left">
            <div class="side-label">Membre de Gauche</div>
            <div class="tiles-zone">
                <button onmousedown="app.handleMenuTouchStart(event, 'x', 1, 'left')" class="tile-btn w-16 h-16"><div class="preview-shape ps-green w-14 h-8 text-lg">x</div></button>
                <button onmousedown="app.handleMenuTouchStart(event, 'unit', 1, 'left')" class="tile-btn w-16 h-16"><div class="preview-shape ps-green w-8 h-8 text-md">1</div></button>
                <button onmousedown="app.handleMenuTouchStart(event, 'x', -1, 'left')" class="tile-btn w-16 h-16"><div class="preview-shape ps-red w-14 h-8 text-lg">-x</div></button>
                <button onmousedown="app.handleMenuTouchStart(event, 'unit', -1, 'left')" class="tile-btn w-16 h-16"><div class="preview-shape ps-red w-8 h-8 text-md">-1</div></button>
            </div>
            <div class="tools-zone phase2-only hidden">
                <div class="tools-row flex-wrap justify-center">
                    <button onclick="app.sideLeft.order()" class="action-btn">Trier</button>
                    <button onclick="app.sideLeft.reduce()" class="action-btn">Regrouper</button>
                    <button onclick="app.sideLeft.simplify()" class="action-btn">Réduire</button>
                </div>
            </div>
        </div>

        <!-- DROITE -->
        <div class="side-panel right">
            <div class="side-label">Membre de Droite</div>
            <div class="tiles-zone">
                <button onmousedown="app.handleMenuTouchStart(event, 'x', 1, 'right')" class="tile-btn w-16 h-16"><div class="preview-shape ps-green w-14 h-8 text-lg">x</div></button>
                <button onmousedown="app.handleMenuTouchStart(event, 'unit', 1, 'right')" class="tile-btn w-16 h-16"><div class="preview-shape ps-green w-8 h-8 text-md">1</div></button>
                <button onmousedown="app.handleMenuTouchStart(event, 'x', -1, 'right')" class="tile-btn w-16 h-16"><div class="preview-shape ps-red w-14 h-8 text-lg">-x</div></button>
                <button onmousedown="app.handleMenuTouchStart(event, 'unit', -1, 'right')" class="tile-btn w-16 h-16"><div class="preview-shape ps-red w-8 h-8 text-md">-1</div></button>
            </div>
            <div class="tools-zone phase2-only hidden">
                <div class="tools-row flex-wrap justify-center">
                    <button onclick="app.sideRight.order()" class="action-btn">Trier</button>
                    <button onclick="app.sideRight.reduce()" class="action-btn">Regrouper</button>
                    <button onclick="app.sideRight.simplify()" class="action-btn">Réduire</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const SNAP = 60;
        const PACK_GAP = 25;
        const SIZES = { 'unit': { w: 40, h: 40 }, 'x': { w: 90, h: 40 } };
        const COLORS = { pos: 'green', neg: 'red', orange: 'orange' };
        
        // LIMITS FOR CONSISTENT WRAPPING (Phase 1 = plus large, adaptatif à l'écran)
const BASE_ROW_WIDTH = 450;         // fallback (mode résolution)
const MIN_ROW_WIDTH_SETUP = 590;    // ~6 tuiles x (90px + 10px d'écart) avant retour à la ligne
function getMaxRowWidth(app) {
    const screenW = app.container.clientWidth / app.scale; // unités "monde"
    const avail = (screenW / 2) - 10;                      // marge légère
    const minW = (app.mode === 'setup') ? MIN_ROW_WIDTH_SETUP : BASE_ROW_WIDTH;
    return Math.max(minW, avail);
}
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
            osc.connect(gain); gain.connect(audioCtx.destination); const now = audioCtx.currentTime;
            if (type === 'pop') { osc.type = 'sine'; osc.frequency.setValueAtTime(300, now); osc.frequency.exponentialRampToValueAtTime(500, now+0.1); gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now+0.1); osc.start(now); osc.stop(now+0.1); }
            else if (type === 'snap') { osc.type = 'square'; osc.frequency.setValueAtTime(100, now); gain.gain.setValueAtTime(0.05, now); gain.gain.exponentialRampToValueAtTime(0.01, now+0.05); osc.start(now); osc.stop(now+0.05); }
            else if (type === 'whoosh') { osc.type = 'triangle'; osc.frequency.setValueAtTime(300, now); osc.frequency.exponentialRampToValueAtTime(50, now+0.3); gain.gain.setValueAtTime(0.05, now); gain.gain.linearRampToValueAtTime(0, now+0.3); osc.start(now); osc.stop(now+0.3); }
            else if (type === 'flip') { osc.type = 'triangle'; osc.frequency.setValueAtTime(200, now); osc.frequency.linearRampToValueAtTime(400, now+0.2); gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now+0.2); osc.start(now); osc.stop(now+0.2); }
        }

        // --- ALGEBRA SIDE ENGINE ---
        class AlgebraSide {
            constructor(id, parentApp) {
                this.id = id;
                this.app = parentApp;
                this.tokens = [];
                this.steps = [{ id: 0, operator: '', type: 'simple', tokenIds: [], factor: 1, oppositeApplied: false, distributed: false, isClosed: false }];
                this.currStepIdx = 0;
                this.nextPackId = 1; this.packMeta = {}; this.lastPack = null;
                this.isSubInput = false; this.isMultInput = false;
                this.lastPos = { x: 0, y: 0, maxY: 0 };
                this.pendingGap = 0;
                this.lastSeqPackId = null;
                this.displayMode = 'normal'; // 'normal', 'ordered', 'reduced'
                this.autoFlow = null; // curseur de placement auto (évite de remplir les trous)
            }

            addTile(type, sign, isGhost=false, manualX=null, manualY=null, mirrorTrigger=false) {
                if(!isGhost && !mirrorTrigger) {
                    this.app.saveState();
                    this.displayMode = 'normal';
                }

                if(!isGhost) playSound('pop');
                
                let step = this.steps[this.currStepIdx];
                if (!isGhost && step.isClosed && !this.isSubInput && !this.isMultInput) {
                    this.steps.push({ id: this.steps.length, operator: '+', type: 'simple', tokenIds: [], factor: 1, oppositeApplied: false, distributed: false, isClosed: false });
                    this.currStepIdx++;
                    step = this.steps[this.currStepIdx];
                    this.lastPack = null;
                }

                let tileSign = sign;
                if (this.isSubInput && step.type === 'subtraction') tileSign = -sign;
                if (this.isMultInput && step.operator === '-') tileSign = -sign;

                let pid;
                if (manualX===null && !isGhost) {
                    if (this.lastPack && this.lastPack.type === type && this.lastPack.sign === tileSign && this.lastPack.step === this.currStepIdx) {
                        pid = this.lastPack.pid;
                    } else {
                        pid = this.nextPackId++;
                        this.lastPack = { pid, type, sign: tileSign, step: this.currStepIdx };
                    }
                } else {
                    pid = this.nextPackId++;
                }

                const el = document.createElement('div');
                el.className = `token ${type==='unit'?'type-unit':'type-x'} ${tileSign===1?'green':'red'}`;
                if (isGhost) el.classList.add('ghost');
                if (this.isSubInput) el.classList.add('in-bracket');
                if (this.isMultInput && !step.distributed) el.classList.add('pending-mult');
                
                let lbl = type==='unit' ? (tileSign===1?'1':'-1') : (tileSign===1?'x':'-x');
                el.innerHTML = `<span style="pointer-events:none;">${lbl}</span>`;
                
                const tId = this.app.nextId++;
                el.id = `t-${tId}`;

                let x, y;
                if (manualX !== null) { 
                    x=manualX; y=manualY;
                    
                    // MIRROR LOGIC FOR SOLVE MODE
                    if (!isGhost && !mirrorTrigger && this.app.mode === 'solve') {
                        const otherSide = this.id === 'left' ? this.app.sideRight : this.app.sideLeft;
                        const w = SIZES[type].w;
                        const mirrorX = -x - w; 
                        otherSide.addTile(type, sign, false, mirrorX, y, true);
                    }
                }
                else {
                    // AUTO PLACEMENT (CLICK) - Mirror Logic
                    const pos = this.findFreeSpot(type);
                    x = pos.x; y = pos.y;
                    
                    if (!isGhost && !mirrorTrigger && this.app.mode === 'solve') {
                        const otherSide = this.id === 'left' ? this.app.sideRight : this.app.sideLeft;
                        const w = SIZES[type].w;
                        const mirrorX = -x - w; 
                        otherSide.addTile(type, sign, false, mirrorX, y, true);
                    }
                }

                el.style.left = x+'px'; el.style.top = y+'px';
                el.addEventListener('mousedown', e => this.app.handleDragStart(e, tId));
                el.addEventListener('touchstart', e => this.app.handleDragStart(e, tId), {passive:false});
                this.app.world.appendChild(el);

                const token = { id: tId, side: this.id, type, sign: tileSign, displaySign: sign, x, y, element: el, pairId: null, packId: pid, ghostIds: [] };
                this.tokens.push(token);
                this.app.allTokens.push(token);

                if (!isGhost) {
                    step.tokenIds.push(tId);
                    if (manualX === null) this.lastSeqPackId = pid;
                    
                    if (this.isMultInput && step.factor > 1) {
                        const stride = 90+20;
                        for(let i=1; i<step.factor; i++) {
                            const g = this.addTile(type, sign, true, x, y + i*stride);
                            token.ghostIds.push(g.id);
                        }
                    }
                }
                this.app.updateEquation();
                return token;
            }

            findFreeSpot(type) {
                // Placement auto : progression "au fil" (ne remplit pas les trous),
                // en partant du centre vers l'extérieur.
                const w = SIZES[type].w;
                const h = SIZES[type].h;
                const gap = 10;

                const screenH = this.app.container.clientHeight / this.app.scale;
                const startY = -screenH/2 + 60;
                const startX = (this.id === 'left') ? -25 : 25;

                const maxW = getMaxRowWidth(this.app);

                // (Ré)initialisation du curseur si besoin
                if (!this.autoFlow || Math.abs((this.autoFlow.startY ?? startY) - startY) > 1) {
                    this.autoFlow = { x: startX, y: startY, lineH: 0, startX, startY };
                }

                const collides = (tx, ty) => {
                    for (let t of this.tokens) {
                        const tw = SIZES[t.type].w;
                        const th = SIZES[t.type].h;
                        if (tx < t.x + tw + 5 && tx + w + 5 > t.x && ty < t.y + th + 5 && ty + h + 5 > t.y) {
                            return true;
                        }
                    }
                    return false;
                };

                // On avance toujours le curseur (jamais de retour en arrière),
                // et on saute les positions en collision.
                let tries = 0;
                while (tries < 300) {
                    const usedW = (this.id === 'left') ? (startX - this.autoFlow.x) : (this.autoFlow.x - startX);
                    if (usedW + w > maxW) {
                        this.autoFlow.y += Math.max(this.autoFlow.lineH, h) + gap;
                        this.autoFlow.x = startX;
                        this.autoFlow.lineH = 0;
                    }

                    const tx = (this.id === 'left') ? (this.autoFlow.x - w) : this.autoFlow.x;
                    const ty = this.autoFlow.y;

                    // Avance du curseur (quoi qu'il arrive)
                    if (this.id === 'left') this.autoFlow.x -= (w + gap);
                    else this.autoFlow.x += (w + gap);
                    this.autoFlow.lineH = Math.max(this.autoFlow.lineH, h);

                    if (!collides(tx, ty)) return { x: tx, y: ty };
                    tries += 1;
                }

                return { x: 0, y: 0 };
            }


            addOperator(op) {
                // Opérateurs (+, -, parenthèses, x2/x3, etc.) supprimés dans cette version :
                // outil de manipulation + automatisations via Ranger / Réduire / Simplifier / Diviser.
                return;
            }

            startMult(f) {
                // Désactivé (mode manipulation)
                return;
            }

            applyOpposite() {
                // Désactivé (mode manipulation)
                return;
            }

            distribute() {
                // Désactivé (mode manipulation)
                return;
            }

            reflow() { }

            order() {
                this.displayMode = 'ordered'; 
                this.organize(false);
                this.app.updateEquation(); 
            }
            
            reduce() {
                this.displayMode = 'reduced'; 
                this.organize(true);
                this.app.updateEquation(); 
            }

            organize(reduced) { 
                this.app.saveState();
                playSound('whoosh');
                
                const screenH = this.app.container.clientHeight / this.app.scale;
                let y = -screenH/2 + 60;
                
                const subset = this.tokens.filter(t => !t.pairId && !t.element.classList.contains('ghost'));
                const rows = [{t:'x',s:1},{t:'x',s:-1},{t:'unit',s:1},{t:'unit',s:-1}];

                // REVISED LAYOUT LOGIC: Center -> Outwards, Lines (Rows)
                rows.forEach(r => {
                    const eligible = subset.filter(t => t.type===r.t && t.sign===r.s);
                    if (!eligible.length) return;

                    let packs = [];
                    if (reduced) {
                        packs = [eligible]; 
                    } else {
                        const map = new Map();
                        eligible.forEach(t => {
                            const pid = (typeof t.packId !== 'undefined') ? t.packId : -1;
                            if(!map.has(pid)) map.set(pid, []);
                            map.get(pid).push(t);
                        });
                        const sortedPids = Array.from(map.keys()).sort((a,b) => a - b);
                        packs = sortedPids.map(pid => map.get(pid));
                    }

                    // --- PLACEMENT LOGIC ---
                    
                    // Flatten tokens for line filling
                    let tokensInOrder = [];
                    let gap = reduced ? 0 : 15;
                    packs.forEach((pack, pIdx) => {
                        pack.forEach(t => tokensInOrder.push({t, w: SIZES[t.type].w, h: SIZES[t.type].h}));
                        if (pIdx < packs.length - 1) tokensInOrder.push({isGap: true, w: gap});
                    });

                    // Break into lines based on width limit
                    let lines = [];
                    let currentLine = [];
                    let currentW = 0;
                    let lineMaxH = 0;
                    
                    // USE CONSTANT WIDTH LIMIT
                    const maxW = BASE_ROW_WIDTH; 

                    tokensInOrder.forEach(item => {
                        if (item.isGap) {
                            currentW += item.w;
                            currentLine.push(item);
                        } else {
                            if (currentW + item.w > maxW) {
                                lines.push({items: currentLine, w: currentW, h: lineMaxH});
                                currentLine = []; currentW = 0; lineMaxH = 0;
                            }
                            currentLine.push(item);
                            currentW += item.w + 2;
                            lineMaxH = Math.max(lineMaxH, item.h);
                        }
                    });
                    if (currentLine.length) lines.push({items: currentLine, w: currentW, h: lineMaxH});

                    // Render Lines
                    lines.forEach(line => {
                        let startX;
                        // RIGHT SIDE: Start from Center (25) -> Right
                        if (this.id === 'right') {
                            startX = 25;
                            let cx = startX;
                            line.items.forEach(item => {
                                if (item.isGap) cx += item.w;
                                else {
                                    this.moveTile(item.t, cx, y);
                                    cx += item.w + 2;
                                }
                            });
                        } 
                        // LEFT SIDE: Start from Center (-25) -> Left
                        else {
                            // To fill R -> L starting from center, we simply decrement X
                            startX = -25;
                            let cx = startX;
                            line.items.forEach(item => {
                                if (item.isGap) cx -= item.w;
                                else {
                                    // item position is its top-left.
                                    // If we are at -25 and want to place an item of width 40 to its left:
                                    // it occupies [-65, -25]. The pos is -65.
                                    cx -= (item.w + 2);
                                    this.moveTile(item.t, cx, y); // Position is top-left
                                }
                            });
                        }
                        y += line.h + 15;
                    });
                });
            }

            moveTile(t, x, y) {
                t.element.classList.add('animating');
                t.x = x; t.y = y;
                t.element.style.left = x + 'px'; t.element.style.top = y + 'px';
                setTimeout(() => t.element.classList.remove('animating'), 500);
            }

            simplify() {
                this.app.saveState();
                playSound('whoosh');

                const EXISTING_REMOVE_MS = 800;
                const PAIR_INTERVAL_MS = 550;

                // 1) Zéros déjà présents (créés manuellement ou automatiquement)
const existingZeros = this.tokens.filter(t => t.pairId !== null);

// On fait disparaître EN MÊME TEMPS les 2 pièces + le badge "0"
if (existingZeros.length > 0) {
    const idSet = new Set();
    existingZeros.forEach(t => {
        idSet.add(Number(t.id));
        if (t.pairId != null) idSet.add(Number(t.pairId));
        t.element.classList.add('vanish');
    });

    // Badges liés (robuste : on lit les ids depuis le DOM)
    document.querySelectorAll('.zero-badge').forEach(b => {
        const parts = (b.id || '').split('-'); // badge-<a>-<c>
        if (parts.length === 3) {
            const a = Number(parts[1]);
            const c = Number(parts[2]);
            if (idSet.has(a) || idSet.has(c)) b.classList.add('vanish');
        }
    });

    setTimeout(() => {
        this.app.removeTokens(existingZeros.map(t => t.id));
        // sécurité : enlever tout badge résiduel associé
        document.querySelectorAll('.zero-badge').forEach(b => {
            const parts = (b.id || '').split('-');
            if (parts.length === 3) {
                const a = Number(parts[1]);
                const c = Number(parts[2]);
                if (idSet.has(a) || idSet.has(c)) b.remove();
            }
        });
    }, EXISTING_REMOVE_MS);
}

                // 2) Nouveaux zéros à créer : uniquement parmi les pièces actives (pas ghost, pas in-bracket)
                const available = this.tokens.filter(t => !t.pairId && !t.element.classList.contains('in-bracket') && !t.element.classList.contains('ghost'));

                const pairs = [];
                ['x', 'unit'].forEach(type => {
                    const pos = available.filter(t => t.type === type && t.sign === 1);
                    const neg = available.filter(t => t.type === type && t.sign === -1);
                    while (pos.length && neg.length) pairs.push([pos.pop(), neg.pop()]);
                });

                // 3) Animation des nouveaux couples (un peu plus lente pour être lisible)
                pairs.forEach((p, i) => {
                    setTimeout(() => {
                        const t1 = p[0];
                        const t2 = p[1];
                        this.app.createZeroPair(t1, t2, true);
                    }, i * PAIR_INTERVAL_MS);
                });
            }

            divide() { this.app.performDivision(); }
            
            layoutForDivision(n, keepIndex) {
                const active = this.tokens.filter(t => !t.pairId && !t.element.classList.contains('ghost'));
                const screenH = this.app.container.clientHeight / this.app.scale;
                const startY = -screenH/2 + 80;
                const gapY = Math.min(120, (screenH - 160) / n);
                
                const xs = active.filter(t => t.type === 'x');
                const us = active.filter(t => t.type === 'unit');
                
                const isLeft = (this.id === 'left');
                const startX = isLeft ? -130 : 40;
                const dir = isLeft ? -1 : 1;
                
                xs.forEach((t, i) => {
                    const row = i % n;
                    const col = Math.floor(i / n);
                    const tx = startX + (col * 100 * dir); 
                    this.moveTile(t, tx, startY + row * gapY);
                    if (row !== keepIndex) t.toDelete = true;
                });
                
                const uStartOffset = (xs.length > 0 ? (Math.ceil(xs.length/n)*100 + 20) : 0) * dir;
                us.forEach((t, i) => {
                    const row = i % n;
                    const col = Math.floor(i / n);
                    const tx = startX + uStartOffset + (col * 45 * dir);
                    this.moveTile(t, tx, startY + row * gapY);
                    if (row !== keepIndex) t.toDelete = true;
                });
            }

            updateUI() { /* épuré : plus de boutons d'opérateurs */ }
        }

        // --- MAIN APP ---
        class AlgebraEqApp {
            constructor() {
                this.nextId = 1;
                this.allTokens = [];
                this.history = []; 
                this.mode = 'setup';
                this.equationVisible = true;
                this.container = document.getElementById('board-container');
                this.world = document.getElementById('board-world');
                this.eqDisplay = document.getElementById('equation-display');
                this.scale = 1; 
                this.pan = {x:0, y:0};
                this.menuDrag = null;
                this.sideLeft = new AlgebraSide('left', this);
                this.sideRight = new AlgebraSide('right', this);
                this.initListeners();
                this.centerView();
                this.updateEquation();
                this.updatePhaseUI();
            }
            
            toggleMode() {
                const btn = document.getElementById('btn-mode');
                const txt = document.getElementById('mode-text');

                if (this.mode === 'setup') {
                    this.mode = 'solve';
                    if (btn) btn.classList.add('solve');
                    if (txt) txt.innerText = "Phase 2 : Résoudre l'équation";
                } else {
                    this.mode = 'setup';
                    if (btn) btn.classList.remove('solve');
                    if (txt) txt.innerText = "Phase 1 : Poser l'équation";
                }

                this.updatePhaseUI();
            }

            updatePhaseUI() {
                const isSolve = (this.mode === 'solve');

                const phase1Btn = document.getElementById('btn-phase1');
                const phase2Btn = document.getElementById('btn-phase2');
                const solveActions = document.getElementById('solve-actions');

                if (phase1Btn) phase1Btn.classList.toggle('hidden', isSolve);
                if (phase2Btn) phase2Btn.classList.toggle('hidden', !isSolve);
                if (solveActions) solveActions.classList.toggle('hidden', !isSolve);

                document.querySelectorAll('.phase2-only').forEach(el => {
                    el.classList.toggle('hidden', !isSolve);
                });

                this.updateDivisionButtonState();
            }
toggleEquationVisibility() {
                this.equationVisible = !this.equationVisible;
                const eq = document.getElementById('equation-display');
                if(this.equationVisible) eq.classList.remove('equation-blur'); else eq.classList.add('equation-blur');
            }
            
            
            performDivision() {
                // Division = uniquement quand l'équation est du type a·x = b (division entière possible).
                const info = this.getDivisionInfo();
                if (!info.possible) return;

                const divisor = info.a;
                if (divisor <= 1) return;

                // Nettoyer flags
                this.clearDivisionFlags();

                this.saveState();
                playSound('whoosh');

                // 1) Si l'utilisateur a déjà fait des "paquets" manuels cohérents, on les respecte.
                const manual = this.detectManualPackets(info);

                if (manual.ok) {
                    // Ne pas bouger les tuiles : on se contente de supprimer tous les paquets sauf 1
                    manual.toDeleteIds.forEach(id => {
                        const t = this.allTokens.find(x => Number(x.id) === Number(id));
                        if (t) t.toDelete = true;
                    });
                } else {
                    // 2) Sinon, on fait l'auto-paquets (mise en lignes) sans toucher l'équation en haut
                    this.sideLeft.layoutForDivision(divisor, 0);
                    this.sideRight.layoutForDivision(divisor, 0);
                }

                // Afficher "÷ divisor" des deux côtés (bref)
                this.showDivisionHints(divisor);

                // Suppression des paquets excédentaires (après un court délai pour être lisible)
                setTimeout(() => { this.applyDivisionDeletion(); }, 1450);
            }

            clearDivisionFlags() {
                [this.sideLeft, this.sideRight].forEach(side => {
                    side.tokens.forEach(t => { t.toDelete = false; });
                });
            }

            showDivisionHints(divisor) {
                const box = document.getElementById('division-hints-board');
                const l = document.getElementById('div-hint-left-board');
                const r = document.getElementById('div-hint-right-board');
                if (!box || !l || !r) return;

                l.textContent = `÷ ${divisor}`;
                r.textContent = `÷ ${divisor}`;

                box.classList.add('show');
                clearTimeout(this._divHintsTimer);
                this._divHintsTimer = setTimeout(() => {
                    box.classList.remove('show');
                }, 1300);
            }

            getDivisionInfo() {
                // Retourne {possible, a, b, xSide, uSide, reason}
                // Règles :
                // - uniquement types {x, unit}
                // - tous les x sont du même côté et sont POSITIFS (pas de -x)
                // - l'autre côté ne contient que des unités, toutes du même signe
                // - b divisible par a (division entière)
                const act = (side) => side.tokens.filter(t =>
                    t && !t.pairId &&
                    !t.element.classList.contains('ghost') &&
                    !t.element.classList.contains('in-bracket')
                );

                const L = act(this.sideLeft);
                const R = act(this.sideRight);

                // Types autorisés
                const bad = [...L, ...R].find(t => t.type !== 'x' && t.type !== 'unit');
                if (bad) return { possible:false, reason:"Contient d'autres tuiles que x et unités." };

                const xL = L.filter(t => t.type === 'x');
                const xR = R.filter(t => t.type === 'x');

                if (xL.length && xR.length) return { possible:false, reason:"Il reste des x des deux côtés." };
                if (!xL.length && !xR.length) return { possible:false, reason:"Aucun x à isoler." };

                const xSide = xL.length ? this.sideLeft : this.sideRight;
                const uSide = xL.length ? this.sideRight : this.sideLeft;

                const xTokens = (xSide === this.sideLeft ? xL : xR);

                // Pas de -x
                if (xTokens.some(t => t.sign !== 1)) return { possible:false, reason:"Présence de -x : il faut d'abord obtenir des x." };

                // Le côté des x ne doit contenir que des x (pas d'unités)
                const xSideActive = act(xSide);
                if (xSideActive.some(t => t.type === 'unit')) return { possible:false, reason:"Le côté des x contient encore des unités." };

                // Le côté des unités ne doit contenir que des unités
                const uSideActive = act(uSide);
                if (uSideActive.some(t => t.type === 'x')) return { possible:false, reason:"Le côté des unités contient encore des x." };

                // Toutes les unités du même signe
                const uPos = uSideActive.filter(t => t.sign === 1).length;
                const uNeg = uSideActive.filter(t => t.sign === -1).length;
                if (uPos && uNeg) return { possible:false, reason:"Unités de signes différents : réduire avant de diviser." };

                const a = xTokens.length;
                if (a <= 0) return { possible:false, reason:"Coefficient de x invalide." };

                // b = somme des signes (unités)
                const b = uSideActive.reduce((s,t)=>s + (t.sign||0), 0);

                // Division entière
                const absB = Math.abs(b);
                if (absB % a !== 0) return { possible:false, reason:"La division n'est pas entière." };

                return {
                    possible:true,
                    a,
                    b,
                    absB,
                    unitsPerGroup: absB / a,
                    unitSign: (uPos ? 1 : (uNeg ? -1 : 1)),
                    xSide,
                    uSide,
                    reason:""
                };
            }

            detectManualPackets(info) {
                // On essaie de reconnaître des paquets déjà faits à la main.
                // Principe : les x servent d'ancrages (a paquets). On attribue chaque unité au x le plus "proche"
                // selon un axe dominant (x ou y) puis on vérifie que chaque paquet reçoit le bon nombre d'unités.
                try {
                    const act = (side) => side.tokens.filter(t =>
                        t && !t.pairId &&
                        !t.element.classList.contains('ghost') &&
                        !t.element.classList.contains('in-bracket')
                    );

                    const xSide = info.xSide;
                    const uSide = info.uSide;

                    const xTokens = act(xSide).filter(t => t.type === 'x' && t.sign === 1);
                    const uTokens = act(uSide).filter(t => t.type === 'unit' && t.sign === info.unitSign);

                    const a = info.a;
                    const k = info.unitsPerGroup;

                    if (xTokens.length !== a) return { ok:false };
                    if (uTokens.length !== info.absB) return { ok:false };

                    // Choix de l'axe : celui où les x sont le plus étalés
                    const xs = xTokens.map(t => t.x);
                    const ys = xTokens.map(t => t.y);
                    const rangeX = Math.max(...xs) - Math.min(...xs);
                    const rangeY = Math.max(...ys) - Math.min(...ys);
                    const axis = (rangeY >= rangeX) ? 'y' : 'x';

                    const anchors = xTokens.map(t => ({ token:t, v:(axis==='y'?t.y:t.x) }))
                                           .sort((a,b)=>a.v-b.v);

                    // attribution des unités
                    const buckets = anchors.map(()=>[]);
                    uTokens.forEach(u => {
                        const uv = (axis==='y'?u.y:u.x);
                        let best = 0;
                        let bestD = Infinity;
                        for (let i=0;i<anchors.length;i++){
                            const d = Math.abs(uv - anchors[i].v);
                            if (d < bestD) { bestD = d; best = i; }
                        }
                        buckets[best].push(u);
                    });

                    // vérif : chaque bucket a exactement k unités (ou 0 si k=0)
                    if (k === 0) {
                        // ok si aucun token unité (déjà garanti)
                    } else {
                        if (buckets.some(b => b.length !== k)) return { ok:false };
                    }

                    // Choisir le paquet à garder : le 1er (stable)
                    const keepIdx = 0;

                    const keepX = anchors[keepIdx].token;
                    const keepUnits = buckets[keepIdx].map(t=>t.id);

                    // Tous les tokens de division à supprimer = tous les autres x + toutes les autres unités
                    const toDeleteIds = [];
                    anchors.forEach((aObj, i) => {
                        if (i !== keepIdx) toDeleteIds.push(aObj.token.id);
                    });
                    buckets.forEach((b, i) => {
                        if (i !== keepIdx) b.forEach(t => toDeleteIds.push(t.id));
                    });

                    return { ok:true, axis, keepIdx, keepXId: keepX.id, keepUnitIds: keepUnits, toDeleteIds };
                } catch(e) {
                    return { ok:false };
                }
            }

            updateDivisionButtonState() {
                const btn = document.getElementById('btn-diviser');
                if (!btn) return;

                // En phase 1, on laisse la logique de visibilité gérer.
                if (this.mode !== 'solve') {
                    btn.disabled = true;
                    btn.title = "";
                    return;
                }

                const info = this.getDivisionInfo();
                btn.disabled = !info.possible || info.a <= 1;
                btn.title = (btn.disabled && info.reason) ? info.reason : "";
            }

            
            applyDivisionDeletion() {
                const toRemove = [];
                [this.sideLeft, this.sideRight].forEach(side => {
                    side.tokens.forEach(t => {
                        if (t.toDelete) {
                            t.element.classList.add('vanish');
                            toRemove.push(t);
                        }
                    });
                });
                if (toRemove.length > 0) playSound('pop');
                setTimeout(() => {
                    this.removeTokens(toRemove.map(t=>t.id));
                }, 500);
            }

            removeTokens(ids) {
                const idSet = new Set(ids.map(x => Number(x)));

                // 1) Nettoyer les zéros (paires) qui pointent vers un token supprimé
                this.allTokens.forEach(t => {
                    if (t && t.pairId != null) {
                        const pid = Number(t.pairId);
                        if (idSet.has(pid) || idSet.has(Number(t.id))) {
                            // on va gérer via suppression des badges + classe
                            t.pairId = null;
                            if (t.element) t.element.classList.remove('is-zero');
                        }
                    }
                });

                // 2) Supprimer badges associés (avant de retirer les éléments)
                document.querySelectorAll('.zero-badge').forEach(b => {
                    const parts = (b.id || '').split('-');
                    if (parts.length === 3) {
                        const a = Number(parts[1]);
                        const c = Number(parts[2]);
                        if (idSet.has(a) || idSet.has(c)) b.remove();
                    }
                });

                // 3) Supprimer éléments DOM des tokens
                ids.forEach(id => {
                    const nid = Number(id);
                    const t = this.allTokens.find(x => Number(x.id) === nid);
                    if (t && t.element) t.element.remove();
                });

                // 4) Purger les structures de données
                this.allTokens = this.allTokens.filter(x => !idSet.has(Number(x.id)));
                this.sideLeft.tokens = this.sideLeft.tokens.filter(x => !idSet.has(Number(x.id)));
                this.sideRight.tokens = this.sideRight.tokens.filter(x => !idSet.has(Number(x.id)));
                this.sideLeft.steps.forEach(s => s.tokenIds = s.tokenIds.filter(tid => !idSet.has(Number(tid))));
                this.sideRight.steps.forEach(s => s.tokenIds = s.tokenIds.filter(tid => !idSet.has(Number(tid))));

                this.updateEquation();
            }
            saveState() {
                // IMPORTANT: Clone deeply to avoid reference issues
                const state = {
                    nextId: this.nextId,
                    // Serialize token data only
                    tokens: this.allTokens.map(t => {
                        const { element, ...data } = t; 
                        return data; 
                    }),
                    stepsL: JSON.parse(JSON.stringify(this.sideLeft.steps)),
                    stepsR: JSON.parse(JSON.stringify(this.sideRight.steps)),
                    currStepL: this.sideLeft.currStepIdx,
                    currStepR: this.sideRight.currStepIdx,
                    isSubL: this.sideLeft.isSubInput, isMultL: this.sideLeft.isMultInput,
                    isSubR: this.sideRight.isSubInput, isMultR: this.sideRight.isMultInput,
                    displayModeL: this.sideLeft.displayMode,
                    displayModeR: this.sideRight.displayMode,
                    nextPackIdL: this.sideLeft.nextPackId,
                    nextPackIdR: this.sideRight.nextPackId,
                    lastPackL: this.sideLeft.lastPack,
                    lastPackR: this.sideRight.lastPack,
                    lastSeqPackIdL: this.sideLeft.lastSeqPackId,
                    lastSeqPackIdR: this.sideRight.lastSeqPackId,
                    autoFlowL: this.sideLeft.autoFlow ? { ...this.sideLeft.autoFlow } : null,
                    autoFlowR: this.sideRight.autoFlow ? { ...this.sideRight.autoFlow } : null
                };
                this.history.push(JSON.stringify(state));
                if(this.history.length > 50) this.history.shift();
            }

            undo() {
                if(this.history.length === 0) return;
                const json = this.history.pop();
                const state = JSON.parse(json);
                this.resetBoard(false);
                
                this.nextId = state.nextId;
                this.sideLeft.steps = state.stepsL; this.sideRight.steps = state.stepsR;
                this.sideLeft.currStepIdx = state.currStepL; this.sideRight.currStepIdx = state.currStepR;
                this.sideLeft.isSubInput = state.isSubL; this.sideLeft.isMultInput = state.isMultL;
                this.sideRight.isSubInput = state.isSubR; this.sideRight.isMultInput = state.isMultR;
                this.sideLeft.displayMode = state.displayModeL || 'normal';
                this.sideRight.displayMode = state.displayModeR || 'normal';

                this.sideLeft.nextPackId = state.nextPackIdL || this.sideLeft.nextPackId;
                this.sideRight.nextPackId = state.nextPackIdR || this.sideRight.nextPackId;
                this.sideLeft.lastPack = state.lastPackL || null;
                this.sideRight.lastPack = state.lastPackR || null;
                this.sideLeft.lastSeqPackId = state.lastSeqPackIdL || null;
                this.sideRight.lastSeqPackId = state.lastSeqPackIdR || null;

                this.sideLeft.autoFlow = state.autoFlowL || null;
                this.sideRight.autoFlow = state.autoFlowR || null;

                state.tokens.forEach(data => {
                    const el = document.createElement('div');
                    const tileSign = data.sign;
                    const type = data.type;
                    el.className = `token ${type==='unit'?'type-unit':'type-x'} ${tileSign===1?'green':'red'}`;
                    let lbl = type==='unit' ? (tileSign===1?'1':'-1') : (tileSign===1?'x':'-x');
                    el.innerHTML = `<span style="pointer-events:none;">${lbl}</span>`;
                    el.id = `t-${data.id}`;
                    el.style.left = data.x+'px'; el.style.top = data.y+'px';
                    el.addEventListener('mousedown', e => this.handleDragStart(e, data.id));
                    el.addEventListener('touchstart', e => this.handleDragStart(e, data.id), {passive:false});
                    this.world.appendChild(el);
                    
                    const token = { ...data, element: el };
                    this.allTokens.push(token);
                    if(token.side === 'left') this.sideLeft.tokens.push(token);
                    else this.sideRight.tokens.push(token);
                });
                
                this.allTokens.forEach(t => {
                    if(t.pairId) {
                        t.element.classList.add('is-zero');
                        const p = this.allTokens.find(x => x.id === t.pairId);
                        if(p && !document.getElementById(`badge-${t.id}-${p.id}`) && !document.getElementById(`badge-${p.id}-${t.id}`)) {
                             const b = document.createElement('div'); b.className='zero-badge'; b.textContent='0'; 
                             b.id=`badge-${t.id}-${p.id}`;
                             const mx=(t.x+p.x)/2; const my=(t.y+p.y)/2;
                             const w = SIZES[t.type].w; const h = SIZES[t.type].h;
                             b.style.left = (mx + w/2) + 'px'; b.style.top = (my + h/2) + 'px';
                             this.world.appendChild(b);
                        }
                    }
                });
                this.sideLeft.updateUI(); this.sideRight.updateUI(); this.updateEquation();
            }

            initListeners() {
                this.container.addEventListener('wheel', e => { e.preventDefault(); this.scale = Math.min(Math.max(0.5, this.scale - e.deltaY * 0.001), 2.5); this.updateTransform(); }, {passive:false});
                
                // RESTORE PANNING (Vertical Only)
                this.container.addEventListener('mousedown', e => {
                    if (this.currentTool === 'pen') return; // en mode stylo, on dessine au lieu de déplacer le plateau
                    if (e.target.closest('.token') || e.target.closest('button')) return;
                    this.isPanning = true; 
                    // We only care about Y start relative to current pan.y
                    this.panStart = { y: e.clientY - this.pan.y };
                    this.container.classList.add('panning');
                });

                window.addEventListener('mousemove', e => {
                    if (this.isPanning) {
                        // Update ONLY Y
                        this.pan.y = e.clientY - this.panStart.y; 
                        this.updateTransform(); 
                    }
                    else if (this.menuDrag) this.handleMenuDragMove(e);
                });
                
                window.addEventListener('mouseup', e => {
                    this.isPanning = false; 
                    this.container.classList.remove('panning');
                    if(this.menuDrag) this.handleMenuDragEnd(e);
                });
                
                this.container.addEventListener('dragover', e => e.preventDefault());
                this.container.addEventListener('drop', e => e.preventDefault());
                window.addEventListener('resize', () => { this.centerView(); });
                document.addEventListener('touchmove', e => { if (this.menuDrag) { e.preventDefault(); this.handleMenuDragMove(e); } }, {passive:false});
                document.addEventListener('touchend', e => { if (this.menuDrag) this.handleMenuDragEnd(e); });
            }

            centerView() {
                const cx = this.container.clientWidth / 2;
                const cy = this.container.clientHeight / 2;
                this.pan.x = cx; 
                this.pan.y = cy - 50;
                this.updateTransform();
            }
            updateTransform() { this.world.style.transform = `translate(${this.pan.x}px, ${this.pan.y}px) scale(${this.scale})`; }
            
            // --- MENU DRAG ---
            handleMenuTouchStart(e, type, sign, side) {
                e.preventDefault();
                const touch = e.touches ? e.touches[0] : e;
                const cx = touch.clientX; const cy = touch.clientY;
                this.menuDrag = { isDragging: false, type, sign, side, startPos: { x: cx, y: cy }, el: null, offset: null };
                const move = (ev) => this.handleMenuDragMove(ev);
                const end = (ev) => {
                    document.removeEventListener('mousemove', move); document.removeEventListener('touchmove', move);
                    document.removeEventListener('mouseup', end); document.removeEventListener('touchend', end);
                    this.handleMenuDragEnd(ev);
                };
                document.addEventListener('mousemove', move); document.addEventListener('touchmove', move, { passive: false });
                document.addEventListener('mouseup', end); document.addEventListener('touchend', end);
            }
            
            handleMenuDragMove(ev) {
                if (!this.menuDrag) return;
                ev.preventDefault();
                const touch = ev.touches ? ev.touches[0] : ev;
                const cx = touch.clientX; const cy = touch.clientY;
                if (!this.menuDrag.isDragging) {
                    const dist = Math.hypot(cx - this.menuDrag.startPos.x, cy - this.menuDrag.startPos.y);
                    if (dist > 5) { this.menuDrag.isDragging = true; this.createMenuGhost(cx, cy); }
                }
                if (this.menuDrag.isDragging && this.menuDrag.el) {
                    this.menuDrag.el.style.left = (cx - this.menuDrag.offset.x) + 'px';
                    this.menuDrag.el.style.top = (cy - this.menuDrag.offset.y) + 'px';
                    const menuBoundary = window.innerHeight - 150;
                    if (cy > menuBoundary) { const s = this.getPreviewScale(this.menuDrag.type); this.menuDrag.el.style.transform = `scale(${s})`; } 
                    else { this.menuDrag.el.style.transform = `scale(${this.scale})`; }
                }
            }
            
            createMenuGhost(cx, cy) {
                const type = this.menuDrag.type; const sign = this.menuDrag.sign;
                const el = document.createElement('div');
                const colorClass = sign === 1 ? 'green' : 'red';
                el.className = `token ${colorClass} type-${type==='unit'?'unit':'x'} menu-ghost scaling-transition`; 
                let label = type==='unit' ? (sign===1?'1':'-1') : (sign===1?'x':'-x');
                el.innerHTML = `<span style="pointer-events:none;">${label}</span>`;
                document.body.appendChild(el);
                const size = SIZES[type];
                const offset = { x: (size.w * this.scale) / 2, y: (size.h * this.scale) / 2 };
                this.menuDrag.offset = offset; this.menuDrag.el = el;
                el.style.left = (cx - offset.x) + 'px'; el.style.top = (cy - offset.y) + 'px';
                const menuBoundary = window.innerHeight - 150;
                if (cy > menuBoundary) { const s = this.getPreviewScale(type); el.style.transform = `scale(${s})`; } 
                else { el.style.transform = `scale(${this.scale})`; }
            }
            
            getPreviewScale(type) {
                let previewW = type === 'x' ? 40 : 24; 
                const realW = SIZES[type].w;
                return previewW / (realW * this.scale);
            }

            handleMenuDragEnd(e) {
                if (!this.menuDrag) return;
                const touch = e.changedTouches ? e.changedTouches[0] : e;
                
                if (this.menuDrag.isDragging && this.menuDrag.el) {
                    const endX = touch.clientX; const endY = touch.clientY;
                    this.menuDrag.el.remove();
                    const menuHeight = 150;
                    const isOverBoard = endY < (window.innerHeight - menuHeight);
                    
                    if (isOverBoard) {
                        const pos = this.getWorldPos(endX, endY);
                        const w = SIZES[this.menuDrag.type].w; const h = SIZES[this.menuDrag.type].h;
                        const x = pos.x - w/2; const y = pos.y - h/2;
                        const dropSide = (x < 0) ? 'left' : 'right';
                        
                        if (dropSide === this.menuDrag.side) {
                            const targetSide = (dropSide === 'left') ? this.sideLeft : this.sideRight;
                            // JUST CALL ADD TILE. The internal logic handles mode check and mirroring.
                            targetSide.addTile(this.menuDrag.type, parseInt(this.menuDrag.sign), false, x, y); 
                        }
                    }
                } else {
                    const targetSide = (this.menuDrag.side === 'left') ? this.sideLeft : this.sideRight;
                    targetSide.addTile(this.menuDrag.type, parseInt(this.menuDrag.sign), false, null, null); 
                }
                this.menuDrag = null;
            }

            // --- BOARD DRAG ---
            handleDragStart(e, id) {
                e.stopPropagation();
                const t = this.allTokens.find(x => x.id === id);
                if (!t) return;
                
                this.saveState(); 

                if (t.pairId) {
                    const p = this.allTokens.find(x => x.id === t.pairId);
                    if(p) { p.pairId=null; p.element.classList.remove('is-zero'); const b = document.getElementById(`badge-${t.id}-${p.id}`)||document.getElementById(`badge-${p.id}-${t.id}`); if(b)b.remove(); }
                    t.pairId=null; t.element.classList.remove('is-zero');
                    this.updateEquation();
                }

                t.element.classList.add('dragging');
                const r = t.element.getBoundingClientRect();
                const offset = { x: (e.touches?e.touches[0].clientX:e.clientX) - r.left, y: (e.touches?e.touches[0].clientY:e.clientY) - r.top };
                
                const startSide = t.x < 0 ? 'left' : 'right';

                const move = ev => {
                    ev.preventDefault();
                    const cx = ev.touches?ev.touches[0].clientX:ev.clientX; const cy = ev.touches?ev.touches[0].clientY:ev.clientY;
                    let wx = (cx - this.container.getBoundingClientRect().left - this.pan.x - offset.x)/this.scale;
                    let wy = (cy - this.container.getBoundingClientRect().top - this.pan.y - offset.y)/this.scale;

                    if (startSide === 'left' && wx > -5 - SIZES[t.type].w) wx = -5 - SIZES[t.type].w;
                    if (startSide === 'right' && wx < 5) wx = 5;

                    t.x = wx; t.y = wy;
                    t.element.style.left = t.x+'px'; t.element.style.top = t.y+'px';
                };
                const end = () => {
                    document.removeEventListener('mousemove', move); document.removeEventListener('touchmove', move);
                    document.removeEventListener('mouseup', end); document.removeEventListener('touchend', end);
                    t.element.classList.remove('dragging');
                    this.checkOverlap(t);
                    this.updateEquation();
                };
                document.addEventListener('mousemove', move); document.addEventListener('touchmove', move, {passive:false});
                document.addEventListener('mouseup', end); document.addEventListener('touchend', end);
            }

            checkOverlap(t1) {
                for(let t2 of this.allTokens) {
                    if (t1===t2 || t2.pairId || t1.type!==t2.type || t1.sign===t2.sign) continue;
                    if ((t1.x < 0 && t2.x > 0) || (t1.x > 0 && t2.x < 0)) continue;
                    const d = Math.hypot(t1.x - t2.x, t1.y - t2.y);
                    if (d < SNAP) { this.createZeroPair(t1, t2); break; }
                }
            }

            createZeroPair(t1, t2, isAuto=false) {
                playSound('snap');

                const mx = (t1.x + t2.x) / 2;
                const my = (t1.y + t2.y) / 2;

                // Animation de rapprochement (plus lisible)
                t1.element.classList.add('animating');
                t2.element.classList.add('animating');
                requestAnimationFrame(() => {
                    t1.x = mx; t1.y = my;
                    t2.x = mx; t2.y = my;
                    t1.element.style.left = mx + 'px';
                    t1.element.style.top = my + 'px';
                    t2.element.style.left = mx + 'px';
                    t2.element.style.top = my + 'px';
                });
                setTimeout(() => {
                    t1.element.classList.remove('animating');
                    t2.element.classList.remove('animating');
                }, 520);

                t1.pairId = t2.id;
                t2.pairId = t1.id;
                t1.element.classList.add('is-zero');
                t2.element.classList.add('is-zero');

                const b = document.createElement('div');
                b.className = 'zero-badge';
                b.textContent = '0';
                b.id = `badge-${t1.id}-${t2.id}`;

                const w = SIZES[t1.type].w;
                const h = SIZES[t1.type].h;
                b.style.left = (mx + w/2) + 'px';
                b.style.top  = (my + h/2) + 'px';
                this.world.appendChild(b);

                this.updateEquation();

                if (isAuto) {
    const HOLD_MS = 750;
    const VANISH_MS = 450; // doit matcher l'animation CSS (0.45s)

    setTimeout(() => {
        // Pièces + "0" disparaissent ensemble
        t1.element.classList.add('vanish');
        t2.element.classList.add('vanish');
        b.classList.add('vanish');

        setTimeout(() => {
            this.removeTokens([t1.id, t2.id]);
            const bb = document.getElementById(b.id);
            if (bb) bb.remove();
        }, VANISH_MS);
    }, HOLD_MS);
}
            }


            updateEquation() {
                const getStr = (side) => {
                    if (side.displayMode === 'reduced') {
                        return this.getReducedStr(side);
                    } else if (side.displayMode === 'ordered') {
                        return this.getOrderedStr(side);
                    }
                    
                    let s = "";
                    const hasNonEmptyBefore = (i) => { for(let k=0; k<i; k++) if(side.steps[k].tokenIds.length > 0) return true; return false; };
                    
                    side.steps.forEach((step, idx) => {
                        const toks = step.tokenIds.map(id => this.allTokens.find(t=>t.id===id)).filter(t => t && !t.pairId);
                        if (!toks.length && idx !== side.currStepIdx) return;
                        
                        let content = "";
                        const groups = []; let cur=null;
                        toks.forEach(t=>{ if(cur && cur.type===t.type && cur.sign===t.displaySign) cur.c++; else { if(cur) groups.push(cur); cur={type:t.type, sign:t.displaySign, c:1}; } });
                        if(cur) groups.push(cur);
                        
                        groups.forEach((g, i) => {
                            const lbl = g.type==='unit' ? '' : 'x';
                            const val = g.c;
                            const col = g.sign === 1 ? COLORS.pos : COLORS.neg;
                            const prefix = (i>0 && g.sign===1) ? `{\\color{${COLORS.pos}}{+}}` : (g.sign===-1?`{\\color{${COLORS.neg}}{-}}`:'');
                            const leadMinus = (i===0 && g.sign===-1) ? `{\\color{${COLORS.neg}}{-}}` : '';
                            const num = (val===1 && g.type!=='unit') ? '' : val;
                            content += (i===0 ? leadMinus : `${prefix}`) + `{\\color{${col}}{${num}${lbl}}}`;
                        });
                        
                        if(!content) content = "\\dots";
                        
                        let pStr = content;
                        if (step.type === 'multiplication' && !step.distributed) pStr = `${step.factor}(${content})`;
                        if (step.type === 'subtraction' && !step.oppositeApplied) pStr = `-(${content})`;
                        
                        if (idx > 0 && hasNonEmptyBefore(idx)) {
                            const rawStr = pStr.replace(/<[^>]*>|{[^}]*}/g, '');
                            if (!pStr.includes('{red}{-}') && !pStr.startsWith('-')) s += `{\\color{${COLORS.pos}}{+}}`;
                        }
                        s += pStr;
                    });
                    return s || "0";
                };

                const l = getStr(this.sideLeft);
                const r = getStr(this.sideRight);

                const leftEl = document.getElementById('eq-left');
                const eqEl = document.getElementById('eq-eq');
                const rightEl = document.getElementById('eq-right');

                if (leftEl && eqEl && rightEl) {
                    katex.render(l, leftEl, { throwOnError: false });
                    katex.render('=', eqEl, { throwOnError: false });
                    katex.render(r, rightEl, { throwOnError: false });
                } else {
                    katex.render(`${l} = ${r}`, document.getElementById('equation-display'), { throwOnError: false });
                }

                this.updateDivisionButtonState();
            }
            getReducedStr(side) {
                const active = side.tokens.filter(t => !t.pairId && !t.element.classList.contains('ghost'));
                if (!active.length) return '0';

                let xPos = 0, xNeg = 0, uPos = 0, uNeg = 0;
                active.forEach(t => {
                    if (t.type === 'x') {
                        if (t.sign === 1) xPos++; else xNeg++;
                    } else if (t.type === 'unit') {
                        if (t.sign === 1) uPos++; else uNeg++;
                    }
                });

                const parts = [];
                const addTerm = (sign, body) => {
                    const col = sign > 0 ? COLORS.pos : COLORS.neg;
                    if (parts.length === 0) {
                        if (sign < 0) {
                            parts.push(`{\\color{${COLORS.neg}}{-}}{\\color{${col}}{${body}}}`);
                        } else {
                            parts.push(`{\\color{${col}}{${body}}}`);
                        }
                    } else {
                        const sym = sign > 0 ? '+' : '-';
                        parts.push(`{\\color{${col}}{${sym}}}{\\color{${col}}{${body}}}`);
                    }
                };

                // Réduire = regrouper verts avec verts, rouges avec rouges (sans annuler vert/rouge)
                if (xPos) addTerm(+1, `${xPos === 1 ? '' : xPos}x`);
                if (xNeg) addTerm(-1, `${xNeg === 1 ? '' : xNeg}x`);
                if (uPos) addTerm(+1, `${uPos}`);
                if (uNeg) addTerm(-1, `${uNeg}`);

                return parts.join('') || '0';
            }

            getOrderedStr(side) {
                const active = side.tokens.filter(t => !t.pairId && !t.element.classList.contains('ghost'));
                if (!active.length) return '0';

                // Ranger = trier par (x verts) puis (x rouges) puis (unit verts) puis (unit rouges)
                // en conservant les paquets (packId) sans les additionner entre eux.
                const groups = new Map();
                for (const t of active) {
                    const pid = (typeof t.packId !== 'undefined') ? t.packId : -1;
                    const key = `${t.type}|${t.sign}|${pid}`;
                    if (!groups.has(key)) groups.set(key, { type: t.type, sign: t.sign, pid, count: 0 });
                    groups.get(key).count += 1;
                }

                const list = Array.from(groups.values()).filter(g => g.count > 0);
                list.sort((a, b) => {
                    const typeA = a.type === 'x' ? 0 : 1;
                    const typeB = b.type === 'x' ? 0 : 1;
                    if (typeA !== typeB) return typeA - typeB;
                    const signA = a.sign === 1 ? 0 : 1;
                    const signB = b.sign === 1 ? 0 : 1;
                    if (signA !== signB) return signA - signB;
                    return a.pid - b.pid;
                });

                let s = '';
                list.forEach((g, i) => {
                    const col = g.sign === 1 ? COLORS.pos : COLORS.neg;
                    const isNeg = g.sign === -1;
                    const val = (g.count === 1 && g.type === 'x') ? '' : g.count;
                    const lbl = g.type === 'x' ? 'x' : '';

                    let prefix = '';
                    if (i === 0) {
                        if (isNeg) prefix = `{\\color{${COLORS.neg}}{-}}`;
                    } else {
                        prefix = isNeg ? `{\\color{${COLORS.neg}}{-}}` : `{\\color{${COLORS.pos}}{+}}`;
                    }
                    s += `${prefix}{\\color{${col}}{${val}${lbl}}}`;
                });

                return s || '0';
            }
            
            // --- TOOLS ---
            setTool(t){
                this.currentTool=t;
                const p=t==='pen';
                // Toggle active class on body to allow click-through for tokens if needed, 
                // or ensure canvas is top.
                if(p) document.body.classList.add('drawing-active');
                else document.body.classList.remove('drawing-active');
                
                document.getElementById('custom-cursor').style.display=p?'block':'none';
                if(p) document.body.style.cursor = 'none';
                else document.body.style.cursor = 'default';
            }
            
            startDraw(e){this.isDrawing=true;const p=this.getWorldPos(e.touches?e.touches[0].clientX:e.clientX,e.touches?e.touches[0].clientY:e.clientY);this.lastDrawPos=p;this.ctx.beginPath();this.ctx.moveTo(p.x,p.y);}
            draw(e){e.preventDefault();const p=this.getWorldPos(e.touches?e.touches[0].clientX:e.touches?e.touches[0].clientY:e.clientY);this.ctx.lineTo(p.x,p.y);this.ctx.stroke();this.lastDrawPos=p;}
            clearDrawing(){this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);}
            resizeCanvas(){this.canvas.width=4000;this.canvas.height=4000;this.canvas.style.width='4000px';this.canvas.style.height='4000px';this.ctx.lineWidth=3;this.ctx.lineCap='round';this.ctx.strokeStyle='#2563eb';}
            moveCursor(e){if(this.currentTool!=='pen')return;const c=document.getElementById('custom-cursor');c.style.left=e.clientX+'px';c.style.top=e.clientY+'px';c.style.transform='translate(-6px,-28px)';}
            getWorldPos(cx, cy) { const r = this.container.getBoundingClientRect(); return { x: (cx - r.left - this.pan.x) / this.scale, y: (cy - r.top - this.pan.y) / this.scale }; }
            
            resetBoard(clearHistory=true) {
                // Remove DOM elements properly
                this.allTokens.forEach(t => t.element.remove());
                document.querySelectorAll('.zero-badge').forEach(b=>b.remove());
                
                // Clear Data
                this.allTokens = [];
                
                // Reset Sides
                this.sideLeft = new AlgebraSide('left', this);
                this.sideRight = new AlgebraSide('right', this);
                
                // Clear Drawing
                ctx.clearRect(0,0,cvs.width,cvs.height);
                
                if(clearHistory) {
                    this.history = [];
                    this.mode = 'setup';
                    document.getElementById('btn-mode').classList.remove('solve');
                    document.getElementById('mode-text').innerText = "Phase 1 : Poser l'équation";
                }
                
                this.centerView();
                this.updateEquation();
            }
        }
        
                // --- DESSIN (STYLO) : version robuste, sans énorme canevas ---
        const cvs = document.getElementById('drawing-canvas');
        const ctx = cvs.getContext('2d');

        // On place le canvas dans le conteneur (non transformé) et on redessine selon pan/zoom.
        const boardContainer = document.getElementById('board-container');
        if (cvs.parentElement !== boardContainer) boardContainer.appendChild(cvs);

        let dpr = window.devicePixelRatio || 1;

        function resizeCvs() {
            dpr = window.devicePixelRatio || 1;
            const w = boardContainer.clientWidth;
            const h = boardContainer.clientHeight;

            cvs.style.position = 'absolute';
            cvs.style.left = '0px';
            cvs.style.top = '0px';
            cvs.style.width = w + 'px';
            cvs.style.height = h + 'px';

            cvs.width = Math.max(1, Math.round(w * dpr));
            cvs.height = Math.max(1, Math.round(h * dpr));

            // Dessin en pixels CSS, rendu HD
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.strokeStyle = '#2563eb';
            ctx.imageSmoothingEnabled = true;
        }
        window.addEventListener('resize', resizeCvs);

        const app = new AlgebraEqApp();
        app.canvas = cvs;
        app.ctx = ctx;

        // --- Boutons outils : état visuel (main / stylo) ---
        const btnToolHand = document.querySelector("button[onclick=\"app.setTool('hand')\"]");
        const btnToolPen  = document.querySelector("button[onclick=\"app.setTool('pen')\"]");

        function setToolBtnState(btn, active) {
            if (!btn) return;
            if (active) {
                btn.classList.add('bg-white', 'shadow', 'text-gray-700');
                btn.classList.remove('text-gray-500', 'hover:bg-gray-200');
            } else {
                btn.classList.remove('bg-white', 'shadow', 'text-gray-700');
                btn.classList.add('text-gray-500', 'hover:bg-gray-200');
            }
        }
        function updateToolButtons(tool) {
            setToolBtnState(btnToolHand, tool === 'hand');
            setToolBtnState(btnToolPen, tool === 'pen');
        }

        // --- Stockage des traits en coordonnées "monde" (pour écrire partout) ---
        const strokes = []; // chaque stroke = [{x,y}, {x,y}, ...] en coords monde
        let isDrawing = false;
        let currentStroke = null;

        function clearCanvas() {
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, cvs.width, cvs.height);
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }

        function worldToCanvas(pt) {
            // monde -> écran (dans le conteneur)
            return {
                x: (app.pan.x + pt.x * app.scale),
                y: (app.pan.y + pt.y * app.scale)
            };
        }

        function redrawAllStrokes() {
            clearCanvas();
            const lw = 3 * app.scale; // épaisseur suit le zoom (si un jour tu ajoutes un zoom)
            for (const s of strokes) {
                if (!s || s.length < 2) continue;
                ctx.lineWidth = lw;
                const p0 = worldToCanvas(s[0]);
                ctx.beginPath();
                ctx.moveTo(p0.x, p0.y);
                for (let i = 1; i < s.length; i++) {
                    const p = worldToCanvas(s[i]);
                    ctx.lineTo(p.x, p.y);
                }
                ctx.stroke();
            }
        }

        // --- Tool binding (sans casser le reste) ---
        app.setTool = function (t) {
            app.currentTool = t;
            updateToolButtons(t);

            const isPen = (t === 'pen');
            const cursorEl = document.getElementById('custom-cursor');

            if (isPen) {
                cursorEl.classList.remove('hidden');
                cursorEl.style.display = 'block';
                document.body.style.cursor = 'none';
                document.body.classList.add('drawing-active');
            } else {
                cursorEl.classList.add('hidden');
                cursorEl.style.display = 'none';
                document.body.style.cursor = 'default';
                document.body.classList.remove('drawing-active');
            }

            redrawAllStrokes();
        };

        app.clearDrawing = function () {
            strokes.length = 0;
            clearCanvas();
        };

        // Redessiner quand le monde bouge (centreView / pan / scale)
        const _updateTransform = app.updateTransform.bind(app);
        app.updateTransform = function () {
            _updateTransform();
            redrawAllStrokes();
        };

        // Curseur croix : suivre la souris
        document.addEventListener('mousemove', (e) => {
            if (app.currentTool !== 'pen') return;
            const c = document.getElementById('custom-cursor');
            c.style.left = e.clientX + 'px';
            c.style.top = e.clientY + 'px';
            c.style.transform = 'translate(-9px,-9px)';
        });

        // Dessin : on dessine en coordonnées écran, mais on enregistre en coordonnées monde
        function clientToCanvas(e) {
            const r = boardContainer.getBoundingClientRect();
            return { x: e.clientX - r.left, y: e.clientY - r.top };
        }

        document.addEventListener('mousedown', (e) => {
            if (app.currentTool !== 'pen') return;
            if (e.target.closest('button')) return; // ne pas dessiner sur les boutons

            isDrawing = true;
            currentStroke = [];

            const wp = app.getWorldPos(e.clientX, e.clientY);
            currentStroke.push(wp);
            strokes.push(currentStroke);

            const cp = clientToCanvas(e);
            ctx.lineWidth = 3 * app.scale;
            ctx.beginPath();
            ctx.moveTo(cp.x, cp.y);
        });

        document.addEventListener('mousemove', (e) => {
            if (app.currentTool !== 'pen' || !isDrawing) return;

            const wp = app.getWorldPos(e.clientX, e.clientY);
            if (currentStroke) currentStroke.push(wp);

            const cp = clientToCanvas(e);
            ctx.lineTo(cp.x, cp.y);
            ctx.stroke();
        });

        document.addEventListener('mouseup', () => {
            isDrawing = false;
            currentStroke = null;
        });

        // Init
        resizeCvs();
        app.setTool('hand');
</script>
</body>
</html>
