<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Calcul Littéral - Équations (1er Degré)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css">
    <style>
        body { font-family: 'Fredoka', sans-serif; background-color: #f0f9ff; overflow: hidden; user-select: none; touch-action: none; }
        
        /* --- TUILES PLATEAU --- */
        .token {
            position: absolute; display: flex; align-items: center; justify-content: center;
            font-weight: 600; color: white; box-shadow: 0 4px 6px rgba(0,0,0,0.25);
            cursor: grab; transition: transform 0.1s, background-color 0.5s; z-index: 10;
            font-family: 'Times New Roman', serif; font-style: italic; font-size: 1.2rem;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3); transform-origin: 0 0;
        }
        .token.dragging { transition: none !important; z-index: 1000 !important; cursor: grabbing; box-shadow: 0 15px 30px rgba(0,0,0,0.4); transform: scale(1.1); }
        .token.animating { transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1), left 0.5s ease-in-out, top 0.5s ease-in-out, background-color 0.5s !important; }
        .vanish { animation: vanish 0.45s ease-in forwards; pointer-events: none; }
        @keyframes vanish { 0% { transform: scale(1); opacity: 1; } 100% { transform: scale(0.1); opacity: 0; } }

        .token.scaling-transition { transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1) !important; }

        .token.green { background: radial-gradient(circle at 30% 30%, #4ade80, #16a34a); border: 2px solid #14532d; }
        .token.red { background: radial-gradient(circle at 30% 30%, #f87171, #dc2626); border: 2px solid #7f1d1d; }
        
        .token.in-bracket { opacity: 0.95; box-shadow: none !important; }
        .token.pending-mult { box-shadow: 0 0 0 3px #3b82f6 !important; }
        .token.is-zero { background: #9ca3af !important; opacity: 0.6; border: 2px solid #6b7280; box-shadow: none; z-index: 5; color: rgba(255,255,255,0.5); }
        .token.fading-gray { background: #9ca3af !important; border-color: #6b7280 !important; box-shadow: none !important; filter: grayscale(1); }
        .token.ghost { opacity: 0.5; filter: grayscale(0.8); pointer-events: none; }

        .token.type-unit { width: 40px; height: 40px; border-radius: 4px; font-style: normal; }
        .token.type-x { width: 90px; height: 40px; border-radius: 4px; }

        .zero-badge { 
            position: absolute; font-size: 2rem; font-weight: 800; color: #374151; 
            pointer-events: none; z-index: 20; text-shadow: 0 0 10px rgba(255,255,255,1); 
            animation: popIn 0.3s; transform: translate(-50%, -50%);
        }
        @keyframes popIn { from { transform: translate(-50%, -50%) scale(0); opacity: 0; } to { transform: translate(-50%, -50%) scale(1); opacity: 1; } }

        /* STRUCTURE */
        #board-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; padding-bottom: 150px; cursor: ns-resize; } /* Cursor indicates vertical scroll */
        #board-container.panning { cursor: grabbing; }
        #board-world { position: absolute; top: 0; left: 0; transform-origin: 0 0; width: 0; height: 0; }
        
        #equation-divider {
            position: absolute; top: -5000px; bottom: -5000px; left: 0; width: 4px;
            background-color: #cbd5e1; border-left: 2px dashed #94a3b8; border-right: 2px dashed #94a3b8;
            transform: translateX(-2px); pointer-events: none; z-index: 0;
        }

        #bottom-bar {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 150px;
            background: white; border-top: 1px solid #cbd5e1;
            display: flex; z-index: 50; box-shadow: 0 -4px 10px rgba(0,0,0,0.05);
        }
        .side-panel { flex: 1; display: flex; align-items: center; justify-content: center; padding: 5px 10px; gap: 10px; position: relative; }
        .side-panel.left { border-right: none; background: #f8fafc; }
        .side-panel.right { background: #fff; }
        
        #menu-divider {
            position: absolute; left: 50%; top: 0; bottom: 0; width: 4px;
            background-color: #cbd5e1; border-left: 2px dashed #94a3b8; border-right: 2px dashed #94a3b8;
            transform: translateX(-2px); pointer-events: none; z-index: 51;
        }

        #center-actions {
            position: absolute; left: 50%; top: 10px; transform: translateX(-50%);
            z-index: 60; display: flex; flex-direction: column; align-items: center;
        }

        .tiles-zone { display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; padding: 5px; }
        .tools-zone { display: flex; flex-direction: column; gap: 4px; align-items: stretch; min-width: 120px; }
        .tools-row { display: flex; gap: 4px; justify-content: center; }

        .tile-btn { 
            position: relative; background: transparent; border: none; cursor: grab; 
            display: flex; align-items: center; justify-content: center; transition: transform 0.1s; 
        }
        .tile-btn:active { cursor: grabbing; transform: scale(0.95); }
        .tile-btn:hover { transform: translateY(-2px); }
        
        .preview-shape { 
            display: flex; align-items: center; justify-content: center; border-radius: 4px; 
            color: white; font-weight: bold; font-family: 'Times New Roman', serif; font-style: italic; 
            text-shadow: 0 1px 2px rgba(0,0,0,0.3); box-shadow: 0 3px 5px rgba(0,0,0,0.2); pointer-events: none; 
        }
        .ps-green { background: radial-gradient(circle at 30% 30%, #4ade80, #16a34a); border: 1px solid #14532d; } 
        .ps-red { background: radial-gradient(circle at 30% 30%, #f87171, #dc2626); border: 1px solid #7f1d1d; }

        .token.menu-ghost {
            position: fixed; z-index: 9999; pointer-events: none; opacity: 0.9;
            box-shadow: 0 10px 20px rgba(0,0,0,0.3); transform-origin: center;
        }
        
        .action-btn { font-size: 0.7rem; font-weight: bold; padding: 6px 10px; border-radius: 6px; border: 1px solid #cbd5e1; background: white; color: #475569; transition: all 0.1s; box-shadow: 0 1px 2px rgba(0,0,0,0.05); cursor: pointer; }
        .action-btn:hover { background: #f1f5f9; border-color: #94a3b8; } .action-btn:active { transform: translateY(1px); }
        
        .btn-op { width: 34px; height: 34px; border-radius: 6px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 1.2rem; box-shadow: 0 1px 2px rgba(0,0,0,0.05); cursor: pointer; }
        .btn-opp-style { background-color: #fff7ed; color: #c2410c; border: 1px solid #fb923c; font-size: 0.7rem; font-weight: bold; padding: 4px 8px; border-radius: 4px; transition: all 0.2s; }
        
        .toggle-mode { background-color: #fef08a; color: #854d0e; border: 1px solid #eab308; }
        .toggle-mode.solve { background-color: #dcfce7; color: #166534; border-color: #22c55e; }
        .equation-blur { filter: blur(5px); opacity: 0.5; }
        
        #custom-cursor { position: fixed; pointer-events: none; z-index: 9999; display: none; }
        .hide-cursor, .hide-cursor * { cursor: none !important; }

        .side-label {
            position: absolute; top: -12px; left: 50%; transform: translateX(-50%);
            background: #e2e8f0; color: #64748b; font-size: 0.6rem; padding: 2px 8px;
            border-radius: 10px; font-weight: bold; z-index: 5;
        }
        
        /* CANEVAS DESSIN */
        #drawing-canvas { position: absolute; top: 0; left: 0; pointer-events: none; z-index: 5; }
        .drawing-active #drawing-canvas { pointer-events: auto; z-index: 100; }
    </style>
</head>
<body class="h-screen w-screen flex flex-col overflow-hidden">

    <div id="custom-cursor" class="fixed pointer-events-none z-50 hidden">
        <svg class="drop-shadow-lg" width="34" height="34" viewBox="0 0 34 34" fill="none">
            <path d="M27 7 L13 21" stroke="#1d4ed8" stroke-width="6" stroke-linecap="round"/>
            <path d="M13 21 L8 32" stroke="#0f172a" stroke-width="4" stroke-linecap="round"/>
            <path d="M8 32 L12 28 L16 32 Z" fill="#111827"/>
            <circle cx="8" cy="32" r="1" fill="white"/>
        </svg>
    </div>

    <!-- HEADER -->
    <header class="bg-white p-2 shadow-md z-30 flex flex-wrap items-center gap-4 shrink-0 justify-between">
        <div class="flex items-center gap-2">
            <button onclick="app.resetBoard()" class="bg-rose-100 text-rose-600 hover:bg-rose-200 p-2 rounded-lg font-bold border border-rose-200 shadow-sm" title="Tout effacer">
                <svg class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>
            </button>
            <button onclick="app.undo()" class="bg-slate-100 text-slate-600 hover:bg-slate-200 p-2 rounded-lg font-bold border border-slate-200 shadow-sm" title="Annuler">
                <svg class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6" /></svg>
            </button>
            <div class="h-8 w-px bg-slate-200 mx-1"></div>
            <button id="btn-mode" onclick="app.toggleMode()" class="toggle-mode px-4 py-2 rounded-lg font-bold text-sm transition flex items-center gap-2 shadow-sm">
                <span id="mode-text">Phase 1 : Poser l'équation</span>
            </button>
        </div>

        <div class="flex-1 flex flex-col items-center justify-center px-4">
            <div class="flex items-center gap-2 bg-slate-50 px-6 py-2 rounded-full border border-slate-200 shadow-inner">
                <div id="equation-display" class="text-3xl font-bold text-slate-700 tracking-tight font-mono transition-all duration-300">0 = 0</div>
                <button onclick="app.toggleEquationVisibility()" class="ml-2 text-slate-400 hover:text-slate-600 focus:outline-none">
                    <svg id="eye-icon" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
                    </svg>
                </button>
            </div>
        </div>

        <div class="flex items-center gap-1 bg-gray-100 p-1 rounded-lg">
            <button onclick="app.setTool('hand')" class="p-2 rounded bg-white shadow text-gray-700"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 11.5V14m0-2.5v-6a1.5 1.5 0 113 0m-3 6a1.5 1.5 0 00-3 0v2a7.5 7.5 0 0015 0v-5a1.5 1.5 0 00-3 0m-6-3V11m0-5.5v-1a1.5 1.5 0 013 0v1m0 0V11m0-5.5a1.5 1.5 0 013 0v3m0 0V11"/></svg></button>
            <button onclick="app.setTool('pen')" class="p-2 rounded text-gray-500 hover:bg-gray-200"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"/></svg></button>
            <button onclick="app.clearDrawing()" class="p-2 rounded text-red-400 hover:bg-red-50"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/></svg></button>
        </div>
    </header>

    <main id="board" class="flex-1 relative bg-white overflow-hidden">
        <div class="absolute inset-0 opacity-10 pointer-events-none" style="background-image: linear-gradient(#94a3b8 1px, transparent 1px), linear-gradient(90deg, #94a3b8 1px, transparent 1px); background-size: 40px 40px;"></div>
        <div id="board-container">
            <div id="board-world">
                <div id="equation-divider"></div>
                <canvas id="drawing-canvas"></canvas>
            </div>
        </div>
    </main>

    <div id="bottom-bar">
        <div id="menu-divider"></div>
        <div id="center-actions">
            <button onclick="app.performDivision()" class="action-btn bg-purple-50 text-purple-700 border-purple-200 hover:bg-purple-100 shadow-md">Diviser</button>
        </div>

        <!-- GAUCHE -->
        <div class="side-panel left">
            <div class="side-label">Membre de Gauche</div>
            <div class="tiles-zone">
                <button onmousedown="app.handleMenuTouchStart(event, 'x', 1, 'left')" class="tile-btn w-16 h-16"><div class="preview-shape ps-green w-14 h-8 text-lg">x</div></button>
                <button onmousedown="app.handleMenuTouchStart(event, 'unit', 1, 'left')" class="tile-btn w-16 h-16"><div class="preview-shape ps-green w-8 h-8 text-md">1</div></button>
                <button onmousedown="app.handleMenuTouchStart(event, 'x', -1, 'left')" class="tile-btn w-16 h-16"><div class="preview-shape ps-red w-14 h-8 text-lg">-x</div></button>
                <button onmousedown="app.handleMenuTouchStart(event, 'unit', -1, 'left')" class="tile-btn w-16 h-16"><div class="preview-shape ps-red w-8 h-8 text-md">-1</div></button>
            </div>
            <div class="tools-zone">
                <div class="tools-row">
                    <button onclick="app.sideLeft.addOperator('separate')" class="btn-op bg-blue-100 text-blue-700 hover:bg-blue-200" title="Ajouter terme">+</button>
                    <button onclick="app.sideLeft.addOperator('subtract')" class="btn-op bg-orange-100 text-orange-700 hover:bg-orange-200" title="Soustraire terme">-</button>
                    <button onclick="app.sideLeft.addOperator('close')" id="btn-close-l" class="hidden btn-op bg-orange-500 text-white hover:bg-orange-600">)</button>
                </div>
                <div class="tools-row">
                    <button onclick="app.sideLeft.startMult(2)" class="text-xs font-bold text-indigo-700 px-2 py-1 bg-indigo-50 rounded hover:bg-indigo-100">2(...)</button>
                    <button onclick="app.sideLeft.startMult(3)" class="text-xs font-bold text-indigo-700 px-2 py-1 bg-indigo-50 rounded hover:bg-indigo-100">3(...)</button>
                </div>
                <div class="tools-row flex-wrap justify-center">
                    <button onclick="app.sideLeft.order()" class="action-btn">Ranger</button>
                    <button onclick="app.sideLeft.reduce()" class="action-btn bg-yellow-50 border-yellow-200 text-yellow-700 hover:bg-yellow-100">Réduire</button>
                    <button onclick="app.sideLeft.simplify()" class="action-btn">Simplifier</button>
                </div>
                <div class="tools-row flex-wrap justify-center">
                    <button onclick="app.sideLeft.applyOpposite()" id="btn-opp-l" class="hidden btn-opp-style">Opposé</button>
                    <button onclick="app.sideLeft.distribute()" id="btn-dist-l" class="hidden action-btn bg-blue-500 text-white hover:bg-blue-600">Développer</button>
                </div>
            </div>
        </div>

        <!-- DROITE -->
        <div class="side-panel right">
            <div class="side-label">Membre de Droite</div>
            <div class="tiles-zone">
                <button onmousedown="app.handleMenuTouchStart(event, 'x', 1, 'right')" class="tile-btn w-16 h-16"><div class="preview-shape ps-green w-14 h-8 text-lg">x</div></button>
                <button onmousedown="app.handleMenuTouchStart(event, 'unit', 1, 'right')" class="tile-btn w-16 h-16"><div class="preview-shape ps-green w-8 h-8 text-md">1</div></button>
                <button onmousedown="app.handleMenuTouchStart(event, 'x', -1, 'right')" class="tile-btn w-16 h-16"><div class="preview-shape ps-red w-14 h-8 text-lg">-x</div></button>
                <button onmousedown="app.handleMenuTouchStart(event, 'unit', -1, 'right')" class="tile-btn w-16 h-16"><div class="preview-shape ps-red w-8 h-8 text-md">-1</div></button>
            </div>
            <div class="tools-zone">
                <div class="tools-row">
                    <button onclick="app.sideRight.addOperator('separate')" class="btn-op bg-blue-100 text-blue-700 hover:bg-blue-200">+</button>
                    <button onclick="app.sideRight.addOperator('subtract')" class="btn-op bg-orange-100 text-orange-700 hover:bg-orange-200">-</button>
                    <button onclick="app.sideRight.addOperator('close')" id="btn-close-r" class="hidden btn-op bg-orange-500 text-white hover:bg-orange-600">)</button>
                </div>
                <div class="tools-row">
                    <button onclick="app.sideRight.startMult(2)" class="text-xs font-bold text-indigo-700 px-2 py-1 bg-indigo-50 rounded hover:bg-indigo-100">2(...)</button>
                    <button onclick="app.sideRight.startMult(3)" class="text-xs font-bold text-indigo-700 px-2 py-1 bg-indigo-50 rounded hover:bg-indigo-100">3(...)</button>
                </div>
                <div class="tools-row flex-wrap justify-center">
                    <button onclick="app.sideRight.order()" class="action-btn">Ranger</button>
                    <button onclick="app.sideRight.reduce()" class="action-btn bg-yellow-50 border-yellow-200 text-yellow-700 hover:bg-yellow-100">Réduire</button>
                    <button onclick="app.sideRight.simplify()" class="action-btn">Simplifier</button>
                </div>
                <div class="tools-row flex-wrap justify-center">
                    <button onclick="app.sideRight.applyOpposite()" id="btn-opp-r" class="hidden btn-opp-style">Opposé</button>
                    <button onclick="app.sideRight.distribute()" id="btn-dist-r" class="hidden action-btn bg-blue-500 text-white hover:bg-blue-600">Développer</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const SNAP = 60;
        const PACK_GAP = 25;
        const SIZES = { 'unit': { w: 40, h: 40 }, 'x': { w: 90, h: 40 } };
        const COLORS = { pos: 'green', neg: 'red', orange: 'orange' };
        
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
            osc.connect(gain); gain.connect(audioCtx.destination); const now = audioCtx.currentTime;
            if (type === 'pop') { osc.type = 'sine'; osc.frequency.setValueAtTime(300, now); osc.frequency.exponentialRampToValueAtTime(500, now+0.1); gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now+0.1); osc.start(now); osc.stop(now+0.1); }
            else if (type === 'snap') { osc.type = 'square'; osc.frequency.setValueAtTime(100, now); gain.gain.setValueAtTime(0.05, now); gain.gain.exponentialRampToValueAtTime(0.01, now+0.05); osc.start(now); osc.stop(now+0.05); }
            else if (type === 'whoosh') { osc.type = 'triangle'; osc.frequency.setValueAtTime(300, now); osc.frequency.exponentialRampToValueAtTime(50, now+0.3); gain.gain.setValueAtTime(0.05, now); gain.gain.linearRampToValueAtTime(0, now+0.3); osc.start(now); osc.stop(now+0.3); }
            else if (type === 'flip') { osc.type = 'triangle'; osc.frequency.setValueAtTime(200, now); osc.frequency.linearRampToValueAtTime(400, now+0.2); gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now+0.2); osc.start(now); osc.stop(now+0.2); }
        }

        // --- ALGEBRA SIDE ENGINE ---
        class AlgebraSide {
            constructor(id, parentApp) {
                this.id = id;
                this.app = parentApp;
                this.tokens = [];
                this.steps = [{ id: 0, operator: '', type: 'simple', tokenIds: [], factor: 1, oppositeApplied: false, distributed: false, isClosed: false }];
                this.currStepIdx = 0;
                this.nextPackId = 1; this.packMeta = {}; this.lastPack = null;
                this.isSubInput = false; this.isMultInput = false;
                this.lastPos = { x: 0, y: 0, maxY: 0 };
                this.pendingGap = 0;
                this.lastSeqPackId = null;
                this.displayMode = 'normal'; // 'normal', 'ordered', 'reduced'
            }

            addTile(type, sign, isGhost=false, manualX=null, manualY=null, mirrorTrigger=false) {
                if(!isGhost && !mirrorTrigger) {
                    this.app.saveState();
                    this.displayMode = 'normal';
                }

                if(!isGhost) playSound('pop');
                
                let step = this.steps[this.currStepIdx];
                if (!isGhost && step.isClosed && !this.isSubInput && !this.isMultInput) {
                    this.steps.push({ id: this.steps.length, operator: '+', type: 'simple', tokenIds: [], factor: 1, oppositeApplied: false, distributed: false, isClosed: false });
                    this.currStepIdx++;
                    step = this.steps[this.currStepIdx];
                    this.lastPack = null;
                }

                let tileSign = sign;
                if (this.isSubInput && step.type === 'subtraction') tileSign = -sign;
                if (this.isMultInput && step.operator === '-') tileSign = -sign;

                let pid;
                if (manualX===null && !isGhost) {
                    if (this.lastPack && this.lastPack.type === type && this.lastPack.sign === tileSign && this.lastPack.step === this.currStepIdx) {
                        pid = this.lastPack.pid;
                    } else {
                        pid = this.nextPackId++;
                        this.lastPack = { pid, type, sign: tileSign, step: this.currStepIdx };
                    }
                } else {
                    pid = this.nextPackId++;
                }

                const el = document.createElement('div');
                el.className = `token ${type==='unit'?'type-unit':'type-x'} ${tileSign===1?'green':'red'}`;
                if (isGhost) el.classList.add('ghost');
                if (this.isSubInput) el.classList.add('in-bracket');
                if (this.isMultInput && !step.distributed) el.classList.add('pending-mult');
                
                let lbl = type==='unit' ? (tileSign===1?'1':'-1') : (tileSign===1?'x':'-x');
                el.innerHTML = `<span style="pointer-events:none;">${lbl}</span>`;
                
                const tId = this.app.nextId++;
                el.id = `t-${tId}`;

                let x, y;
                if (manualX !== null) { 
                    x=manualX; y=manualY;
                    
                    // MIRROR LOGIC FOR SOLVE MODE
                    if (!isGhost && !mirrorTrigger && this.app.mode === 'solve') {
                        const otherSide = this.id === 'left' ? this.app.sideRight : this.app.sideLeft;
                        const w = SIZES[type].w;
                        const mirrorX = -x - w; 
                        otherSide.addTile(type, sign, false, mirrorX, y, true);
                    }
                }
                else {
                    // AUTO PLACEMENT (CLICK) - Mirror Logic
                    const pos = this.findFreeSpot(type);
                    x = pos.x; y = pos.y;
                    
                    if (!isGhost && !mirrorTrigger && this.app.mode === 'solve') {
                        const otherSide = this.id === 'left' ? this.app.sideRight : this.app.sideLeft;
                        const w = SIZES[type].w;
                        const mirrorX = -x - w; 
                        otherSide.addTile(type, sign, false, mirrorX, y, true);
                    }
                }

                el.style.left = x+'px'; el.style.top = y+'px';
                el.addEventListener('mousedown', e => this.app.handleDragStart(e, tId));
                el.addEventListener('touchstart', e => this.app.handleDragStart(e, tId), {passive:false});
                this.app.world.appendChild(el);

                const token = { id: tId, side: this.id, type, sign: tileSign, displaySign: sign, x, y, element: el, pairId: null, packId: pid, ghostIds: [] };
                this.tokens.push(token);
                this.app.allTokens.push(token);

                if (!isGhost) {
                    step.tokenIds.push(tId);
                    if (manualX === null) this.lastSeqPackId = pid;
                    
                    if (this.isMultInput && step.factor > 1) {
                        const stride = 90+20;
                        for(let i=1; i<step.factor; i++) {
                            const g = this.addTile(type, sign, true, x, y + i*stride);
                            token.ghostIds.push(g.id);
                        }
                    }
                }
                this.app.updateEquation();
                return token;
            }

            findFreeSpot(type) {
                const w = SIZES[type].w; 
                const h = SIZES[type].h;
                const gap = 10;
                const screenH = this.app.container.clientHeight / this.app.scale;
                const startY = -screenH/2 + 60; // Top margin
                
                const maxCols = 8;
                const maxRows = 20;

                // Loop through rows first, then columns
                for(let row = 0; row < maxRows; row++) {
                    for(let col = 0; col < maxCols; col++) {
                        let tx, ty;
                        
                        if (this.id === 'left') {
                            // Fill Right-to-Left starting from center (-25)
                            const startX = -25;
                            // Shift left by width of token + column offset
                            tx = startX - w - (col * (w + gap));
                        } else {
                            // Fill Left-to-Right starting from center (+25)
                            const startX = 25;
                            tx = startX + (col * (w + gap));
                        }
                        
                        ty = startY + (row * (h + gap));
                        
                        // Strict AABB Collision Check against ALL existing tokens
                        let collision = false;
                        for(let t of this.tokens) {
                            // Existing token dimensions
                            const tw = SIZES[t.type].w;
                            const th = SIZES[t.type].h;
                            
                            // Check overlap with buffer
                            if (tx < t.x + tw + 5 && 
                                tx + w + 5 > t.x && 
                                ty < t.y + th + 5 && 
                                ty + h + 5 > t.y) {
                                collision = true;
                                break;
                            }
                        }
                        
                        if (!collision) return {x: tx, y: ty};
                    }
                }
                return {x: 0, y: 0}; // Fallback
            }

            // ... (methods) ...
            getPos(w, h, gap) { return {x:0,y:0}; }

            addOperator(op) {
                this.app.saveState();
                this.displayMode = 'normal';
                if (op === 'separate') { playSound('pop'); this.lastPack=null; this.pendingGap = PACK_GAP; }
                else if (op === 'subtract') {
                    if (this.isSubInput) return;
                    this.pendingGap = PACK_GAP;
                    this.steps.push({ id: this.steps.length, operator: '-', type: 'subtraction', tokenIds: [], factor:1, distributed:false, isClosed:false });
                    this.currStepIdx++; this.isSubInput = true;
                    document.getElementById(`btn-close-${this.id === 'left' ? 'l' : 'r'}`).classList.remove('hidden');
                }
                else if (op === 'close') {
                    const s = this.steps[this.currStepIdx];
                    if (this.isSubInput) { this.isSubInput=false; s.isClosed=true; }
                    else if (this.isMultInput) { this.isMultInput=false; s.isClosed=true; }
                    document.getElementById(`btn-close-${this.id === 'left' ? 'l' : 'r'}`).classList.add('hidden');
                    this.updateUI();
                }
                this.app.updateEquation();
            }

            startMult(f) {
                if (this.isSubInput || this.isMultInput) return;
                this.app.saveState();
                this.displayMode = 'normal';
                this.steps.push({ id: this.steps.length, operator: '+', type: 'multiplication', tokenIds: [], factor: f, distributed:false, isClosed:false });
                this.currStepIdx++; this.isMultInput = true;
                document.getElementById(`btn-close-${this.id === 'left' ? 'l' : 'r'}`).classList.remove('hidden');
                this.app.updateEquation();
            }

            applyOpposite() {
                const p = this.steps.filter(s=>s.type==='subtraction' && !s.oppositeApplied);
                if(!p.length) return; 
                this.app.saveState();
                this.displayMode = 'normal';
                playSound('flip');
                p.forEach(s => {
                    s.tokenIds.forEach(id => { 
                        const t = this.tokens.find(x=>x.id===id); 
                        if(t){ 
                            t.displaySign = t.sign;
                            t.element.classList.remove('in-bracket'); 
                        } 
                    });
                    s.oppositeApplied = true;
                });
                this.updateUI();
                this.app.updateEquation();
            }

            distribute() {
                const s = this.steps.find(x => x.type === 'multiplication' && !x.distributed && x.isClosed);
                if (!s) return;
                this.app.saveState();
                this.displayMode = 'normal';
                s.tokenIds.forEach(mid => {
                    const m = this.tokens.find(t => t.id === mid);
                    if (m && m.ghostIds) {
                        m.ghostIds.forEach(gid => {
                            const g = this.tokens.find(t => t.id === gid);
                            if (g) {
                                g.element.classList.remove('ghost', 'pending-mult');
                                s.tokenIds.push(gid);
                            }
                        });
                        m.element.classList.remove('pending-mult');
                    }
                });
                s.distributed = true;
                this.reflow();
                this.updateUI();
                this.app.updateEquation();
            }

            reflow() { }

            order() {
                this.displayMode = 'ordered'; 
                this.organize(false);
                this.app.updateEquation(); 
            }
            
            reduce() {
                this.displayMode = 'reduced'; 
                this.organize(true);
                this.app.updateEquation(); 
            }

            organize(reduced) { 
                this.app.saveState();
                playSound('whoosh');
                
                const screenH = this.app.container.clientHeight / this.app.scale;
                let y = -screenH/2 + 60;
                
                const subset = this.tokens.filter(t => !t.pairId && !t.element.classList.contains('ghost'));
                const rows = [{t:'x',s:1},{t:'x',s:-1},{t:'unit',s:1},{t:'unit',s:-1}];

                // REVISED LAYOUT LOGIC: Center -> Outwards, Lines (Rows)
                rows.forEach(r => {
                    const eligible = subset.filter(t => t.type===r.t && t.sign===r.s);
                    if (!eligible.length) return;

                    let packs = [];
                    if (reduced) {
                        packs = [eligible]; 
                    } else {
                        const map = new Map();
                        eligible.forEach(t => {
                            const pid = (typeof t.packId !== 'undefined') ? t.packId : -1;
                            if(!map.has(pid)) map.set(pid, []);
                            map.get(pid).push(t);
                        });
                        const sortedPids = Array.from(map.keys()).sort((a,b) => a - b);
                        packs = sortedPids.map(pid => map.get(pid));
                    }

                    // --- PLACEMENT LOGIC ---
                    
                    // Flatten tokens for line filling
                    let tokensInOrder = [];
                    let gap = reduced ? 0 : 15;
                    packs.forEach((pack, pIdx) => {
                        pack.forEach(t => tokensInOrder.push({t, w: SIZES[t.type].w, h: SIZES[t.type].h}));
                        if (pIdx < packs.length - 1) tokensInOrder.push({isGap: true, w: gap});
                    });

                    // Break into lines based on width limit
                    let lines = [];
                    let currentLine = [];
                    let currentW = 0;
                    let lineMaxH = 0;
                    const maxW = 450; // Max line width before wrap

                    tokensInOrder.forEach(item => {
                        if (item.isGap) {
                            currentW += item.w;
                            currentLine.push(item);
                        } else {
                            if (currentW + item.w > maxW) {
                                lines.push({items: currentLine, w: currentW, h: lineMaxH});
                                currentLine = []; currentW = 0; lineMaxH = 0;
                            }
                            currentLine.push(item);
                            currentW += item.w + 2;
                            lineMaxH = Math.max(lineMaxH, item.h);
                        }
                    });
                    if (currentLine.length) lines.push({items: currentLine, w: currentW, h: lineMaxH});

                    // Render Lines
                    lines.forEach(line => {
                        let startX;
                        // RIGHT SIDE: Start from Center (25) -> Right
                        if (this.id === 'right') {
                            startX = 25;
                            let cx = startX;
                            line.items.forEach(item => {
                                if (item.isGap) cx += item.w;
                                else {
                                    this.moveTile(item.t, cx, y);
                                    cx += item.w + 2;
                                }
                            });
                        } 
                        // LEFT SIDE: Start from Center (-25) -> Left
                        else {
                            // To fill R -> L starting from center, we simply decrement X
                            startX = -25;
                            let cx = startX;
                            line.items.forEach(item => {
                                if (item.isGap) cx -= item.w;
                                else {
                                    // item position is its top-left.
                                    // If we are at -25 and want to place an item of width 40 to its left:
                                    // it occupies [-65, -25]. The pos is -65.
                                    cx -= (item.w + 2);
                                    this.moveTile(item.t, cx, y); // Position is top-left
                                }
                            });
                        }
                        y += line.h + 15;
                    });
                });
            }

            moveTile(t, x, y) {
                t.element.classList.add('animating');
                t.x = x; t.y = y;
                t.element.style.left = x + 'px'; t.element.style.top = y + 'px';
                setTimeout(() => t.element.classList.remove('animating'), 500);
            }

            simplify() {
                this.app.saveState();
                playSound('whoosh');
                
                // 1. Mark existing zeros for removal
                const existingZeros = this.tokens.filter(t => t.pairId !== null);
                existingZeros.forEach(t => t.element.classList.add('vanish'));
                
                // 2. Find new zeros
                const available = this.tokens.filter(t => !t.pairId && !t.element.classList.contains('in-bracket') && !t.element.classList.contains('ghost') && !existingZeros.includes(t));
                
                const pairs = [];
                ['x','unit'].forEach(type => {
                    const pos = available.filter(t => t.type === type && t.sign === 1);
                    const neg = available.filter(t => t.type === type && t.sign === -1);
                    while(pos.length && neg.length) pairs.push([pos.pop(), neg.pop()]);
                });
                
                // 3. Remove existing zeros after short delay
                if (existingZeros.length > 0) {
                    setTimeout(() => {
                        this.app.removeTokens(existingZeros.map(t => t.id));
                        // Remove badges
                        document.querySelectorAll('.zero-badge').forEach(b => b.remove());
                    }, 500);
                }

                // 4. Animate new pairs
                pairs.forEach((p, i) => {
                    setTimeout(() => {
                        const t1 = p[0]; const t2 = p[1];
                        this.app.createZeroPair(t1, t2, true);
                    }, i * 300);
                });
            }

            divide() { this.app.performDivision(); }
            
            layoutForDivision(n, keepIndex) {
                const active = this.tokens.filter(t => !t.pairId && !t.element.classList.contains('ghost'));
                const screenH = this.app.container.clientHeight / this.app.scale;
                const startY = -screenH/2 + 80;
                const gapY = Math.min(120, (screenH - 160) / n);
                
                const xs = active.filter(t => t.type === 'x');
                const us = active.filter(t => t.type === 'unit');
                
                const isLeft = (this.id === 'left');
                const startX = isLeft ? -40 : 40; 
                const dir = isLeft ? -1 : 1;
                
                xs.forEach((t, i) => {
                    const row = i % n;
                    const col = Math.floor(i / n);
                    const tx = startX + (col * 100 * dir); 
                    this.moveTile(t, tx, startY + row * gapY);
                    if (row !== keepIndex) t.toDelete = true;
                });
                
                const uStartOffset = (xs.length > 0 ? (Math.ceil(xs.length/n)*100 + 20) : 0) * dir;
                us.forEach((t, i) => {
                    const row = i % n;
                    const col = Math.floor(i / n);
                    const tx = startX + uStartOffset + (col * 45 * dir);
                    this.moveTile(t, tx, startY + row * gapY);
                    if (row !== keepIndex) t.toDelete = true;
                });
            }

            updateUI() {
                const btnDist = document.getElementById(`btn-dist-${this.id === 'left' ? 'l' : 'r'}`);
                const hasPendingDist = this.steps.some(s => s.type === 'multiplication' && !s.distributed && s.isClosed);
                if (hasPendingDist) btnDist.classList.remove('hidden'); else btnDist.classList.add('hidden');
                const btnOpp = document.getElementById(`btn-opp-${this.id === 'left' ? 'l' : 'r'}`);
                const hasPendingOpp = this.steps.some(s => s.type === 'subtraction' && !s.oppositeApplied);
                if (hasPendingOpp) btnOpp.classList.remove('hidden'); else btnOpp.classList.add('hidden');
            }
        }

        // --- MAIN APP ---
        class AlgebraEqApp {
            constructor() {
                this.nextId = 1;
                this.allTokens = [];
                this.history = []; 
                this.mode = 'setup';
                this.equationVisible = true;
                this.container = document.getElementById('board-container');
                this.world = document.getElementById('board-world');
                this.eqDisplay = document.getElementById('equation-display');
                this.scale = 1; 
                this.pan = {x:0, y:0};
                this.menuDrag = null;
                this.sideLeft = new AlgebraSide('left', this);
                this.sideRight = new AlgebraSide('right', this);
                this.initListeners();
                this.centerView();
                this.updateEquation();
            }
            
            toggleMode() {
                const btn = document.getElementById('btn-mode');
                const txt = document.getElementById('mode-text');
                if (this.mode === 'setup') {
                    this.mode = 'solve';
                    btn.classList.add('solve'); txt.innerText = "Phase 2 : Résoudre (Balance)";
                } else {
                    this.mode = 'setup';
                    btn.classList.remove('solve'); txt.innerText = "Phase 1 : Poser l'équation";
                }
            }

            toggleEquationVisibility() {
                this.equationVisible = !this.equationVisible;
                const eq = document.getElementById('equation-display');
                if(this.equationVisible) eq.classList.remove('equation-blur'); else eq.classList.add('equation-blur');
            }
            
            performDivision() {
                const leftX = this.sideLeft.tokens.filter(t => t.type === 'x' && !t.pairId).length;
                const rightX = this.sideRight.tokens.filter(t => t.type === 'x' && !t.pairId).length;
                const divisor = Math.max(leftX, rightX);
                if (divisor <= 1) return;
                
                this.saveState();
                playSound('whoosh');
                this.sideLeft.layoutForDivision(divisor, 0);
                this.sideRight.layoutForDivision(divisor, 0);
                setTimeout(() => { this.applyDivisionDeletion(); }, 1000);
            }
            
            applyDivisionDeletion() {
                const toRemove = [];
                [this.sideLeft, this.sideRight].forEach(side => {
                    side.tokens.forEach(t => {
                        if (t.toDelete) {
                            t.element.classList.add('vanish');
                            toRemove.push(t);
                        }
                    });
                });
                if (toRemove.length > 0) playSound('pop');
                setTimeout(() => {
                    this.removeTokens(toRemove.map(t=>t.id));
                }, 500);
            }

            removeTokens(ids) {
                ids.forEach(id => {
                    const t = this.allTokens.find(x => x.id === id);
                    if(t) t.element.remove();
                });
                this.allTokens = this.allTokens.filter(x => !ids.includes(x.id));
                this.sideLeft.tokens = this.sideLeft.tokens.filter(x => !ids.includes(x.id));
                this.sideRight.tokens = this.sideRight.tokens.filter(x => !ids.includes(x.id));
                this.sideLeft.steps.forEach(s => s.tokenIds = s.tokenIds.filter(id => !ids.includes(id)));
                this.sideRight.steps.forEach(s => s.tokenIds = s.tokenIds.filter(id => !ids.includes(id)));
                this.updateEquation();
            }

            saveState() {
                // IMPORTANT: Clone deeply to avoid reference issues
                const state = {
                    nextId: this.nextId,
                    // Serialize token data only
                    tokens: this.allTokens.map(t => {
                        const { element, ...data } = t; 
                        return data; 
                    }),
                    stepsL: JSON.parse(JSON.stringify(this.sideLeft.steps)),
                    stepsR: JSON.parse(JSON.stringify(this.sideRight.steps)),
                    currStepL: this.sideLeft.currStepIdx,
                    currStepR: this.sideRight.currStepIdx,
                    isSubL: this.sideLeft.isSubInput, isMultL: this.sideLeft.isMultInput,
                    isSubR: this.sideRight.isSubInput, isMultR: this.sideRight.isMultInput,
                    displayModeL: this.sideLeft.displayMode,
                    displayModeR: this.sideRight.displayMode
                };
                this.history.push(JSON.stringify(state));
                if(this.history.length > 50) this.history.shift();
            }

            undo() {
                if(this.history.length === 0) return;
                const json = this.history.pop();
                const state = JSON.parse(json);
                this.resetBoard(false);
                
                this.nextId = state.nextId;
                this.sideLeft.steps = state.stepsL; this.sideRight.steps = state.stepsR;
                this.sideLeft.currStepIdx = state.currStepL; this.sideRight.currStepIdx = state.currStepR;
                this.sideLeft.isSubInput = state.isSubL; this.sideLeft.isMultInput = state.isMultL;
                this.sideRight.isSubInput = state.isSubR; this.sideRight.isMultInput = state.isMultR;
                this.sideLeft.displayMode = state.displayModeL || 'normal';
                this.sideRight.displayMode = state.displayModeR || 'normal';

                state.tokens.forEach(data => {
                    const el = document.createElement('div');
                    const tileSign = data.sign;
                    const type = data.type;
                    el.className = `token ${type==='unit'?'type-unit':'type-x'} ${tileSign===1?'green':'red'}`;
                    let lbl = type==='unit' ? (tileSign===1?'1':'-1') : (tileSign===1?'x':'-x');
                    el.innerHTML = `<span style="pointer-events:none;">${lbl}</span>`;
                    el.id = `t-${data.id}`;
                    el.style.left = data.x+'px'; el.style.top = data.y+'px';
                    el.addEventListener('mousedown', e => this.handleDragStart(e, data.id));
                    el.addEventListener('touchstart', e => this.handleDragStart(e, data.id), {passive:false});
                    this.world.appendChild(el);
                    
                    const token = { ...data, element: el };
                    this.allTokens.push(token);
                    if(token.side === 'left') this.sideLeft.tokens.push(token);
                    else this.sideRight.tokens.push(token);
                });
                
                this.allTokens.forEach(t => {
                    if(t.pairId) {
                        t.element.classList.add('is-zero');
                        const p = this.allTokens.find(x => x.id === t.pairId);
                        if(p && !document.getElementById(`badge-${t.id}-${p.id}`) && !document.getElementById(`badge-${p.id}-${t.id}`)) {
                             const b = document.createElement('div'); b.className='zero-badge'; b.textContent='0'; 
                             b.id=`badge-${t.id}-${p.id}`;
                             const mx=(t.x+p.x)/2; const my=(t.y+p.y)/2;
                             const w = SIZES[t.type].w; const h = SIZES[t.type].h;
                             b.style.left = (mx + w/2) + 'px'; b.style.top = (my + h/2) + 'px';
                             this.world.appendChild(b);
                        }
                    }
                });
                this.sideLeft.updateUI(); this.sideRight.updateUI(); this.updateEquation();
            }

            initListeners() {
                this.container.addEventListener('wheel', e => { e.preventDefault(); this.scale = Math.min(Math.max(0.5, this.scale - e.deltaY * 0.001), 2.5); this.updateTransform(); }, {passive:false});
                
                // RESTORE PANNING (Vertical Only)
                this.container.addEventListener('mousedown', e => {
                    if (e.target.closest('.token') || e.target.closest('button')) return;
                    this.isPanning = true; 
                    // We only care about Y start relative to current pan.y
                    this.panStart = { y: e.clientY - this.pan.y };
                    this.container.classList.add('panning');
                });

                window.addEventListener('mousemove', e => {
                    if (this.isPanning) {
                        // Update ONLY Y
                        this.pan.y = e.clientY - this.panStart.y; 
                        this.updateTransform(); 
                    }
                    else if (this.menuDrag) this.handleMenuDragMove(e);
                });
                
                window.addEventListener('mouseup', e => {
                    this.isPanning = false; 
                    this.container.classList.remove('panning');
                    if(this.menuDrag) this.handleMenuDragEnd(e);
                });
                
                this.container.addEventListener('dragover', e => e.preventDefault());
                this.container.addEventListener('drop', e => e.preventDefault());
                window.addEventListener('resize', () => { this.centerView(); });
                document.addEventListener('touchmove', e => { if (this.menuDrag) { e.preventDefault(); this.handleMenuDragMove(e); } }, {passive:false});
                document.addEventListener('touchend', e => { if (this.menuDrag) this.handleMenuDragEnd(e); });
            }

            centerView() {
                const cx = this.container.clientWidth / 2;
                const cy = this.container.clientHeight / 2;
                this.pan.x = cx; 
                this.pan.y = cy - 50;
                this.updateTransform();
            }
            updateTransform() { this.world.style.transform = `translate(${this.pan.x}px, ${this.pan.y}px) scale(${this.scale})`; }
            
            // --- MENU DRAG ---
            handleMenuTouchStart(e, type, sign, side) {
                e.preventDefault();
                const touch = e.touches ? e.touches[0] : e;
                const cx = touch.clientX; const cy = touch.clientY;
                this.menuDrag = { isDragging: false, type, sign, side, startPos: { x: cx, y: cy }, el: null, offset: null };
                const move = (ev) => this.handleMenuDragMove(ev);
                const end = (ev) => {
                    document.removeEventListener('mousemove', move); document.removeEventListener('touchmove', move);
                    document.removeEventListener('mouseup', end); document.removeEventListener('touchend', end);
                    this.handleMenuDragEnd(ev);
                };
                document.addEventListener('mousemove', move); document.addEventListener('touchmove', move, { passive: false });
                document.addEventListener('mouseup', end); document.addEventListener('touchend', end);
            }
            
            handleMenuDragMove(ev) {
                if (!this.menuDrag) return;
                ev.preventDefault();
                const touch = ev.touches ? ev.touches[0] : ev;
                const cx = touch.clientX; const cy = touch.clientY;
                if (!this.menuDrag.isDragging) {
                    const dist = Math.hypot(cx - this.menuDrag.startPos.x, cy - this.menuDrag.startPos.y);
                    if (dist > 5) { this.menuDrag.isDragging = true; this.createMenuGhost(cx, cy); }
                }
                if (this.menuDrag.isDragging && this.menuDrag.el) {
                    this.menuDrag.el.style.left = (cx - this.menuDrag.offset.x) + 'px';
                    this.menuDrag.el.style.top = (cy - this.menuDrag.offset.y) + 'px';
                    const menuBoundary = window.innerHeight - 150;
                    if (cy > menuBoundary) { const s = this.getPreviewScale(this.menuDrag.type); this.menuDrag.el.style.transform = `scale(${s})`; } 
                    else { this.menuDrag.el.style.transform = `scale(${this.scale})`; }
                }
            }
            
            createMenuGhost(cx, cy) {
                const type = this.menuDrag.type; const sign = this.menuDrag.sign;
                const el = document.createElement('div');
                const colorClass = sign === 1 ? 'green' : 'red';
                el.className = `token ${colorClass} type-${type==='unit'?'unit':'x'} menu-ghost scaling-transition`; 
                let label = type==='unit' ? (sign===1?'1':'-1') : (sign===1?'x':'-x');
                el.innerHTML = `<span style="pointer-events:none;">${label}</span>`;
                document.body.appendChild(el);
                const size = SIZES[type];
                const offset = { x: (size.w * this.scale) / 2, y: (size.h * this.scale) / 2 };
                this.menuDrag.offset = offset; this.menuDrag.el = el;
                el.style.left = (cx - offset.x) + 'px'; el.style.top = (cy - offset.y) + 'px';
                const menuBoundary = window.innerHeight - 150;
                if (cy > menuBoundary) { const s = this.getPreviewScale(type); el.style.transform = `scale(${s})`; } 
                else { el.style.transform = `scale(${this.scale})`; }
            }
            
            getPreviewScale(type) {
                let previewW = type === 'x' ? 40 : 24; 
                const realW = SIZES[type].w;
                return previewW / (realW * this.scale);
            }

            handleMenuDragEnd(e) {
                if (!this.menuDrag) return;
                const touch = e.changedTouches ? e.changedTouches[0] : e;
                
                if (this.menuDrag.isDragging && this.menuDrag.el) {
                    const endX = touch.clientX; const endY = touch.clientY;
                    this.menuDrag.el.remove();
                    const menuHeight = 150;
                    const isOverBoard = endY < (window.innerHeight - menuHeight);
                    
                    if (isOverBoard) {
                        const pos = this.getWorldPos(endX, endY);
                        const w = SIZES[this.menuDrag.type].w; const h = SIZES[this.menuDrag.type].h;
                        const x = pos.x - w/2; const y = pos.y - h/2;
                        const dropSide = (x < 0) ? 'left' : 'right';
                        
                        if (dropSide === this.menuDrag.side) {
                            const targetSide = (dropSide === 'left') ? this.sideLeft : this.sideRight;
                            targetSide.addTile(this.menuDrag.type, parseInt(this.menuDrag.sign), false, x, y); 
                        }
                    }
                } else {
                    const targetSide = (this.menuDrag.side === 'left') ? this.sideLeft : this.sideRight;
                    targetSide.addTile(this.menuDrag.type, parseInt(this.menuDrag.sign), false, null, null); 
                }
                this.menuDrag = null;
            }

            // --- BOARD DRAG ---
            handleDragStart(e, id) {
                e.stopPropagation();
                const t = this.allTokens.find(x => x.id === id);
                if (!t) return;
                
                this.saveState(); 

                if (t.pairId) {
                    const p = this.allTokens.find(x => x.id === t.pairId);
                    if(p) { p.pairId=null; p.element.classList.remove('is-zero'); const b = document.getElementById(`badge-${t.id}-${p.id}`)||document.getElementById(`badge-${p.id}-${t.id}`); if(b)b.remove(); }
                    t.pairId=null; t.element.classList.remove('is-zero');
                    this.updateEquation();
                }

                t.element.classList.add('dragging');
                const r = t.element.getBoundingClientRect();
                const offset = { x: (e.touches?e.touches[0].clientX:e.clientX) - r.left, y: (e.touches?e.touches[0].clientY:e.clientY) - r.top };
                
                const startSide = t.x < 0 ? 'left' : 'right';

                const move = ev => {
                    ev.preventDefault();
                    const cx = ev.touches?ev.touches[0].clientX:ev.clientX; const cy = ev.touches?ev.touches[0].clientY:ev.clientY;
                    let wx = (cx - this.container.getBoundingClientRect().left - this.pan.x - offset.x)/this.scale;
                    let wy = (cy - this.container.getBoundingClientRect().top - this.pan.y - offset.y)/this.scale;

                    if (startSide === 'left' && wx > -5 - SIZES[t.type].w) wx = -5 - SIZES[t.type].w;
                    if (startSide === 'right' && wx < 5) wx = 5;

                    t.x = wx; t.y = wy;
                    t.element.style.left = t.x+'px'; t.element.style.top = t.y+'px';
                };
                const end = () => {
                    document.removeEventListener('mousemove', move); document.removeEventListener('touchmove', move);
                    document.removeEventListener('mouseup', end); document.removeEventListener('touchend', end);
                    t.element.classList.remove('dragging');
                    this.checkOverlap(t);
                    this.updateEquation();
                };
                document.addEventListener('mousemove', move); document.addEventListener('touchmove', move, {passive:false});
                document.addEventListener('mouseup', end); document.addEventListener('touchend', end);
            }

            checkOverlap(t1) {
                for(let t2 of this.allTokens) {
                    if (t1===t2 || t2.pairId || t1.type!==t2.type || t1.sign===t2.sign) continue;
                    if ((t1.x < 0 && t2.x > 0) || (t1.x > 0 && t2.x < 0)) continue;
                    const d = Math.hypot(t1.x - t2.x, t1.y - t2.y);
                    if (d < SNAP) { this.createZeroPair(t1, t2); break; }
                }
            }

            createZeroPair(t1, t2, isAuto=false) {
                playSound('snap');
                const mx=(t1.x+t2.x)/2; const my=(t1.y+t2.y)/2;
                t1.x=mx; t1.y=my; t2.x=mx; t2.y=my;
                t1.element.style.left=mx+'px'; t1.element.style.top=my+'px';
                t2.element.style.left=mx+'px'; t2.element.style.top=my+'px';
                t1.pairId=t2.id; t2.pairId=t1.id;
                t1.element.classList.add('is-zero'); t2.element.classList.add('is-zero');
                
                const b = document.createElement('div'); b.className='zero-badge'; b.textContent='0'; b.id=`badge-${t1.id}-${t2.id}`;
                const w = SIZES[t1.type].w; const h = SIZES[t1.type].h;
                b.style.left = (mx + w/2) + 'px'; b.style.top = (my + h/2) + 'px';
                this.world.appendChild(b);
                this.updateEquation(); 

                if(isAuto) {
                    setTimeout(() => {
                        t1.element.classList.add('vanish'); t2.element.classList.add('vanish'); b.classList.add('vanish');
                        setTimeout(() => {
                            t1.element.remove(); t2.element.remove(); b.remove();
                            this.removeTokens([t1.id, t2.id]);
                        }, 500);
                    }, 500);
                }
            }

            updateEquation() {
                const getStr = (side) => {
                    if (side.displayMode === 'reduced') {
                        return this.getReducedStr(side);
                    } else if (side.displayMode === 'ordered') {
                        return this.getOrderedStr(side);
                    }
                    
                    let s = "";
                    const hasNonEmptyBefore = (i) => { for(let k=0; k<i; k++) if(side.steps[k].tokenIds.length > 0) return true; return false; };
                    
                    side.steps.forEach((step, idx) => {
                        const toks = step.tokenIds.map(id => this.allTokens.find(t=>t.id===id)).filter(t => t && !t.pairId);
                        if (!toks.length && idx !== side.currStepIdx) return;
                        
                        let content = "";
                        const groups = []; let cur=null;
                        toks.forEach(t=>{ if(cur && cur.type===t.type && cur.sign===t.displaySign) cur.c++; else { if(cur) groups.push(cur); cur={type:t.type, sign:t.displaySign, c:1}; } });
                        if(cur) groups.push(cur);
                        
                        groups.forEach((g, i) => {
                            const lbl = g.type==='unit' ? '' : 'x';
                            const val = g.c;
                            const col = g.sign === 1 ? COLORS.pos : COLORS.neg;
                            const prefix = (i>0 && g.sign===1) ? `{\\color{${COLORS.pos}}{+}}` : (g.sign===-1?`{\\color{${COLORS.neg}}{-}}`:'');
                            const leadMinus = (i===0 && g.sign===-1) ? `{\\color{${COLORS.neg}}{-}}` : '';
                            const num = (val===1 && g.type!=='unit') ? '' : val;
                            content += (i===0 ? leadMinus : `\\;${prefix}\\;`) + `{\\color{${col}}{${num}${lbl}}}`;
                        });
                        
                        if(!content) content = "\\dots";
                        
                        let pStr = content;
                        if (step.type === 'multiplication' && !step.distributed) pStr = `${step.factor}(${content})`;
                        if (step.type === 'subtraction' && !step.oppositeApplied) pStr = `-(${content})`;
                        
                        if (idx > 0 && hasNonEmptyBefore(idx)) {
                            const rawStr = pStr.replace(/<[^>]*>|{[^}]*}/g, '');
                            if (!pStr.includes('{red}{-}') && !pStr.startsWith('-')) s += `\\;{\\color{${COLORS.pos}}{+}}\\;`;
                        }
                        s += pStr;
                    });
                    return s || "0";
                };

                const l = getStr(this.sideLeft);
                const r = getStr(this.sideRight);
                katex.render(`${l} = ${r}`, document.getElementById('equation-display'));
            }

            getReducedStr(side) {
                const active = side.tokens.filter(t => !t.pairId && !t.element.classList.contains('ghost'));
                if (!active.length) return "0";
                
                let xCount = 0; let unitCount = 0;
                active.forEach(t => { if (t.type === 'x') xCount += t.sign; else if (t.type === 'unit') unitCount += t.sign; });
                
                let parts = [];
                if (xCount !== 0) {
                    const col = xCount > 0 ? COLORS.pos : COLORS.neg;
                    const val = Math.abs(xCount) === 1 ? "" : Math.abs(xCount);
                    const sign = xCount < 0 ? "-" : "";
                    parts.push(`{\\color{${col}}{${sign}${val}x}}`);
                }
                if (unitCount !== 0) {
                    const col = unitCount > 0 ? COLORS.pos : COLORS.neg;
                    const signStr = unitCount > 0 ? "+" : "-";
                    const displaySign = (parts.length > 0) ? `\\;{\\color{${col}}{${signStr}}}\\;` : (unitCount < 0 ? `{\\color{${COLORS.neg}}{-}}` : "");
                    parts.push(`${displaySign}{\\color{${col}}{${Math.abs(unitCount)}}}`);
                }
                return parts.join("") || "0";
            }

            getOrderedStr(side) {
                const active = side.tokens.filter(t => !t.pairId && !t.element.classList.contains('ghost'));
                if (!active.length) return "0";
                const packs = new Map();
                active.forEach(t => {
                    const pid = (typeof t.packId !== 'undefined') ? t.packId : -1;
                    if (!packs.has(pid)) packs.set(pid, { type: t.type, count: 0 });
                    packs.get(pid).count += t.sign;
                });
                let packList = Array.from(packs.entries()).map(([pid, data]) => ({ pid, ...data })).filter(p => p.count !== 0);
                packList.sort((a, b) => {
                    if (a.type !== b.type) { return a.type === 'x' ? -1 : 1; }
                    return a.pid - b.pid;
                });
                let s = "";
                packList.forEach((p, i) => {
                    const col = p.count > 0 ? COLORS.pos : COLORS.neg;
                    const isNeg = p.count < 0;
                    const val = Math.abs(p.count) === 1 && p.type === 'x' ? "" : Math.abs(p.count);
                    const lbl = p.type === 'x' ? "x" : "";
                    let prefix = "";
                    if (i === 0) { if (isNeg) prefix = `{\\color{${COLORS.neg}}{-}}`; } 
                    else { if (isNeg) prefix = `\\;{\\color{${COLORS.neg}}{-}}\\;`; else prefix = `\\;{\\color{${COLORS.pos}}{+}}\\;`; }
                    s += `${prefix}{\\color{${col}}{${val}${lbl}}}`;
                });
                return s || "0";
            }
            
            // --- TOOLS ---
            setTool(t){
                this.currentTool=t;
                const p=t==='pen';
                // Toggle active class on body to allow click-through for tokens if needed, 
                // or ensure canvas is top.
                if(p) document.body.classList.add('drawing-active');
                else document.body.classList.remove('drawing-active');
                
                document.getElementById('custom-cursor').style.display=p?'block':'none';
                if(p) document.body.style.cursor = 'none';
                else document.body.style.cursor = 'default';
            }
            
            startDraw(e){this.isDrawing=true;const p=this.getWorldPos(e.touches?e.touches[0].clientX:e.clientX,e.touches?e.touches[0].clientY:e.clientY);this.lastDrawPos=p;this.ctx.beginPath();this.ctx.moveTo(p.x,p.y);}
            draw(e){e.preventDefault();const p=this.getWorldPos(e.touches?e.touches[0].clientX:e.touches?e.touches[0].clientY:e.clientY);this.ctx.lineTo(p.x,p.y);this.ctx.stroke();this.lastDrawPos=p;}
            clearDrawing(){this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);}
            resizeCanvas(){this.canvas.width=4000;this.canvas.height=4000;this.canvas.style.width='4000px';this.canvas.style.height='4000px';this.ctx.lineWidth=3;this.ctx.lineCap='round';this.ctx.strokeStyle='#2563eb';}
            moveCursor(e){if(this.currentTool!=='pen')return;const c=document.getElementById('custom-cursor');c.style.left=e.clientX+'px';c.style.top=e.clientY+'px';c.style.transform='translate(-6px,-28px)';}
            getWorldPos(cx, cy) { const r = this.container.getBoundingClientRect(); return { x: (cx - r.left - this.pan.x) / this.scale, y: (cy - r.top - this.pan.y) / this.scale }; }
            
            resetBoard(clearHistory=true) {
                // Remove DOM elements properly
                this.allTokens.forEach(t => t.element.remove());
                document.querySelectorAll('.zero-badge').forEach(b=>b.remove());
                
                // Clear Data
                this.allTokens = [];
                
                // Reset Sides
                this.sideLeft = new AlgebraSide('left', this);
                this.sideRight = new AlgebraSide('right', this);
                
                // Clear Drawing
                ctx.clearRect(0,0,cvs.width,cvs.height);
                
                if(clearHistory) {
                    this.history = [];
                    this.mode = 'setup';
                    document.getElementById('btn-mode').classList.remove('solve');
                    document.getElementById('mode-text').innerText = "Phase 1 : Poser l'équation";
                }
                
                this.centerView();
                this.updateEquation();
            }
        }
        
        const cvs = document.getElementById('drawing-canvas');
        const ctx = cvs.getContext('2d');
        let isDrawing=false; let lastP={x:0,y:0};
        function resizeCvs() { cvs.width=4000; cvs.height=4000; cvs.style.width='4000px'; cvs.style.height='4000px'; ctx.lineWidth=3; ctx.lineCap='round'; ctx.strokeStyle='#2563eb'; }
        window.addEventListener('resize', resizeCvs); resizeCvs();
        
        const app = new AlgebraEqApp();
        app.canvas = cvs;
        app.ctx = ctx;
        
        // Correct Tool binding
        app.setTool = function(t){ 
            app.currentTool=t; 
            if(t==='pen'){
                document.getElementById('custom-cursor').classList.remove('hidden');
                document.body.style.cursor='none';
                document.body.classList.add('drawing-active');
            } else {
                document.getElementById('custom-cursor').classList.add('hidden');
                document.body.style.cursor='default';
                document.body.classList.remove('drawing-active');
            } 
        };
        app.clearDrawing = function(){ ctx.clearRect(0,0,cvs.width,cvs.height); };
        
        // Drawing Events attached to WINDOW/DOCUMENT to catch them over overlay
        document.addEventListener('mousemove', e => { 
            if(app.currentTool==='pen') { 
                const c=document.getElementById('custom-cursor'); 
                c.style.left=e.clientX+'px'; 
                c.style.top=e.clientY+'px'; 
                c.style.transform='translate(-6px,-28px)'; 
                if(isDrawing) { 
                    const p = app.getWorldPos(e.clientX, e.clientY); 
                    ctx.beginPath(); ctx.moveTo(lastP.x, lastP.y); ctx.lineTo(p.x, p.y); ctx.stroke(); 
                    lastP = p; 
                } 
            } 
        });
        
        document.addEventListener('mousedown', e => { 
            if(app.currentTool==='pen') { 
                if (e.target.closest('button')) return; // Don't draw on buttons
                isDrawing=true; 
                lastP = app.getWorldPos(e.clientX, e.clientY); 
            } 
        });
        
        document.addEventListener('mouseup', () => isDrawing=false);
    </script>
</body>
</html>
