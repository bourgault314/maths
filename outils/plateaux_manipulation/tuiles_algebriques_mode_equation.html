<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Calcul Littéral - Équations (Balance)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css">
    <style>
        body { font-family: 'Fredoka', sans-serif; background-color: #f0f9ff; overflow: hidden; user-select: none; }
        
        /* --- TUILES PLATEAU --- */
        .token {
            position: absolute; display: flex; align-items: center; justify-content: center;
            font-weight: 600; color: white; box-shadow: 0 4px 6px rgba(0,0,0,0.25);
            cursor: grab; transition: transform 0.1s, background-color 0.5s; z-index: 10;
            font-family: 'Times New Roman', serif; font-style: italic; font-size: 1.2rem;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3); transform-origin: 0 0;
        }
        .token.dragging { transition: none !important; z-index: 1000 !important; cursor: grabbing; box-shadow: 0 15px 30px rgba(0,0,0,0.4); transform: scale(1.1); }
        .token.animating { transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1), left 0.5s ease-in-out, top 0.5s ease-in-out, background-color 0.5s !important; }
        .vanish { animation: vanish 0.45s ease-in forwards; pointer-events: none; }
        @keyframes vanish { 0% { transform: scale(1); opacity: 1; } 100% { transform: scale(0.1); opacity: 0; } }

        /* Couleurs */
        .token.green { background: radial-gradient(circle at 30% 30%, #4ade80, #16a34a); border: 2px solid #14532d; }
        .token.red { background: radial-gradient(circle at 30% 30%, #f87171, #dc2626); border: 2px solid #7f1d1d; }
        
        /* Etats spéciaux */
        .token.in-bracket { opacity: 0.95; box-shadow: none !important; }
        .token.pending-mult { box-shadow: 0 0 0 3px #3b82f6 !important; }
        .token.is-zero { background: #9ca3af !important; opacity: 0.6; border: 2px solid #6b7280; box-shadow: none; z-index: 5; color: rgba(255,255,255,0.5); }
        .token.fading-gray { background: #9ca3af !important; border-color: #6b7280 !important; box-shadow: none !important; filter: grayscale(1); }
        .token.ghost { opacity: 0.5; filter: grayscale(0.8); pointer-events: none; }

        /* Tailles */
        .token.type-unit { width: 40px; height: 40px; border-radius: 4px; font-style: normal; }
        .token.type-x { width: 90px; height: 40px; border-radius: 4px; }
        .token.type-x2 { width: 90px; height: 90px; border-radius: 4px; }

        /* Badge Zéro */
        .zero-badge { 
            position: absolute; font-size: 2rem; font-weight: 800; color: #374151; 
            pointer-events: none; z-index: 20; text-shadow: 0 0 10px rgba(255,255,255,1); 
            animation: popIn 0.3s; transform: translate(-50%, -50%);
        }
        @keyframes popIn { from { transform: translate(-50%, -50%) scale(0); opacity: 0; } to { transform: translate(-50%, -50%) scale(1); opacity: 1; } }

        /* STRUCTURE */
        #board-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; cursor: grab; padding-bottom: 140px; }
        #board-container.panning { cursor: grabbing; }
        #board-world { position: absolute; top: 0; left: 0; transform-origin: 0 0; width: 0; height: 0; }
        
        #equation-divider {
            position: absolute; top: -5000px; bottom: -5000px; left: 0; width: 4px;
            background-color: #cbd5e1; border-left: 2px dashed #94a3b8; border-right: 2px dashed #94a3b8;
            transform: translateX(-2px); pointer-events: none; z-index: 0;
        }

        /* MENU BAS */
        #bottom-bar {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 140px;
            background: white; border-top: 1px solid #cbd5e1;
            display: flex; z-index: 50; box-shadow: 0 -4px 10px rgba(0,0,0,0.05);
        }
        .side-panel { flex: 1; display: flex; align-items: center; justify-content: center; padding: 5px 10px; gap: 10px; position: relative; }
        .side-panel.left { border-right: none; background: #f8fafc; }
        .side-panel.right { background: #fff; }
        
        #menu-divider {
            position: absolute; left: 50%; top: 0; bottom: 0; width: 4px;
            background-color: #cbd5e1; border-left: 2px dashed #94a3b8; border-right: 2px dashed #94a3b8;
            transform: translateX(-2px); pointer-events: none; z-index: 51;
        }

        .tiles-zone { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; padding: 5px; }
        .tools-zone { display: flex; flex-direction: column; gap: 6px; }
        .tools-row { display: flex; gap: 4px; }

        /* Tuiles Menu (Preview) */
        .tile-btn { 
            position: relative; background: transparent; border: none; cursor: grab; 
            display: flex; align-items: center; justify-content: center; transition: transform 0.1s; 
        }
        .tile-btn:active { cursor: grabbing; transform: scale(0.95); }
        .tile-btn:hover { transform: translateY(-2px); }
        
        .preview-shape { 
            display: flex; align-items: center; justify-content: center; border-radius: 4px; 
            color: white; font-weight: bold; font-family: 'Times New Roman', serif; font-style: italic; 
            text-shadow: 0 1px 2px rgba(0,0,0,0.3); box-shadow: 0 3px 5px rgba(0,0,0,0.2); pointer-events: none; 
        }
        .ps-green { background: radial-gradient(circle at 30% 30%, #4ade80, #16a34a); border: 1px solid #14532d; } 
        .ps-red { background: radial-gradient(circle at 30% 30%, #f87171, #dc2626); border: 1px solid #7f1d1d; }

        /* Ghost spécifique pour le Drag du menu (attaché au body) */
        .token.menu-ghost {
            position: fixed; /* Fixé à l'écran, pas au monde */
            z-index: 9999;
            pointer-events: none;
            opacity: 0.9;
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
            transform: scale(1.1);
        }
        
        .action-btn { font-size: 0.65rem; font-weight: bold; padding: 4px 8px; border-radius: 4px; border: 1px solid #cbd5e1; background: white; color: #475569; transition: all 0.1s; box-shadow: 0 1px 2px rgba(0,0,0,0.05); }
        .action-btn:hover { background: #f1f5f9; border-color: #94a3b8; } .action-btn:active { transform: translateY(1px); }
        
        .btn-op { width: 32px; height: 32px; border-radius: 6px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 1.1rem; box-shadow: 0 1px 2px rgba(0,0,0,0.05); }
        .btn-opp-style { background-color: #fff7ed; color: #c2410c; border: 1px solid #fb923c; font-size: 0.65rem; font-weight: bold; padding: 4px 8px; border-radius: 4px; transition: all 0.2s; }
        .btn-opp-style:hover { background-color: #ffedd5; }
        
        .toggle-mode { background-color: #fef08a; color: #854d0e; border: 1px solid #eab308; }
        .toggle-mode.solve { background-color: #dcfce7; color: #166534; border-color: #22c55e; }
        .equation-blur { filter: blur(5px); opacity: 0.5; }
        
        #custom-cursor { position: fixed; pointer-events: none; z-index: 9999; display: none; }
        .hide-cursor, .hide-cursor * { cursor: none !important; }
    </style>
</head>
<body class="h-screen w-screen flex flex-col overflow-hidden">

    <div id="custom-cursor" class="fixed pointer-events-none z-50 hidden">
        <svg class="drop-shadow-lg" width="34" height="34" viewBox="0 0 34 34" fill="none">
            <path d="M27 7 L13 21" stroke="#1d4ed8" stroke-width="6" stroke-linecap="round"/>
            <path d="M13 21 L8 32" stroke="#0f172a" stroke-width="4" stroke-linecap="round"/>
            <path d="M8 32 L12 28 L16 32 Z" fill="#111827"/>
            <circle cx="8" cy="32" r="1" fill="white"/>
        </svg>
    </div>

    <!-- HEADER -->
    <header class="bg-white p-2 shadow-md z-30 flex flex-wrap items-center gap-4 shrink-0 justify-between">
        <div class="flex items-center gap-2">
            <button onclick="app.resetBoard()" class="bg-rose-100 text-rose-600 hover:bg-rose-200 p-2 rounded-lg font-bold border border-rose-200 shadow-sm" title="Tout effacer">
                <svg class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>
            </button>
            <div class="h-8 w-px bg-slate-200 mx-1"></div>
            <button id="btn-mode" onclick="app.toggleMode()" class="toggle-mode px-4 py-2 rounded-lg font-bold text-sm transition flex items-center gap-2 shadow-sm">
                <span id="mode-text">Phase 1 : Poser l'équation</span>
            </button>
        </div>

        <div class="flex-1 flex flex-col items-center justify-center px-4">
            <div class="flex items-center gap-2 bg-slate-50 px-6 py-2 rounded-full border border-slate-200 shadow-inner">
                <div id="equation-display" class="text-3xl font-bold text-slate-700 tracking-tight font-mono transition-all duration-300">0 = 0</div>
                <button onclick="app.toggleEquationVisibility()" class="ml-2 text-slate-400 hover:text-slate-600 focus:outline-none">
                    <svg id="eye-icon" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
                    </svg>
                </button>
            </div>
        </div>

        <div class="flex items-center gap-1 bg-gray-100 p-1 rounded-lg">
            <button onclick="app.setTool('hand')" class="p-2 rounded bg-white shadow text-gray-700"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 11.5V14m0-2.5v-6a1.5 1.5 0 113 0m-3 6a1.5 1.5 0 00-3 0v2a7.5 7.5 0 0015 0v-5a1.5 1.5 0 00-3 0m-6-3V11m0-5.5v-1a1.5 1.5 0 013 0v1m0 0V11m0-5.5a1.5 1.5 0 013 0v3m0 0V11"/></svg></button>
            <button onclick="app.setTool('pen')" class="p-2 rounded text-gray-500 hover:bg-gray-200"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"/></svg></button>
            <button onclick="app.clearDrawing()" class="p-2 rounded text-red-400 hover:bg-red-50"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/></svg></button>
        </div>
    </header>

    <main id="board" class="flex-1 relative bg-white overflow-hidden cursor-move">
        <div class="absolute inset-0 opacity-10 pointer-events-none" style="background-image: linear-gradient(#94a3b8 1px, transparent 1px), linear-gradient(90deg, #94a3b8 1px, transparent 1px); background-size: 40px 40px;"></div>
        <div id="board-container">
            <div id="board-world">
                <div id="equation-divider"></div>
                <canvas id="drawing-canvas"></canvas>
            </div>
        </div>
    </main>

    <div id="bottom-bar">
        <div id="menu-divider"></div>

        <!-- GAUCHE -->
        <div class="side-panel left">
            <div class="tiles-zone">
                <button onmousedown="app.handleMenuTouchStart(event, 'x2', 1, 'left')" class="tile-btn w-16 h-16"><div class="preview-shape ps-green w-12 h-12 text-lg">x²</div></button>
                <button onmousedown="app.handleMenuTouchStart(event, 'x', 1, 'left')" class="tile-btn w-16 h-16"><div class="preview-shape ps-green w-14 h-8 text-lg">x</div></button>
                <button onmousedown="app.handleMenuTouchStart(event, 'unit', 1, 'left')" class="tile-btn w-16 h-16"><div class="preview-shape ps-green w-8 h-8 text-md">1</div></button>
                <button onmousedown="app.handleMenuTouchStart(event, 'x2', -1, 'left')" class="tile-btn w-16 h-16"><div class="preview-shape ps-red w-12 h-12 text-lg">-x²</div></button>
                <button onmousedown="app.handleMenuTouchStart(event, 'x', -1, 'left')" class="tile-btn w-16 h-16"><div class="preview-shape ps-red w-14 h-8 text-lg">-x</div></button>
                <button onmousedown="app.handleMenuTouchStart(event, 'unit', -1, 'left')" class="tile-btn w-16 h-16"><div class="preview-shape ps-red w-8 h-8 text-md">-1</div></button>
            </div>
            <div class="tools-zone">
                <div class="tools-row">
                    <button onclick="app.sideLeft.addOperator('separate')" class="btn-op bg-blue-100 text-blue-700 hover:bg-blue-200" title="Séparer">+</button>
                    <button onclick="app.sideLeft.addOperator('subtract')" class="btn-op bg-orange-100 text-orange-700 hover:bg-orange-200" title="Soustraire">-</button>
                    <button onclick="app.sideLeft.addOperator('close')" id="btn-close-l" class="hidden btn-op bg-orange-500 text-white hover:bg-orange-600">)</button>
                </div>
                <div class="tools-row">
                    <button onclick="app.sideLeft.startMult(2)" class="text-xs font-bold text-indigo-700 px-2 py-1 bg-indigo-50 rounded hover:bg-indigo-100">2x(?)</button>
                    <button onclick="app.sideLeft.startMult(3)" class="text-xs font-bold text-indigo-700 px-2 py-1 bg-indigo-50 rounded hover:bg-indigo-100">3x(?)</button>
                </div>
                <div class="tools-row flex-wrap justify-end">
                    <button onclick="app.sideLeft.order()" class="action-btn">Ranger</button>
                    <button onclick="app.sideLeft.reduce()" class="action-btn">Réduire</button>
                    <button onclick="app.sideLeft.simplify()" class="action-btn">Simplifier</button>
                    <button onclick="app.sideLeft.applyOpposite()" id="btn-opp-l" class="hidden btn-opp-style">Opposé</button>
                    <button onclick="app.sideLeft.distribute()" id="btn-dist-l" class="hidden action-btn bg-blue-500 text-white hover:bg-blue-600">Développer</button>
                </div>
            </div>
        </div>

        <!-- DROITE -->
        <div class="side-panel right">
            <div class="tiles-zone">
                <button onmousedown="app.handleMenuTouchStart(event, 'x2', 1, 'right')" class="tile-btn w-16 h-16"><div class="preview-shape ps-green w-12 h-12 text-lg">x²</div></button>
                <button onmousedown="app.handleMenuTouchStart(event, 'x', 1, 'right')" class="tile-btn w-16 h-16"><div class="preview-shape ps-green w-14 h-8 text-lg">x</div></button>
                <button onmousedown="app.handleMenuTouchStart(event, 'unit', 1, 'right')" class="tile-btn w-16 h-16"><div class="preview-shape ps-green w-8 h-8 text-md">1</div></button>
                <button onmousedown="app.handleMenuTouchStart(event, 'x2', -1, 'right')" class="tile-btn w-16 h-16"><div class="preview-shape ps-red w-12 h-12 text-lg">-x²</div></button>
                <button onmousedown="app.handleMenuTouchStart(event, 'x', -1, 'right')" class="tile-btn w-16 h-16"><div class="preview-shape ps-red w-14 h-8 text-lg">-x</div></button>
                <button onmousedown="app.handleMenuTouchStart(event, 'unit', -1, 'right')" class="tile-btn w-16 h-16"><div class="preview-shape ps-red w-8 h-8 text-md">-1</div></button>
            </div>
            <div class="tools-zone">
                <div class="tools-row">
                    <button onclick="app.sideRight.addOperator('separate')" class="btn-op bg-blue-100 text-blue-700 hover:bg-blue-200">+</button>
                    <button onclick="app.sideRight.addOperator('subtract')" class="btn-op bg-orange-100 text-orange-700 hover:bg-orange-200">-</button>
                    <button onclick="app.sideRight.addOperator('close')" id="btn-close-r" class="hidden btn-op bg-orange-500 text-white hover:bg-orange-600">)</button>
                </div>
                <div class="tools-row">
                    <button onclick="app.sideRight.startMult(2)" class="text-xs font-bold text-indigo-700 px-2 py-1 bg-indigo-50 rounded hover:bg-indigo-100">2x(?)</button>
                    <button onclick="app.sideRight.startMult(3)" class="text-xs font-bold text-indigo-700 px-2 py-1 bg-indigo-50 rounded hover:bg-indigo-100">3x(?)</button>
                </div>
                <div class="tools-row flex-wrap">
                    <button onclick="app.sideRight.order()" class="action-btn">Ranger</button>
                    <button onclick="app.sideRight.reduce()" class="action-btn">Réduire</button>
                    <button onclick="app.sideRight.simplify()" class="action-btn">Simplifier</button>
                    <button onclick="app.sideRight.applyOpposite()" id="btn-opp-r" class="hidden btn-opp-style">Opposé</button>
                    <button onclick="app.sideRight.distribute()" id="btn-dist-r" class="hidden action-btn bg-blue-500 text-white hover:bg-blue-600">Développer</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const SNAP = 60;
        const PACK_GAP = 25;
        const SIZES = { 'unit': { w: 40, h: 40 }, 'x': { w: 90, h: 40 }, 'x2': { w: 90, h: 90 } };
        const COLORS = { pos: 'green', neg: 'red', orange: 'orange' };
        
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
            osc.connect(gain); gain.connect(audioCtx.destination); const now = audioCtx.currentTime;
            if (type === 'pop') { osc.type = 'sine'; osc.frequency.setValueAtTime(300, now); osc.frequency.exponentialRampToValueAtTime(500, now+0.1); gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now+0.1); osc.start(now); osc.stop(now+0.1); }
            else if (type === 'snap') { osc.type = 'square'; osc.frequency.setValueAtTime(100, now); gain.gain.setValueAtTime(0.05, now); gain.gain.exponentialRampToValueAtTime(0.01, now+0.05); osc.start(now); osc.stop(now+0.05); }
            else if (type === 'whoosh') { osc.type = 'triangle'; osc.frequency.setValueAtTime(300, now); osc.frequency.exponentialRampToValueAtTime(50, now+0.3); gain.gain.setValueAtTime(0.05, now); gain.gain.linearRampToValueAtTime(0, now+0.3); osc.start(now); osc.stop(now+0.3); }
            else if (type === 'flip') { osc.type = 'triangle'; osc.frequency.setValueAtTime(200, now); osc.frequency.linearRampToValueAtTime(400, now+0.2); gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now+0.2); osc.start(now); osc.stop(now+0.2); }
        }

        // --- ALGEBRA SIDE ENGINE ---
        class AlgebraSide {
            constructor(id, parentApp) {
                this.id = id;
                this.app = parentApp;
                this.tokens = [];
                this.steps = [{ id: 0, operator: '', type: 'simple', tokenIds: [], factor: 1, oppositeApplied: false, distributed: false, isClosed: false }];
                this.currStepIdx = 0;
                this.nextPackId = 1; this.packMeta = {}; this.lastPack = null;
                this.isSubInput = false; this.isMultInput = false;
                this.lastPos = { x: 0, y: 0, maxY: 0 };
                this.pendingGap = 0;
                this.lastSeqPackId = null;
            }

            getStartPos() {
                const screenW = this.app.container.clientWidth / this.app.scale;
                const screenH = this.app.container.clientHeight / this.app.scale;
                const topY = -screenH/2 + 60;
                if (this.id === 'left') return { x: -screenW/2 + 40, y: topY, maxY: 0 };
                else return { x: 40, y: topY, maxY: 0 };
            }

            addTile(type, sign, isGhost=false, manualX=null, manualY=null, mirrorTrigger=false) {
                if (this.tokens.length === 0 && !manualX) this.lastPos = this.getStartPos();

                if (!isGhost && !mirrorTrigger && this.app.mode === 'solve') {
                    const otherSide = this.id === 'left' ? this.app.sideRight : this.app.sideLeft;
                    otherSide.addTile(type, sign, false, null, null, true);
                }

                if(!isGhost) playSound('pop');
                
                let step = this.steps[this.currStepIdx];
                if (!isGhost && step.isClosed && !this.isSubInput && !this.isMultInput) {
                    this.steps.push({ id: this.steps.length, operator: '+', type: 'simple', tokenIds: [], factor: 1, oppositeApplied: false, distributed: false, isClosed: false });
                    this.currStepIdx++;
                    step = this.steps[this.currStepIdx];
                    this.lastPack = null;
                }

                let tileSign = sign;
                if (this.isSubInput && step.type === 'subtraction') tileSign = -sign;
                if (this.isMultInput && step.operator === '-') tileSign = -sign;

                let pid;
                if (manualX===null && !isGhost) {
                    const now = Date.now();
                    if (this.lastPack && this.lastPack.type === type && this.lastPack.sign === tileSign && this.lastPack.step === this.currStepIdx) {
                        pid = this.lastPack.pid;
                    } else {
                        pid = this.nextPackId++;
                        this.lastPack = { pid, type, sign: tileSign, step: this.currStepIdx };
                    }
                } else {
                    pid = this.nextPackId++;
                }

                const el = document.createElement('div');
                el.className = `token ${type==='unit'?'type-unit':(type==='x'?'type-x':'type-x2')} ${tileSign===1?'green':'red'}`;
                if (isGhost) el.classList.add('ghost');
                if (this.isSubInput) el.classList.add('in-bracket');
                if (this.isMultInput && !step.distributed) el.classList.add('pending-mult');
                
                let lbl = type==='unit' ? (tileSign===1?'1':'-1') : (type==='x' ? (tileSign===1?'x':'-x') : (tileSign===1?'x²':'-x²'));
                el.innerHTML = `<span style="pointer-events:none;">${lbl}</span>`;
                
                const tId = this.app.nextId++;
                el.id = `t-${tId}`;

                let x, y;
                if (manualX !== null) { x=manualX; y=manualY; }
                else {
                    let gap = 0;
                    if (this.pendingGap > 0) { gap = this.pendingGap; this.pendingGap = 0; }
                    else if (this.lastSeqPackId !== null && pid !== this.lastSeqPackId) gap = PACK_GAP;
                    
                    const pos = this.getPos(SIZES[type].w, SIZES[type].h, gap);
                    x = pos.x; y = pos.y;
                }

                el.style.left = x+'px'; el.style.top = y+'px';
                el.addEventListener('mousedown', e => this.app.handleDragStart(e, tId));
                el.addEventListener('touchstart', e => this.app.handleDragStart(e, tId), {passive:false});
                this.app.world.appendChild(el);

                const token = { id: tId, side: this.id, type, sign: tileSign, displaySign: sign, x, y, element: el, pairId: null, packId: pid, ghostIds: [] };
                this.tokens.push(token);
                this.app.allTokens.push(token);

                if (!isGhost) {
                    step.tokenIds.push(tId);
                    if (manualX === null) this.lastSeqPackId = pid;
                    
                    if (this.isMultInput && step.factor > 1) {
                        const stride = 90+20;
                        for(let i=1; i<step.factor; i++) {
                            const g = this.addTile(type, sign, true, x, y + i*stride);
                            token.ghostIds.push(g.id);
                        }
                    }
                }
                this.app.updateEquation();
                return token;
            }

            getPos(w, h, gap) {
                const padding = 2;
                this.lastPos.x += gap;
                const screenW = this.app.container.clientWidth / this.app.scale;
                const limit = (this.id === 'left') ? -20 : (screenW/2 - 20);
                const start = (this.id === 'left') ? (-screenW/2 + 40) : 40; 
                
                if (this.lastPos.x + w + padding > limit) {
                    this.lastPos.x = start;
                    this.lastPos.y += this.lastPos.maxY + 20;
                    this.lastPos.maxY = 0;
                }
                const res = { x: this.lastPos.x, y: this.lastPos.y };
                this.lastPos.x += w + padding;
                this.lastPos.maxY = Math.max(this.lastPos.maxY, h);
                return res;
            }

            addOperator(op) {
                if (op === 'separate') { playSound('pop'); this.lastPack=null; this.pendingGap = PACK_GAP; }
                else if (op === 'subtract') {
                    if (this.isSubInput) return;
                    this.pendingGap = PACK_GAP;
                    this.steps.push({ id: this.steps.length, operator: '-', type: 'subtraction', tokenIds: [], factor:1, distributed:false, isClosed:false });
                    this.currStepIdx++; this.isSubInput = true;
                    document.getElementById(`btn-close-${this.id === 'left' ? 'l' : 'r'}`).classList.remove('hidden');
                }
                else if (op === 'close') {
                    const s = this.steps[this.currStepIdx];
                    if (this.isSubInput) { this.isSubInput=false; s.isClosed=true; }
                    else if (this.isMultInput) { this.isMultInput=false; s.isClosed=true; }
                    document.getElementById(`btn-close-${this.id === 'left' ? 'l' : 'r'}`).classList.add('hidden');
                    this.updateUI();
                }
                this.app.updateEquation();
            }

            startMult(f) {
                if (this.isSubInput || this.isMultInput) return;
                this.steps.push({ id: this.steps.length, operator: '+', type: 'multiplication', tokenIds: [], factor: f, distributed:false, isClosed:false });
                this.currStepIdx++; this.isMultInput = true;
                document.getElementById(`btn-close-${this.id === 'left' ? 'l' : 'r'}`).classList.remove('hidden');
                this.app.updateEquation();
            }

            applyOpposite() {
                const p = this.steps.filter(s=>s.type==='subtraction' && !s.oppositeApplied);
                if(!p.length) return; 
                playSound('flip');
                p.forEach(s => {
                    s.tokenIds.forEach(id => { 
                        const t = this.tokens.find(x=>x.id===id); 
                        if(t){ 
                            t.displaySign = t.sign;
                            t.element.classList.remove('in-bracket'); 
                        } 
                    });
                    s.oppositeApplied = true;
                });
                this.updateUI();
                this.app.updateEquation();
            }

            distribute() {
                const s = this.steps.find(x => x.type === 'multiplication' && !x.distributed && x.isClosed);
                if (!s) return;
                s.tokenIds.forEach(mid => {
                    const m = this.tokens.find(t => t.id === mid);
                    if (m && m.ghostIds) {
                        m.ghostIds.forEach(gid => {
                            const g = this.tokens.find(t => t.id === gid);
                            if (g) {
                                g.element.classList.remove('ghost', 'pending-mult');
                                s.tokenIds.push(gid);
                            }
                        });
                        m.element.classList.remove('pending-mult');
                    }
                });
                s.distributed = true;
                this.reflow();
                this.updateUI();
                this.app.updateEquation();
            }

            reflow() {
                this.lastPos = this.getStartPos();
                this.lastSeqPackId = null;
                this.steps.forEach((step, idx) => {
                    const toks = step.tokenIds.map(id => this.tokens.find(t=>t.id===id)).filter(Boolean);
                    if (!toks.length) return;

                    if (step.type === 'multiplication' && step.distributed) {
                        if (idx > 0) this.lastPos.x += PACK_GAP;
                        const groups = { 'x2': [], 'x': [], 'unit': [] };
                        toks.forEach(t => groups[t.type].push(t));
                        
                        let cx = this.lastPos.x; let cy = this.lastPos.y;
                        const screenW = this.app.container.clientWidth / this.app.scale;
                        const limit = (this.id==='left' ? -20 : (screenW/2 - 20));
                        const start = (this.id==='left' ? (-screenW/2 + 40) : 40);

                        if (cx + 200 > limit) { cx = start; cy += this.lastPos.maxY + 20; }
                        let mh = 0;
                        ['x2','x','unit'].forEach(type => {
                            const l = groups[type];
                            if(!l.length) return;
                            l.sort((a,b)=>b.sign - a.sign);
                            l.forEach(t => {
                                t.element.classList.add('animating');
                                t.x = cx; t.y = cy; t.element.style.left = cx+'px'; t.element.style.top = cy+'px';
                                setTimeout(()=>t.element.classList.remove('animating'),500);
                                cx += SIZES[type].w + 2;
                            });
                            cx += PACK_GAP; mh = Math.max(mh, SIZES[type].h);
                        });
                        this.lastPos.x = cx; this.lastPos.y = cy; this.lastPos.maxY = Math.max(this.lastPos.maxY, mh);
                    } else {
                        if (idx > 0) this.lastPos.x += PACK_GAP;
                        let lastPid = null;
                        toks.forEach(t => {
                            let gap = 0;
                            if (lastPid !== null && t.packId !== lastPid) gap = PACK_GAP;
                            const pos = this.getPos(SIZES[t.type].w, SIZES[t.type].h, gap);
                            t.element.classList.add('animating');
                            t.x = pos.x; t.y = pos.y; t.element.style.left = t.x+'px'; t.element.style.top = t.y+'px';
                            setTimeout(()=>t.element.classList.remove('animating'),500);
                            lastPid = t.packId;
                        });
                    }
                });
            }

            organize() { this.orderAllInternal(false); }
            reduce() { this.orderAllInternal(true); }
            orderAllInternal(reduced) {
                const screenW = this.app.container.clientWidth / this.app.scale;
                const startX = (this.id === 'left') ? (-screenW/2 + 40) : 40;
                const limitX = (this.id === 'left') ? -20 : (screenW/2 - 20);
                const screenH = this.app.container.clientHeight / this.app.scale;
                let y = -screenH/2 + 60;
                const rows = [{t:'x2',s:1},{t:'x2',s:-1},{t:'x',s:1},{t:'x',s:-1},{t:'unit',s:1},{t:'unit',s:-1}];
                rows.forEach(r => {
                    const subset = this.tokens.filter(t => t.type===r.t && t.sign===r.s && !t.pairId && !t.element.classList.contains('ghost'));
                    if (!subset.length) return;
                    let x = startX; let rh = 0;
                    subset.forEach(t => {
                        if (x + SIZES[t.type].w > limitX) { x = startX; y += rh + 10; rh = 0; }
                        t.element.classList.add('animating');
                        t.x = x; t.y = y; t.element.style.left=x+'px'; t.element.style.top=y+'px';
                        setTimeout(()=>t.element.classList.remove('animating'), 500);
                        x += SIZES[t.type].w + 2; rh = Math.max(rh, SIZES[t.type].h);
                    });
                    y += rh + (reduced ? 10 : 20);
                });
            }

            simplify() {
                playSound('whoosh');
                const available = this.tokens.filter(t => !t.pairId && !t.element.classList.contains('in-bracket') && !t.element.classList.contains('ghost'));
                const pairs = [];
                ['x2','x','unit'].forEach(type => {
                    const pos = available.filter(t => t.type === type && t.sign === 1);
                    const neg = available.filter(t => t.type === type && t.sign === -1);
                    while(pos.length && neg.length) pairs.push([pos.pop(), neg.pop()]);
                });
                pairs.forEach((p, i) => {
                    setTimeout(() => {
                        const t1 = p[0]; const t2 = p[1];
                        this.app.createZeroPair(t1, t2, true);
                    }, i * 300);
                });
            }

            updateUI() {
                const btnDist = document.getElementById(`btn-dist-${this.id === 'left' ? 'l' : 'r'}`);
                const hasPendingDist = this.steps.some(s => s.type === 'multiplication' && !s.distributed && s.isClosed);
                if (hasPendingDist) btnDist.classList.remove('hidden'); else btnDist.classList.add('hidden');
                const btnOpp = document.getElementById(`btn-opp-${this.id === 'left' ? 'l' : 'r'}`);
                const hasPendingOpp = this.steps.some(s => s.type === 'subtraction' && !s.oppositeApplied);
                if (hasPendingOpp) btnOpp.classList.remove('hidden'); else btnOpp.classList.add('hidden');
            }
        }

        // --- MAIN APP ---
        class AlgebraEqApp {
            constructor() {
                this.nextId = 1;
                this.allTokens = [];
                this.mode = 'setup';
                this.equationVisible = true;
                this.container = document.getElementById('board-container');
                this.world = document.getElementById('board-world');
                this.eqDisplay = document.getElementById('equation-display');
                this.scale = 1; this.pan = {x:0, y:0};
                this.menuDrag = null;
                this.sideLeft = new AlgebraSide('left', this);
                this.sideRight = new AlgebraSide('right', this);
                this.initListeners();
                this.centerView();
                this.updateEquation();
            }

            initListeners() {
                this.container.addEventListener('wheel', e => { e.preventDefault(); this.scale = Math.min(Math.max(0.5, this.scale - e.deltaY * 0.001), 2.5); this.updateTransform(); }, {passive:false});
                this.container.addEventListener('mousedown', e => {
                    if (e.target.closest('.token') || e.target.closest('button')) return;
                    this.isPanning = true; this.panStart = { x: e.clientX - this.pan.x, y: e.clientY - this.pan.y };
                    this.container.classList.add('panning');
                });
                window.addEventListener('mousemove', e => {
                    if (this.isPanning) { this.pan.x = e.clientX - this.panStart.x; this.pan.y = e.clientY - this.panStart.y; this.updateTransform(); }
                    else if (this.menuDrag) this.handleMenuDragMove(e);
                });
                window.addEventListener('mouseup', e => {
                    this.isPanning = false; this.container.classList.remove('panning');
                    if(this.menuDrag) this.handleMenuDragEnd(e);
                });
                this.container.addEventListener('dragover', e => e.preventDefault());
                this.container.addEventListener('drop', e => e.preventDefault());
                window.addEventListener('resize', () => { this.centerView(); });
                document.addEventListener('touchmove', e => { if (this.menuDrag) { e.preventDefault(); this.handleMenuDragMove(e); } }, {passive:false});
                document.addEventListener('touchend', e => { if (this.menuDrag) this.handleMenuDragEnd(e); });
            }

            centerView() {
                const cx = this.container.clientWidth / 2;
                const cy = this.container.clientHeight / 2;
                this.pan.x = cx; this.pan.y = cy - 50;
                this.updateTransform();
            }
            updateTransform() { this.world.style.transform = `translate(${this.pan.x}px, ${this.pan.y}px) scale(${this.scale})`; }
            
            // --- MENU DRAG ---
            handleMenuTouchStart(e, type, sign, side) {
                e.preventDefault();
                const touch = e.touches ? e.touches[0] : e;
                
                // CRUCIAL FIX: Attach ghost to BODY, using FIXED position (screen coords)
                // This ensures it floats ABOVE everything (menus, container clipping)
                const dragEl = document.createElement('div');
                dragEl.className = `token menu-ghost ${type==='unit'?'type-unit':(type==='x'?'type-x':'type-x2')} ${sign==1?'green':'red'}`;
                
                let lbl = type==='unit' ? (sign===1?'1':'-1') : (type==='x' ? (sign===1?'x':'-x') : (sign===1?'x²':'-x²'));
                dragEl.innerHTML = `<span style="pointer-events:none;">${lbl}</span>`;
                
                document.body.appendChild(dragEl); // Append to BODY

                this.menuDrag = { type, sign, side, el: dragEl };
                this.handleMenuDragMove(e);
            }
            
            handleMenuDragMove(e) {
                const touch = e.touches ? e.touches[0] : e;
                const w = SIZES[this.menuDrag.type].w; const h = SIZES[this.menuDrag.type].h;
                // Use ClientX/Y directly for Fixed Position
                this.menuDrag.el.style.left = (touch.clientX - w/2) + 'px';
                this.menuDrag.el.style.top = (touch.clientY - h/2) + 'px';
            }

            handleMenuDragEnd(e) {
                const touch = e.changedTouches ? e.changedTouches[0] : e;
                
                // Get World Position for Drop Logic
                const pos = this.getWorldPos(touch.clientX, touch.clientY);
                const w = SIZES[this.menuDrag.type].w; const h = SIZES[this.menuDrag.type].h;
                const x = pos.x - w/2; const y = pos.y - h/2;
                
                this.menuDrag.el.remove(); // Cleanup ghost
                
                // Check if dropped on board (above menu)
                const menuHeight = 140;
                const isOverBoard = touch.clientY < (window.innerHeight - menuHeight);
                const dropSide = (x < 0) ? 'left' : 'right';
                
                if (isOverBoard) {
                    if (this.mode === 'setup') {
                        const targetSide = (dropSide === 'left') ? this.sideLeft : this.sideRight;
                        targetSide.addTile(this.menuDrag.type, parseInt(this.menuDrag.sign), false, x, y);
                    } else {
                        // Solve Mode: Mirror Logic
                        const targetSide = (dropSide === 'left') ? this.sideLeft : this.sideRight;
                        targetSide.addTile(this.menuDrag.type, parseInt(this.menuDrag.sign), false, x, y, true);
                        const otherSide = (dropSide === 'left') ? this.sideRight : this.sideLeft;
                        otherSide.addTile(this.menuDrag.type, parseInt(this.menuDrag.sign), false, null, null, true);
                    }
                } else {
                    // Clicked or dropped back in menu -> Auto Add
                    const targetSide = (this.menuDrag.side === 'left') ? this.sideLeft : this.sideRight;
                    targetSide.addTile(this.menuDrag.type, parseInt(this.menuDrag.sign), false, null, null); 
                }
                
                this.menuDrag = null;
            }

            // --- BOARD DRAG ---
            handleDragStart(e, id) {
                e.stopPropagation();
                const t = this.allTokens.find(x => x.id === id);
                if (!t) return;
                
                if (t.pairId) {
                    const p = this.allTokens.find(x => x.id === t.pairId);
                    if(p) { p.pairId=null; p.element.classList.remove('is-zero'); const b = document.getElementById(`badge-${t.id}-${p.id}`)||document.getElementById(`badge-${p.id}-${t.id}`); if(b)b.remove(); }
                    t.pairId=null; t.element.classList.remove('is-zero');
                    this.updateEquation();
                }

                t.element.classList.add('dragging');
                const r = t.element.getBoundingClientRect();
                const offset = { x: (e.touches?e.touches[0].clientX:e.clientX) - r.left, y: (e.touches?e.touches[0].clientY:e.clientY) - r.top };
                
                const startSide = t.x < 0 ? 'left' : 'right';

                const move = ev => {
                    ev.preventDefault();
                    const cx = ev.touches?ev.touches[0].clientX:ev.clientX; const cy = ev.touches?ev.touches[0].clientY:ev.clientY;
                    let wx = (cx - this.container.getBoundingClientRect().left - this.pan.x - offset.x)/this.scale;
                    let wy = (cy - this.container.getBoundingClientRect().top - this.pan.y - offset.y)/this.scale;

                    if (this.mode === 'solve') {
                        const w = SIZES[t.type].w;
                        // HARD BARRIER
                        if (startSide === 'left') { 
                             if (wx > -5 - w) wx = -5 - w; 
                        } else { 
                             if (wx < 5) wx = 5; 
                        }
                    }
                    t.x = wx; t.y = wy;
                    t.element.style.left = t.x+'px'; t.element.style.top = t.y+'px';
                };
                const end = () => {
                    document.removeEventListener('mousemove', move); document.removeEventListener('touchmove', move);
                    document.removeEventListener('mouseup', end); document.removeEventListener('touchend', end);
                    t.element.classList.remove('dragging');
                    this.checkOverlap(t);
                    this.updateEquation();
                };
                document.addEventListener('mousemove', move); document.addEventListener('touchmove', move, {passive:false});
                document.addEventListener('mouseup', end); document.addEventListener('touchend', end);
            }

            checkOverlap(t1) {
                for(let t2 of this.allTokens) {
                    if (t1===t2 || t2.pairId || t1.type!==t2.type || t1.sign===t2.sign) continue;
                    if ((t1.x < 0 && t2.x > 0) || (t1.x > 0 && t2.x < 0)) continue;
                    
                    const d = Math.hypot(t1.x - t2.x, t1.y - t2.y);
                    if (d < SNAP) {
                        this.createZeroPair(t1, t2);
                        break;
                    }
                }
            }

            createZeroPair(t1, t2, isAuto=false) {
                playSound('snap');
                const mx=(t1.x+t2.x)/2; const my=(t1.y+t2.y)/2;
                t1.x=mx; t1.y=my; t2.x=mx; t2.y=my;
                t1.element.style.left=mx+'px'; t1.element.style.top=my+'px';
                t2.element.style.left=mx+'px'; t2.element.style.top=my+'px';
                t1.pairId=t2.id; t2.pairId=t1.id;
                t1.element.classList.add('is-zero'); t2.element.classList.add('is-zero');
                
                const b = document.createElement('div'); b.className='zero-badge'; b.textContent='0'; b.id=`badge-${t1.id}-${t2.id}`;
                
                // CENTERED ZERO BADGE
                const w = SIZES[t1.type].w; const h = SIZES[t1.type].h;
                b.style.left = (mx + w/2) + 'px'; 
                b.style.top = (my + h/2) + 'px';
                
                this.world.appendChild(b);
                
                this.updateEquation(); 

                if(isAuto) {
                    setTimeout(() => {
                        t1.element.classList.add('vanish'); t2.element.classList.add('vanish'); b.classList.add('vanish');
                        setTimeout(() => {
                            t1.element.remove(); t2.element.remove(); b.remove();
                            this.allTokens = this.allTokens.filter(t => t.id !== t1.id && t.id !== t2.id);
                            this.sideLeft.tokens = this.sideLeft.tokens.filter(t => t.id !== t1.id && t.id !== t2.id);
                            this.sideRight.tokens = this.sideRight.tokens.filter(t => t.id !== t1.id && t.id !== t2.id);
                            this.sideLeft.steps.forEach(s => s.tokenIds = s.tokenIds.filter(id => id !== t1.id && id !== t2.id));
                            this.sideRight.steps.forEach(s => s.tokenIds = s.tokenIds.filter(id => id !== t1.id && id !== t2.id));
                        }, 500);
                    }, 500);
                }
            }

            toggleMode() {
                const btn = document.getElementById('btn-mode');
                const txt = document.getElementById('mode-text');
                if (this.mode === 'setup') {
                    this.mode = 'solve';
                    btn.classList.add('solve'); txt.innerText = "Phase 2 : Résoudre (Balance)";
                } else {
                    this.mode = 'setup';
                    btn.classList.remove('solve'); txt.innerText = "Phase 1 : Poser l'équation";
                }
            }

            toggleEquationVisibility() {
                this.equationVisible = !this.equationVisible;
                const eq = document.getElementById('equation-display');
                if(this.equationVisible) eq.classList.remove('equation-blur'); else eq.classList.add('equation-blur');
            }

            resetBoard() {
                this.allTokens.forEach(t => t.element.remove());
                document.querySelectorAll('.zero-badge').forEach(b=>b.remove());
                this.allTokens = [];
                this.sideLeft = new AlgebraSide('left', this);
                this.sideRight = new AlgebraSide('right', this);
                this.mode = 'setup';
                document.getElementById('btn-mode').classList.remove('solve');
                document.getElementById('mode-text').innerText = "Phase 1 : Poser l'équation";
                this.centerView();
                this.updateEquation();
            }

            updateEquation() {
                const getStr = (side) => {
                    let s = "";
                    const hasNonEmptyBefore = (i) => { for(let k=0; k<i; k++) if(side.steps[k].tokenIds.length > 0) return true; return false; };
                    
                    side.steps.forEach((step, idx) => {
                        const toks = step.tokenIds.map(id => this.allTokens.find(t=>t.id===id)).filter(t => t && !t.pairId);
                        if (!toks.length && idx !== side.currStepIdx) return;
                        
                        let content = "";
                        const groups = []; let cur=null;
                        toks.forEach(t=>{ if(cur && cur.type===t.type && cur.sign===t.displaySign) cur.c++; else { if(cur) groups.push(cur); cur={type:t.type, sign:t.displaySign, c:1}; } });
                        if(cur) groups.push(cur);
                        
                        groups.forEach((g, i) => {
                            const lbl = g.type==='unit' ? '' : (g.type==='x'?'x':'x^2');
                            const val = g.c;
                            const col = g.sign === 1 ? COLORS.pos : COLORS.neg;
                            const prefix = (i>0 && g.sign===1) ? `{\\color{${COLORS.pos}}{+}}` : (g.sign===-1?`{\\color{${COLORS.neg}}{-}}`:'');
                            const leadMinus = (i===0 && g.sign===-1) ? `{\\color{${COLORS.neg}}{-}}` : '';
                            const num = (val===1 && g.type!=='unit') ? '' : val;
                            content += (i===0 ? leadMinus : `\\;${prefix}\\;`) + `{\\color{${col}}{${num}${lbl}}}`;
                        });
                        
                        if(!content) content = "\\dots";
                        
                        let pStr = content;
                        if (step.type === 'multiplication' && !step.distributed) pStr = `${step.factor}(${content})`;
                        if (step.type === 'subtraction' && !step.oppositeApplied) pStr = `-(${content})`;
                        
                        if (idx > 0 && hasNonEmptyBefore(idx)) {
                            const rawStr = pStr.replace(/<[^>]*>|{[^}]*}/g, '');
                            if (!pStr.includes('{red}{-}') && !pStr.startsWith('-')) s += `\\;{\\color{${COLORS.pos}}{+}}\\;`;
                        }
                        s += pStr;
                    });
                    return s || "0";
                };

                const l = getStr(this.sideLeft);
                const r = getStr(this.sideRight);
                katex.render(`${l} = ${r}`, document.getElementById('equation-display'));
            }

            undo() { /* ... */ }
            setTool(t){this.currentTool=t;const p=t==='pen';this.container.classList.toggle('hide-cursor',p);document.getElementById('custom-cursor').style.display=p?'block':'none';}
            startDraw(e){this.isDrawing=true;const p=this.getWorldPos(e.touches?e.touches[0].clientX:e.clientX,e.touches?e.touches[0].clientY:e.clientY);this.lastDrawPos=p;this.ctx.beginPath();this.ctx.moveTo(p.x,p.y);}
            draw(e){e.preventDefault();const p=this.getWorldPos(e.touches?e.touches[0].clientX:e.touches?e.touches[0].clientY:e.clientY);this.ctx.lineTo(p.x,p.y);this.ctx.stroke();this.lastDrawPos=p;}
            clearDrawing(){this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);}
            resizeCanvas(){this.canvas.width=4000;this.canvas.height=4000;this.canvas.style.width='4000px';this.canvas.style.height='4000px';this.ctx.lineWidth=3;this.ctx.lineCap='round';this.ctx.strokeStyle='#2563eb';}
            moveCursor(e){if(this.currentTool!=='pen')return;const c=document.getElementById('custom-cursor');c.style.left=e.clientX+'px';c.style.top=e.clientY+'px';c.style.transform='translate(-6px,-28px)';}
            getWorldPos(cx, cy) { const r = this.container.getBoundingClientRect(); return { x: (cx - r.left - this.pan.x) / this.scale, y: (cy - r.top - this.pan.y) / this.scale }; }
        }
        
        const cvs = document.getElementById('drawing-canvas');
        const ctx = cvs.getContext('2d');
        let isDrawing=false; let lastP={x:0,y:0};
        function resizeCvs() { cvs.width=4000; cvs.height=4000; cvs.style.width='4000px'; cvs.style.height='4000px'; ctx.lineWidth=3; ctx.lineCap='round'; ctx.strokeStyle='#2563eb'; }
        window.addEventListener('resize', resizeCvs); resizeCvs();
        const app = new AlgebraEqApp();
        app.setTool = function(t){ app.currentTool=t; if(t==='pen'){document.getElementById('custom-cursor').classList.remove('hidden');document.body.style.cursor='none';}else{document.getElementById('custom-cursor').classList.add('hidden');document.body.style.cursor='default';} };
        app.clearDrawing = function(){ ctx.clearRect(0,0,cvs.width,cvs.height); };
        document.addEventListener('mousemove', e => { if(app.currentTool==='pen') { const c=document.getElementById('custom-cursor'); c.style.left=e.clientX+'px'; c.style.top=e.clientY+'px'; c.style.transform='translate(-6px,-28px)'; if(isDrawing) { const p = app.getWorldPos(e.clientX, e.clientY); ctx.beginPath(); ctx.moveTo(lastP.x, lastP.y); ctx.lineTo(p.x, p.y); ctx.stroke(); lastP = p; } } });
        document.addEventListener('mousedown', e => { if(app.currentTool==='pen') { isDrawing=true; lastP = app.getWorldPos(e.clientX, e.clientY); } });
        document.addEventListener('mouseup', () => isDrawing=false);
    </script>
</body>
</html>
